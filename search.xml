<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Golang [技术启发] 安全函数 SaveFunc</title>
      <link href="posts/19008af7.html"/>
      <url>posts/19008af7.html</url>
      
        <content type="html"><![CDATA[<p>安全地执行不安全的函数</p><span id="more"></span><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在日常开发中，可能会遇到一种场景：</p><p>开启一个事务去执行某个任务，这个任务的其中一个子任务有可能失败，但是你又不想这个失败影响整个事务，只想打印一下日志。这种场景就可以用上安全函数 SaveFunc。</p><p>举个栗子，在修改简历时，我希望能发送一条通知给关注了这份简历的人，而发送通知有可能失败，甚至引发 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateResume</span><span class="params">(rid Resume, data ResumeData)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> data == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个事务更新简历</span></span><br><span class="line">    err := newTransaction(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rid.SetData(data)</span><br><span class="line marked">        SendNotice()    <span class="comment">// 可能因这个函数 panic 而导致整个 UpdateResume 事务失败</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;transaction fail. Cause: &quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;transaction success.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendNotice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> Search(ctx) == <span class="literal">nil</span> &#123;</span><br><span class="line marked">        <span class="built_in">panic</span>(<span class="string">&quot;can not get resume.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notice := <span class="built_in">new</span>(Notice)</span><br><span class="line">    <span class="keyword">if</span> !notice.Send() &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;sent notice fail.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">&quot;sent notice success.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在发送通知的函数 <code>SendNotice()</code> 如果 Search 不到资源则会直接 panic，这样会影响到整个事务失败回滚，从而 <code>UpdateResume()</code> 也失败。</p><p>这样显然不合理，总不能因为你发送通知失败就不让我更新简历吧？所以对于这样的场景，我们要对 <code>SendNotice()</code> 做安全处理。</p><h2 id="SaveFunc"><a href="#SaveFunc" class="headerlink" title="SaveFunc"></a>SaveFunc</h2><p>那么就轮到主角 <code>SaveFunc()</code> 登场了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/pkg/errors&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UnsaveFunc <span class="function"><span class="keyword">func</span> <span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveFunc</span><span class="params">(fn UnsaveFunc)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = errors.Wrap(r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SaveFunc()</code> 其实非常简单，函数名你可以换成你自己喜欢的名字。</p><p>它仅仅做一件非常普通的事情，把不安全的函数 fn 传递进来，在这里面执行，即使 fn 发生 panic 也会被 defer 中捕获，然后 recover，使得程序不会被中断。</p><p>这样加了一层用于兜底，就不怕不安全的函数会影响外层事务的执行了。</p><p>具体使用如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnsaveFunc <span class="function"><span class="keyword">func</span> <span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveFunc</span><span class="params">(fn UnsaveFunc)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = errors.Wrap(r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateResume</span><span class="params">(rid Resume, data ResumeData)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> data == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个事务更新简历</span></span><br><span class="line">    err := newTransaction(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rid.SetData(data)</span><br><span class="line marked">        <span class="keyword">if</span> e := SaveFunc(SendNotice()); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;transaction fail. Cause: &quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;transaction success.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给不安全函数增加一个返回值 error 以符合 UnsaveFunc 定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendNotice</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> Search(ctx) == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;can not get context.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notice := <span class="built_in">new</span>(Notice)</span><br><span class="line">    <span class="keyword">if</span> !notice.Send() &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;sent notice fail.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码将原本的例子中不安全的函数 <code>SendNotice()</code> 增加了一个返回值 error 以符合 UnsaveFunc 的定义。</p><p>然后在调用的地方 <code>UpdateResume()</code> 用 <code>SaveFunc(SendNotice)</code> 将函数传递进去。这样即使 <code>SendNotice()</code> 发生 panic 也会被 SaveFunc 处理掉，不会影响 <code>UpdateResume()</code>。</p><p>但这样有三个不好的地方：</p><ol><li>它破坏了原本的 <code>SendNotice()</code>，是一种侵入性的改造；</li><li>它限定了不安全函数 <code>SendNotice()</code> 不能携带参数；</li><li>它限定了不安全函数 <code>SendNotice()</code> 不能返回结果。</li></ol><p>这对这几个问题，我们可以用闭包来解决。</p><h2 id="使用闭包替代侵入性改造"><a href="#使用闭包替代侵入性改造" class="headerlink" title="使用闭包替代侵入性改造"></a>使用闭包替代侵入性改造</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendNotice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> Search(ctx) == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;can not get context.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notice := <span class="built_in">new</span>(Notice)</span><br><span class="line">    <span class="keyword">if</span> !notice.Send() &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;sent notice fail.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">&quot;sent notice success.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line marked"><span class="function"><span class="keyword">func</span> <span class="title">ClosureSendNotice</span><span class="params">()</span> <span class="title">UnsaveFunc</span></span> &#123;</span><br><span class="line marked">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line marked">        SendNotice()</span><br><span class="line marked">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line marked">    &#125;</span><br><span class="line marked">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateResume</span><span class="params">(rid Resume, data ResumeData)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> data == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个事务更新简历</span></span><br><span class="line">    err := newTransaction(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rid.SetData(data)</span><br><span class="line marked">        <span class="keyword">if</span> e := SaveFunc(ClosureSendNotice()); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;transaction fail. Cause: &quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;transaction success.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用一个闭包返回一个 UnsaveFunc，将不安全的函数 <code>SendNotice()</code> 放在里面，这样就不会造成侵入性改造，也不需要更改 UnsaveFunc 的定义了。</p><p>这样就解决第一个问题。</p><h2 id="使用闭包解决参数问题"><a href="#使用闭包解决参数问题" class="headerlink" title="使用闭包解决参数问题"></a>使用闭包解决参数问题</h2><p>为了说明这个问题，我们先让 <code>SendNotice()</code> 需要接收一个参数。</p><figure class="highlight go"><figcaption><span>14, 16, 29</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendNotice</span><span class="params">(rid Resume)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> Search(ctx) == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;can not get context.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notice := <span class="built_in">new</span>(Notice)</span><br><span class="line marked">    notice.rid = rid</span><br><span class="line">    <span class="keyword">if</span> !notice.Send() &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;sent notice fail.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">&quot;sent notice success.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实也很简单</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendNotice</span><span class="params">(rid Resume)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> Search(ctx) == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;can not get context.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notice := <span class="built_in">new</span>(Notice)</span><br><span class="line marked">    notice.rid = rid</span><br><span class="line">    <span class="keyword">if</span> !notice.Send() &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;sent notice fail.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">&quot;sent notice success.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ClosureSendNotice</span><span class="params">(rid Resume)</span> <span class="title">UnsaveFunc</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        SendNotice(rid)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateResume</span><span class="params">(rid Resume, data ResumeData)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> data == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个事务更新简历</span></span><br><span class="line">    err := newTransaction(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rid.SetData(data)</span><br><span class="line">        <span class="keyword">if</span> e := SaveFunc(ClosureSendNotice(rid)); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;transaction fail. Cause: &quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;transaction success.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实也很简单，只需要给闭包函数写上 <code>SendNotice()</code> 需要的参数，然后闭包中的 <code>SendNotice()</code> 直接调用就行。</p><p>参数会栈逃逸到堆上，这点不需要担心作用域的问题。</p><h2 id="使用闭包解决返回值问题"><a href="#使用闭包解决返回值问题" class="headerlink" title="使用闭包解决返回值问题"></a>使用闭包解决返回值问题</h2><p>这个问题好像跟最初的场景相悖了。</p><p>如果不安全函数 <code>SendNotice()</code> 有返回值，那么在 <code>UpdateResume()</code> 中的事务有两种情况：</p><ol><li>事务中 <strong>不需要</strong> 用到 <code>SendNotice()</code> 的返回值</li><li>事务中 <strong>需要</strong> 用到 <code>SendNotice()</code> 的返回值</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateResume</span><span class="params">(rid Resume, data ResumeData)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    err := newTransaction(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rid.SetData(data)</span><br><span class="line">        <span class="keyword">if</span> e := SaveFunc(ClosureSendNotice(rid)); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不需要用到，那么就不需要考虑返回值的事情了。</p><p>如果需要用到，说明事务中依赖 <code>SendNotice()</code> 的返回值，这样的话，<code>SendNotice()</code> 失败不就意味着整个事务失败了吗。那还费劲心机搞个 SaveFunc 干嘛？</p><p>所以返回值这点，可以不处理。</p><p>照目前这个场景是这种结论，我还没想出其他场景。</p><p>如果非要处理返回值这个问题也不是没有办法，但是要连同 SaveFunc 一起改造，也很不正确。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnsaveFunc <span class="function"><span class="keyword">func</span> <span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SaveFunc</span><span class="params">(fn UnsaveFunc)</span> <span class="params">(arg <span class="keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = errors.Wrap(r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendNotice</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> Search(ctx) == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;can not get resume.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notice := <span class="built_in">new</span>(Notice)</span><br><span class="line">    <span class="keyword">if</span> !notice.Send() &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;sent notice fail.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">&quot;sent notice success.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ClosureSendNotice</span><span class="params">()</span> <span class="title">UnsaveFunc</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">        res := SendNotice()</span><br><span class="line">        <span class="keyword">if</span> !res &#123;</span><br><span class="line">            <span class="keyword">return</span> res, errors.New(<span class="string">&quot;fail.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateResume</span><span class="params">(rid Resume, data ResumeData)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> data == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个事务更新简历</span></span><br><span class="line">    err := newTransaction(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rid.SetData(data)</span><br><span class="line"></span><br><span class="line">        res, e := SaveFunc(ClosureSendNotice(rid))</span><br><span class="line">        <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(e)</span><br><span class="line">        &#125;</span><br><span class="line">        log.Println(res)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;transaction fail. Cause: &quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">&quot;transaction success.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> Advanced </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 事务 </tag>
            
            <tag> 安全函数 </tag>
            
            <tag> SaveFunc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git-commit message 编写指南</title>
      <link href="posts/2e4490bf.html"/>
      <url>posts/2e4490bf.html</url>
      
        <content type="html"><![CDATA[<p>commit message 不要乱写</p><span id="more"></span><h2 id="提交信息规范"><a href="#提交信息规范" class="headerlink" title="提交信息规范"></a>提交信息规范</h2><p>我们对项目的 git 提交信息格式进行统一格式约定，这将提升项目日志的可读性。</p><p>共包含三个部分：</p><ul><li>Header（必须）</li><li>Body（可省略）</li><li>Footer（可省略）</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;type&gt;</span>[scope]: <span class="params">&lt;subject&gt;</span></span><br><span class="line"><span class="comment">// 空一行</span></span><br><span class="line"><span class="params">&lt;body&gt;</span></span><br><span class="line"><span class="comment">// 空一行</span></span><br><span class="line"><span class="params">&lt;footer&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>其中，Header 是必需的，Body 和 Footer 可以省略(默认忽略)，一般我们在 <code>git commit</code> 提交时指定的 <code>-m</code> 参数，就相当于默认指定 Header。</p></blockquote><blockquote><p>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。</p></blockquote><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 部分只有一行，包括三个字段：type（必需）、scope（可选）和 subject（必需），可以用如下格式表示它的结构：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>[scope]: <span class="tag">&lt;<span class="name">subject</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>用于表述此次提交信息的意义，首写字母大写，包括但不局限于如下类型：</p><ul><li>功能相关<ul><li><code>Feat</code>：新功能（feature）</li><li><code>Fix</code>：Bug 修复</li><li><code>Test</code>：增加测试</li></ul></li><li>文档相关<ul><li><code>Docs</code>：文档内容变化（documentation）</li><li><code>Style</code>：格式（不影响代码运行的变动）</li></ul></li><li>优化相关<ul><li><code>Perf</code>：性能优化</li><li><code>Refactor</code>：重构（即不是新增功能，也不是修改 Bug 的代码变动）</li></ul></li><li>版本相关<ul><li><code>Revert</code>：代码回滚</li><li><code>Release</code>：版本发布</li></ul></li><li>构建相关<ul><li><code>Chore</code>：构建过程或辅助工具的变动</li><li><code>Build</code>：基础构建系统或依赖库的变化</li><li><code>Ci</code>：CI 构建系统及其脚本变化<h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视仓库不同而不同</li></ul></li></ul><h4 id="subject"><a href="#subject" class="headerlink" title="subject"></a>subject</h4><p>subject是 commit 目的的简短描述，用于简要描述修改变更的内容，不超过50个字符。如 <code>Update code highlighting in readme.md</code>。</p><ul><li>句尾不要使用符号。</li><li>使用第一人称、现在时、祈使句语气。</li><li>以动词开头，比如change，而不是changed或changes</li><li>第一个字母小写</li></ul><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。</p><blockquote><p>  More detailed explanatory text, if necessary. Wrap it to about 72  characters or so. Further paragraphs come after blank lines.- Bullet  points are okay, too- Use a hanging indent</p></blockquote><p>有两个注意点。</p><ul><li>使用第一人称现在时，比如使用change而不是changed或changes。</li><li>应该说明代码变动的动机，以及与以前行为的对比。</li></ul><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>Footer 部分只用于两种情况。</p><h4 id="1、不兼容变动"><a href="#1、不兼容变动" class="headerlink" title="1、不兼容变动"></a>1、不兼容变动</h4><p>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">BREAKING CHANGE:</span> <span class="string">isolate</span> <span class="string">scope</span> <span class="string">bindings</span> <span class="string">definition</span> <span class="string">has</span> <span class="string">changed.</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">To migrate the code follow the example below:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">Before:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">scope:</span> &#123;</span><br><span class="line">      <span class="attr">myAttr:</span> <span class="string">&#x27;attribute&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attr">After:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">scope:</span> &#123;</span><br><span class="line">      <span class="attr">myAttr:</span> <span class="string">&#x27;@&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="string">The</span> <span class="string">removed</span> <span class="string">`inject`</span> <span class="string">wasn&#x27;t</span> <span class="string">generaly</span> <span class="string">useful</span> <span class="string">for</span> <span class="string">directives</span> <span class="string">so</span> <span class="string">there</span> <span class="string">should</span> <span class="string">be</span> <span class="literal">no</span> <span class="string">code</span> <span class="string">using</span> <span class="string">it.</span></span><br></pre></td></tr></table></figure><h4 id="2、关闭-Issue"><a href="#2、关闭-Issue" class="headerlink" title="2、关闭 Issue"></a>2、关闭 Issue</h4><p>如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。</p><blockquote><p>Closes #234</p></blockquote><p>也可以一次关闭多个 issue 。</p><blockquote><p>Closes #123, #245, #992</p></blockquote><h3 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h3><p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。</p><blockquote><p>revert: feat(pencil): add ‘graphiteWidth’ option</p><p>This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</p></blockquote><p>Body部分的格式是固定的，必须写成This reverts commit .，其中的hash是被撤销 commit 的 SHA 标识符。</p><p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。</p><h2 id="标签规范"><a href="#标签规范" class="headerlink" title="标签规范"></a>标签规范</h2><p>为了方便维护人员和用户能够快速找到他们想要查看的问题，我们使用“标签”功能对 Pull requests 和 Issues 进行分类。</p><p>如果您不确定某个标签的含义，或者不知道将哪些标签应用于 PR 或 issue，千万别错过这个。</p><p>Issue 的标签：</p><ul><li>类型<ul><li><code>Bug</code>: 检测到需要进行确认的 Bug</li><li><code>Feature Request</code>: 提出了新功能请求的 Issue</li><li><code>Question</code>: 提出疑问的 Issue</li><li><code>Meta</code>: 表明使用条款变更的 Issue</li><li><code>Support</code>: 被标记为支持请求的 Issue</li><li><code>Polls</code>: 发起投票的 Issue</li></ul></li><li>结果<ul><li><code>Duplicate</code>: 重复提及的 Issue</li><li><code>Irrelevant</code>: 与 NexT 主题无关的 Issue</li><li><code>Expected Behavior</code>: 与预期行为相符的 Issue</li><li><code>Need More Info</code>: 需要更多信息的 Issue</li><li><code>Need Verify</code>: 需要开发人员或用户确认 Bug 或解决方法的 Issue</li><li><code>Verified</code>: 已经被确认的 Issue</li><li><code>Can&#39;t Reproduce</code>: 无法复现的 Issue</li><li><code>Solved</code>: 已经解决的 Issue</li><li><code>Stale</code>: 由于长期无人回应被封存的 Issue</li></ul></li></ul><p>Pull Request 的标签：</p><ul><li><code>Breaking Change</code>: 产生重大变动的 Pull Request</li><li><code>Bug Fix</code>: 修复相关 Bug 的 Pull Request</li><li><code>New Feature</code>: 添加了新功能的 Pull Request</li><li><code>Feature</code>: 为现有功能提供选项或加成的 Pull Request</li><li><code>i18n</code>: 更新了翻译的 Pull Request</li><li><code>Work in Progress</code>: 仍在进行改动和完善的 Pull Request</li><li><code>Skip Release</code>: 无需在 Release Note 中展现的 Pull Request</li></ul><p>两者兼有：</p><ul><li><code>Roadmap</code>: 与 NexT 主题发展相关的 Issue 或者 Pull Request</li><li><code>Help Wanted</code>: 需要帮助的 Issue 或者 Pull Request</li><li><code>Discussion</code>: 需要进行讨论的 Issue 或者 Pull Request</li><li><code>Improvement</code>: 需要改进的 Issue 或者改进了 NexT 主题的 Pull Request</li><li><code>Performance</code>: 提出性能问题的 Issue 或者提高了 NexT 主题性能的 Pull Request</li><li><code>Hexo</code>: 与 Hexo 和 Hexo 插件相关的 Issue 或者 Pull Request</li><li><code>Template Engine</code>: 与模版引擎相关的 Issue 或者 Pull Request</li><li><code>CSS</code>: 与 NexT 主题 CSS 文件相关的 Issue 或者 Pull Request</li><li><code>Fonts</code>: 与 NexT 主题字体相关的 Issue 或者 Pull Request</li><li><code>PJAX</code>: 与 PJAX 相关的 Issue 或者 Pull Request</li><li><code>3rd Party Plugin</code>: 与第三方插件和服务相关的 Issue 或者 Pull Request</li><li><code>Docs</code>: 与文档说明相关的 Issue 或者 Pull Request</li><li><code>Configurations</code>: 与 NexT 主题设置相关的 Issue 或者 Pull Request</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> commit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang [深入理解] 10-实现抽象类</title>
      <link href="posts/dc573b7e.html"/>
      <url>posts/dc573b7e.html</url>
      
        <content type="html"><![CDATA[<p>虽然不推荐，但免不了要用到。</p><span id="more"></span><h1 id="实现抽象类"><a href="#实现抽象类" class="headerlink" title="实现抽象类"></a>实现抽象类</h1><p>最近在仿写一个程序的代码，那个程序使用的是「TypeScript」，一种面向对象的、动态的、强类型的语言，而 Golang 是静态的、强类型的、并且没有明确表明是面向对象的一种语言。</p><p>Golang 官方对于 Go 是否是面向对象语言的回答是：Yes and no。官方的态度就是我没说我是面向对象，但是你可以按照面向对象的范式去编写程序。</p><p>基本上面向对象的“封装、继承、多态、抽象”，在 Go 语言层面都有一定的实现，例如：</p><ul><li>  使用 struct 进行封装</li><li>  在 struct 中使用匿名字段进行继承和多态</li><li>   使用接口实现抽象</li></ul><p>但是对于其他一些概念上如：静态、抽象类等则没有直接的语法和机制进行实现。但是还是有一些方法可以实现，今天只讨论怎么实现，不讨论这样实现是否违背 Golang 的设计哲学。编程的范式有很多种，最常见的无非面向过程、面向对象、函数式这三种，三者各有优劣，咱们不作无畏之争。</p><h2 id="为什么需要抽象类：抽象类本质"><a href="#为什么需要抽象类：抽象类本质" class="headerlink" title="为什么需要抽象类：抽象类本质"></a>为什么需要抽象类：抽象类本质</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><blockquote><p>  在面向对象中，将所有的事物按照其<strong>属性</strong>和<strong>行为</strong>分门别类，也就是面向对象的基本单位之一 —— 类 Class。</p></blockquote><p>例如学校里的同学都是学生，<br>他们有共同的属性是学号、班级、姓名、年龄，<br>他们有共同的行为是上课、实训、吃饭、睡觉，<br>所以可以将属性和行为作为基本元素，组成一个 <code>学生类</code>。</p><p>再例如学校里的大人都是教职工，<br>他们有共同的属性是工号、科室、姓名、年龄，<br>他们有共同的行为是授课、带实训、吃饭、睡觉，<br>所以可以将属性和行为作为基本元素，组成一个 <code>教师类</code>。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>  多个类之间的属性、行为会有重复，将这些重复提取出来，提升一层，就成了父类，原本的那些类就称作子类，它们去继承这个父类，就能继续拥有这些重复的属性和行为。这就是继承 extends</p></blockquote><p>例如学生类和教师类都有重复属性：姓名、年龄；重复行为：吃饭、睡觉。</p><p>学生和老师共同点是他们都是人，所以将姓名、年龄、吃饭、睡觉提取出来，组成一个新的类 —— <code>人类</code>。</p><p>然后学生类和教师类继承人类，就能拥有这四个重复的属性和行为。</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><blockquote><p>  有时候重复的行为虽然做的事情是一样的，但是具体怎么做是不同的。</p><p>  那么这时这个行为就是一种抽象的行为。那你在定义这个行为的时候就不能将内容写死。于是就需要声明这个行为是一种抽象行为，给它定义为一个抽象方法。</p></blockquote><p>例如老师的授课行为，都是授课，但是英语老师的授课方式是听说读写、化学老师的授课方式是燃烧爆炸、语文老师的授课方式是之乎者也。</p><p>所以我们要把授课声明为一个抽象方法。</p><blockquote><p>  你也许会觉得我照样可以写死啊，然后语文老师类继承教师类，然后重写授课这个方法，化学老师类继承教师类，然后也重写授课这个方法，这样也行啊。</p><p>  是的，这样的确可以，不过教师类中写死的那部分就成了一种“默认行为”。当子类重写的时候，执行重写的行为，没有重写则执行这种“默认行为”。</p><p>  不过，当你站在顶层设计的时候，还要为一种抽象行为设置默认，会不会优点顾此失彼哦？</p></blockquote><p>其实当你站在上帝视角设计时，你应该不太愿意陷入细节里，而更愿意把握好大局。我设计一个教师类，我指定它有这些行为，具体怎么实现，谁继承谁负责。就像架构师在设计系统时关注这里用什么技术、那里用什么结构才能让系统更稳定、性能更好，而不是设计到一半陷入到“这个判断这样写是否效率更高”的细节里。所以当有这些抽象行为时，将他们定义为抽象方法更好。</p><p>而从另一个角度来说，任何人，只要他有具体的授课内容，即使他没有工号、没有科室，但他也是教书育人、为人师表不是么？例如孔子，他没有工号、没有科室，但是他教书育人，弟子三千圣贤七十二，不也被尊为至圣先师嘛。</p><p>所以这也是一个稍微哲学的问题，它从更加开放的角度去评判，一个人是否是老师，不是看他有没有教师资格证，有没有工号，有没有科室，只要他实现具体的授课方式，他就是一个老师。</p><p>到这里我想你应该能理解 Golang 中，一个结构体 S 只要实现了接口 I 中的所有方法，就表示 S 实现了 I，A 是一个 I 类型。</p><p>一个司机结构体 <code>Driver</code>，只要实现了教师接口 <code>Teacher</code> 中的授课方法 <code>teach()</code>，<br>那么 <code>Driver</code> 就是一个 <code>Teacher</code>，他就是一个教练，<br><code>Driver</code> 就是一个 <code>Teacher</code> 类型。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><blockquote><p>  所以在设计中，我们总会倾向于去定义一些规则，也就是这些抽象行为，然后让实现者自己来实现。这就是接口——interface。</p></blockquote><p>在 Golang 和 面向对象的典型代表 Java 中都有对接口的支持。在 Java 中一个类实现某个接口时要显式的使用 <code>implements</code> 关键字，在 Golang 中则是某个接口体具有接口中的所有方法的具体实现即可。一种是侵入式的，一种是非侵入式的。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><blockquote><p>  有时候我就是想在设计某个类型的时候，它有的行为是抽象的，我不指定它的默认行为；而有的行为我就给它个默认行为。</p><p>  那么这种时候可以使用抽象类。接口是绝对抽象的，类是绝对具象的，而抽象类则是在绝对抽象和绝对具象之间。</p></blockquote><p>就像第一句话说的，有些行为我就想给它个默认行为，有些则不想。而接口不会有具体实现，类必须有具体实现，而抽象类则是可以有具体实现，也可以没有具体实现。</p><p>例如教师类有授课、打卡上班两种行为。授课方式多种多样，打卡上班方式也多种多样。那我现在只声明授课是一种抽象行为，谁继承谁自行实现，再给打卡上班指定一种默认行为方式 —— 指纹打卡。</p><p>如此当 语文老师类 继承了 教师类 以后，必须实现授课的具体行为，也就是实现抽象方法；至于打卡上班行为，可以重写个人脸识别打卡，也可以不重写，那就默认指纹打卡。</p><p><strong>所以抽象类更像一种中庸之道。取绝对抽象和绝对具象的折中，增加了程序的灵活性。</strong></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在设计时，将一类事物的共有的属性和行为提取出来，定义为一类。</p><p>将多个类中重复的部分剥离出来，定义为父类，让子类去继承。</p><p>为一类事物定性时可以不关注具体其具体行为，只关注其有没有这个行为即可。这些行为称为抽象行为，即抽象方法。将这些抽象行为封装起来，就是一个接口。</p><p>为一类事物定性时，想要给一些抽象行为设置默认行为，就改用抽象类。</p><h2 id="Golang-实现抽象类"><a href="#Golang-实现抽象类" class="headerlink" title="Golang 实现抽象类"></a>Golang 实现抽象类</h2><p>Golang 中的接口是非侵入式的，接口中的方法是没有具体实现的，抽象类是可以有具体实现的，于是将接口和结构体结合起来，实现抽象类。</p><p>抽象类分两种情况：具有默认行为的抽象方法使用到 <code>this</code> 的 和 没使用到的。</p><h3 id="没使用到-this-的情况"><a href="#没使用到-this-的情况" class="headerlink" title="没使用到 this 的情况"></a>没使用到 this 的情况</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义抽象类</span></span><br><span class="line"><span class="keyword">type</span> IAbsClass <span class="keyword">interface</span> &#123;<span class="comment">// 使用接口定义抽象行为</span></span><br><span class="line">    abs()<span class="comment">// 抽象方法，需要子类实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AbsClass <span class="keyword">struct</span> &#123;&#125;<span class="comment">// 定义抽象类结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this AbsClass)</span> <span class="title">common</span><span class="params">()</span></span>  &#123;<span class="comment">// 具有默认行为的抽象方法，没使用到 this</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;AbsClass common()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------- 分割线 -----------------------------</span></span><br><span class="line"><span class="comment">// 子类1继承抽象类</span></span><br><span class="line"><span class="keyword">type</span> SubClass1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    AbsClass</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this SubClass1)</span> <span class="title">abs</span><span class="params">()</span></span> &#123;<span class="comment">// 子类实现抽象方法</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;SubClass1 implement abs().&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSubClass1</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">SubClass1</span></span> &#123;<span class="comment">// 子类构造方法</span></span><br><span class="line">    s := <span class="built_in">new</span>(SubClass1)</span><br><span class="line">    s.name = name</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类2继承抽象类</span></span><br><span class="line"><span class="keyword">type</span> SubClass2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    AbsClass</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this SubClass2)</span> <span class="title">abs</span><span class="params">()</span></span> &#123;<span class="comment">// 子类实现抽象方法</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;SubClass2 implement abs().&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this SubClass2)</span> <span class="title">common</span><span class="params">()</span></span> &#123;<span class="comment">// 子类重写抽象方法</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;SubClass2 overwrite common().&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSubClass2</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">SubClass2</span></span> &#123;<span class="comment">// 子类构造方法</span></span><br><span class="line">    s := <span class="built_in">new</span>(SubClass)</span><br><span class="line">    s.name = name</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过接口 <code>IAbsClass</code> 定义抽象方法 <code>abs()</code>，然后定义一个配对的结构体 <code>AbsClass</code>，结构体实现那些具有默认行为的抽象方法 <code>common()</code>。</p><p>然后子类 <code>SubClass1</code> 和 <code>SubClass2</code> 继承抽象类，也就是嵌入匿名字段 <code>AbsClass</code>，然后自己实现抽象方法 <code>abs()</code> 。</p><p>而且 <code>SubClass2</code> 还对有默认行为的 <code>common()</code> 不满意，自己进行了重写。</p><p>使用方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sub1 := NewSubClass1(<span class="string">&quot;Boii&quot;</span>)</span><br><span class="line">    sub2 := NewSubClass2(<span class="string">&quot;Eva&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    sub1.abs()<span class="comment">// &quot;SubClass1 implement abs().&quot;</span></span><br><span class="line">    sub2.abs()<span class="comment">// &quot;SubClass2 implement abs().&quot;</span></span><br><span class="line">    </span><br><span class="line">    sub1.common()<span class="comment">// &quot;AbsClass common()&quot;</span></span><br><span class="line">    sub2.common()<span class="comment">// &quot;SubClass2 overwrite common().&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>SubClass2</code> 对具有默认行为的抽象方法 <code>common()</code> 进行了重写，所以调用时调的是重写的方法。</p><h3 id="使用到-this-的情况"><a href="#使用到-this-的情况" class="headerlink" title="使用到 this 的情况"></a>使用到 this 的情况</h3><p>Golang 中本身并不是明确支持继承，所以如果我们为抽象方法定义默认行为是需要使用到 this 的话，Golang 不会做自动转换，它会认为这个 this 就是 <code>AbsClass</code> 本身，而不是 <code>SubClass1</code> 或 <code>SubClass2</code>。</p><p>基于这种情况，我们需要 3 步：</p><ol><li>  在 <code>AbsClass</code> 中加入一个接口字段 <code>i IAbsClass</code></li><li>  在使用 this 的时候换成 <code>this.i</code></li><li>  由于 i 是个接口类型，子类 <code>SubClass1、SubClass2</code> 在实例化时得将自己注册进去。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">type</span> IAbsClass <span class="keyword">interface</span> &#123;</span><br><span class="line">    abs()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AbsClass <span class="keyword">struct</span> &#123;</span><br><span class="line">    i IAbsClass<span class="comment">// == 增加一个接口字段 == </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this AbsClass)</span> <span class="title">common1</span><span class="params">()</span></span> &#123;<span class="comment">// 具有默认行为的抽象方法，没使用到 this</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;AbsClass common()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this AbsClass)</span> <span class="title">common2</span><span class="params">()</span></span> &#123;<span class="comment">// 具有默认行为的抽象方法，使用到了 this</span></span><br><span class="line">    this.i.abs()<span class="comment">// == 不能直接 this，要用 this.i ==</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------- 分割线 -----------------------------</span></span><br><span class="line"><span class="comment">// 子类1继承抽象类</span></span><br><span class="line"><span class="keyword">type</span> SubClass1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    AbsClass</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this SubClass1)</span> <span class="title">abs</span><span class="params">()</span></span> &#123;<span class="comment">// 子类实现抽象方法</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;SubClass1 implement abs().&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSubClass1</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">SubClass1</span></span> &#123;<span class="comment">// 子类构造方法</span></span><br><span class="line">    s := <span class="built_in">new</span>(SubClass1)</span><br><span class="line">    s.AbsClass.i = s<span class="comment">// == 将自己注册进去 ==</span></span><br><span class="line">    s.name = name</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类2继承抽象类</span></span><br><span class="line"><span class="keyword">type</span> SubClass2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    AbsClass</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this SubClass2)</span> <span class="title">abs</span><span class="params">()</span></span> &#123;<span class="comment">// 子类实现抽象方法</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;SubClass2 implement abs().&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSubClass2</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">SubClass2</span></span> &#123;<span class="comment">// 子类构造方法</span></span><br><span class="line">    s := <span class="built_in">new</span>(SubClass)</span><br><span class="line">    s.name = name</span><br><span class="line">    s.AbsClass.i = s<span class="comment">// == 将自己注册进去 ==</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样通过子类 <code>SubClass1、SubClass2</code> 调用 <code>common()</code> 时才能正确的执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sub1 := NewSubClass1(<span class="string">&quot;Boii&quot;</span>)</span><br><span class="line">    sub2 := NewSubClass2(<span class="string">&quot;Eva&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    sub1.common2()<span class="comment">// &quot;SubClass1 implement abs().&quot;</span></span><br><span class="line">    sub2.common2()<span class="comment">// &quot;SubClass2 implement abs().&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过有无这种行为去定性一个类，而不是通过如何实现这种行为去定性，这就是面向接口编程。</p><p>将一些行为聚合在一起，不实现它们，就是一个接口。如果要给这些行为一个默认行为，那就用抽象类。</p><p>Java 中的抽象类和接口都支持成员变量，但在 Golang 中实现抽象类时，无法兼顾成员变量，因为接口不可以有变量。虽然可以把抽象类的成员变量放在抽象类结构体中，也可以在子类中访问到，但是无法做到泛化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(ia IAstClass)</span></span> &#123;</span><br><span class="line">    fmt.Println(ia.name)<span class="comment">// 编译失败，接口中没有变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a AstClass)</span></span> &#123;</span><br><span class="line">    fmt.Println(a.name)<span class="comment">// 编译失败，无法将子类传进来 test(sub1)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(ia IAstClass)</span></span> &#123;</span><br><span class="line">    fmt.Println(ia.(AstClass).name)<span class="comment">// 编译失败，test(sub1) 会报错说断言失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然可以在抽象类接口中，为抽象类结构体增加 getter、setter 方法，然后抽象类结构体实现 getter、setter 方法，但其实也不是好。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">type</span> IAbsClass <span class="keyword">interface</span> &#123;</span><br><span class="line">    abs()</span><br><span class="line">    getAbsName() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AbsClass <span class="keyword">struct</span> &#123;</span><br><span class="line">    i IAbsClass<span class="comment">// == 增加一个接口字段 == </span></span><br><span class="line">    absName <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a AbsClass)</span> <span class="title">getAbsName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.absName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------- 分割线 -----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(ia IAstClass)</span></span> &#123;</span><br><span class="line">    fmt.Println(ia.getAstName())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性多了可以将所有的 getter、setter 放在一个接口 <code>IGetAstAttr</code> 中，然后 <code>IAstClass</code> 中嵌入这个 <code>IGetAstAttr</code>，或者更进一步使用选项设计模式管理所有 getter、setter。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">type</span> IAbsClass <span class="keyword">interface</span> &#123;</span><br><span class="line">    IGetAstAttr</span><br><span class="line">    abs()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IGetAstAttr <span class="keyword">interface</span> &#123;</span><br><span class="line">    getAbsName()  <span class="keyword">string</span></span><br><span class="line">    getAbsAge()   <span class="keyword">int</span></span><br><span class="line">    getAbsEmail() <span class="keyword">string</span></span><br><span class="line">    </span><br><span class="line">    setAbsName()  <span class="keyword">string</span></span><br><span class="line">    setAbsAge()   <span class="keyword">int</span></span><br><span class="line">    setAbsEmail() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AbsClass <span class="keyword">struct</span> &#123;</span><br><span class="line">    i IAbsClass<span class="comment">// == 增加一个接口字段 == </span></span><br><span class="line">    <span class="comment">// 抽象类的成员变量</span></span><br><span class="line">    absName  <span class="keyword">string</span></span><br><span class="line">4absAge   <span class="keyword">int</span></span><br><span class="line">    absEmail <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a AbsClass)</span> <span class="title">getAbsName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.absName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------- 分割线 -----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(ia IAstClass)</span></span> &#123;</span><br><span class="line">    fmt.Println(ia.getAstName())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我总觉得这样违背了 Golang 的设计哲学。我也不喜欢这种脱离本质的东西。如果已经到了这种程度，倒不如重新设计，看看如何通过组合替代继承。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> Advanced </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 面向对象 </tag>
            
            <tag> 抽象类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang [深入理解] 9-值实现 VS 指针实现</title>
      <link href="posts/aabd6c1b.html"/>
      <url>posts/aabd6c1b.html</url>
      
        <content type="html"><![CDATA[<p>都是实现，有啥区别？</p><span id="more"></span><h1 id="值实现-VS-指针实现"><a href="#值实现-VS-指针实现" class="headerlink" title="值实现 VS 指针实现"></a>值实现 VS 指针实现</h1><p>值接收者方法（Value receiver method）和指针接收者方法（Pointer receiver method），都可以被结构体变量（struct variable）或结构体指针（struct pointer）调用。</p><p>值接收者方法中，对接收者的修改，<strong>不会</strong>影响调用者。<br>指针接收者方法中，对接收者的修改，<strong>会</strong>影响调用者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span> &#123;</span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s S)</span> <span class="title">read</span><span class="params">()</span></span> &#123;<span class="comment">// 值实现，值接收者方法</span></span><br><span class="line">    s.age = <span class="number">50</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *S)</span> <span class="title">write</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;<span class="comment">// 指针实现，指针接收者方法</span></span><br><span class="line">    s.age = n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sV := A&#123;age: <span class="number">10</span>&#125;<span class="comment">// 结构体变量</span></span><br><span class="line">    sP := &amp;A&#123;age: <span class="number">10</span>&#125;<span class="comment">// 结构体指针</span></span><br><span class="line">    </span><br><span class="line">    sV.read()<span class="comment">// 结构体变量可以调用值实现的方法</span></span><br><span class="line">    fmt.Println(sV.age)<span class="comment">// 10</span></span><br><span class="line">    sV.write(<span class="number">15</span>)<span class="comment">// 结构体变量可以调用指针实现的方法</span></span><br><span class="line">    fmt.Println(sV.age)<span class="comment">// 15</span></span><br><span class="line">    </span><br><span class="line">    sP.read()<span class="comment">// 结构体指针可以调用值实现的方法</span></span><br><span class="line">    fmt.Println(sP.age)<span class="comment">// 10</span></span><br><span class="line">    sP.write(<span class="number">18</span>)<span class="comment">// 结构体指针可以调用指针实现的方法</span></span><br><span class="line">    fmt.Println(sP.age)<span class="comment">// 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述栗子中，</p><ul><li><p>  sP 是结构体指针，在 sP 调用值方法 <code>sP.read()</code> 时，编译器会自动转换为 <code>(*sP).read()</code>；</p></li><li><p>  sV 是结构体变量，在 sV 调用指针方法 <code>sV.write()</code> 时，编译器会自动转换为 <code>(&amp;sV).write(15)</code>。</p></li></ul><table><thead><tr><th></th><th><strong>值接收者方法</strong></th><th><strong>指针接收者方法</strong></th></tr></thead><tbody><tr><td><strong>结构体变量调用者</strong></td><td>可以调用，类似于传值</td><td>可以调用，相当于 <code>(&amp;sV).write(15)</code></td></tr><tr><td><strong>结构体指针调用者</strong></td><td>可以调用，相当于 <code>(*sP).read()</code></td><td>可以调用，类似与传指针，所以会影响调用者</td></tr><tr><td><strong>修改</strong></td><td>不影响调用者</td><td>影响调用者</td></tr></tbody></table><h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p>要看类型的本质。如果一个结构体类型的实例，应该是独一份的，那么就应该用指针接收者方法。</p><p>例如，文件结构体。每个文件都是独一份的，对应地，文件结构体返回一个文件对象，这个对象应该唯一的代表这个文件，所以文件结构体的方法应该使用指针接收者方法。</p><h2 id="涉及接口"><a href="#涉及接口" class="headerlink" title="涉及接口"></a>涉及接口</h2><p>在<strong>不涉及</strong>接口的情况下，值实现和指针实现，结构体变量和结构体指针都调用。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo//blog/illustration-pic/Go/IMG/20210903230710.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo//blog/illustration-pic/Go/IMG/20210903230710.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>但是在<strong>涉及</strong>接口的情况下，这两种实现还是有区别的。</p><ul><li>使用值实现接口方法时，等于 “值实现 + 指针实现”；</li><li>使用指针实现接口方法时，仅等于 “指针实现”。</li></ul><blockquote><p>值实现 = 值实现 + 指针实现</p><p>指针实现 = 指针实现</p></blockquote><p>调用的时候依然是结构体变量和结构体指针都能调值实现方法和指针实现方法，这一点没变。</p><p>区别的地方在于，当你要把结构体传递给接口变量时，会有区分。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo//blog/illustration-pic/Go/IMG/20210904000750.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo//blog/illustration-pic/Go/IMG/20210904000750.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>举个栗子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ier <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Sa <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> Sb <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Sa)</span> <span class="title">print</span><span class="params">()</span></span> &#123;&#125;<span class="comment">// Sa 使用值实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Sb)</span> <span class="title">print</span><span class="params">()</span></span> &#123;&#125;<span class="comment">// Sb 使用指针实现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sav := Sa&#123;&#125;<span class="comment">// 结构体变量，Sa 使用值实现了 Ier</span></span><br><span class="line">    sap := &amp;Sa&#123;&#125;<span class="comment">// 结构体指针，Sa 使用值实现了 Ier</span></span><br><span class="line">    </span><br><span class="line">    sbv := Sb&#123;&#125;<span class="comment">// 结构体变量，Sb 使用指针实现了 Ier</span></span><br><span class="line">    sbp := &amp;Sb&#123;&#125;<span class="comment">// 结构体变量，Sb 使用指针实现了 Ier</span></span><br><span class="line">    </span><br><span class="line">    sav.<span class="built_in">print</span>()<span class="comment">// 结构体变量 可以调用 值实现方法</span></span><br><span class="line">    sap.<span class="built_in">print</span>()<span class="comment">// 结构体指针 可以调用 值实现方法</span></span><br><span class="line">    sbv.<span class="built_in">print</span>()<span class="comment">// 结构体变量 可以调用 指针实现方法</span></span><br><span class="line">    sbp.<span class="built_in">print</span>()<span class="comment">// 结构体指针 可以调用 指针实现方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> ier1 Ier</span><br><span class="line">    ier1 = sav<span class="comment">// 值实现者 的 结构体变量 可以传递给 接口变量</span></span><br><span class="line">    ier1 = sap<span class="comment">// 值实现者 的 结构体指针 可以传递给 接口变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指针实现者 的 结构体变量 不能传给 接口变量 </span></span><br><span class="line">    ier1 = sbv<span class="comment">// cannot use sbv (type Sb) as type Ier in assignment: Sb does not implement Ier (print method has pointer receiver)</span></span><br><span class="line">    ier1 = sbp<span class="comment">// 指针实现者 的 结构体指针 可以传递给 接口变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> Advanced </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 值实现 </tag>
            
            <tag> 指针实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang [深入理解] 7-关于 nil</title>
      <link href="posts/655173cc.html"/>
      <url>posts/655173cc.html</url>
      
        <content type="html"><![CDATA[<p>关于你可能知道的 nil 的使用</p><span id="more"></span><h1 id="关于-nil"><a href="#关于-nil" class="headerlink" title="关于 nil"></a>关于 nil</h1><p><code>nil</code> 是啥？golang 中的 nil 相当于其他语言中的 NULL。</p><p>但 nil 的本质是啥？到底是一种类型？还是一种变量？还是一个关键字？</p><p>按照博主 <a href="https://mp.weixin.qq.com/s/sHLYy_4XA6254-vLmlu0IA">奇伢云存储</a> 的介绍，nil 是一个特殊变量，也是一种触发机制。</p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// nil is a predeclared identifier representing the zero value for a</span></span><br><span class="line">&gt;<span class="comment">// pointer, channel, func, interface, map, or slice type.</span></span><br><span class="line">&gt;<span class="keyword">var</span> <span class="literal">nil</span> Type <span class="comment">// Type must be a pointer, channel, func, interface, map, or slice type</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// Type is here for the purposes of documentation only. It is a stand-in</span></span><br><span class="line">&gt;<span class="comment">// for any Go type, but represents the same type for any given function</span></span><br><span class="line">&gt;<span class="comment">// invocation.</span></span><br><span class="line">&gt;<span class="keyword">type</span> Type <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>在编译器层面，nil 是使用一个变量来表示。</p></blockquote><p>nil 其实是语言层面给出的：在编译器中，nil 是一个 Type 型变量，Type 类型 是以 int 为基础的自定义类型。</p><p>但这不代表我们使用语言编程程序时能把 nil 当作一个变量。比如你把 nil 赋值给一个 byte 型变量，是不可以的，因为编译器不让。这是编译器的特权，你可没有！</p><p>这里明确一点，能够赋值 nil 的类型只有 “引用六兄弟  SMCIFP”：</p><ul><li><code>slice</code></li><li><code>map</code></li><li><code>chan</code></li><li><code>interface</code></li><li><code>func</code></li><li><code>pointer</code></li></ul><p>这就是编译器给你这位语言使用者的权限。在上面的源码中 <code>var nil Type</code> 后面的注释就有写。</p><p>所以除了这 6 兄弟之外，别的类型都<strong>不可以</strong>赋值 nil，或者和 nil 比较。</p><blockquote><p>  你可以把这 “引用六兄弟 SMCIFP” 理解为一种 nilable 的类型。</p><p>  所谓 nilable，就是可以赋值为 nil（able to assign with nil），可以和 nil 比较（able to compare to nil）。</p><p>  如果用 go 提案中用泛型表示，即：</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> nilable <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> []<span class="keyword">int</span>, <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>, <span class="keyword">chan</span> <span class="keyword">int</span>, <span class="keyword">interface</span>&#123;&#125;, unsafe.Pointer, <span class="function"><span class="keyword">func</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span>[<span class="title">T</span> <span class="title">nilable</span>] <span class="params">(a T)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assign</span>[<span class="title">T</span> <span class="title">nilable</span>] <span class="params">(a T)</span></span> &#123;</span><br><span class="line">    a = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  并不严谨，仅仅用于表达 nilable 这个意思而已。</p></blockquote><p>于是在编译器编译你的代码的时候，如果它看到你写出 <code>a == nil</code> 或 <code>a = nil</code> 这样的代码时，它要确认 a 是 nilable 的（是引用六兄弟 SMCIFP）。所以说 nil 是一种触发机制。</p><p>那么这六兄弟有什么特殊呢？</p><p>我们将 go 中的类型分为<code>值类型</code>和<code>引用类型</code> 两类。</p><ul><li>值类型就是 int 系列、uint 系列等；</li><li>引用类型就是 “引用六兄弟 SMCIFP”。</li></ul><p>在 golang 中，使用变量前需要先声明变量。声明变量的本质是分配一块内存。</p><p>Clang（golang 的前辈）在声明变量是分配内存，但也只是分配内存，并不管这块内存里是不是干净的，所以会出现野指针此类问题。</p><p>我写 Clang 的时候就会有一个习惯，在声明变量的时候顺带初始化一个零值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> price = <span class="number">0.0</span>; </span><br><span class="line"><span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>这样的习惯可以有效的预防一些意料之外的情况。</p><p>但是 golang 是二十一世纪的语言，它的变量声明在分配内存时是「置 0 分配」，也就是说 golang 可以保证你声明的变量分配的那块内存是干净的，你可以放心的使用。</p><p>所以在 golang 中声明一个变量但没有初始化，这个变量的值是其类型的零值，即：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum <span class="keyword">int</span>     <span class="comment">// sum == 0</span></span><br><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span>  <span class="comment">// str == &quot;&quot;</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span>      <span class="comment">// p == nil</span></span><br></pre></td></tr></table></figure><h2 id="SMCIFP"><a href="#SMCIFP" class="headerlink" title="SMCIFP"></a>SMCIFP</h2><blockquote><p>  先声明一点：这六兄弟中，slice、map、chan、interface 是一种复合结构，pointer 和 func 是一个指针。</p></blockquote><p>其实上面引用中的这句话已经能大概的看出答案了，因为他们是指针，所以是 nilable。我们可以看看编译器中这“六兄弟”的结构。</p><p>slice</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">   array unsafe.Pointer         <span class="comment">// 管理的内存块首地址</span></span><br><span class="line">   <span class="built_in">len</span>   <span class="keyword">int</span>                    <span class="comment">// 动态数组实际使用大小</span></span><br><span class="line">   <span class="built_in">cap</span>   <span class="keyword">int</span>                    <span class="comment">// 动态数组内存大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.</span></span><br><span class="line">    <span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span></span><br><span class="line">    count     <span class="keyword">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">    flags     <span class="keyword">uint8</span></span><br><span class="line">    B         <span class="keyword">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">    noverflow <span class="keyword">uint16</span> <span class="comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">    hash0     <span class="keyword">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">    oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">    nevacuate  <span class="keyword">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"></span><br><span class="line">    extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chan</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span></span><br><span class="line">    closed   <span class="keyword">uint32</span></span><br><span class="line">    elemtype *_type <span class="comment">// element type</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">    recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">    sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interface</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>func 和 pointer 本身就是一个指针。</p><p>可以看出，map 和 chan 两个都是比较大的结构体，而当你声明一个 map 或 chan 时，你必须通过 <code>make()</code> 才能使用。为什么？</p><p>因为这两个结构体比较大，为了提高性能，你声明的时候 <code>var c chan int</code> 的时候，c 是个指针，当你 <code>make()</code> 的时候才会分配内存，也就是初始化 <code>hchan</code>。map 也是同样的道理。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo//blog/illustration-pic/Go/IMG/IMG20210821110117.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo//blog/illustration-pic/Go/IMG/IMG20210821110117.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>像图中那样，slice、map、chan、interface 不管他们有多大，例如 slice 有 1000 个元素，map 有 10万对键值对，chan 缓存中有 100万 个数据，那都是他们背后的数组的大小；他们本身的大小，只有一个结构体那么大。</p><p>所以编译器在判断 nil 的时候其实非常快，因为这几个类型本身是指针，编译器只需要像如下判断即可：</p><ul><li>对于 slice 的时候，判断 s 中的 array 字段是不是零值；</li><li>对于 map、chan 的时候，判断 m、c 自身是不是零值；</li><li>对于 interface 的时候，判断 i 自身是不是零值；</li><li>对于 pointer、func 的时候，判断 p、f 自身是不是零值；</li></ul><p>同样，在赋值 nil 的时候，也是把他们自身赋值为 nil 即可。</p><p>除了 slice，因为它的结构比较小，总共就 24Byte（32位机中 12B），所以声明的时候直接初始化了一个 slice 结构，对 array 字段进行维护。</p><p>具体细节，推荐仔细阅读 <a href="https://mp.weixin.qq.com/s/sHLYy_4XA6254-vLmlu0IA">https://mp.weixin.qq.com/s/sHLYy_4XA6254-vLmlu0IA</a>，这篇文章讲的非常通俗和详细。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>nil 只能用于引用六兄弟 SMCIFP；</li><li>变量只是一个指向一块内存的指针</li><li>slice 结构较小，所以声明的时候就直接分配内存了，map 和 chan 需要 make() 才分配内存。</li><li>除了 pointer 和 func，其他都是使用对应结构体来管理</li><li>对 MCIFP 的判断 nil 和 赋值 nil，都是对变量本身进行操作，而 Slice 是对 array 字段进行操作。</li></ol><p>再次强烈推荐阅读 <a href="https://mp.weixin.qq.com/s/sHLYy_4XA6254-vLmlu0IA">https://mp.weixin.qq.com/s/sHLYy_4XA6254-vLmlu0IA</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> Advanced </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 引用类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang [深入理解] 4-string 实现原理</title>
      <link href="posts/bf9901b3.html"/>
      <url>posts/bf9901b3.html</url>
      
        <content type="html"><![CDATA[<p>关于你可能知道的 string</p><span id="more"></span><h1 id="string-实现原理"><a href="#string-实现原理" class="headerlink" title="string 实现原理"></a>string 实现原理</h1><h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>在计算机中，一切都是数字「0」和「1」，确切点说应该是「低电平」和「高电平」。</p><p>从理论角度来说，「数」是客观存在的，是真理般的存在，而「进制」是主观存在的，是人类掌握「数」的一种工具。</p><p>一个数，可以用二进制、八进制、十进制、十六进制、二十六进制、三十八进制等各种进制来表示。不同进制之间可以按照一定规则进行转换，0 和 1 两个数字，可以组成二进制的最基本单位，所以可以通过 101 表示十进制 5，110 表示十进制 6。</p><p>于是，在计算机中，不管我们要表示任何数，只要转换成二进制，并替换成计算机中的高低电平，既可以在计算机中确切的表示一个数。</p><p>但是人类世界不仅有数，还有文字。文字由一个一个字符组成，正如英文由字母组成，汉字由笔画组成。在计算机中无法直接表示文字，于是计算机先驱们想出了使用“编号约定”的办法，为每一个字符编一个数字编号，这样就使得文字和数字之间有了映射关系，进而可以在计算机中表示文字。</p><p>最初的“编号约定”是 ASCII 码表，由于计算机发展于西方，西文的基本单位 26 个字母，大小写一共 52 个，加上一些符号、控制字符，组成了 ASCII 码表。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo//blog/illustration-pic/Go/IMG/20210905115324.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo//blog/illustration-pic/Go/IMG/20210905115324.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>基础 ASCII 码表只有 127 个字符，使用 7 个比特（7 位二进制数）即可表示，而在计算机中 8 个比特组成 1 个字节，所以基础 ASCII 码表也好，扩展 ASCII 码表也好，用 1 个字节足矣。</p><p>但是人类语言不止英文一种，还有中文、俄文、日文等等，每种语言一个编码表又使得相互之间会导致码值冲突，混乱不堪。所以 Unicode 通用学术学会便制定了一个通用字符集 UTF，国内也称作“万国码”，由此促进了文字在每一台计算机上的兼容性，防止两台计算机采用不同的编码方式导致 A 计算机的文字到 B 计算机上变成乱码。</p><p>UTF 采用的是变长编码（有兴趣的同学自行了解为什么不是定长编码 <a href="https://www.bilibili.com/video/BV1hv411x7we">Golang string</a> ），小编号的字符占少字节，大编号占多字节。每一个字符的编码中的每一个字节都有几个位来用作“前缀”，通过前缀识别出该字节属于哪一个区间。具体如下：</p><table><thead><tr><th>编号</th><th>编码模版</th></tr></thead><tbody><tr><td>0~127</td><td>0xxx xxxx</td></tr><tr><td>128~2047</td><td>110x xxxx 10xx xxxx</td></tr><tr><td>2048~65535</td><td>1110 xxxx 10xx xxxx 10xx xxxx</td></tr></tbody></table><p>例如，英文字符 <code>c</code> 的编号为 99，在 0 到 127 的区间，于是采用 <code>0xxx xxxx</code> 的模板，十进制 99 转为二进制为 <code>1100011</code>，替换到 <code>xxx xxxx</code>，最终编码结果为 <code>0110 0011</code>。</p><p>再比如，中文字符 <code>世</code> 的编号为 19990，在 2048 到 65535 的区间，于是采用 <code>1110 xxxx 10xx xxxx 10xx xxxx</code> 的模板，十进制的 19990 转为二进制为 <code>0100 1110 0001 0110</code> ，替换到模板中，最终编码结果为 <code>1110 0100 1011 1000 1001 0110</code>。</p><p>再比如，当计算机看到 <code>1110 0111 10 010101 10 001100</code> 时，第一个字节的前缀 <code>1110</code> 使得计算机明白，这个字符一共占用 3 个字节，除了读取完当前这个字节，还要往后读取 2 个字节。于是从第一个字节中抽取 <code>0111</code>，第二和第三个字节剥离前缀 <code>10</code> 后得到 <code>010101</code> 和 <code>001100</code>，将这三部分拼接得到 <code>0111 010101 001100</code>，十进制为 30028，对应中文字符 <code>界</code> 字。</p><h2 id="string-结构"><a href="#string-结构" class="headerlink" title="string 结构"></a>string 结构</h2><p>说回 string 结构。在 C 语言中，字符串是一个字符数组指针，指向一个字符数组，这样便知道了字符串的开始，使用 <code>\0</code> 表示字符串结束。这样的设计存在的问题是，字符串中无法表示 <code>\0</code> 本身。</p><p>golang 在这个基础上进行了改进，没有采用 <code>\0</code> 表示，而是增加了一个 <code>len</code> 字段用于记录字节数组 <code>str</code> 的长度，这样即可以在字符串中使用 <code>\0</code>，而且求字符串长度时直接返回 <code>len</code> 的值即可，时间复杂度仅为 <code>O(1)</code>。</p><p>在源码包中 <code>src/runtime/stirng.go:stringStruct</code> 对 字符串 定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    str unsafe.Pointer<span class="comment">// 指向字节数组的指针</span></span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span><span class="comment">// 字节数组的长度，即字节个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是，<code>len</code> 表示的是 <code>str</code> 这个字节数组的长度，不是字符的长度。因为有的字符的长度为 2，有的为 3，有的为 1。例如一个中英混合的字符串 <code>&quot;abc世界&quot;</code>，它的 len 为 9，<code>abc</code> 占用 3 字节，<code>世</code> 占用 3 字节，<code>界</code> 占用 3 字节。</p><h2 id="复制问题"><a href="#复制问题" class="headerlink" title="复制问题"></a>复制问题</h2><p>字符串的复制有 2 种方法：</p><ul><li>  直接赋值 <code>=</code></li><li>  <code>re-slice</code> 语法</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">hello2 := hello1<span class="comment">// hello</span></span><br><span class="line">hello3 := hello1[<span class="number">1</span>:<span class="number">4</span>]<span class="comment">// ell</span></span><br></pre></td></tr></table></figure><p>采用这两种方法时，两个字符串共享同一个底层字节数组，也就是说，是一种浅复制。</p><p>因为 Golang 中字符串一旦定义就不可更改，对字符串中字符的修改较为麻烦，且修改完后会返回一个新的修改好的字节数组，已经不是一开始那个字节数组了，所以可以放心的使用浅复制。</p><h2 id="类型转换问题"><a href="#类型转换问题" class="headerlink" title="类型转换问题"></a>类型转换问题</h2><p>一个字符串的值可以显式地转换成一个字节切片 <code>[]byte</code>，反过来也可以。字节 <code>byte</code> 是 <code>uint8</code> 的别名，所以 <code>[]byte</code> 等于 <code>[]uint8</code>。</p><p>一个字符串的值可以显式地转换成一个码点切片 <code>[]rune</code>，反过来也可以。码点 <code>rune</code> 是 <code>uint32</code> 的别名，所以 <code>[]rune</code> 等于 <code>[]uint32</code>。</p><p>所以转换问题的主角就是 <code>string</code>、<code>[]byte</code>、<code>[]rune</code> 三者。</p><h3 id="rune-gt-string"><a href="#rune-gt-string" class="headerlink" title="[]rune -&gt; string"></a><code>[]rune -&gt; string</code></h3><p>在一个从码点切片 <code>[]rune</code> 到字符串 <code>string</code> 的转换中，码点切片中的每个码点值 <code>rune</code> 将被 UTF-8 编码为一到四个字节至结果字符串中。 </p><p>如果一个码点值是一个不合法的Unicode码点值，则它将被视为「Unicode替换字符值（Unicode replacement character）<code>0xFFFD</code>」。</p><p> 替换字符值<code>0xFFFD</code>将被 UTF-8 编码为三个字节<code>0xef 0xbf 0xbd</code>。</p><h3 id="string-gt-rune"><a href="#string-gt-rune" class="headerlink" title="string -&gt; []rune"></a><code>string -&gt; []rune</code></h3><p>当一个字符串 <code>string</code> 被转换为一个码点切片 <code>[]rune</code> 时，此字符串中存储的字节序列将被解读为一个一个码点的 UTF-8 编码序列。</p><p>非法的UTF-8编码字节序列将被转化为Unicode替换字符值<code>0xFFFD</code>。</p><h3 id="string-gt-byte"><a href="#string-gt-byte" class="headerlink" title="string -&gt; []byte"></a><code>string -&gt; []byte</code></h3><p>当一个字符串 <code>string</code> 被转换为一个字节切片 <code>[]byte</code> 时，结果切片中的底层字节序列是此字符串中存储的字节序列的一份<strong>深复制</strong>。</p><p> 即Go运行时将为结果切片开辟一块足够大的内存来容纳被复制过来的所有字节。当此字符串的长度较长时，此转换开销是比较大的。</p><h3 id="byte-gt-string"><a href="#byte-gt-string" class="headerlink" title="[]byte -&gt; string"></a><code>[]byte -&gt; string</code></h3><p>当一个字节切片 <code>[]byte</code> 被转换为一个字符串 <code>string</code> 时，此字节切片中的字节序列也将被<strong>深复制</strong>到结果字符串中。 当此字节切片的长度较长时，此转换开销同样是比较大的。</p><p>在这两种转换（<code>string -&gt; []byte</code>、<code>[]byte -&gt; string</code>）中，必须使用深复制的原因是：</p><blockquote><p>  <code>[]byte</code> 字节切片中的字节元素是可修改的，但是字符串中的字节是不可修改的；</p><p>  所以一个 <code>[]byte</code> 和一个字符串 <code>string</code> 是不能共享底层字节序列的。</p></blockquote><p>请注意，在字符串和字节切片之间的转换中，</p><ul><li>  非法的UTF-8编码字节序列将被保持原样不变。</li><li>  标准编译器做了一些优化，从而使得这些转换在某些情形下将不用深复制。 这样的情形将在下一节中介绍。</li></ul><h3 id="byte-lt-gt-rune"><a href="#byte-lt-gt-rune" class="headerlink" title="[]byte &lt;-!-&gt; []rune"></a><code>[]byte &lt;-!-&gt; []rune</code></h3><p>Go并不支持字节切片和码点切片之间的直接转换。我们可以用下面列出的方法来实现这样的转换：</p><ul><li>  利用字符串做为中间过渡。这种方法相对方便但效率较低，因为需要做两次深复制。</li><li>  使用<a href="https://golang.google.cn/pkg/unicode/utf8/">unicode/utf8</a>标准库包中的函数来实现这些转换。 这种方法效率较高，但使用起来不太方便。</li><li>  使用<a href="https://golang.google.cn/pkg/bytes/#Runes"><code>bytes</code>标准库包中的<code>Runes</code>函数</a>来将一个字节切片转换为码点切片（<code>[]byte -&gt; []rune</code>：<code>bytes.Runes()</code>）。 但此包中没有将码点切片转换为字节切片的函数。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">4<span class="string">&quot;bytes&quot;</span></span><br><span class="line">4<span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">4s := <span class="string">&quot;颜色感染是一个有趣的游戏。&quot;</span></span><br><span class="line">4bs := []<span class="keyword">byte</span>(s) <span class="comment">// string -&gt; []byte</span></span><br><span class="line">4s = <span class="keyword">string</span>(bs)  <span class="comment">// []byte -&gt; string</span></span><br><span class="line">4rs := []<span class="keyword">rune</span>(s) <span class="comment">// string -&gt; []rune</span></span><br><span class="line">4s = <span class="keyword">string</span>(rs)  <span class="comment">// []rune -&gt; string</span></span><br><span class="line"></span><br><span class="line">4rs = bytes.Runes(bs) <span class="comment">// []byte -&gt; []rune</span></span><br><span class="line">4bs = Runes2Bytes(rs) <span class="comment">// []rune -&gt; []byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Runes2Bytes</span><span class="params">(rs []<span class="keyword">rune</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">4n := <span class="number">0</span></span><br><span class="line">4<span class="keyword">for</span> _, r := <span class="keyword">range</span> rs &#123;</span><br><span class="line">44n += utf8.RuneLen(r)</span><br><span class="line">4&#125;</span><br><span class="line">4n, bs := <span class="number">0</span>, <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">4<span class="keyword">for</span> _, r := <span class="keyword">range</span> rs &#123;</span><br><span class="line">44n += utf8.EncodeRune(bs[n:], r)</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="keyword">return</span> bs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本小节摘自 <a href="https://gfw.go101.org/article/string.html">《Go 101》字符串相关的类型转换</a></p><h2 id="比较问题"><a href="#比较问题" class="headerlink" title="比较问题"></a>比较问题</h2><p>字符串类型都是可比较类型，因为底层是字节数组，和字符 <code>byte</code>、<code>rune</code> 一样，他们背后的基础类型是 <code>uint8</code> 和 <code>uint32</code> 。</p><p>所以两个字符串 <code>string</code> 或 两个字符 <code>byte、rune</code> 之间可以使用等于、不等、大于、大于等于、小于、小于等于的比较：<code>string == string</code>、<code>string != string</code>、<code>string &gt; string</code>、<code>rune &gt;= rune</code>、<code>byte &lt; byte</code>、<code>byte &lt;= byte</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hello := <span class="string">&quot;hello&quot;</span></span><br><span class="line">world := <span class="string">&quot;world&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(hello == world)<span class="comment">// false</span></span><br><span class="line">fmt.Println(hello != world)<span class="comment">// true</span></span><br><span class="line">fmt.Println(hello &gt; world)<span class="comment">// false</span></span><br><span class="line">fmt.Println(hello &gt;= world)<span class="comment">// false</span></span><br><span class="line">fmt.Println(hello &lt; world)<span class="comment">// true</span></span><br><span class="line">fmt.Println(hello &lt;= world)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>当比较两个字符串值的时候，它们的底层字节将逐一进行比较。</p><p>如果一个字符串 a 是另一个字符串 b 的前缀，并且另一个字符串 b 较长;<br>则另一个字符串 b 为两者中的较大者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello := <span class="string">&quot;hello&quot;</span></span><br><span class="line">world := <span class="string">&quot;world&quot;</span></span><br><span class="line">helloworld := hello + world</span><br><span class="line"></span><br><span class="line">fmt.Println(hello &gt; helloworld) <span class="comment">// false</span></span><br><span class="line">fmt.Println(hello &gt;= helloworld) <span class="comment">// false</span></span><br><span class="line">fmt.Println(hello &lt; helloworld) <span class="comment">// true</span></span><br><span class="line">fmt.Println(hello &lt;= helloworld) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="字符串相等比较"><a href="#字符串相等比较" class="headerlink" title="字符串相等比较"></a>字符串相等比较</h3><p>对于两个字符串相等或不等的比较，Go编译器会先比较他们的 <code>len</code> 字段：</p><ul><li>  如果两个 <code>len</code> 的值不相等，则两个字符串肯定不相等；</li><li>  如果两个 <code>len</code> 的值相等，则比较两个字符串底层的字节数组指针 <code>str</code> 是否相等，也就是看看是不是引用了同一个底层字节数组。如果是则相等，如果不是则逐个比较每一个字节。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> Advanced </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang [深入理解] 2-slice 实现原理</title>
      <link href="posts/cd747566.html"/>
      <url>posts/cd747566.html</url>
      
        <content type="html"><![CDATA[<p>关于你可能知道的 slice</p><span id="more"></span><h1 id="slice-实现原理"><a href="#slice-实现原理" class="headerlink" title="slice 实现原理"></a>slice 实现原理</h1><p>slice 是一段底层数组的描述。</p><blockquote><p>在 <a href="https://golang.org/ref/spec#Slice_types">golang spec</a> 是这么说的：</p><p>A slice is a descriptor for a contiguous segment of an <em>underlying array</em> and provides access to a numbered sequence of elements from that array. A slice type denotes the set of all slices of arrays of its element type. The number of elements is called the length of the slice and is never negative. The value of an uninitialized slice is <code>nil</code>.</p><p>切片是底层数组的连续段的描述符，提供对该数组中编号的元素序列的访问。切片类型表示其元素类型的数组的所有切片的集合。元素的数量称为切片的长度，并且永远不会为负。未初始化切片的值为<code>nil</code>。</p></blockquote><h2 id="slice-结构"><a href="#slice-结构" class="headerlink" title="slice 结构"></a>slice 结构</h2><p>在源码包中 <code>src/runtime/slice.go:slice</code> 对 Slice 定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个结构体可以更清晰看出，切片是基于一个底层数组的（即 array 字段，其为一个指针，指向一个数组），并且带有两个字段：<code>长度 len</code> 和 <code>容量 cap</code>。</p><ul><li><p>  容量，指的是切片的底层数组的元素最大个数。</p></li><li><p>  长度，指的是切片的底层数组的元素目前个数。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Go/IMG/IMG20210820132115.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Go/IMG/IMG20210820132115.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>创建切片共有 3 种方式：</p><ol><li><p>  通过字面量直接创建</p></li><li><p>  基于已有 数组/slice 创建</p></li><li><p>通过 make() 创建</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">8</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;<span class="comment">// 1. 通过字面量直接创建</span></span><br><span class="line">s2 := arr[<span class="number">2</span>:<span class="number">6</span>]<span class="comment">// 2. 通过下标基于数组或切片创建</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">20</span>)<span class="comment">// 3. 通过关键字 make 创建</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="re-slice"><a href="#re-slice" class="headerlink" title="[:] re-slice"></a><code>[:]</code> re-slice</h2><p><code>[:]</code> 语法在 <a href="https://golang.org/ref/spec#Slice_types">golang spec</a> 称为 <code>Slice Expression</code>，也有称作 <code>re-slice</code>，是 golang 中很常用的一种获得切片的方法。但在使用时有一些地方需要注意。</p><p><code>[:]</code> 语法有两种基本形式：</p><ol><li>  <code>[low : high]</code></li><li>  <code>[low : high : max]</code></li></ol><p>第一种基本形式中，low 和 high 都<strong>允许使用字面常量或变量</strong>，都<strong>允许忽略不写</strong>，所以有以下几种形式：</p><ul><li>  <code>[2:5]</code>、<code>[2:]</code>、<code>[:5]</code>、<code>[:]</code></li></ul><p>第二种基本形式中，low、high、max 都<strong>允许使用字面常量或变量</strong>，但只允许 low 忽略不写，所以只有 2 种形式：</p><ul><li>  <code>[2:5:6]</code>、<code>[:5:6]</code></li></ul><p>在忽略不写的情况下：</p><ul><li><p>  low的默认值为 <code>0</code>，即基础数组的第一个元素开始算起</p></li><li><p>  high的默认值为 <code>len(基础数组/切片)</code>，即基础数组/切片的最后一个</p></li><li><p>  max 的默认值为 <code>len(底层数组)</code>，即底层数组的最后一个元素（包含最后一个元素）</p></li></ul><p>举个栗子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">10</span>)    <span class="comment">// 切片 b，b 的基础数组和底层数组都是某个匿名数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">8</span>; i++ &#123;</span><br><span class="line">4b = <span class="built_in">append</span>(b, i+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;b:&quot;</span>, b)<span class="comment">// b: [1 2 3 4 5 6 7 8] </span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(b), <span class="built_in">cap</span>(b))<span class="comment">// 8 10</span></span><br><span class="line"></span><br><span class="line">j := b[<span class="number">2</span>:<span class="number">7</span>]<span class="comment">// 切片 j，基础数组是 b，底层数组是某个匿名数组</span></span><br><span class="line">fmt.Println(<span class="string">&quot;j:&quot;</span>, j)<span class="comment">// j: [3 4 5 6 7]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(j), <span class="built_in">cap</span>(j))<span class="comment">// 5 8</span></span><br><span class="line"></span><br><span class="line">k := j[<span class="number">2</span>:]<span class="comment">// 切片 k，基础数组是 j，底层数组是某个匿名数组</span></span><br><span class="line">fmt.Println(<span class="string">&quot;k:&quot;</span>, k)<span class="comment">// k: [5 6 7]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(k), <span class="built_in">cap</span>(k))<span class="comment">// 3 6</span></span><br><span class="line"></span><br><span class="line">l := j[<span class="number">1</span>:<span class="number">4</span>:<span class="number">6</span>]<span class="comment">// 切片 l，基础数组是 j, 底层数组是某个匿名数组</span></span><br><span class="line">fmt.Println(<span class="string">&quot;l:&quot;</span>, l)<span class="comment">// l: [4 5 6]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(l), <span class="built_in">cap</span>(l))<span class="comment">// 3 5</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Go/IMG/image-20210820161028818.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Go/IMG/image-20210820161028818.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>此外 low、high、max 的默认值也有一些要求，但概括起来就是：<br>$$<br>0 \le low \le len(s) \le high \le max \le cap(s)<br>$$<br>即：low 不能超过 high、high 不能超过 max、max 不能超过 cap(s)；反之，max 不能小于 high、high 不能小于 low、low 不能小于 0。</p><ul><li>  low 的取值在 <code>[0, high]</code></li><li>  high 的取值在 <code>[low, max]</code></li><li>  max 的取值在 <code>[high, cap(s)]</code></li></ul><h2 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a>扩容策略</h2><p>Slice 是基于底层数组的一种动态数组，相对于长度固定的数组，Slice 更灵活，且体现在：当底层数组容量不足时，Slice 会自动扩容。既然会自动扩容，那么就一定有扩容策略。</p><p>扩容关注点：容量<br>扩容时机：<code>len(s) == cap(s)</code><br>扩容触发场景：<code>len(s) == cap(s)</code> 时继续使用 <code>append()</code> 追加元素<br>扩容策略：</p><ul><li><p>扩容后能容纳要追加的元素：</p><ul><li>  <code>if oldCap &lt;  1024 &#123; newCap = oldCap * 2&#125;</code></li><li>  <code>if oldCap &gt;= 1024 &#123; newCap = oldCap * 1.25&#125;</code></li></ul></li><li><p>扩容后不能容纳要追加的元素：</p><ul><li>  newCap = 预估的容量</li></ul></li></ul><h2 id="复制问题"><a href="#复制问题" class="headerlink" title="复制问题"></a>复制问题</h2><p>在复制 Slice 时，如果仅仅使用等于号 <code>s1 = s2</code>，这样只是拷贝了一个地址。</p><p>要实现完全的复制，需要使用 golang 提供的 <code>copy()</code> 函数。</p><p> <img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Go/IMG/IMG20210820183847.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Go/IMG/IMG20210820183847.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>使用 <code>copy()</code> 拷贝时，会将源切片的元素逐个拷贝到目的切片指向的数组中，拷贝的数量取两个切片长度的最小值。例如上图中，s1 长度为 8，s2 长度为 5，则共拷贝 5 个元素，即 <code>copy()</code> 不会发生扩容。</p><blockquote><p>  注意，<code>copy()</code> 是覆盖行为。原有数据将会被覆盖。</p></blockquote><h2 id="比较问题"><a href="#比较问题" class="headerlink" title="比较问题"></a>比较问题</h2><p>在 Slice 的比较中，因为 Slice 不是<code>可比较类型</code>，直接用恒等号 <code>==</code> 比较是无法通过编译的，如果取地址比较也是行不通的，因为 Slice 是结构体，取地址比较的是两个结构体，自然是 false。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s2 := s1</span><br><span class="line"></span><br><span class="line">s1 == s2 <span class="comment">// 无法通过编译</span></span><br><span class="line">&amp;s1 == &amp;s2<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>所以，Slice 比较肯定不是那么肤浅的。</p><p>Slice 的比较在网上盛传的有两种：<code>使用 reflect.DeepEqual()</code> 和 <code>手写比较函数</code>。</p><p>因为 <code>reflect.DeepEqual()</code> 效率较低，所以才有手写比较函数。下面简单展示下 <code>DeepEqual()</code>，然后讲解手写比较函数。</p><h3 id="reflect-DeepEqual"><a href="#reflect-DeepEqual" class="headerlink" title="reflect.DeepEqual()"></a>reflect.DeepEqual()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(a, b []<span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> reflect.DeepEqual(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写比较函数"><a href="#手写比较函数" class="headerlink" title="手写比较函数"></a>手写比较函数</h3><p>其实比较两个 Slice 的思路也简单：</p><ol><li>  先看看长度是否相等；</li><li>  再看看是不是<strong>都为 nil</strong> 或 <strong>都不为 nil</strong>，是就 true，否就下一步（都为 nil 也是相等）；</li><li>  遍历随便哪一个，在遍历中两两比较，一旦不等就返回 false（如果是用在安全方面要预防计时攻击）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(a, b []<span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) &#123;<span class="comment">// 比较长度，长度都不同肯定不相等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (a==<span class="literal">nil</span>) != (b==<span class="literal">nil</span>) &#123;<span class="comment">// 看看是否都为 nil 或 都不为 nil</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;<span class="comment">// 遍历，逐个比较</span></span><br><span class="line">        <span class="keyword">if</span> a[i] != b[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在遍历之前还可以加入 BCE 优化，不过第一步比较长度时，编译器已经获取了 a 和 b 的长度了，在遍历时应该不会再次检查边界了。</p><h2 id="性能陷阱"><a href="#性能陷阱" class="headerlink" title="性能陷阱"></a>性能陷阱</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>golang 具有垃圾回收功能，而一个切片的底层数组，有可能被多个切片引用（即有多个 Slice 指向同一个底层数组），例如 <code>[:] re-slice</code> 就是对底层数组的再一次引用。</p><p>这样的机制就有可能带来一个问题：</p><blockquote><p>  有一个结构体切片 a 有100 个元素，每个结构体的大小是 1 MB，也就是 a 的大小是 100 MB；</p><p>  然后另一个切片 b 引用了 切片 a 最后两个元素，即 <code>b := a[len(a)-2:]</code>。当 a 使用完后 GC 是没法回收这个 100 MB 的底层数组的，因为还有 b 在引用着。</p><p>  于是就会出现这种 用到只有 2 MB，但却无法回收剩下 98 MB 的空间。这就是我想说的性能陷阱。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BigStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := []BigStruct &#123; ... <span class="number">100</span> 个&#125;</span><br><span class="line">b := a[<span class="built_in">len</span>(a)<span class="number">-2</span>:]</span><br></pre></td></tr></table></figure><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>比较推荐的做法是，采用 <code>copy()</code> 的方法替代 <code>re-slice</code>，因为 <code>copy(b, a)</code> 后 a 和 b 引用的不是同一个底层数组。这样 a 使用完以后，底层数组那 100 MB 的空间也能被 GC 回收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BigStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := []BigStruct &#123; ... <span class="number">100</span> 个&#125;</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]BigStruct, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">copy</span>(b, a)</span><br></pre></td></tr></table></figure><h2 id="BCE-优化"><a href="#BCE-优化" class="headerlink" title="BCE 优化"></a>BCE 优化</h2><p>边界检查</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>  每个 Slice 都指向一个底层数组</li><li>  每个 Slice 都保存了当前 Slice 的长度、底层数组的可用容量</li><li>  因为 Slice 本身是结构体，带有 <code>len</code> 和 <code>cap</code> 字段，所以计算长度和容量都是 <code>O(1)</code></li><li>  因为 Slice 本身是结构体，所以通过函数传递时不会拷贝整个切片，属于引用传递</li><li>  因为 Slice 本身是结构体，其中 array 字段为指针类型，所以在函数内对 Slice 的修改会影响到外部。</li><li>  使用 append() 追加元素时有可能触发扩容，扩容后将生成新的切片</li><li>  使用 copy() 复制 Slice 时，目的 Slice 原有的内容会被覆盖</li><li>  创建切片时尽可能根据实际需要预分配容量，尽量避免追加过程中扩容操作，有利于提升性能</li><li>  拷贝时需要判断实际拷贝的个数</li><li>  谨慎使用多个切片操作同一个数组，以防读写冲突</li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> Advanced </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang [深入理解] 1-for &amp; range</title>
      <link href="posts/b56ec5ea.html"/>
      <url>posts/b56ec5ea.html</url>
      
        <content type="html"><![CDATA[<p>两种遍历方式的使用与区别</p><span id="more"></span><h1 id="for-和-range-区别"><a href="#for-和-range-区别" class="headerlink" title="for 和 range 区别"></a>for 和 range 区别</h1><p>range 可以用来遍历 “引用六兄弟” 中的三个：slice、map、chan，加上数组 array。</p><p>对于数组和 slice，还可以用 for 来遍历。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="slice-array"><a href="#slice-array" class="headerlink" title="slice/array"></a>slice/array</h3><blockquote><ul><li>  对于 range 循环，循环次数会在循环开始前计算好，在循环过程中修改切片长度并不会改变本次循环的次数。</li><li>  对于空切片，循环次数为 0。</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">11</span>, <span class="number">99</span>, <span class="number">16</span>, <span class="number">55</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">    fmt.Println(i, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="number">0</span> <span class="number">11</span></span><br><span class="line"><span class="number">1</span> <span class="number">99</span></span><br><span class="line"><span class="number">2</span> <span class="number">16</span></span><br><span class="line"><span class="number">3</span> <span class="number">55</span></span><br></pre></td></tr></table></figure><p>这种方式中，v 是 s 中元素的一份拷贝，对 v 的修改并不会影响 s 中原本的元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">11</span>, <span class="number">99</span>, <span class="number">16</span>, <span class="number">55</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">    v += <span class="number">10</span><span class="comment">// v 只是一份拷贝，并不会影响 s 里的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line">[<span class="number">11</span> <span class="number">99</span> <span class="number">16</span> <span class="number">55</span>]</span><br></pre></td></tr></table></figure><p>除非 s 中的元素是指针，则对 v 的修改会影响 s，下面将会讲到。</p><p>此外采用下面两种方式也可以修改 s 中的元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">11</span>, <span class="number">99</span>, <span class="number">16</span>, <span class="number">55</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">    s[i] += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line">[<span class="number">21</span> <span class="number">109</span> <span class="number">26</span> <span class="number">65</span>]</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">11</span>, <span class="number">99</span>, <span class="number">16</span>, <span class="number">55</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">    s[i] += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line">[<span class="number">21</span> <span class="number">109</span> <span class="number">26</span> <span class="number">65</span>]</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><blockquote><ul><li><p>  迭代过程中，删除还没遍历到的键值对，则该键值对不会被遍历。</p></li><li><p>  迭代过程中，如果创建新的键值对，则新的键值对有可能被遍历，也有可能不会被遍历。</p></li><li><p>  对于空字典，遍历次数为 0。</p></li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">4<span class="number">11</span>: <span class="number">10</span>,</span><br><span class="line">4<span class="number">22</span>: <span class="number">20</span>,</span><br><span class="line">4<span class="number">33</span>: <span class="number">30</span>,</span><br><span class="line">4<span class="number">44</span>: <span class="number">40</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">4v += <span class="number">5</span><span class="comment">// 仅仅是对拷贝的修改，不会影响 m</span></span><br><span class="line">4fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(m)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output：</span></span><br><span class="line"><span class="number">22</span> <span class="number">25</span></span><br><span class="line"><span class="number">33</span> <span class="number">35</span></span><br><span class="line"><span class="number">44</span> <span class="number">45</span></span><br><span class="line"><span class="number">11</span> <span class="number">15</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">11</span>:<span class="number">10</span> <span class="number">22</span>:<span class="number">20</span> <span class="number">33</span>:<span class="number">30</span> <span class="number">44</span>:<span class="number">40</span>]</span><br></pre></td></tr></table></figure><p>同样这种方式对 v 进行修改是不会影响 m 的。</p><p>下面这种就可以</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">4<span class="number">11</span>: <span class="number">10</span>,</span><br><span class="line">4<span class="number">22</span>: <span class="number">20</span>,</span><br><span class="line">4<span class="number">33</span>: <span class="number">30</span>,</span><br><span class="line">4<span class="number">44</span>: <span class="number">40</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">4m[k] += <span class="number">1</span><span class="comment">// 这种方式就会修改到 m 的元素</span></span><br><span class="line">4fmt.Println(k, m[k])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(m)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="number">11</span> <span class="number">11</span></span><br><span class="line"><span class="number">22</span> <span class="number">21</span></span><br><span class="line"><span class="number">33</span> <span class="number">31</span></span><br><span class="line"><span class="number">44</span> <span class="number">41</span></span><br><span class="line"><span class="keyword">map</span>[<span class="number">11</span>:<span class="number">11</span> <span class="number">22</span>:<span class="number">21</span> <span class="number">33</span>:<span class="number">31</span> <span class="number">44</span>:<span class="number">41</span>]</span><br></pre></td></tr></table></figure><h3 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h3><blockquote><ul><li><p>  发送给信道的值，可以通过 range 遍历，直到信道被关闭，才会退出循环。</p></li><li><p>  如果是未分配内存的 nil 信道，循环将永远阻塞。</p></li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">byte</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    ch &lt;- <span class="string">&#x27;o&#x27;</span></span><br><span class="line">    ch &lt;- <span class="string">&#x27;i&#x27;</span></span><br><span class="line">    ch &lt;- <span class="string">&#x27;i&#x27;</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(c))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line">b</span><br><span class="line">o</span><br><span class="line">i</span><br><span class="line">i</span><br></pre></td></tr></table></figure><h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>接下来我们主要针对基本类型和结构体类型，比较他们使用 for 和 range 的性能。</p><p>只有 slice 和 array 才有办法 for 和 range 都使用，所以接下来的比对如下：</p><table><thead><tr><th></th><th>for</th><th>range</th></tr></thead><tbody><tr><td><strong>基本类型</strong></td><td>for + []int</td><td>range + []int</td></tr><tr><td><strong>结构体</strong></td><td>for + []struct</td><td>range + []struct</td></tr></tbody></table><h3 id="for-int-VS-range-int"><a href="#for-int-VS-range-int" class="headerlink" title="for + []int VS range + []int"></a><code>for + []int</code> VS <code>range + []int</code></h3><p>主要方式有 3 种：</p><ul><li>  <code>for i:=0; i &lt; len(s); i++</code></li><li>  <code>for i := range s</code></li><li>  <code>for i, v := range s</code></li></ul><blockquote><p>先说结论：</p><p>遍历 <code>[]int</code> ，三种方式并没太大差别。</p></blockquote><h4 id="int"><a href="#int" class="headerlink" title="[]int"></a>[]int</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">geneI</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">4nums := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, n)</span><br><span class="line">4rand.Seed(time.Now().Unix())</span><br><span class="line">4<span class="keyword">for</span> z := <span class="number">0</span>; z &lt; n; z++ &#123;</span><br><span class="line">44nums = <span class="built_in">append</span>(nums, rand.Int())</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">I_For</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">4n := <span class="built_in">len</span>(nums)</span><br><span class="line">4<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">44_ = nums[i]</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// range i 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">I_RangeI</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">4<span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">44_ = nums[i]</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// range iv 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">I_RangeIV</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">4<span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">44_, _ = i, v</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkI_For</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">4nums := geneI(<span class="number">1</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line">4<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">44I_For(nums)</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkI_RangeI</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">4nums := geneI(<span class="number">1</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line">4<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">44I_RangeI(nums)</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkI_RangeIV</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">4nums := geneI(<span class="number">1</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line">4<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">44I_RangeIV(nums)</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后的结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ go version </span><br><span class="line">go1.16.6 linux/amd64</span><br><span class="line"></span><br><span class="line">$ go <span class="built_in">test</span> . -bench=I_ -benchmem</span><br><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">cpu: Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHz</span><br><span class="line">BenchmarkI_For-4            2685            431122 ns/op            3124 B/op          0 allocs/op</span><br><span class="line">BenchmarkI_RangeI-4         2686            431759 ns/op            3123 B/op          0 allocs/op</span><br><span class="line">BenchmarkI_RangeIV-4        2688            432650 ns/op            3120 B/op          0 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok   3.586s</span><br></pre></td></tr></table></figure><p>从结果可以看出，在遍历基本类型切片时，不管是时间上（ns/op），还是空间上（B/op），还是系统调用上（allocs/op），都没啥差别。</p><blockquote><p>  现在是 2021-8-19，以上是 go 1.16.6 版本测试的结果，并没有太大差别，不像网上说的 for 比 range 快。</p></blockquote><h4 id="struct"><a href="#struct" class="headerlink" title="[]struct"></a>[]struct</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> N = <span class="number">1</span> &lt;&lt; <span class="number">20</span></span><br><span class="line"><span class="keyword">type</span> Per <span class="keyword">struct</span> &#123;</span><br><span class="line">4ins [<span class="number">2048</span>]<span class="keyword">byte</span></span><br><span class="line">4age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">geneS</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">Per</span></span> &#123;</span><br><span class="line">4persons := <span class="built_in">make</span>([]Per, <span class="number">0</span>, n)</span><br><span class="line">4rand.Seed(time.Now().Unix())</span><br><span class="line">4<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">44persons = <span class="built_in">append</span>(persons, Per&#123;age: rand.Int(), ins: [<span class="number">2048</span>]<span class="keyword">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>&#125;&#125;)</span><br><span class="line">4&#125;</span><br><span class="line">4<span class="keyword">return</span> persons</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">S_For</span><span class="params">(persons []Per)</span></span> &#123;</span><br><span class="line">4n := <span class="built_in">len</span>(persons)</span><br><span class="line">4<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">44_ = persons[i].age</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">S_RangeI</span><span class="params">(persons []Per)</span></span> &#123;</span><br><span class="line">4<span class="keyword">for</span> i := <span class="keyword">range</span> persons &#123;</span><br><span class="line">44_ = persons[i].age</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">S_RangeIV</span><span class="params">(persons []Per)</span></span> &#123;</span><br><span class="line">4<span class="keyword">for</span> i, v := <span class="keyword">range</span> persons &#123;</span><br><span class="line">44_, _ = i, v.age</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkS_For</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">4persons := geneS(N)</span><br><span class="line">4b.ResetTimer()</span><br><span class="line">4<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">44S_For(persons)</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkS_RangeI</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">4persons := geneS(N)</span><br><span class="line">4b.ResetTimer()</span><br><span class="line">4<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">44S_RangeI(persons)</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkS_RangeIV</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">4persons := geneS(N)</span><br><span class="line">4b.ResetTimer()</span><br><span class="line">4<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">44S_RangeIV(persons)</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> . -bench=S_ -benchmem</span><br><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">cpu: Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHz</span><br><span class="line">BenchmarkS_For-4            2850            421009 ns/op               0 B/op          0 allocs/op</span><br><span class="line">BenchmarkS_RangeI-4         2850            420993 ns/op               0 B/op          0 allocs/op</span><br><span class="line">BenchmarkS_RangeIV-4        2848            421131 ns/op               0 B/op          0 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok     7.330s</span><br></pre></td></tr></table></figure><p>可以看到基本也没太大区别。</p><h4 id="struct-1"><a href="#struct-1" class="headerlink" title="[]*struct"></a>[]*struct</h4><blockquote><p>  结论：即使是结构体指针切片，跑出来的结果几乎相差无几</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PS_For</span><span class="params">(persons []*Per)</span></span> &#123;</span><br><span class="line">4n := <span class="built_in">len</span>(persons)</span><br><span class="line">4<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">44_ = persons[i].age</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PS_RangeI</span><span class="params">(persons []*Per)</span></span> &#123;</span><br><span class="line">4<span class="keyword">for</span> i := <span class="keyword">range</span> persons &#123;</span><br><span class="line">44_ = persons[i].age</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PS_RangeIV</span><span class="params">(persons []*Per)</span></span> &#123;</span><br><span class="line">4<span class="keyword">for</span> i, v := <span class="keyword">range</span> persons &#123;</span><br><span class="line">44_, _ = i, v.age</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPS_For</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">4persons := genePS(N)</span><br><span class="line">4b.ResetTimer()</span><br><span class="line">4<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">44PS_For(persons)</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPS_RangeI</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">4persons := genePS(N)</span><br><span class="line">4b.ResetTimer()</span><br><span class="line">4<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">44PS_RangeI(persons)</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkPS_RangeIV</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">4persons := genePS(N)</span><br><span class="line">4b.ResetTimer()</span><br><span class="line">4<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">44PS_RangeIV(persons)</span><br><span class="line">4&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">test</span> . -bench=S_ -benchmem  </span><br><span class="line">goos: linux</span><br><span class="line">goarch: amd64</span><br><span class="line">cpu: Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHz</span><br><span class="line">BenchmarkS_For-4                83856697                14.13 ns/op            0 B/op          0 allocs/op</span><br><span class="line">BenchmarkS_RangeI-4             66149228                17.66 ns/op            0 B/op          0 allocs/op</span><br><span class="line">BenchmarkS_RangeIV-4            72271676                16.61 ns/op            0 B/op          0 allocs/op</span><br><span class="line">BenchmarkPS_For-4               71399964                21.43 ns/op            0 B/op          0 allocs/op</span><br><span class="line">BenchmarkPS_RangeI-4            63293829                18.62 ns/op            0 B/op          0 allocs/op</span><br><span class="line">BenchmarkPS_RangeIV-4           63576286                18.57 ns/op            0 B/op          0 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok       7.565s</span><br></pre></td></tr></table></figure><h2 id="能修改元素的遍历"><a href="#能修改元素的遍历" class="headerlink" title="能修改元素的遍历"></a>能修改元素的遍历</h2><p>前面说 <code>for i, v := range s</code> 这种方式，v 是一份拷贝，对 v 的修改不会影响 s 中的元素。</p><p>但是如果 v 是个指针，对 v 的修改还是会影响的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line">b := <span class="number">20</span></span><br><span class="line">c := <span class="number">30</span></span><br><span class="line"></span><br><span class="line">s := []*<span class="keyword">int</span>&#123;&amp;a, &amp;b, &amp;c&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(a, b, c)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">    *v += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output：</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span></span><br><span class="line"><span class="number">11</span> <span class="number">21</span> <span class="number">31</span></span><br></pre></td></tr></table></figure><p>再举个结构体的栗子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">persons := <span class="built_in">make</span>([]*Person, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">persons = <span class="built_in">append</span>(persons, &amp;Person&#123;age: <span class="number">15</span>&#125;, &amp;Person&#123;age: <span class="number">25</span>&#125;, &amp;Person&#123;age: <span class="number">35</span>&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(persons[<span class="number">0</span>], persons[<span class="number">1</span>], persons[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> persons &#123;</span><br><span class="line">    v.age += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(persons[<span class="number">0</span>], persons[<span class="number">1</span>], persons[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line">&amp;&#123; <span class="number">15</span>&#125; &amp;&#123; <span class="number">25</span>&#125; &amp;&#123; <span class="number">35</span>&#125;</span><br><span class="line">&amp;&#123; <span class="number">16</span>&#125; &amp;&#123; <span class="number">26</span>&#125; &amp;&#123; <span class="number">36</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>遍历总共有 3 种方式：</p><ol><li>  <strong>for</strong>：<code>for i:=0; i&lt;n; i++</code></li><li>  <strong>rangeI</strong>：<code>for i := range items</code></li><li>  <strong>rangeIV</strong>：<code>for i, v := range items</code></li></ol><p>三种方式都各有所长。其中 rangeIV 中 v 是 items 中元素的一份拷贝，如果 v 不是指针，那么对于 v 的修改并不会影响 items 里面的元素，如果 v 是指针，则能够影响。</p><p>正是因为 v 是一份拷贝，所以在一些旧版本中可能会因此降低了性能，但在新版本（至少 go 1.16.6 ，我并没有去求证）中，从基准测试来看是没有什么区别，可能在新版本中做了优化。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> Advanced </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 性能比较 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OneTiny 开发日记4-2021-8-16</title>
      <link href="posts/ca82ac25.html"/>
      <url>posts/ca82ac25.html</url>
      
        <content type="html"><![CDATA[<p>基础不牢，地动山摇</p><span id="more"></span><h2 id="接受配置文件"><a href="#接受配置文件" class="headerlink" title="接受配置文件"></a>接受配置文件</h2><p>这段时间又换系统了。一开始想使用 ArchLinux ，但是对于网络那块的问题还是有些不稳定，虽然 ArchLinux 并不难操作，但是真的是太太太太太简洁了！基本上要啥没啥，都得自己去找去安装。尽管教程很多但是除非很喜欢折腾，不然 ArchLinux 并不是适合大部分动手能力强的人。</p><p>最后还是选择 Manjaro + i3 的配置方案。Manjaro 配置了一些基本需要用到的软件，比如网络管理、蓝牙管理、电池管理等等一系列刚需软件。如果不喜欢，卸载了换个别的，一样是定制度很高。</p><p>在使用新系统的时候，频繁的需要接触配置文件，很多东西都可以通过自己修改配置文件达到自己想要的效果。渐渐的，之前不希望 OneTiny 有任何配置文件的想法逐渐改变。在使用 i3 的时候，很多小而美的软件也有配置文件。独立一个可执行程序虽好，但少了用户自定义的自由，整个软件的可玩性也就不高了。</p><h2 id="整改"><a href="#整改" class="headerlink" title="整改"></a>整改</h2><p>接受了这个观念，一下子很多问题迎刃而解。例如我想要配置好 9012 端口，下次直接使用 onetiny 命令就运行在 9012 端口，而不用每次运行的时候都得手动指定端口号。</p><p>此外有了配置文件和配置目录，更新功能在下载新版本时的临时目录也有地方了，断点续传的临时文件也有地方放了，还有很多配置项都可以在配置文件中写好。</p><blockquote><p>但是未来我还是会开辟一个分支，仅保留核心部分功能，也就是最初的样子，v0.1 那一版的样子，但是会有并发下载、断点续传这些与核心业务相关的功能，而没有什么密码访问、自动更新这些无关核心问题的功能。而 master 分支继续开发新功能。</p></blockquote><p>整改起来也方便。使用 <code>os.UserConfigDir()</code> 就可以获取用户的配置目录路径，在其下创建一个 <code>tiny/</code> 目录和一个 <code>config.yml</code> 文件即可。</p><p>这里采用的是 YAML 格式的配置文件，虽然网上很多说 TOML 是最好的配置文件格式啥的，但…我真没觉得好到想这些布道师说的一样。虽然我也喜欢拥抱新事物，但是项目中配置项很少，YAML 也不复杂。</p><p>这里感谢 <a href="https://github.com/spf13/viper">spf13/viper</a> 这个库，非常好用，功能丰富，使用也不难。配置问题很容易就解决了。</p><p>同时为了支持子命令，我换成 <a href="https://github.com/urfave/cli">urfave/cli</a> 这个库，之前看没看太懂，觉得很繁琐，现在用了之后觉得还不错。</p><p>最后是对项目结构小小的重构了一下。根据<a href="https://gitee.com/Boii/OneTiny#command-map">命令</a>将整个项目分为 <code>core</code> 部分、<code>config</code> 部分、<code>update</code> 部分。</p><p>core 部分是核心业务，使用 <code>gin</code> 框架支持，做起来其实和做一个 web 应用相差无几。<br>config 部分对应子命令 <code>onetiny config</code>，用于设置一些配置。设置生效后会写入文件。<br>update 部分对应子命令 <code>onetiny update</code>，用于检查更新，自动更新等。</p><p>目前的结构就是使用 cli 管理这些命令，每个命令都有不同的职责，所以分成不同的模块，使用不同的库。</p><h2 id="新功能"><a href="#新功能" class="headerlink" title="新功能"></a>新功能</h2><p>这次还新增了一个访问登录功能。如果开启服务的人指定了访问者需要登录的话，访问者需要输入帐号密码才能看到共享目录，才能下载。</p><p>一开始开发这个程序的时候是为了解决自己的场景，就是自己有多台设备，设备之间互传文件的一个问题，是一种单用户的场景。但是慢慢的越做越像一个局域网内的 NSA ，像一台文件服务器，场景中也假设了多用户，而不是一开始的单用户。</p><p>不过没关系，反正自己写着玩，自己的程序就是自己喜欢写成啥样就啥样（因为到现在还没人给我提 issue 哈哈哈）。</p><p>写这个功能的时候其实就跟写 web 项目时做保持登录一样。<br>注册方式是通过命令 <code>onetiny sec -u 帐号 -p 密码</code> 来注册，也就是写进配置文件。<br>访问时会经过中间件 <code>checkLogin()</code> 检查 cookie ，没有 cookie 或者 cookie 对不上就转回去登录。</p><h2 id="掉坑"><a href="#掉坑" class="headerlink" title="掉坑"></a>掉坑</h2><p>在做登录功能的时候才发现我对 web 其实很不了解，一个完整的登录流程都了解不透彻后来慢慢摸索才明白。</p><p>通常的登录流程是这样的：<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo//blog/illustration-pic/devlog/20210816171610.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo//blog/illustration-pic/devlog/20210816171610.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>客户端访问 A 页面，服务端验证是否登录过，也就是有没有 session 或者 cookie 或者 token 之类的；<ul><li>有就响应，没有就重定向到登录页；</li></ul></li><li>客户端这边收到登录页后需要输入账号密码，通过表单提交到服务端；</li><li>这个时候客户端还是停留在登录页的，然后使用 Ajax 监听服务器发来的响应；<ul><li>根据响应的内容判断是提示密码错误，还是收下 cookie，重新提交访问 A 页面的请求</li></ul></li><li>重新提交访问 A 页面的请求后就就可以等待响应，正常显示了。</li></ul><p>在这里踩了两个坑，都是因为基础不牢的原因。</p><ul><li><p>第一个是不了解前端，在后端那研究怎么让浏览器自动重新提交访问请求。其实如果之前不要那么排斥前端，多了解下就会知道 Ajax，且现在大多网站都用 Ajax 来做这一步。Ajax 有原生的，如 XMLHttpRequest，也有 jquery 封装好的等等。</p></li><li><p>第二个是不了解 HTTP 响应状态码，重定向分很多种情况，瞎用个 <code>301 永久移动</code> 就上去了，结果就是程序都对，但就是登录完还跳回登录页。因为浏览器在访问一个页面时收到 301 的话，它会将这个页面和新的页面做一个绑定，缓存起来。这样下次用户再访问时直接展示那个新的页面。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo//blog/illustration-pic/devlog/20210816172838.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo//blog/illustration-pic/devlog/20210816172838.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>正确的做法应该是使用 <code>307 临时重定向</code>。</p><p>最后还是在浏览器调试器里分析出来的，也算是个不大不小的坑。<br>以前只知道重定向，没关注过不同的重定向的区别。基础不牢，地动山摇。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>虽然经验不足的我搞这么一个小功能搞了一天两夜，但也还是收获了一些东西，发现自己一些问题，要抓紧时间补上。而且在写这篇日记的时候发现 gitee 上有人 star 了我的项目，还有三个 watch，一下子觉得这两天掉的头发值了。</p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OneTiny </tag>
            
            <tag> FTP </tag>
            
            <tag> 局域网 </tag>
            
            <tag> gin </tag>
            
            <tag> 独立开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 [1-物理层]</title>
      <link href="posts/81730e0e.html"/>
      <url>posts/81730e0e.html</url>
      
        <content type="html"><![CDATA[<p>梦开始的地方</p><span id="more"></span><h1 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1-物理层"></a>1-物理层</h1><blockquote><p>物理层解决如何在连接各种计算机的传输媒体上<strong>传输数据比特流</strong>，而不是指具体的传输媒体。</p></blockquote><p>主要任务：确定与传输媒体接口相关的一些特性 -&gt; 定义标准</p><ol><li><p><strong>机械特性</strong>：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、<code>引线数目</code>、<code>引脚数量</code>和排列情况。</p><p> <img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/RJ45.jpeg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/RJ45.jpeg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p><strong>电气特性</strong>：规定传输二进制位时，线路上信号的<code>电压范围</code>、阻抗匹配、传输<code>速率</code>和<code>距离</code>限制等。</p><p> 如：某网络在物理层规定，用<code>+10v ～ +15v</code>表示二进制 0, 用<code>-10v ～ -15v</code>表示二进制 1，电线长度 &lt; 15m</p></li><li><p><strong>功能特性</strong>：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。</p><p> 如：描述一个物理层接口引脚处于高电平时的含义。</p></li><li><p><strong>规程特性</strong>：也叫过程特性，定义各条物理线路的<code>工作规程</code>和<code>时序关系</code>。</p></li></ol><h2 id="典型的数据通信模型"><a href="#典型的数据通信模型" class="headerlink" title="典型的数据通信模型"></a>典型的数据通信模型</h2><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210717144541.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210717144541.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>通信的目的是<strong>传送消息</strong>。</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li><p><strong>数据</strong>：传送信息的实体，通常是有意义的符号序列。</p></li><li><p><strong>信号</strong>：数据的电气/电磁的表现，是数据在传输过程中的<code>存在形式</code>。</p><ul><li>数字信号：代表消息的参数取值是离散的。<img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210717150845.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210717150845.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>模拟信号：代表消息的参数取值是连续的。<img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210717150844.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210717150844.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ul></li><li><p><strong>信源</strong>：产生和发送数据的源头。</p></li><li><p><strong>信宿</strong>：接收数据的终点。</p></li><li><p><strong>信道</strong>：信号的传输媒介。一般用来表示某一方向传送信息的介质，因此一条通信线路往往包含一条发信信道和一条接收信道。</p><ul><li>按传输信号分：模拟信道、数字信道</li><li>按传输介质分：无线信道、有线信道</li></ul></li></ul><h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><ol><li><strong>单工通信</strong>：只有一个方向的通信而没有反方向的交互，仅需一条信道。</li><li><strong>半双工通信</strong>：通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要两条信道。</li><li><strong>全双工通信</strong>：通信双方可以同时发送和接收信息，需要两条信道。</li></ol><h3 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h3><ol><li><strong>串行传输</strong>：速度<code>慢</code>，费用<code>低</code>，适合<code>远</code>距离</li><li><strong>并行传输</strong>：速度<code>快</code>，费用<code>高</code>，适合<code>近</code>距离</li></ol><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210717154421.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210717154421.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="码元、速率、波特、带宽"><a href="#码元、速率、波特、带宽" class="headerlink" title="码元、速率、波特、带宽"></a>码元、速率、波特、带宽</h3><h4 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h4><div class="note info"><p><span class='p blue'>码元</span>，指用一个<strong>固定时长</strong>的<strong>信号波形</strong>（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位。</p><p>时长内的信号称为 <span class='p green'>K 进制码元</span>，而该时长称为<strong>码元宽度</strong>。</p><p>当码元的离散状态有 M 个时（M 大于 2），此时码元为 <strong>M 进制码元</strong>。</p></div><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210718022820.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210718022820.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h4 id="速率、带宽"><a href="#速率、带宽" class="headerlink" title="速率、带宽"></a>速率、带宽</h4><span class='p blue'>速率</span>，也叫数据率，指数据的**传输速率**（主机发送到信道上的速度），表示单位时间内传输的数据量。可以用**码元传输速率**和**信息传输速率**表示。<ul><li><p><strong>码元传输速率</strong>：表示单位时间内，数字通信系统所传输的 M 进制码元个数（也可称为<code>信号变化次数</code>、<code>脉冲个数</code>），又称码元速率、波形速率、调制速率、符号速率等，单位是<span class='p green'>波特（Baud）</span>。</p><p>  1 波特表示数字通信系统每秒传输 1 个码元（1 Baud = 1 码元/s），3 波特表示每秒传输 3 个码元。</p><p>  这里的码元可以是多进制的，也可以是二进制的，即<strong>码元速率与码元进制无关</strong>。</p></li><li><p><strong>信息传输速率</strong>：表示单位时间内，数字通信系统所传输的二进制码元个数（即<code>比特数</code>），又称信息速率、比特率等，单位是<span class='p blue'>比特/秒（b/s）</span>。</p></li></ul><blockquote><p>码元速率与信息速率的关系:</p><p>若一个码元携带 n bit 的信息量，则 M Baud 的码元传输速率所对应的信息传输速率为 $M \times n$ bit/s。</p><p>如：3 波特二进制码元的信息速率。</p><p>二进制码元中每个码元携带 1 个比特信息，3 波特表示每秒传输 3 个码元，则对应的信息速率为 $3 \times 1$ b/s。</p><p>四进制码元中每个码元携带 2 个比特信息，8 波特表示每秒传输 8 个码元，则对应的信息速率为 $8 \times 2$ b/s。</p></blockquote><span class='p blue'>带宽</span>，表示在单位时间内从网络中某一点到另一点所能通过的“最高传输数据率”（主机传输到信道上），常用来表示网络通信线路所能传输数据的能力。单位是 b/s。<blockquote><p>带宽与速率的关系：带宽是最高传输数据率，速率是实际传输数据率。</p></blockquote><h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><p>某一数字通信系统传输的四进制码元，4s 传输了 8000 个码元，求码元速率和信息速率。</p><p>某一数字通信系统传输的十六进制码元，6s 传输了 7200 个码元，求码元速率和信息速率。</p><p>那种更快？</p><p>答：</p><p>四进制码元系统：码元速率 = $8000 \div 4 = 2000$ Baud，信息速率 = $2000 \times log_24=4000b/s$</p><p>十六进制码元系统：码元速率 = $7200\div6=1200$ Baud，信息速率 = $1200\times log_2{16} = 4800b/s$</p><p>系统传输的是比特流，通常比较的是信息速率，所以第二种更快。</p><h2 id="奈氏准则、香农定理"><a href="#奈氏准则、香农定理" class="headerlink" title="奈氏准则、香农定理"></a>奈氏准则、香农定理</h2><h3 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h3><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210718105114.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210718105114.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>影响失真程度的因素：</p><ol><li>码元传输速率</li><li>信号传输距离</li><li>噪声干扰</li><li>传输媒体质量</li></ol><p>码间串扰：接收端收到的信号波形<strong>失去了码元之间清晰界限</strong>的现象。</p><h3 id="奈氏准则（奈奎斯特定理）"><a href="#奈氏准则（奈奎斯特定理）" class="headerlink" title="奈氏准则（奈奎斯特定理）"></a>奈氏准则（奈奎斯特定理）</h3><blockquote><p>奈氏准则：在理想低通（无噪声、带宽受限）条件下，为了避免码间串扰，极限码元传输速率为 2W Baud。</p><p>W 是信道带宽，单位是 Hz。</p></blockquote><p>理想：指无电磁干扰<br>低通：指低于信道带宽（信道能通过的最高频率和最低频率之差）<br>极限码元速率：$2W ;Baud$<br>推广可得：极限信息速率：$2Wlog_2V ;b/s$，V为码元进制，$log_2V$为码元的离散电平数目</p><ol><li>在任何信道中，码元速率是有上限的。超过上限就会出现严重的码间串扰问题，使接收端不可能完全正确识别码元。</li><li>信道的频带越宽（即能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输。</li><li>奈氏准则给出了码元速率的限制，当没有给出信息速率的限制。</li><li>由于码元速率受限与奈氏准则，所以要提高数据传输速率，就必须提高码元进制以使每个码元携带更多比特的信息量。</li></ol><h3 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h3><p>噪声存在于所有电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但噪声的影响是相对的，所信号较强，那么噪声影响相对较小。即信号强度与噪声影响成反比。因此，信噪比就很重要。</p><p>信噪比 = 信号的平均功率 S /噪声的平均功率 N，记为 S/N，并用分贝（dB）作为度量单位，即：<br>$$<br>信噪比（dB） = 10 \times log_{10}{(S/N)}<br>$$</p><blockquote><p>香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值为<br>$$<br>信道的极限数据传输速率 = Wlog_2(1+S/N)（b/s）\\<br>信道的极限数据传输速率 = 信道带宽 \times log_2(1+信号平均功率/噪声平均功率)（比特/秒）<br>$$</p></blockquote><ol><li>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。</li><li>对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。</li><li>只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输。</li><li>香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。</li><li>从香农定理可以看出，若信道带宽 W 或信道比 S/N 没有上限(不可能),那么信道的极限信息传输速率也就没有上限。</li></ol><h4 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h4><p>电话系统的典型参数是信道带宽为 3kHz，信噪比为 30dB，则该系统最大数据传输速率是多少？</p><p>答：<br>$$<br>30dB = 10log_{10}(S/N) \\<br>3dB = log_{10}(S/N) \\<br>dB = S/N = 1000<br>$$<br>信道的极限数据传输速率 = $Wlog_2(1+S/N) = 3k \times log_2{(1+1000)} \approx 30kb/s$</p><table><thead><tr><th></th><th>奈氏准则</th><th>香农定理</th></tr></thead><tbody><tr><td></td><td>宽带受限、无噪声下，为了避免码间串扰，码元传输速率上限为 2W Baud。</td><td>宽带受限、有噪声条件下的信息传输速率。</td></tr><tr><td>信道极限数据传输速率</td><td>$2Wlog_2V$（W 信道带宽，V 码元进制）</td><td>$Wlog_2(1+S/N)$（W 信道带宽，S/N 信噪比）</td></tr><tr><td>提高速率</td><td>提高码元进制</td><td>提高带宽或信噪比</td></tr></tbody></table><h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p>信道上传播的信号分为 <code>基带信号</code> 和 <code>宽带信号</code>。</p><ul><li><p><strong>基带信号</strong>：<code>来自信源</code>的信号，将数字信号 1 和 0 直接用两种不同的电压表示，再送到<code>数字信道</code>上去传输（基带传输）。</p><p>  像计算机输出的代表各种文字或图像的数据信号都属于基带信号，基带信号就是发出的<code>直接表达了要传输的信息的信号</code>，如我们说话的甚或就是基带信号。</p></li><li><p><strong>宽带信号</strong>：将基带信号进行调制后形成的频分复用模拟信号，再传送到<code>模拟信道</code>上去传输（宽带传输）。</p><p>  把基带信号经过<code>载波调制</code>后，把信号的<code>频率范围</code>搬移到较高的频段，以便在信道中传输（即仅在一段频率范围内能够通过信道）。</p></li></ul><p>在传输距离近时，计网采用<strong>基带传输</strong>方式（因为近距离衰减小，从而信号内容不易发生变化）</p><p>在传输距离远时，计网采用<strong>宽带传输</strong>方式（因为远距离衰减大，即使信号变化大也能过滤还原出基带信号）</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719005553.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719005553.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719012004.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719012004.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="数字数据-gt-数字信号"><a href="#数字数据-gt-数字信号" class="headerlink" title="数字数据 ==&gt; 数字信号"></a>数字数据 ==&gt; 数字信号</h4><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719013104.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719013104.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ol><li><p><strong>非归零编码</strong>：<code>高 1 低 0</code>。编码容易实现，但没有检错功能，且无法判断一个码元的开始和结束，以至于首发双方难以保持同步。</p></li><li><p><strong>归零编码</strong>：<code>信号电平在一个码元内都要恢复到零</code>。</p></li><li><p><strong>反向不归零编码</strong>：<code>0 则电平翻转，1 则电平不变</code>。</p><p> <img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719020151.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719020151.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p><strong>曼彻斯特编码</strong>：<code>前高后低表示 1，前低后高表示 0</code>。将一个码元分成两个相等的间隔，每一个码元的中间出现跳变，位中间的跳变既作时钟信号（可用于同步），又作数据信号，但它所占的频带宽度是原始基带宽度的两倍。</p></li><li><p><strong>差分曼彻斯特编码</strong>：<code>同 1 异 0</code>，<code>前后两个码元之间发生跳变则前一个为 1，没发生跳变则前一个为 0</code>。码元中间的一次电平跳变可以实现自动同步，差分曼彻斯特的抗干扰性强于曼彻斯特。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719015938.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719015938.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ol start="6"><li><p><strong>4B/5B编码</strong>：比特流中插入额外的比特以打破一连串的 0 或 1，就是用 5 个比特来编码 4 个比特的数据，之后再传给接收方，因此称为 4B/5B。编码效率为80%。</p><p> 只采用 16 种对应 16 种不同的 4 位码，另外16中作为控制码（帧的开始、结束，线路状态等）或保留。</p></li></ol><h4 id="数字数据-gt-模拟信号"><a href="#数字数据-gt-模拟信号" class="headerlink" title="数字数据 ==&gt; 模拟信号"></a>数字数据 ==&gt; 模拟信号</h4><p>数字数据调制技术：</p><ul><li>调制：在发送端将数字信号转换为模拟信号</li><li>解调：在接收端将模拟信号转换为数字信号</li></ul><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719011417.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719011417.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>调幅：载波的振幅随基带数字信号而变化。</p><p>调频：载波的频率随基带数字信号而变化。</p><p>调相：载波的初始相位随基带数字信号而变化。</p><p>QAM：调幅+调相，在调相的基础上对振幅进行调整，或在调幅的基础上对相位进行调整。</p><h3 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h3><h4 id="模拟信号-gt-数字信号"><a href="#模拟信号-gt-数字信号" class="headerlink" title="模拟信号 ==&gt; 数字信号"></a>模拟信号 ==&gt; 数字信号</h4><ol><li><p><strong>抽样</strong>：对模拟信号周期性扫描，把时间上连续的信号变成时间上离散的信号。</p><p> 为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样：$采样频率;f \ge 2f;信号最高频率$</p></li><li><p><strong>量化</strong>：把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这样就能把连续的电平幅值转换为离散的数字量。</p></li><li><p><strong>编码</strong>：把量化的结果转化为与之对应的二进制编码。</p></li></ol><h4 id="模拟信号-gt-模拟信号"><a href="#模拟信号-gt-模拟信号" class="headerlink" title="模拟信号 ==&gt; 模拟信号"></a>模拟信号 ==&gt; 模拟信号</h4><p>为了实现传输的有效性，可能需要较高的频率。这种调剂方式还可以使用<strong>频分复用</strong>技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式；模拟的声音数据是加载到模拟的载波信号中传输的。</p><h2 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h2><p>传输介质，也称传输媒体/传输媒介，是数据传输系统在发送设备和接收设备之间的<strong>物理通路</strong>。</p><p>传输介质不是物理层，而是在物理层下面，有体系结构第 0 层之称，而物理层是第 1 层。</p><p>在传输媒体中传输的是信号，传输媒体并不知道所传输的信号代表什么意思，当物理层规定了电气特性，因此能够识别所传送的比特流。</p><p>传输介质分 <code>导向性传输介质</code> 和 <code>非导向性传输介质</code>。</p><ul><li>导向性传输介质：电磁波沿着固定媒介（铜线/光纤）传播。</li><li>非导向性传输介质：自由空间、空气、真空、海水等。</li></ul><h3 id="导向性传输介质"><a href="#导向性传输介质" class="headerlink" title="导向性传输介质"></a>导向性传输介质</h3><h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4><p>由两个采用一定规则并排绞合的、相互绝缘的铜导线组成。绞合可以减少对相邻导线的电磁干扰。</p><p>为了进一步提高抗电磁干扰能力，可在双绞线外面加上一个金属丝编制成的屏蔽层。</p><p>有屏蔽层的就是屏蔽双绞线 STP，没有的就是非屏蔽层双绞线 UTP。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/%E5%8F%8C%E7%BB%9E%E7%BA%BF20210719132756.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/%E5%8F%8C%E7%BB%9E%E7%BA%BF20210719132756.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>双绞线价格便宜，在局域网和传统电话网中普遍使用。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几公里到数十公里。</p><p>距离太远时，对于<strong>模拟传输</strong>，要用放大器放大衰减的信号；对于<strong>数字传输</strong>，要用中继器将失真的信号整形。</p><h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%8620210719133337.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%8620210719133337.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>同轴电缆由<span class='p yellow'>导线铜质芯线</span>、<span class='p blue'>绝缘层</span>、<span class='p green'>网状编织屏蔽层</span>、<span class='p red'>塑料外层</span>构成。</p><p>通常将同轴电缆分为两类：</p><ol><li>$50\Omega$同轴电缆，主要用于传送<code>基带数字信号</code>，又称为<span class='p blue'>基带同轴电缆</span>，在局域网中得到广泛应用；</li><li>$75\Omega$同轴电缆，主要用于传送<code>宽带信号</code>，又称为<span class='p blue'>宽带同轴电缆</span>，主要用于有线电视系统。</li></ol><p>由于外导体屏蔽层的作用，同轴电缆<strong>抗干扰特性</strong>比双绞线好，被广泛应用于传输较高速率的数据，其<strong>传输距离</strong>更远，但价格较双绞线<strong>贵</strong>。</p><h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h4><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/%E5%85%89%E7%BA%A420210719135510.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/%E5%85%89%E7%BA%A420210719135510.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>光纤通信，是利用光导纤维（简称光纤）传递光脉冲来进行通信。有光脉冲表示 1，无光脉冲表示 0。而可见光大约是 $10^8MHz$，因此光纤通信系统的带宽远远大于目前其他各种传输媒体的带宽。</p><p>光纤在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲作用下能产生出光脉冲；<br>在接收端用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。</p><p>光纤主要由<code>纤芯</code>（实心的！）和<code>包层</code>构成，光波通过纤芯进行传导，包层较纤芯有较低折射率。当光纤从高折射率的介质射向低折射率的介质时，其折射角将大于入射角。因此，如果入射角，就会出现<strong>全反射</strong>，即光线碰到包层就会折射会纤芯。这个过程不断重复，光就沿着光纤传输下去。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719135701.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719135701.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><table><thead><tr><th></th><th>定义</th><th>光源</th><th>特点</th></tr></thead><tbody><tr><td>单模光纤</td><td>一种在<strong>横向模式</strong>直接传输光信号的光纤</td><td>定向性很好的激光二极管</td><td>衰耗小，适合<strong>远</strong>距离传输</td></tr><tr><td>多模光纤</td><td>有<strong>多种</strong>传输光信号模式的光纤</td><td>发光二极管</td><td>易失真，适合<strong>近</strong>距离传输</td></tr></tbody></table><p>光纤特点：</p><ol><li>传输损耗小，中继距离长，对远距离传输特别经济。</li><li>抗雷电和电磁干扰性能好。</li><li>无串音干扰，保密性好，也不易被窃听或截取数据。</li><li>体积小，重量轻。</li></ol><h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a>非导向性传输介质</h3><p>无线电波</p><p>微波</p><p>红外线、激光</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719140743.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719140743.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><h3 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h3><p>诞生原因：由于传输存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，导致接收错误。</p><p>功能：对信号进行<strong>再生和还原</strong>，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。</p><p>中继器的两端：</p><ul><li>两端的网络部分是网段，而不是子网，适用于完全相同的两类网络互连，且两个网段速率要相同。</li><li>中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。</li><li>两端可连相同媒体，也可连不同媒体。</li><li>中继器两端的网段一定要是同一个协议，因为中继器不会存储转发。</li></ul><p>5-4-3规则：最多只能有5个网段，最多只能有4个中继器，最多只能有3台设备。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719142429.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719142429.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="集线器（多口中继器）"><a href="#集线器（多口中继器）" class="headerlink" title="集线器（多口中继器）"></a>集线器（多口中继器）</h3><p>功能：对信号进行<strong>再生放大转发</strong>，对衰减信号进行放大，接着转发到其他所有（除输入端口外）处于工作状态的端口上，以增加信号传输的距离，延长网络长度。</p><p>集线器不具备定向传送能力，只能广播，无法分割冲突域，是一个共享式设备。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719151349.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210719151349.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 物理层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 [0-概述]</title>
      <link href="posts/f56d3ab8.html"/>
      <url>posts/f56d3ab8.html</url>
      
        <content type="html"><![CDATA[<p>计算机网络一览~</p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>计算机网络是<strong>互联</strong>的、<strong>自治</strong>的计算机集合。</p><ul><li>互联：互联互通、</li><li>自治：无主从关系，相互独立。有通信，但不能控制对方</li></ul><h3 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h3><ol><li><strong>数据通信</strong>：数据可以在信道上传输，使得硬件设备可以通信</li><li><strong>资源共享</strong>：硬件、软件、数据的共享</li><li>分布式处理：多台计算机各自承担同一工作任务的不同部分</li><li>提高可靠性：一台主机挂了，另外一台可以顶上。</li><li>负载均衡</li></ol><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h4><p>硬件、软件、协议</p><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><p>分为边缘部分和核心部分</p><ul><li>边缘部分：各种主机、终端机、服务器等；用于直接使用，分<code>C/S方式</code>和<code>P2P方式</code></li><li>核心部分：各种路由器、集线器等；为边缘部分服务</li></ul><h4 id="功能组成"><a href="#功能组成" class="headerlink" title="功能组成"></a>功能组成</h4><ul><li>通信子网：实现数据通信</li><li>资源子网：实现资源共享/数据处理<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210109163200605_13306.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210109163200605_13306.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>按分布范围分：<ol><li>广域网 WAN - 使用交换技术</li><li>城域网 MAN</li><li>局域网 LAN - 广播技术</li><li>个人区域网 PAN</li></ol></li><li>按使用者分<ol><li>公用网 - 中国电信、移动、联通</li><li>专用网 - 军队、政府、银行等使用的专用网络，需要一定权限</li></ol></li><li>按交换技术分<ol><li>电路交换</li><li>报文交换</li><li>分组交换</li></ol></li><li>按拓扑结构分<ol><li>总线型</li><li>星型</li><li>环形</li><li>网状型 - 常用于广域网</li></ol></li><li>按传输技术分<ol><li>广播式网络 - 共享公共通信信道</li><li>点对点网络 - 使用<strong>分组存储转发</strong>和<strong>路由选择</strong>机制</li></ol></li></ol><h2 id="标准化工作"><a href="#标准化工作" class="headerlink" title="标准化工作"></a>标准化工作</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul><li>法定标准：由权威机构制定的正式的、合法的标准，如OSI</li><li>事实标准：某些公司的产品在竞争中占据主流，时间长了，这些产品中的协议和技术就成了标准，如 TCP/IP</li></ul><h3 id="RFC"><a href="#RFC" class="headerlink" title="RFC"></a>RFC</h3><p>RFC (Request For Comments) —— 互联网标准的形式</p><p>RFC要上升为互联网正式标准的四个阶段：</p><ol><li>互联网草案 (Internet Draft) : 这个阶段还不是RFC文档</li><li>建议标准 (Proposed Standard) : 被收录后就进入这个阶段，成为RFC文档，然后进一步完善成为草案标准</li><li>草案标准 (Draft Standard) : 完善以后就形成一个草案标准，交由IETF、IAB 审核</li><li>互联网标准 (Internet Standard) : 通过审核以后就正式成为互联网标准。</li></ol><blockquote><p>2013年后取消了草案标准这一阶段，被收录为RFC文档完善审核通过后直接成为互联网标准。</p></blockquote><h3 id="相关组织"><a href="#相关组织" class="headerlink" title="相关组织"></a>相关组织</h3><table><thead><tr><th></th><th>主要贡献</th></tr></thead><tbody><tr><td><strong>ISO</strong> 国际标准化组织</td><td>OSI 参考模型、HDLC协议</td></tr><tr><td><strong>ITU</strong> 国际电信联盟</td><td>指定通信规则</td></tr><tr><td><strong>IEEE</strong> 国际电气电子工程师协会</td><td>学术论文、IEEE802系列标准、5G</td></tr><tr><td><strong>IETF</strong> Internet工程任务组</td><td>负责互联网标准制定</td></tr></tbody></table><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>又称 数据率 或 数据传输率 或 比特率（比特，即 1/0 ，又称“位”）<br>指连接在计算机网络上的主机在数字信道上传送数据位数的速度。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210109170709637_8154.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210109170709637_8154.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>单位是 b/s、kb/s、Mb/s、Gb/s、TB/s</p><table><thead><tr><th></th><th align="right">速率</th><th>存储容量（1Byte=8bit）</th></tr></thead><tbody><tr><td>千</td><td align="right">$1kb/s = 10^3b/s$</td><td>$1KB=2^{10}B=1024B=1024\times8b$</td></tr><tr><td>兆</td><td align="right">$1Mb/s = 10^3kb/s = 10^6b/s$</td><td>$1MB=2^{10}KB=1024KB$</td></tr><tr><td>吉</td><td align="right">$1Gb/s = 10^3Mb/s = 10^6kb/s=10^9b/s$</td><td>$1GB=2^{10}MB=1024MB$</td></tr><tr><td>太</td><td align="right">$1Tb/s=10^3Gb/s=10^6Mb/s=10^9kb/s=10^{12}b/s$</td><td>$1TB=2^{10}GB=1024GB$</td></tr></tbody></table><h3 id="带宽（车道数）"><a href="#带宽（车道数）" class="headerlink" title="带宽（车道数）"></a>带宽（车道数）</h3><blockquote><p>计算机网络中，带宽表示网络通信线路传送数据的能力，通常指单位时间内从网络中某一点到另一点所能通过的“最高数据率”，即网络设备所支持的最高速度</p></blockquote><p>带宽用来表示网络的通信线路传送数据的能力，通常指单位时间内从网络中的一端到另一端所能通过的“最高数据率”。<br>单位是 b/s、kb/s、Mb/s、Gb/s、Tb/s<br>换言之，就是<strong>一秒内我这个设备能传输到信道上的最多的比特数</strong>。</p><h3 id="吞吐量（车流量）"><a href="#吞吐量（车流量）" class="headerlink" title="吞吐量（车流量）"></a>吞吐量（车流量）</h3><blockquote><p>单位时间内通过某个网络（或信道、接口）的数据量。即实际接收到的数据量。</p></blockquote><p>单位是 b/s、kb/s、Mb/s、Gb/s、TB/s</p><p>带宽是理想，吞吐量是现实。</p><p>带宽指的是最大的发送或接收能力，吞吐量是实际的发送或接收的量。</p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><blockquote><p>指数据从网络的一段传送到另一端所需的时间。也叫延迟、迟延。单位是 s。</p></blockquote><p>时延包括 4 大类：</p><ol><li><p><strong>发送时延</strong>（传输时延）：一堆数据从开始推送到信道上那一刻起，到全部推完，这个动作持续的时间。</p><p> $发送时延 = \frac {数据长度} {信道带宽(发送速率)}$</p></li><li><p><strong>传播时延</strong>：一堆数据在数据链路上跑到目的地的用时。取决于电磁波传播速度($2\times10^8m/s$)和链路长度</p><p> $传播时延 = \frac {链路长度} {电磁波传播速度}$</p></li><li><p><strong>排队时延</strong>：数据在经过路由器、交换机等设备时不一定能马上处理，需要等待；排队时延指等待输入/输出链路可用这段时间。</p><p> 排队时延包括<code>等待输入链路时的排队</code>和<code>等待输出链路时的排队</code>。</p></li><li><p><strong>处理时延</strong>：指排队排到了以后，路由器/交换机等设备对数据进行检错、分析的这段时间。</p></li></ol><blockquote><p>时延 = 发送时延 + 传播时延 + 排队时延 + 处理时延</p></blockquote><blockquote><p>举个例子：从 A 城拉一车水果到 B 城。</p><p>发送时延 = 把水果装到车上的时间</p><p>传播时延 = 把车从 A 城开到 B 城花费的时间</p><p>排队时延 = 车在路上经过安检，在排队等待安检的这段时间</p><p>处理时延 = 被安检这个过程花费的时间</p></blockquote><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><blockquote><p>时延带宽积 bit = 传播时延 s $\times$ 带宽 bit/s</p><p>时延带宽积又称 <strong>以比特为单位的链路长度</strong>，即某段链路中现在有多少比特。</p></blockquote><p>带宽是最大发送速率，也就是货物装车最快能装多快。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210716135740.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210716135740.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h3><blockquote><p>RTT 指从发送法发送数据开始，到发送方收到接收方的确认（接收方收到数据后立即发送确认）总共经历的时延。</p></blockquote><p>RTT 越大，在收到确认之前，可以发送的数据越多。</p><p>RTT 包括 <code>往返传播时延</code> = 传播时延$\times$2 + <code>末端处理时间</code></p><p>RTT 只管信道上的时延，不管主机上的发送时延。</p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>利用率包括<code>信道利用率</code> 和 <code>网络利用率</code>。</p><p>$信道利用率 = \frac {有数据通过时间} {(有+无)数据通过时间}$</p><p>网络利用率 = 信道利用率加权平均值</p><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210716144426.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210716144426.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>实体：第 n 层还中的活动元素称为 n 层实体。同一层的实体叫对等实体。</li><li>协议：为进行网络中的对等实体数据交换而建立的规则、标准或约定，称为网络协议。[水平]<ul><li>语法：规定传输数据的格式</li><li>语义：规定所要完成的功能</li><li>同步：规定各种操作的顺序</li></ul></li><li>接口(访问服务点，SAP)：上层使用下层服务的入口。</li><li>服务：下层为相邻上层提供的功能调用。[垂直]</li></ul><blockquote><p>PDU = PCI + SDU</p><p>数据包 = 上层数据 + 本层协议头</p></blockquote><ul><li><p>SDU, Service Data Unit，服务数据单元：为完成用户所要求的功能而应传送的数据。</p></li><li><p>PCI, Protocols Control Infomation，协议控制信息：控制协议操作的信息。</p></li><li><p>PDU, Protocols Data Unit，协议数据单元：对等层次之间传送的数据单位。</p></li></ul><p>分层的基本原则</p><ol><li>各层之间相互<strong>独立</strong>，每层只实现一种相对独立的功能。</li><li>每层之间<strong>界面自然清晰</strong>，易于理解，相互交流尽可能少。</li><li>结构上可分隔开，每层都采用<strong>最合适的技术</strong>来实现。</li><li>保持<strong>下层</strong>对<strong>上层</strong>的独立性，上层单向使用下层提供的服务。</li><li>整个分层结构应该能促进标准化工作。</li></ol><blockquote><p>网络体系结构是从<strong>功能</strong>上描述计算机网络结构。</p><p>计算机网络体系结构，简称网络体系结构，是分层结构。</p><p>每层遵循某个/某些<strong>网络协议</strong>以完成本层功能。</p><p>计算机网络体系结构是计算机网络的<strong>各层及其协议的集合</strong>。</p><p>第 n 层在向 n+1 层提供服务时，此服务不仅包含第 n 层本身的功能，还包含由下层服务提供的功能。</p><p>仅仅在<strong>相邻层间有接口</strong>，且所提供服务的具体实现细节对上一层完全屏蔽。</p><p>体系结构是<strong>抽象</strong>的，而实现是指能运行的一些软件和硬件。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210716183548.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210716183548.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="OSI-网络模型"><a href="#OSI-网络模型" class="headerlink" title="OSI 网络模型"></a>OSI 网络模型</h3><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/7%E5%B1%82_20210716175720.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/7%E5%B1%82_20210716175720.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>法定标准：7 层 OSI 参考模型</p><p>事实标准：4 层 TCP/IP 参考模型</p><p>上面 4 层是<strong>端到端</strong>的通信，下面 3 层是<strong>点到点</strong>的通信。</p><ul><li><p><strong>应用层</strong>：所有能和用户交互产生网络流量的程序。典型应用层服务：</p><ul><li>文件传输 FTP</li><li>电子邮件 SMTP</li><li>万维网 HTTP</li></ul></li><li><p><strong>表示层</strong>：用于处理在两个通信系统中交换信息的表示方式（语法和语义）</p><ul><li>功能一：数据格式交换</li><li>功能二：数据加密解密</li><li>功能三：数据压缩和恢复</li></ul></li><li><p><strong>会话层</strong>：向表示层实体/用户进程提供<strong>建立连接</strong>并在连接上<strong>有序</strong>地<strong>传输</strong>数据。这是会话，也是建立同步（SYN）</p><ul><li>功能一：建立、管理、终止会话</li><li>功能二：使用校验点可使会话在通信失效时从<strong>校验点/同步点</strong>继续恢复通信，实现数据同步。适用于传输大文件。</li><li>主要协议：ADSP、ASP</li></ul></li><li><p><strong>传输层</strong>：负责主机中两个进程的通信，即端到端的通信。传输单位是<code>报文段</code>或<code>用户数据报</code>。</p><ul><li>功能一：可靠传输 TCP、不可靠传输 UDP</li><li>功能二：差错控制</li><li>功能三：流量控制（协调发送端和接收端的速度问题）</li><li>功能四：复用分用<ul><li>复用：多个应用层进程可同时使用下面运输层的服务。</li><li>分用：运输层把收到的信息分别交付给上面应用层中相应的进程。</li></ul></li><li>主要协议：TCP、UDP</li></ul></li><li><p><strong>网络层</strong>：主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。传输单位是<code>数据报</code>。</p><ul><li>数据报和分组的关系是：数据报过长的时候就可以切成很多个分组。</li><li>功能一：路由选择（选择最佳路径）</li><li>功能二：差错控制</li><li>功能三：流量控制（协调发送端和接收端的速度问题）</li><li>功能四：拥塞控制。若所有结点都来不及接收分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要进行拥塞控制。</li><li>主要协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF。</li></ul></li><li><p><strong>数据链路层</strong>：主要任务是把网络层传下来的数据报<strong>组装成帧</strong>。传输单位是<code>帧</code>。</p><ul><li>功能一：成帧（定义帧的开始和结束）</li><li>功能二：差错控制，包括<code>帧错</code>和<code>位错</code></li><li>功能三：流量控制</li><li>功能四：访问（接入）控制，控制对信道的访问</li><li>主要协议：SDLC、HDLC、PPP、STP</li></ul></li><li><p><strong>物理层</strong>：主要任务是在<strong>物理媒体上</strong>实现比特流的<strong>透明传输</strong>。</p><ul><li>透明传输：指不管所传数据是什么样的比特组合，都应当能够在链路上传送。</li><li>功能一：定义接口特性，如接头有多少引脚、使用多少跟线、电压所少…</li><li>功能二：定义传输模式<ul><li>单工：只能发送或只能接收</li><li>半双工：可以发送或接收，但同一时刻只可以一方在发送或接收</li><li>全双工：可以在发送的同时也在接收</li></ul></li><li>功能三：定义传输速率</li><li>功能四：比特同步</li><li>功能五：比特编码</li><li>主要协议：Rj45、IEEE 802.3</li></ul></li></ul><table><thead><tr><th></th><th>主要任务</th><th>传输单位</th><th>主要协议</th></tr></thead><tbody><tr><td>应用层</td><td>处理用户交互产生的数据</td><td>APDU</td><td>HTTP、FTP、DNS</td></tr><tr><td>表示层</td><td>处理在两个通信系统中交换信息的表示方式</td><td>PPDU</td><td>JPEG、ASCII</td></tr><tr><td>会话层</td><td>建立连接，并在连接上有序地传输数据</td><td>SPDU</td><td>ADSP、ASP</td></tr><tr><td>传输层</td><td>负责主机中两个进程的通信</td><td>报文段/用户数据报</td><td>TCP、UDP</td></tr><tr><td>网络层</td><td>源主机到目的主机的数据分组路由与转发</td><td>数据报</td><td>IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</td></tr><tr><td>数据链路层</td><td>把网络层传下来的数据报组装成帧</td><td>帧</td><td>SDLC、HDLC、PPP、STP</td></tr><tr><td>物理层</td><td>比特传输</td><td>比特</td><td>Rj45、IEEE 802.3</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/TCP/IP.gif" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/TCP/IP.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="TCP-IP-网络模型"><a href="#TCP-IP-网络模型" class="headerlink" title="TCP/IP 网络模型"></a>TCP/IP 网络模型</h3><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/4%E5%B1%82_20210716183806.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/4%E5%B1%82_20210716183806.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><table><thead><tr><th></th><th>OSI 模型</th><th>TCP/IP 模型</th></tr></thead><tbody><tr><td>网络层</td><td>无连接+面向连接</td><td>无连接</td></tr><tr><td>传输层</td><td>面向链接</td><td>无连接+面向连接</td></tr></tbody></table><p>面向连接：喂你吃东西之前问你要不要吃，然后给你吃。</p><p>无连接：直接塞你嘴里。</p><p>面向连接分三个阶段：</p><ol><li><strong>建立连接</strong>：再此阶段发出一个建立连接的请求；</li><li><strong>数据传输</strong>：只有在连接成功建立之后，才能开始数据传输；</li><li><strong>释放连接</strong>：数据传输完成后，释放连接。</li></ol><p>无连接：直接进行数据传输。</p><h3 id="5层参考模型"><a href="#5层参考模型" class="headerlink" title="5层参考模型"></a>5层参考模型</h3><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/5%E5%B1%82_20210716214222.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/5%E5%B1%82_20210716214222.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="数据封装与解封装"><a href="#数据封装与解封装" class="headerlink" title="数据封装与解封装"></a>数据封装与解封装</h3><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210716213207.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/408/NET/20210716213207.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
          <category> NET </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 七层模型 </tag>
            
            <tag> OSI 模型 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OneTiny 开发日记3-2021-6-29</title>
      <link href="posts/41947.html"/>
      <url>posts/41947.html</url>
      
        <content type="html"><![CDATA[<p>新增访问层级限制</p><span id="more"></span><p>更新功能没写成，还是没想好怎么处理整个流程。</p><p>摆在面前有两个问题：</p><ol><li>下载下来的新版本（可执行文件）放在哪</li><li>如何关闭自己然后启动新版本</li></ol><p>所以暂时搁置，转头去实现访问层级限制功能。</p><h2 id="使用中间件"><a href="#使用中间件" class="headerlink" title="使用中间件"></a>使用中间件</h2><p>这次把中间件用上了，还把之前对浏览器的默认行为：请求 favicon.ico 进行拦截的部分放在单独的中间件里，并且应用到全局。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start 函数负责启动 gin 实例，开始提供 HTTP 服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gin.SetMode(gin.ReleaseMode)</span><br><span class="line">    r := gin.New()</span><br><span class="line">    r.Use(gin.LoggerWithWriter(config.Output),gin.Recovery())</span><br><span class="line">    <span class="comment">// 中间件</span></span><br><span class="line">    r.Use(middleware.InterceptICO)</span><br><span class="line">    r.Use(middleware.CheckLevel)</span><br><span class="line"></span><br><span class="line">    r.NoRoute(controller.NotFound)</span><br><span class="line">    r.GET(<span class="string">&quot;/*filename&quot;</span>, controller.Handler)</span><br><span class="line">    r.POST(<span class="string">&quot;/upload&quot;</span>, controller.Upload)</span><br><span class="line"></span><br><span class="line">    printInfo()</span><br><span class="line"></span><br><span class="line">    err := r.Run(<span class="string">&quot;:&quot;</span> + config.Port)</span><br><span class="line">    <span class="keyword">if</span> _, ok := err.(*net.OpError); ok &#123;</span><br><span class="line">        log.Fatal(color.RedString(<span class="string">&quot;指定的 %s 端口已被占用，请换一个端口号。&quot;</span>, config.Port))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截浏览器默认请求行为的中间件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// InterceptICO 拦截浏览器默认请求 favicon.ico 的行为</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InterceptICO</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> strings.HasSuffix(c.Param(<span class="string">&quot;filename&quot;</span>), <span class="string">&quot;.ico&quot;</span>) &#123;</span><br><span class="line">        c.Status(http.StatusOK)</span><br><span class="line">        c.Abort()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gin 的封装真的让 web 开发变得很方便，中间件也让代码更加清晰，耦合度降低。Nice！</p><h2 id="新增参数-x"><a href="#新增参数-x" class="headerlink" title="新增参数 -x"></a>新增参数 -x</h2><p>这次新增一个访问层级限制的功能，使用参数 <code>-x</code> 或者 <code>--max</code> 可以指定。</p><p>例如：</p><p>用户指定共享目录为：<code>/a/b</code> , 最大层级为 2，则访问者最深可以访问到 <code>/a/b/c/d</code> 、<code>/a/b/c/d/file</code> 。</p><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><code>/a/b</code></p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><code>/a/b/file</code></p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><code>/a/b/c</code></p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><code>/a/b/c/file</code></p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><code>/a/b/c/d</code></p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p><code>/a/b/c/d/file</code></p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p><code>/a/b/c/d/e</code></p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p><code>/a/b/c/d/e/file</code></p>            </div><p>其实这个功能有点鸡肋，真实场景下限制访问层级可能不常用，只有一个场景会很常见。</p><p>即：共享者只是想开放共享目录那一层给人访问，你可以看到这一层有什么子目录和文件，你可以下载这一层的所有文件，但不能深入访问子目录。</p><p>所以我把参数的默认值设置为 0。即只能访问共享目录那一层，如果要开放子目录给人访问，就自己设置 <code>-x</code> 参数。</p><p>最核心的就是这个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查当前访问的路径是否超过限定层级</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isOverLevel</span><span class="params">(relPath <span class="keyword">string</span>, isFile <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    rel, _ := filepath.Rel(config.RootPath, filepath.Join(config.RootPath, relPath))</span><br><span class="line">    i := strings.Split(rel, config.SEPARATORS)</span><br><span class="line">    level := <span class="built_in">len</span>(i)</span><br><span class="line">    <span class="keyword">if</span> i[<span class="number">0</span>] == <span class="string">&quot;.&quot;</span> &#123;</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> isFile &#123;</span><br><span class="line">        level--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level &gt; <span class="keyword">int</span>(config.MaxLevel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>filepath.Rel</code> 把当前访问路径切出来，按照路径分隔符 <code>config.SEPARATORS</code> 切割，判断切割出来的个数是否超过设定的最大访问层级。</p><p>如果访问的是共享目录，<code>filepath.Rel</code> 会返回一个单元素切片 <code>[&quot;.&quot;]</code>，应该把 level 修正为 0 。<br>如果访问的是文件，会超出 1 级，应该把 level 自减 1 。</p><p>例如 <code>filepath.Rel(&quot;/a/b&quot;, &quot;/a/b/c/file&quot;)</code> 会得到 <code>/c/file</code>，切割得到切片为 <code>[&quot;c&quot; &quot;file&quot;]</code>，level 为 2 。但这个 file 实际上是 c 目录下的一个文件，应该是与 c 同一层级 1，所以做一次自减来修正。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>今晚想了想，这好像是个 FTP 工具，却用 HTTP 来实现，总感觉怪怪的。有时间研究研究 FTP 协议，看看能不能用 FTP 协议实现吧。</p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OneTiny </tag>
            
            <tag> FTP </tag>
            
            <tag> 局域网 </tag>
            
            <tag> gin </tag>
            
            <tag> 独立开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OneTiny 开发日记2-2021-6-25</title>
      <link href="posts/42715.html"/>
      <url>posts/42715.html</url>
      
        <content type="html"><![CDATA[<p>第一次修改别人的东西哈哈</p><span id="more"></span><p>今天开始给 OneTiny 增加更新的功能，本来想做一个跟 oh-my-zsh 一样的效果，就是会突然跳出来问你是不是要更新，是的话就给你下载最新版然后重启一下终端。</p><p>但是写着写着渐渐面临一个问题，下载后放哪？如果是类 Unix 系统怎么把文件放到 /usr/bin 目录下？放完怎么让他自己启动？</p><p>慢慢的又修改思路，换成不自动检查更新或隔一段时间检查，通过 <code>onetiny update</code> 命令可以主动更新。</p><p>在写的时候新引入了两个库，一个时负责下载时显示进度的 <a href="https://github.com/schollz/progressbar">progressbar</a>，一个是解析命令参数的 <a href="https://github.com/integrii/flaggy">flaggy</a>。</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/schollz/progressbar"><img src="https://github-readme-stats.vercel.app/api/pin/?username=schollz&repo=progressbar&theme=algolia&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=schollz&repo=progressbar&theme=algolia&show_owner=true" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/integrii/flaggy"><img src="https://github-readme-stats.vercel.app/api/pin/?username=integrii&repo=flaggy&theme=algolia&show_owner=true" class="lazyload" data-srcset="https://github-readme-stats.vercel.app/api/pin/?username=integrii&repo=flaggy&theme=algolia&show_owner=true" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/></a></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h2 id="修改-progressbar-库"><a href="#修改-progressbar-库" class="headerlink" title="修改 progressbar 库"></a>修改 progressbar 库</h2><ul><li>修改内容：修复了多了很多空行的情况</li></ul><p>在使用 <a href="https://github.com/schollz/progressbar">progressbar</a> 时，跑了官方给出的示例但是没得到官方的效果。</p><p>官网给出的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    bar := progressbar.Default(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        bar.Add(<span class="number">1</span>)</span><br><span class="line">        time.Sleep(<span class="number">40</span> * time.Millisecond)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方演示的效果：<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/devlog/20210625142209.gif" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/devlog/20210625142209.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br>实际跑出来的效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> go run main.go</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">100%</span><span class="bash"> |█████████████████████████████████████| (100/100, 25bit/s)</span> </span><br></pre></td></tr></table></figure><p>有很多的空行。<br>应用到 OneTiny 里也是一样，官方并没有给出太多答案。<br>不过进度条的核心就在于 <code>\r</code> 字符串，于是顺着代码一步步找下去，最后在库的源文件 <code>progressbar.go</code> 中找到了一个函数 <code>clearProgressBar()</code>:</p><details cyan><summary> 点击查看 `clearProgressBar()` </summary>              <div class='content'>              <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clearProgressBar</span><span class="params">(c config, s state)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> c.useANSICodes &#123;</span><br><span class="line">        <span class="comment">// write the &quot;clear current line&quot; ANSI escape sequence</span></span><br><span class="line">        <span class="keyword">return</span> writeString(c, <span class="string">&quot;\033[2K\r&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fill the empty content</span></span><br><span class="line">    <span class="comment">// to overwrite the progress bar and jump</span></span><br><span class="line">    <span class="comment">// back to the beginning of the line</span></span><br><span class="line">    str := fmt.Sprintf(<span class="string">&quot;\r%s\r&quot;</span>, strings.Repeat(<span class="string">&quot; &quot;</span>, s.maxLineWidth))</span><br><span class="line">    <span class="keyword">return</span> writeString(c, str)</span><br><span class="line">    <span class="comment">// the following does not show correctly if the previous line is longer than subsequent line</span></span><br><span class="line">    <span class="comment">// return writeString(c, &quot;\r&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>看到最下面的注释，虽然我不知道上面 return 了下，但是最后一句注释让我觉得有戏。<br>于是我把上面的 return 注释掉，取消了最后一行 return 的注释。</p><details cyan><summary> 点击查看修改后的 `clearProgressBar()` </summary>              <div class='content'>              <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func clearProgressBar(c config, s state) error &#123;</span><br><span class="line">    if c.useANSICodes &#123;</span><br><span class="line">        // write the &quot;clear current line&quot; ANSI escape sequence</span><br><span class="line">        return writeString(c, &quot;\033[2K\r&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    // fill the empty content</span><br><span class="line">    // to overwrite the progress bar and jump</span><br><span class="line">    // back to the beginning of the line</span><br><span class="line"><span class="deletion">-   str := fmt.Sprintf(&quot;\r%s\r&quot;, strings.Repeat(&quot; &quot;, s.maxLineWidth))</span></span><br><span class="line"><span class="deletion">-   return writeString(c, str)</span></span><br><span class="line">    // the following does not show correctly if the previous line is longer than subsequent line</span><br><span class="line"><span class="addition">+   return writeString(c, &quot;\r&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><p>结果居然正常了…正常了…常了…了…</p><p>好吧没时间管那么多，提交了个 <a href="https://github.com/schollz/progressbar/issues/102">issue</a> 给官方就走了。</p><h2 id="修改-flaggy-库"><a href="#修改-flaggy-库" class="headerlink" title="修改 flaggy 库"></a>修改 flaggy 库</h2><ul><li>修改点：增加了修改 <code>--help</code> 和 <code>--version</code> 的描述信息的接口，增加了打印版本信息的简写 <code>-v</code></li></ul><p>之前使用的是 <code>flag</code> 包解析命令行参数，但这包对子命令不友好。</p><h3 id="增加修改-SetHelpFlagDescription-和-SetVersionFlagDescription"><a href="#增加修改-SetHelpFlagDescription-和-SetVersionFlagDescription" class="headerlink" title="增加修改 SetHelpFlagDescription 和 SetVersionFlagDescription"></a>增加修改 SetHelpFlagDescription 和 SetVersionFlagDescription</h3><p>我准备把原本的命令改成：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  tiny</span><br><span class="line">  ├── -a --allow     指定是否允许访问者上传。</span><br><span class="line">  ├── -r --road      指定对外开放的目录的绝对路径。 (default: /home/boii/...)</span><br><span class="line">  ├── -p --port      指定开放的端口 (default: 9090)</span><br><span class="line">  ├── -h --help      打印帮助信息。</span><br><span class="line"><span class="addition">+ ├── -v --version   打印版本信息。当前版本: v0.2.1</span></span><br><span class="line"><span class="addition">+ └── update         更新到最新版本</span></span><br><span class="line"><span class="addition">+     └── -l --list       列出当前最新版本和更新内容</span></span><br></pre></td></tr></table></figure><p>增加了打印版本信息、update 子命令； update 子命令不带参数时执行更新。</p><p>用 flag 包太麻烦了，找了一会儿 github 之后终于找到一个比较适合的库 <a href="https://github.com/integrii/flaggy">flaggy</a>。使用方式和 flag 大体相似，支持子命令等更丰富的功能。</p><p>但是在打印 help 信息时，它把 <code>--help</code> 和 <code>--version</code> 的描述写死了，还不提供接口给人修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tiny - 一个用于局域网内共享文件的FTP程序。</span><br><span class="line"></span><br><span class="line">  Usage:</span><br><span class="line">    tiny [update]</span><br><span class="line"></span><br><span class="line">  Subcommands: </span><br><span class="line">    update (u)   update 可以帮你进行版本升级</span><br><span class="line"></span><br><span class="line">  Flags: </span><br><span class="line">       --version   Displays the program version string.</span><br><span class="line">    -h --help      Displays help with available flag, subcommand, and positional value parameters.</span><br><span class="line">    -r --road      指定对外开放的目录的绝对路径。 (default: /home/boii/...)</span><br><span class="line">    -p --port      指定开放的端口 (default: 9090)</span><br><span class="line">    -a --allow     指定是否允许访问者上传。</span><br></pre></td></tr></table></figure><p>中英混杂，看着就别扭。</p><p>文档中给出的示例也只有一点点，让我猜了好久最后找到了。</p><details cyan><summary> 点击查看修改步骤 </summary>              <div class='content'>              <div class="tabs" id="tab-id"><ul class="nav-tabs"><li class="tab active"><a class="#tab-id-1">步骤1</a></li><li class="tab"><a class="#tab-id-2">步骤2</a></li><li class="tab"><a class="#tab-id-3">步骤3</a></li><li class="tab"><a class="#tab-id-4">最后</a></li><li class="tab"><a class="#tab-id-5">使用</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-id-1"><p>在 <code>main.go</code> 中增加两个函数，开发者可以通过这两个函数修改默认的描述信息：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  // SetName sets the name of the default package command parser</span><br><span class="line">  func SetName(name string) &#123;</span><br><span class="line">      DefaultParser.Name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ // SetHelpFlagDescription sets the help flag description of the default package command parser</span></span><br><span class="line"><span class="addition">+ func SetHelpFlagDescription(description string) &#123;</span></span><br><span class="line"><span class="addition">+ DefaultParser.HelpFlagDescription = description</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+ // SetVersionFlagDescription sets the version flag description of + the default package command parser</span></span><br><span class="line"><span class="addition">+ func SetVersionFlagDescription(description string) &#123;</span></span><br><span class="line"><span class="addition">+ DefaultParser.VersionFlagDescription = description</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br><span class="line"></span><br><span class="line">  // ShowHelpAndExit shows parser help and exits with status code 2</span><br><span class="line">  func ShowHelpAndExit(message string) &#123;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>当然，原本的默认描述还是要保留的</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  // defaultVersion is applied to parsers when they are created</span><br><span class="line">  const defaultVersion = &quot;0.0.0&quot;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ var defaultHelpFlagDescription = &quot;Displays help with available flag, subcommand, and positional value parameters.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ var defaultVersionFlagDescription = &quot;Displays the program version string.&quot;</span></span><br><span class="line"></span><br><span class="line">  // DebugMode indicates that debug output should be enabled</span><br><span class="line">  var DebugMode bool</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-id-2"><p>在 <code>helpValues.go</code> 中修改两处地方：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   // if the built-in version flag is enabled, then add it as a help flag</span><br><span class="line">   if p.ShowVersionWithVersionFlag &#123;</span><br><span class="line">       defaultVersionFlag := HelpFlag&#123;</span><br><span class="line">           ShortName:    &quot;&quot;,</span><br><span class="line">           LongName:     versionFlagLongName,</span><br><span class="line"><span class="deletion">-           Description:  &quot;Displays the program version string.&quot;,</span></span><br><span class="line"><span class="addition">+           Description:  DefaultParser.VersionFlagDescription,</span></span><br><span class="line">           DefaultValue: &quot;&quot;,</span><br><span class="line">           Spacer:       makeSpacer(versionFlagLongName, maxLength),</span><br><span class="line">       &#125;</span><br><span class="line">       h.Flags = append(h.Flags, defaultVersionFlag)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // if the built-in help flag exists, then add it as a help flag</span><br><span class="line">   if p.ShowHelpWithHFlag &#123;</span><br><span class="line">       defaultHelpFlag := HelpFlag&#123;</span><br><span class="line">           ShortName:    helpFlagShortName,</span><br><span class="line">           LongName:     helpFlagLongName,</span><br><span class="line"><span class="deletion">-           Description:  &quot;Displays help with available flag, subcommand, and positional value parameters.&quot;,</span></span><br><span class="line"><span class="addition">+           Description:  DefaultParser.HelpFlagDescription,</span></span><br><span class="line">           DefaultValue: &quot;&quot;,</span><br><span class="line">           Spacer:       makeSpacer(helpFlagLongName, maxLength),</span><br><span class="line">       &#125;</span><br><span class="line">       h.Flags = append(h.Flags, defaultHelpFlag)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-id-3"><p>修改 <code>subCommand.go</code> 中的结构体</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type Subcommand struct &#123;</span><br><span class="line">    Name                   string</span><br><span class="line">    ShortName              string</span><br><span class="line">    Description            string</span><br><span class="line"><span class="addition">+   HelpFlagDescription    string // the help flag description</span></span><br><span class="line"><span class="addition">+   VersionFlagDescription string // the version flag description</span></span><br><span class="line">    Position               int    // the position of this subcommand, not including flags</span><br><span class="line">    Subcommands            []*Subcommand</span><br><span class="line">    Flags                  []*Flag</span><br><span class="line">    PositionalFlags        []*PositionalValue</span><br><span class="line">    ParsedValues           []parsedValue // a list of values and positionals parsed</span><br><span class="line">    AdditionalHelpPrepend  string        // additional prepended message when Help is displayed</span><br><span class="line">    AdditionalHelpAppend   string        // additional appended message when Help is displayed</span><br><span class="line">    Used                   bool          // indicates this subcommand was found and parsed</span><br><span class="line">    Hidden                 bool          // indicates this subcommand should be hidden from help</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我也想不明白为啥 DefaultParser 声明是个 <code>*Parser</code>，但是在 VSCODE 中点击跳转会跳到 SubCommand。</p></div><div class="tab-pane" id="tab-id-4"><p>最后，修改一下 <code>parser.go</code> 中的结构体。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">type Parser struct &#123;</span><br><span class="line">    Subcommand</span><br><span class="line">    Version                    string             // the optional version of the parser.</span><br><span class="line"><span class="addition">+   HelpFlagDescription        string             // the help flag description</span></span><br><span class="line"><span class="addition">+   VersionFlagDescription     string             // the version flag description</span></span><br><span class="line">    ShowHelpWithHFlag          bool               // display help when -h or --help passed</span><br><span class="line">    ShowVersionWithVersionFlag bool               // display the version when --version passed</span><br><span class="line">    ShowHelpOnUnexpected       bool               // display help when an unexpected flag or subcommand is passed</span><br><span class="line">    TrailingArguments          []string           // everything after a -- is placed here</span><br><span class="line">    HelpTemplate               *template.Template // template for Help output</span><br><span class="line">    trailingArgumentsExtracted bool               // indicates that trailing args have been parsed and should not be appended again</span><br><span class="line">    parsed                     bool               // indicates this parser has parsed</span><br><span class="line">    subcommandContext          *Subcommand        // points to the most specific subcommand being used</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NewParser creates a new ArgumentParser ready to parse inputs</span><br><span class="line">func NewParser(name string) *Parser &#123;</span><br><span class="line">    // this can not be done inline because of struct embedding</span><br><span class="line">    p := &amp;Parser&#123;&#125;</span><br><span class="line">    p.Name = name</span><br><span class="line">    p.Version = defaultVersion</span><br><span class="line"><span class="addition">+   p.HelpFlagDescription = defaultHelpFlagDescription</span></span><br><span class="line"><span class="addition">+   p.VersionFlagDescription = defaultVersionFlagDescription</span></span><br><span class="line">    p.ShowHelpOnUnexpected = true</span><br><span class="line">    p.ShowHelpWithHFlag = true</span><br><span class="line">    p.ShowVersionWithVersionFlag = true</span><br><span class="line">    p.SetHelpTemplate(DefaultHelpTemplate)</span><br><span class="line">    p.subcommandContext = &amp;Subcommand&#123;&#125;</span><br><span class="line">    return p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-id-5"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    flaggy.SetName(&quot;tiny&quot;)</span><br><span class="line">    flaggy.SetVersion(VERSION)</span><br><span class="line">    flaggy.SetDescription(&quot;一个用于局域网内共享文件的FTP程序。&quot;)</span><br><span class="line"><span class="addition">+   flaggy.SetHelpFlagDescription(&quot;打印帮助信息。&quot;)</span></span><br><span class="line"><span class="addition">+   flaggy.SetVersionFlagDescription(&quot;打印版本信息。当前版本: &quot; + VERSION)</span></span><br><span class="line">    flaggy.String(&amp;RootPath, &quot;r&quot;, &quot;road&quot;, &quot;指定对外开放的目录的绝对路径。&quot;)</span><br><span class="line">    flaggy.String(&amp;Port, &quot;p&quot;, &quot;port&quot;, &quot;指定开放的端口&quot;)</span><br><span class="line">    flaggy.Bool(&amp;IsAllowUpload, &quot;a&quot;, &quot;allow&quot;, &quot;指定是否允许访问者上传。&quot;)</span><br><span class="line">    ...</span><br><span class="line">    flaggy.Parse()</span><br></pre></td></tr></table></figure></div></div></div>              </div>            </details><h3 id="增加打印版本信息的-v"><a href="#增加打印版本信息的-v" class="headerlink" title="增加打印版本信息的 -v"></a>增加打印版本信息的 -v</h3><p>原本的打印信息有两种方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第一种</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmd --version</span></span><br><span class="line">0.0.1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二种</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmd version</span></span><br><span class="line">0.0.1</span><br></pre></td></tr></table></figure><p>可能是为了把 -v 留给使用者定义成 <code>--verbose</code> 之类的，所以源码中只有几个默认的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strings used for builtin help and version flags both short and long</span></span><br><span class="line"><span class="keyword">const</span> versionFlagLongName = <span class="string">&quot;version&quot;</span></span><br><span class="line"><span class="keyword">const</span> helpFlagLongName = <span class="string">&quot;help&quot;</span></span><br><span class="line"><span class="keyword">const</span> helpFlagShortName = <span class="string">&quot;h&quot;</span></span><br></pre></td></tr></table></figure><p>不过我暂时用不到，我希望能有第三种方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第三种</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmd -v</span></span><br><span class="line">0.0.1</span><br></pre></td></tr></table></figure><p>所以进行了以下修改：</p><div class="tabs" id="tab-id"><ul class="nav-tabs"><li class="tab active"><a class="#tab-id-1">步骤1</a></li><li class="tab"><a class="#tab-id-2">步骤2</a></li><li class="tab"><a class="#tab-id-3">步骤3</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tab-id-1"><p><code>main.go</code> 添加 <code>versionFlagShortName</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  // strings used for builtin help and version flags both short and long</span><br><span class="line">  const versionFlagLongName = &quot;version&quot;</span><br><span class="line"><span class="addition">+ const versionFlagShortName = &quot;v&quot;</span></span><br><span class="line">  const helpFlagLongName = &quot;help&quot;</span><br><span class="line">  const helpFlagShortName = &quot;h&quot;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-id-2"><p><code>helpValues.go</code> 修改一下，这样打印帮助信息的时候才会显示出来 <code>-v</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    // if the built-in version flag is enabled, then add it as a help flag</span><br><span class="line">    if p.ShowVersionWithVersionFlag &#123;</span><br><span class="line">        defaultVersionFlag := HelpFlag&#123;</span><br><span class="line"><span class="deletion">-           ShortName:    &quot;&quot;,</span></span><br><span class="line"><span class="addition">+           ShortName:    versionFlagShortName,</span></span><br><span class="line">            LongName:     versionFlagLongName,</span><br><span class="line">            Description:  DefaultParser.VersionFlagDescription,</span><br><span class="line">            DefaultValue: &quot;&quot;,</span><br><span class="line">            Spacer:       makeSpacer(versionFlagLongName, maxLength),</span><br><span class="line">        &#125;</span><br><span class="line">        h.Flags = append(h.Flags, defaultVersionFlag)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tab-id-3"><p><code>subCommand.go</code> 修改一下，这里主要是让 -v 生效</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        // if the flag being passed is version or v and the option to display</span><br><span class="line">        // version with version flags, then display version</span><br><span class="line">        if p.ShowVersionWithVersionFlag &#123;</span><br><span class="line"><span class="deletion">-           if flagName == versionFlagLongName &#123;</span></span><br><span class="line"><span class="addition">+           if flagName == versionFlagLongName || flagName == versionFlagShortName &#123;</span></span><br><span class="line">                p.ShowVersionAndExit()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>同样在 <code>subCommand.go</code> 修改一下，这里主要是检查使用者是不是定义了 -v 或者 –version</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// ensureNoConflictWithBuiltinVersion ensures that the flags on this subcommand do</span><br><span class="line">// not conflict with the builtin version flag (-v/--version). Exits the program</span><br><span class="line">// if a conflict is found.</span><br><span class="line">func (sc *Subcommand) ensureNoConflictWithBuiltinVersion() &#123;</span><br><span class="line">    for _, f := range sc.Flags &#123;</span><br><span class="line">        if f.LongName == versionFlagLongName &#123;</span><br><span class="line">            sc.exitBecauseOfVersionFlagConflict(f.LongName)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="deletion">-       if f.ShortName == versionFlagLongName &#123;</span></span><br><span class="line"><span class="addition">+       if f.ShortName == versionFlagShortName &#123;</span></span><br><span class="line">            sc.exitBecauseOfVersionFlagConflict(f.ShortName)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OneTiny </tag>
            
            <tag> FTP </tag>
            
            <tag> 局域网 </tag>
            
            <tag> gin </tag>
            
            <tag> 独立开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OneTiny 开发日记1-2021-6-22</title>
      <link href="posts/25754.html"/>
      <url>posts/25754.html</url>
      
        <content type="html"><![CDATA[<p>开发 OneTiny 时的一点思路</p><span id="more"></span><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>自从买了台二手 Surface 二合一电脑以后，的确效率上去了，可以手写真香，手终于能跟上脑子了。<br>一开始拿来当出门用的备用机，轻便，但是使用久了以后，渐渐开始有和主力机之间传输文件的需求。<br>最简单的就是拿个 U 盘拷过来拷过去，一次两次还好，多了就烦了。</p><p>于是经过搜索我发现了 Python 可以通过在命令行输入 <code>python -m http.server 8000</code> 来暂时开启一个共享目录，同一局域网内的主机就可以访问到这个目录的内容。<br>但是这条命令在 Linux 中可以，在 Windows 下不能执行。</p><p>想想这玩意本质就是开启一个 HTTP 服务，指定当前目录为 HTTP 服务的根目录。刚好学了 <code>Gin</code> 框架，而 Golang 又可以编译独立的可执行文件，还可以交叉编译，于是说干就干开始干活。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>开启一个 HTTP 服务以后，当有人访问时，需要返回目录下的内容。<br>返回的页面采用最简单的效果，基本没有 CSS 。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/devlog/20210622134240.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/devlog/20210622134240.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/devlog/20210622134617.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/devlog/20210622134617.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/devlog/20210622134734.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/devlog/20210622134734.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><code>v0.1 版</code>非常简单，程序启动的时候通过 <code>-r</code> 指定目录，没有的话默认当前目录；通过 <code>-p</code> 可以指定程序运行的端口。</p><p>当有人访问时，也就是程序接收到请求，读取目录下所有文件包括目录，交给 HTML 生成器 <code>generateHTML</code> 生成 HTML 内容，然后返回给访问者。</p><p>如果用户点击的是目录，则遍历该目录、生成 HTML，返回；<br>如果用户点击的是文件，则触发下载行为，将文件传输给访问者。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/devlog/20210622150113.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/devlog/20210622150113.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><code>v0.1.1 版</code>时重构了 获取IP 函数，解决了 Windows 下给出的无效 IP 的问题，并修复了下载文件异常的问题。</p><p>到这里 OneTiny 作为一个局域网 FTP 工具已经可以提供稳定的服务了。</p><p>但是只能单向下载文件还不够，如果能上传就好了，有来有回。</p><p>于是 <code>v0.2 版</code>新增了上传功能，并且在 HTML 部分增加了显示文件大小、返回上一级目录的链接。</p><p>这一版在新增功能的时候做了一部分重构。由于 0.1 版直接获取请求路径中的参数导致代码耦合度非常高，所以创建了一个 <code>FileStruction</code> 的模型，用于存储文件的绝对路径、相对路径、文件大小等信息。</p><p><code>v0.2.1 版</code>的时候觉得，有时候开放一个目录供人下载文件，但不希望对方上传文件上来，所以需要一个开关来设置是否允许上传。于是增加了 <code>-a</code> 的参数，默认不可以上传，除非加上 <code>-a</code> 参数才会在客户端展示的时候展示出上传框。</p><p><code>v0.2.2 版</code>对整个程序做了较大幅度的重构，将一些全局的变量移动到 config 包，然后把启动 Gin 实例的部分移动到 start 包，并做了对 <code>-p</code> 、<code>-r</code> 参数的校验，避免用户指定系统预留的端口，或者输入一个不存在的目录作为访问根目录。还另外增加了 color 包用于控制台彩色打印（windows 除外）。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这是我的第一个规范使用 Git 维护的独立项目，源自自身实际需求。<br>虽然市面上有许多现成的好看的功能更强大的 FTP 工具，但是我觉得那些太复杂，且需要安装等等。<br>我更愿意使用一个简简单单的只负责在局域网内的设备间传输文件的工具，除了必要的功能不添加太多复杂的功能，所以连界面也采用最简单的 “裸 HTML” 。<br>（我也不喜欢把时间花在写出华丽的界面上，而更愿意把时间拿来完善和增强本身的功能）</p><p>简单、专注、无需安装，这些是 OneTiny 的特点，也是 OneTiny 的局限。<br>我希望除了图形界面版本，OneTiny 能一直保持这种大道至简的风格，专注与局域网 FTP 这个职责即可。</p><p><em>Давай!</em></p><h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><ul><li><input checked="" disabled="" type="checkbox"> 上传功能</li><li><input disabled="" type="checkbox"> 自动检查更新功能</li><li><input disabled="" type="checkbox"> 密码验证功能（防止局域网内监听）</li><li><input disabled="" type="checkbox"> 增加图形界面（使用 <a href="https://fyne.io/">fyne</a>）</li><li><input disabled="" type="checkbox"> 限定访问层级</li><li><input disabled="" type="checkbox"> 限定允许上传位置</li><li><input disabled="" type="checkbox"> 大文件多线程下载</li><li><input disabled="" type="checkbox"> 断点续传</li></ul><h2 id="版本历史"><a href="#版本历史" class="headerlink" title="版本历史"></a>版本历史</h2><div class="timeline"><div class="timenode"><div class="meta"><p><p>2021-06-16 <a href="https://github.com/TCP404/OneTiny/releases/tag/v0.2.2">0.2.1 -&gt; 0.2.2</a></p></p></div><div class="body"><ol><li>Refactor: 对gin实例启动部分进行重构，移动至 start 包内；新增 config 包</li><li>Style：控制台增加彩色打印（windows除外）</li><li>Fix: 增加 flag 参数的验证</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-06-16 <a href="https://github.com/TCP404/OneTiny/releases/tag/v0.2.1">v0.2 -&gt; v0.2.1</a></p></p></div><div class="body"><ul><li>Feat: 新增 允许上传 flag <code>-a</code></li></ul></div></div><div class="timenode"><div class="meta"><p><p>2021-06-11 <a href="https://github.com/TCP404/OneTiny/releases/tag/v0.2">v0.1.1 -&gt; v0.2</a></p></p></div><div class="body"><ol><li>Feat: 新增上传功能</li><li>Style: 文件列表增加 文件大小，增加返回上一级目录链接</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-06-11 <a href="https://github.com/TCP404/OneTiny/releases/tag/v0.1.1">v0.1 -&gt; v0.1.1</a></p></p></div><div class="body"><ol><li>Fix: 修复了下载文件异常</li><li>Refactor: 重构了获取IP函数</li></ol></div></div><div class="timenode"><div class="meta"><p><p>2021-06-11 <a href="https://github.com/TCP404/OneTiny/releases/tag/v0.1">nil -&gt; v0.1</a></p></p></div><div class="body"><ol><li>首个版本，具有局域网内单向共享文件的功能，未具有上传功能。</li><li>可通过 <code>-p</code> 指定端口，通过 <code>-r</code> 指定目录</li></ol></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OneTiny </tag>
            
            <tag> FTP </tag>
            
            <tag> 局域网 </tag>
            
            <tag> gin </tag>
            
            <tag> 独立开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStruction 0x09 图-3</title>
      <link href="posts/1aa7bff2.html"/>
      <url>posts/1aa7bff2.html</url>
      
        <content type="html"><![CDATA[<p>图的应用: 最小生成树、最短路径、拓扑排序、关键路径</p><span id="more"></span><h1 id="9-图3"><a href="#9-图3" class="headerlink" title="9-图3"></a>9-图3</h1><p>图在现实中有着许多的应用，帮助人们解决了许多问题，同时图的应用也是比较晦涩难懂的地方。</p><p>本文图的应用共有：</p><ul><li>最小生成树</li><li>最短路径法</li><li>拓扑排序</li><li>关键路径</li></ul><p>从图结构的角度看，图的应用有两种：一种的解决无向图的，一种是解决有向图的。<br>更详细的看：</p><ul><li>最小生成树使用的是贪心算法，得到的是局部最优解，有可能得到的不是全局最优解</li><li>最短路径法使用的是动态规划，得到的是全局最优解</li><li>拓扑排序关注的是点</li><li>关键路径关注的是边</li></ul><p>接下来每讲一个应用之前我会先举一个场景，这样学习的时候才不至于不知道用来干嘛的。</p><h2 id="最小生成树-Minimum-Spanning-Tree"><a href="#最小生成树-Minimum-Spanning-Tree" class="headerlink" title="最小生成树 Minimum Spanning Tree"></a>最小生成树 Minimum Spanning Tree</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>假设现在有 北、上、广、深、杭、厦 几个城市，他们之间要建立通信联络网。<br>一共有 6 个城市，他们之间最少只需要 6 - 1 = 5 条通信线路即可连通。<br>但是各个城市之间的距离是不同的，距离越远，建立费用越高（即距离和费用成正比）。<br>所以，问题就是：怎么样让这 6 个城市建立起通信联络网，并且建立费用最低？</p><p>答案是使用最小生成树。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210715201359.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210715201359.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>要理解最小生成树，可以从<strong>最小</strong>和<strong>树</strong>去理解。</p><p>先理解「树」：<br>首先，生成树是一颗树，那么一堆顶点要生成一棵树，就不能有环<br>其次，每个顶点都不能落下，所以这些顶点得组成一个连通图</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210715172624.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210715172624.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>接着理解「最小」：<br>一张网，也就是路径上带权值的图，可以有很多生成树，而最小生成树则是：所有生成树里路径权值总和最小的一颗生成树。</p><h3 id="普里姆算法-Prim"><a href="#普里姆算法-Prim" class="headerlink" title="普里姆算法 (Prim)"></a>普里姆算法 (Prim)</h3><p>从任一顶点出发，将其加入已选顶点数组、其邻接的边加入备选边数组；<br>选取该顶点权值最小的一条边，所连接的顶点也加入已选顶点数组，并将该边</p><h3 id="克鲁斯卡尔算法-Kruskal"><a href="#克鲁斯卡尔算法-Kruskal" class="headerlink" title="克鲁斯卡尔算法 (Kruskal)"></a>克鲁斯卡尔算法 (Kruskal)</h3><p>克鲁斯卡尔算法适合求 稀疏网 的最小生成树。</p><p>克鲁斯卡尔算法的做法是将每一条边和权值存储到数组中，然后</p><ol><li>进行一次从小到大的排序。</li><li>从最小的边开始，将边放置到顶点上。放置前判断是否产生环：<ol><li>是：跳过这条边</li><li>否：放置这条边</li></ol></li><li>重复步骤 1</li></ol><p>总共放置顶点总数 - 1 次即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Vertex a, b;</span><br><span class="line">    <span class="keyword">int</span> Weight;</span><br><span class="line">&#125; Edge;</span><br><span class="line"></span><br><span class="line">Edge net[];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(net);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len(net); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; VertexCount<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isCycle(net[i].a)) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addEdge(net[i]);</span><br><span class="line">            n++;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先将每条边和其权值存储到数组里，做一个从小到大的排序<br>遍历数组，判断是否产生环<br>    是：删除该边<br>    否：将边放入图中，进入下一轮<br>    循环次数：顶点总数 - 1</p><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p><code>最短路径</code>和<code>最小生成树</code>都是求几个顶点之间的最短的路径，区别在于：</p><ul><li><code>最小生成树</code>的思想是使用贪心算法，而贪心算法能获得的是局部最优解，不一定是全局最优解</li><li><code>最短路径</code>的思想则是使用动态规划，而动态规划能获得的是全局最优解</li></ul><h3 id="迪杰斯特拉算法-Dijkstra"><a href="#迪杰斯特拉算法-Dijkstra" class="headerlink" title="迪杰斯特拉算法 (Dijkstra)"></a>迪杰斯特拉算法 (Dijkstra)</h3><h3 id="弗洛伊德算法-Floyd"><a href="#弗洛伊德算法-Floyd" class="headerlink" title="弗洛伊德算法 (Floyd)"></a>弗洛伊德算法 (Floyd)</h3><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="AOV-网-Activity-On-Vertex-Network"><a href="#AOV-网-Activity-On-Vertex-Network" class="headerlink" title="AOV-网 (Activity On Vertex Network)"></a>AOV-网 (Activity On Vertex Network)</h3><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><h3 id="AOE-网-Activity-On-Edge-Network"><a href="#AOE-网-Activity-On-Edge-Network" class="headerlink" title="AOE-网 (Activity On Edge Network)"></a>AOE-网 (Activity On Edge Network)</h3>]]></content>
      
      
      <categories>
          
          <category> DataStruction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> DataStruction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStruction 0x08 图-2</title>
      <link href="posts/55493.html"/>
      <url>posts/55493.html</url>
      
        <content type="html"><![CDATA[<p>图的存储</p><span id="more"></span><h1 id="8-图2"><a href="#8-图2" class="headerlink" title="8-图2"></a>8-图2</h1><h2 id="图的ADT"><a href="#图的ADT" class="headerlink" title="图的ADT"></a>图的ADT</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ADT 图 Graph</span><br><span class="line">Data</span><br><span class="line">    顶点的有穷非空集合和边的集合</span><br><span class="line"><span class="function">Operation</span></span><br><span class="line"><span class="function">    <span class="title">CreateGraph</span><span class="params">(*G, V, E)</span>: 按照顶点集V和边集E的定义构造图G</span></span><br><span class="line"><span class="function">    <span class="title">DestoryGraph</span><span class="params">(G*)</span>: 图G存在则销毁</span></span><br><span class="line"><span class="function">    <span class="title">LocateVex</span><span class="params">(G*, v)</span>: 若图G中存在顶点v，则返回v在图中的顶点数组的下标</span></span><br><span class="line"><span class="function">    <span class="title">GetVex</span><span class="params">(G*, v)</span>: 返回图中顶点v的值</span></span><br><span class="line"><span class="function">    <span class="title">PutVex</span><span class="params">(G*, v, value)</span>: 将图G中顶点v赋值value</span></span><br><span class="line"><span class="function">    <span class="title">FirstNeighbor</span><span class="params">(G*, v)</span>: 返回顶点v的第一个邻接点，若无则返回空</span></span><br><span class="line"><span class="function">    <span class="title">NextNeighbor</span><span class="params">(G*, v1, v2)</span>: 返回顶点v1相对于顶点v2的下一个邻接点，若v2是v1的最后一个邻接点则返回空</span></span><br><span class="line"><span class="function">    <span class="title">InsertVex</span><span class="params">(G*, v)</span>: 在图G中增加顶点v</span></span><br><span class="line"><span class="function">    <span class="title">DeleteVex</span><span class="params">(G*, v)</span>: 删除图G中顶点v及其相关的边/弧</span></span><br><span class="line"><span class="function">    <span class="title">InsertArc</span><span class="params">(G*, v1, v2)</span>: 在图G中增加弧&lt;v1, v2&gt;，若G是无向图，还需添加对称弧&lt;v2, v1&gt;</span></span><br><span class="line"><span class="function">    <span class="title">DeleteArc</span><span class="params">(G*, v1, v2)</span>: 在图G中删除弧&lt;v1, v2&gt;，若G是无向图，还需删除对称弧&lt;v2, v1&gt;</span></span><br><span class="line"><span class="function">    <span class="title">DFSTraverse</span><span class="params">(G*)</span>: 对图G中进行深度优先遍历</span></span><br><span class="line"><span class="function">    <span class="title">BFSTraverse</span><span class="params">(G*)</span>: 对图G中进行广度优先遍历</span></span><br><span class="line"><span class="function">    <span class="title">Adjacent</span><span class="params">(G*, v1, v2)</span>: 判断图G中是否存在边/弧&lt;v1, v2&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Neighbors</span><span class="params">(G*, v)</span>: 列出图G中与顶点v邻接的边</span></span><br><span class="line"><span class="function">    <span class="title">GetEdgeValue</span><span class="params">(G*, v1, v2)</span>: 获取图G中边/弧&lt;v1, v2&gt;对应的权值</span></span><br><span class="line"><span class="function">    <span class="title">SetEdgeValue</span><span class="params">(G*, v1, v2, value)</span>: 设置图G中边/弧&lt;v1, v2&gt;对应的权值为value</span></span><br><span class="line"><span class="function">endADT</span></span><br></pre></td></tr></table></figure><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><p>图的顶点之间没有次序关系，且顶点的邻接情况多变，无法用统一的格式来存储。</p><p>图的存储结构总共有以下 5 种方式：</p><ol><li>邻接矩阵</li><li>邻接表</li><li>十字链表</li><li>邻接多重表</li><li>边集数组</li></ol><h3 id="邻接矩阵-Adjacent-Matrix"><a href="#邻接矩阵-Adjacent-Matrix" class="headerlink" title="邻接矩阵 Adjacent Matrix"></a>邻接矩阵 Adjacent Matrix</h3><div class="note quote blue"><p>图的邻接矩阵的存储方式是用两个数组来表示图。<br>一个一维数组用来存储图中的顶点集，一个二维数组（称为邻接矩阵）用来存储图中的边集。</p><p>图的邻接矩阵表示法 = 一维数组 $\times$ 1 + 二维数组 $\times$ 1</p></div><p>设 图G 有 n 个顶点，则邻接矩阵是一个 $n \times n$ 的方阵，定义为：</p><p>$$<br>Arc[i][j] =<br>\begin{cases}<br>1, &amp; {(v_i, v_j) \in E 或 \langle v_i, v_j \rangle \in E} \\<br>0, &amp; {反之}<br>\end{cases}<br>$$</p><h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><h5 id="理论描述"><a href="#理论描述" class="headerlink" title="理论描述"></a>理论描述</h5><p><strong>顶点集</strong>很容易表示，使用顶点结构类型的一维数组来存储顶点信息。<br><strong>边集</strong>可以用 <strong>矩阵(Metrix)</strong> 来表示，而矩阵在计算机中可以使用二维数组来实现。</p><p>eg: <img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201221132810429_2398.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201221132810429_2398.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="> </p><p>这个图的边集可以变成下面的矩阵：</p><p>$$<br>\begin{bmatrix}<br>0 &amp; 1 &amp; 1 &amp; 0 \\<br>1 &amp; 0 &amp; 1 &amp; 0 \\<br>1 &amp; 1 &amp; 0 &amp; 1 \\<br>0 &amp; 0 &amp; 1 &amp; 0<br>\end{bmatrix}<br>$$</p><p>所以对于图 <strong>G =（V, {E}）</strong>，可以使用一个一维数组来存储顶点集 V，再用一个二维数组来存储边集 E。<br>于是一张图可以变成下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201221172548767_15519.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201221172548767_15519.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="无向图邻接矩阵"></p><p>上图中，有一个结构体 <code>struct Graph</code>，结构体中包含一个一维数组 <code>Vertex[]</code> 和一个二维数组 <code>Edge[][]</code>，一个 <code>v_count</code> 存储顶点数，一个 <code>e_count</code> 存储边数。</p><p><code>Vertex[]</code> 用来存储顶点信息，<code>Edge[][]</code> 用来存储边的信息。</p><p>例如 (v1, v2) 就将 <code>Edge[0][1]</code> 置为1；而 (v1, v2) 也可以表示为 (v2, v1) ，所以 <code>Edge[1][0]</code> 也应置为1。<br>而简单图不会有自己邻接自己的边，所以 <code>Edge[0][0]、Edge[1][1]、Edge[2][2]、Edge[3][3]</code> 均为0。</p><p>稍微观察可以发现，无向图的邻接矩阵一定是一个<span class='p blue'>对称矩阵</span>[^1]，于是我们可以很容易知道图中的信息：</p><ol><li>某个顶点的度，起始就是这个顶点 v<sub>i</sub> 在邻接矩阵中第 i 行（或第 i 列）的元素之和。eg：顶点 v3 的度就是 1+1+0+1 = 3</li><li>求顶点 v<sub>i</sub> 的所有邻接点就是在邻接矩阵中第 i 行所有元素为 1 的点。eg：顶点 v2 的所有邻接点就遍历 Edge[1][…]，其中为 <code>Eege[1][0]、Edge[1][2]</code> 为1，表示 v1 和 v3 为邻接点。</li></ol><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GraphModel.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GRAPH_MODEL_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRAPH_MODEL_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    ERROR,</span><br><span class="line">    OK,</span><br><span class="line">&#125; Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DG,  <span class="comment">// 有向图</span></span><br><span class="line">    UDG, <span class="comment">// 无向图</span></span><br><span class="line">    DN,  <span class="comment">// 有向网</span></span><br><span class="line">    UDN, <span class="comment">// 无向网</span></span><br><span class="line">&#125; GraphKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* Vertex; <span class="comment">// 顶点数组类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Edge;     <span class="comment">// 邻接矩阵类型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// GRAPH_MODEL_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MatrixGraph.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MATRIX_GRAPH_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MATRIX_GRAPH_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GraphModel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Vertex vers[MAX];       <span class="comment">// 顶点数组</span></span><br><span class="line">    Edge   edges[MAX][MAX]; <span class="comment">// 邻接矩阵（边数组）</span></span><br><span class="line">    <span class="keyword">size_t</span> v_count;         <span class="comment">// 顶点总数</span></span><br><span class="line">    <span class="keyword">size_t</span> e_count;         <span class="comment">// 边总数</span></span><br><span class="line">    GraphKind kind;         <span class="comment">// 图类型</span></span><br><span class="line">&#125; MatrixGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 创建无向图</span></span><br><span class="line"><span class="comment"> * @param G 要操作初始化的图</span></span><br><span class="line"><span class="comment"> * @return 成功返回OK，失败返回ERROR</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Status <span class="title">CreatUDG</span><span class="params">(MatrixGraph* G)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 返回某个顶点在顶点集合中的下标</span></span><br><span class="line"><span class="comment"> * @param G 要查找的图结构</span></span><br><span class="line"><span class="comment"> * @param v 顶点</span></span><br><span class="line"><span class="comment"> * @return 返回下标，不存在返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MatrixGraph* G, Vertex v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MATRIX_GRAPH_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MatrixGraph.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MatrixGraph.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreatUDG</span><span class="params">(MatrixGraph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G-&gt;kind = UDG;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please type the count of Vertex : &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;G-&gt;v_count);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please type the count of Edge : &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;G-&gt;e_count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 录入顶点数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please type Vertex in turn.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;v_count; i++) &#123;</span><br><span class="line">        G-&gt;vers[i] = <span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(Vertex));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Vertex %d :&quot;</span>, i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, G-&gt;vers[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化邻接矩阵，所有边的权值设置为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;v_count; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G-&gt;v_count; j++) &#123;</span><br><span class="line">            G-&gt;edges[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 录入邻接矩阵</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please type Vertex and Adjacent. \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;e_count; i++) &#123;</span><br><span class="line">        Vertex v1 = <span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(Vertex));</span><br><span class="line">        Vertex v2 = <span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(Vertex));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Vertex %d : &quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, v1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Adjacent %d : &quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, v2);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/** 核心代码 begin */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取顶点的下标</span></span><br><span class="line">        <span class="keyword">int</span> x = LocateVex(G, v1);</span><br><span class="line">        <span class="keyword">int</span> y = LocateVex(G, v2);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">-1</span> || y == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        <span class="comment">// 对应位置置为1</span></span><br><span class="line">        G-&gt;edges[x][y] = <span class="number">1</span>;</span><br><span class="line">        G-&gt;edges[y][x] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 核心代码 end */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(v1);</span><br><span class="line">        <span class="built_in">free</span>(v2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MatrixGraph* G, Vertex v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; G-&gt;v_count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(v, G-&gt;vers[index]) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index == G-&gt;v_count ? <span class="number">-1</span> : index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MatrixGraph G;</span><br><span class="line">    Status status = CreatUDG(&amp;G);</span><br><span class="line">    <span class="keyword">if</span> (status = ERROR) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Create Graph Failed~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The Adjacent Matrix: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.v_count; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t%s&quot;</span>, G.vers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.e_count; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t%s&quot;</span>, G.vers[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.e_count; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\t%d&quot;</span>, G.edges[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MatrixGraph.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><h5 id="理论描述-1"><a href="#理论描述-1" class="headerlink" title="理论描述"></a>理论描述</h5><p>有向图和无向图的区别在于邻接矩阵。</p><p>在有向图邻接矩阵中，<br>第 i 行含义：以结点 v<sub>i</sub> 为尾的弧（即出度边）<br>第 i 列含义：以结点 v<sub>i</sub> 为头的弧（即入度边）</p><p>其特点为：</p><ul><li>无向图的邻接矩阵一定是对称的，当有向图的邻接矩阵不一定是对称的。</li><li>顶点 v<sub>i</sub> 的出度 = 第 i <strong>行</strong>元素之和</li><li>顶点 v<sub>i</sub> 的入度 = 第 i <strong>列</strong>元素之和</li><li>顶点 v<sub>i</sub> 的度 = 第 i 行元素之和 + 第 i 列元素之和</li></ul><div class="note done"><p>口诀：</p><ul><li><code>Arc[行][列]</code></li><li><code>Arc[出][入]</code></li><li><strong>列头入，行尾出</strong>：即 列为弧头、入度；行为弧尾、出度。</li></ul></div><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201221172927072_32706.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201221172927072_32706.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="有向图邻接矩阵"></p><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p>在代码实现上，有向图与无向图唯一的区别在于：录入弧的数据之后，只需要执行赋值一次就可以。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">G-&gt;edges[x][y] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// G-&gt;edges[y][x] = 1;</span></span><br></pre></td></tr></table></figure><p>这里我将有向图和无向图的创建合并在一起，在调用函数时多传入一个 GraphKind 类型参数来区分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreatGraph</span><span class="params">(MatrixGraph* G, GraphKind kind)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G-&gt;kind = kind;</span><br><span class="line">    <span class="comment">// 录入顶点数和边数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 录入顶点数组</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 初始化邻接矩阵，所有边的权值设置为0</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 录入邻接矩阵</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please type %s and %s. \n&quot;</span>, kind == UDG ? <span class="string">&quot;Vertex&quot;</span> : <span class="string">&quot;InDegree&quot;</span>, kind == UDG ? <span class="string">&quot;Adjacent&quot;</span> : <span class="string">&quot;OutDegree&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;e_count; i++) &#123;</span><br><span class="line">        Vertex v1 = <span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(Vertex));</span><br><span class="line">        Vertex v2 = <span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(Vertex));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d : &quot;</span>, kind == UDG ? <span class="string">&quot;Vertex&quot;</span> : <span class="string">&quot;OutDegree&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, v1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d : &quot;</span>, kind == UDG ? <span class="string">&quot;Adjacent&quot;</span> : <span class="string">&quot;InDegree&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, v2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = LocateVex(G, v1);</span><br><span class="line">        <span class="keyword">int</span> y = LocateVex(G, v2);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">-1</span> || y == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">        G-&gt;edges[x][y] = <span class="number">1</span>;</span><br><span class="line">        G-&gt;edges[y][x] = kind == UDG ? <span class="number">1</span> : <span class="number">0</span>;    <span class="comment">// 无向图置为1，有向图保持默认</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(v1);</span><br><span class="line">        <span class="built_in">free</span>(v2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Status status = CreatGraph(&amp;G);</span></span><br><span class="line">Status status = CreatGraph(&amp;G, DG);</span><br></pre></td></tr></table></figure><p>同时，有向图的顶点的度 = 出度 + 入度，可以实现一个函数根据图的类型来返回顶点的度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 获取某个顶点的度</span></span><br><span class="line"><span class="comment"> * @param G 要查找的图</span></span><br><span class="line"><span class="comment"> * @param v 要查询度的顶点</span></span><br><span class="line"><span class="comment"> * @return 该顶点的度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">GetDegree</span><span class="params">(MatrixGraph* G, Vertex v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取无向图的度：累加第i行或第i列的元素之和</span></span><br><span class="line">    <span class="comment">// 获取有向图的度：累加第i行和第i列的元素之和并相加</span></span><br><span class="line">    <span class="keyword">int</span> index = LocateVex(G, v);</span><br><span class="line">    <span class="keyword">int</span> inDegree = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> outDegree = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;e_count; i++) &#123;</span><br><span class="line">        inDegree += G-&gt;edges[i][index];</span><br><span class="line">        outDegree += G-&gt;edges[index][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> G-&gt;kind == UDG ? inDegree : inDegree + outDegree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无向图的度只需要返回行的和或列的和就行，有向图的度则需要相加再返回。</p><h4 id="网"><a href="#网" class="headerlink" title="网"></a>网</h4><p>边或弧带权的图即为网。</p><h5 id="理论描述-2"><a href="#理论描述-2" class="headerlink" title="理论描述"></a>理论描述</h5><p>设 图G 有 n 个顶点，则邻接矩阵是一个 $n \times n$ 的方阵，定义为：</p><p>$$<br>Arc[i][j] =<br>\begin{cases}<br>W_{ij}, &amp; {(v_i, v_j) \in E 或 \langle v_i, v_j \rangle \in E} \\<br>0, &amp; {i=j} \\<br>∞, &amp; {反之}<br>\end{cases}<br>$$</p><p>这里 $W_{ij}$ 表示 $\langle v_i, v_j \rangle$ 或 $(v_i, v_j)$ 上的权值。<br>$\infty$ 表示一个计算机允许的、大于所有边上权值的值，即一个不可能的极限值，在C语言中可以使用 <code>INT_MAX</code> 来表示无穷。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201221215629050_25484.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201221215629050_25484.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="网的邻接矩阵"></p><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><p>网的大部分代码与有向图和无向图的相同的，只有几处需要修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化邻接矩阵，所有边的权值设置为无穷</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;v_count; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G-&gt;v_count; j++) &#123;</span><br><span class="line">        G-&gt;edges[i][j] = INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化时，不能初始化为0，而要初始化为 <code>INT_MAX</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 录入邻接矩阵</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please type %s and %s. \n&quot;</span>, kind == UDN ? <span class="string">&quot;Vertex&quot;</span> : <span class="string">&quot;InDegree&quot;</span>, kind == UDN ? <span class="string">&quot;Adjacent&quot;</span> : <span class="string">&quot;OutDegree&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;e_count; i++) &#123;</span><br><span class="line">        Vertex v1 = <span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(Vertex));</span><br><span class="line">        Vertex v2 = <span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(Vertex));</span><br><span class="line">        <span class="keyword">int</span> weight = <span class="number">0</span>; <span class="comment">// 权值</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d : &quot;</span>, kind == UDN ? <span class="string">&quot;Vertex&quot;</span> : <span class="string">&quot;OutDegree&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, v1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d : &quot;</span>, kind == UDN ? <span class="string">&quot;Adjacent&quot;</span> : <span class="string">&quot;InDegree&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, v2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Value %d: &quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;weight);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = LocateVex(G, v1);</span><br><span class="line">        <span class="keyword">int</span> y = LocateVex(G, v2);</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">-1</span> || y == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">        G-&gt;edges[x][y] = weight;</span><br><span class="line">        G-&gt;edges[y][x] = kind == UDN ? weight : INT_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(v1);</span><br><span class="line">        <span class="built_in">free</span>(v2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>录入邻接矩阵时也需要多录入一个权值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.e_count; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t%s&quot;</span>, G.vers[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.e_count; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t%s&quot;</span>, G.edges[i][j] == INT_MAX ? <span class="string">&quot;∞&quot;</span> : (<span class="keyword">char</span>*)G.edges[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印时也稍作处理。</p><h3 id="邻接表-Adjacent-List"><a href="#邻接表-Adjacent-List" class="headerlink" title="邻接表 Adjacent List"></a>邻接表 Adjacent List</h3><p>邻接矩阵适合处理稠密图，对于稀疏图，邻接矩阵会造成巨大的浪费。在数据结构中，解决浪费问题需要往链式结构的方向去想。</p><div class="note quote"><p>图的邻接表的存储方式是用一维数组和单链表来表示图。<br>一个一维数组用来存储图中的顶点集，多个单链表用来存储图中的边集。</p><p>图的邻接矩阵表示法 = 一维数组 $\times$ 1 + 单链表 $\times$ n</p></div><h4 id="无向图的邻接表"><a href="#无向图的邻接表" class="headerlink" title="无向图的邻接表"></a>无向图的邻接表</h4><p>邻接表的处理方法如下：</p><ul><li>图的顶点集用一维数组存储，数组元素为 <code>数据域(data)</code> + <code>首邻接点域(firstEdge)</code>；</li><li>图的边/弧集用单链表存储，链表结点由 <code>邻接点域(adjvex)</code> + <code>指针域(next)</code> 构成；</li></ul><p><code>首邻接点域</code> 指的是顶点的第一个边链表结点的地址，链表中的 <code>邻接点域</code> 存储的是邻接点的在顶点数组中的下标。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222123713244_31065.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222123713244_31065.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="邻接表"></p><p>从上图可以看出，一个无向图可以用一个顶点类型的一维数组来存储顶点，每个顶点都各自有一条边链表，存储着该顶点的所有邻接点；</p><p>顶点数组中的某个顶点 <code>Vertex[i]</code> 和 对应边链表中的任一个结点构成了一条边。</p><p>eg：</p><p>$v_1$ 的邻接点是 $v_2$ 和 $v_3$，在顶点数组中 $v_1$ 的下标是 0；<br/><br>在 <code>Vertex[0]</code> 数据域(data) 中存着 $v_1$，首邻接点域(firstEdge) 存储着边链的第一个结点的地址；<br/><br>在边链的第一个结点中，邻接点域(adjvex) 存储着 $v_2$ 的下标 1，然后指针域(next) 指向下一个结点；<br/><br>下一个结点的邻接点域存储着 $v_3$ 的下标 2，后面不再有了，所以指针域为空。<br/></p><p>仔细观察可以发现以下特点：</p><ul><li>无向图的邻接表重复存储着数据（邻接矩阵里也是），但总比邻接矩阵节省空间。</li><li>边链中的结点，除了与顶点数组中的元素，相互之间没有关系。</li><li>顶点的度 = 它的边链的结点数</li><li>求顶点的所有邻接点 = 遍历顶点的边链并取邻接点域</li><li>如果有 n 条边，则边链表会有 2n 个结点</li></ul><h4 id="有向图的邻接表"><a href="#有向图的邻接表" class="headerlink" title="有向图的邻接表"></a>有向图的邻接表</h4><p>有向图的邻接表是类似的，但有向图区分方向。</p><p>我们以顶点为弧尾来存储边链表，并称这样的边链表为<strong>出边表</strong>，或<strong>正邻接表</strong><br>我们以顶点为弧头来存储边链表，并称这样的边链表为<strong>入边表</strong>，或<strong>逆邻接表</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222123739148_26529.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222123739148_26529.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="右上出边表 和 右下入边表"/></div><span class="image-caption">右上出边表 和 右下入边表</span></div><p>右上为出边表，右下为入边表</p><p>出边表中，顶点 v1 作为弧尾，邻接弧头 v2，所以首邻接点与指向出边表的第一个结点，结点中的数据域存储着弧头 v2 的下标 1。所以 v1 和 <code>Vertex[1]</code> 共同组成一条弧。</p><p>而顶点 v2 有 2 个出度，所以 v2 的出边表中有 2 个结点。</p><p>入边表中，顶点 v3 作为弧头，邻接弧尾 v2 和 v4，所以首邻接点指向入边表的第一个结点，结点中存着 v2 的下标 1，第二个结点存着 v4 下标 3。</p><p>观察两个表，可以发现以下特点：</p><ul><li>使用入边表表示图时，顶点的入度 = 对应入边表的结点数量，要计算出度只能遍历所有边链表</li><li>使用出边表表示图时，顶点的出度 = 对应出边表的结点数量，要计算入度只能遍历所有边链表</li><li>边链表中的结点，除了与顶点元素，相互之间没有关系</li><li>弧的总数 = 所有边链表的结点的总数之和</li></ul><h4 id="有向网的邻接表"><a href="#有向网的邻接表" class="headerlink" title="有向网的邻接表"></a>有向网的邻接表</h4><p>有向网和无向网的邻接表仅仅只是在边链表中的结点增加一个变量 weight 来存储权值。同样有有向无向、出边入边之分。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222123823531_26765.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222123823531_26765.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="网的邻接表"></p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 边链表结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;          <span class="comment">// 邻接点域、邻接点下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span>   <span class="comment">// 指针域</span></span><br><span class="line">&#125; EdgeNode, ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* Vertex;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Vertex data;         <span class="comment">// 数据域</span></span><br><span class="line">    EdgeNode firstEdge;  <span class="comment">// 首邻接点域</span></span><br><span class="line">&#125; VertexNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VertexNode vexs[MAX];    <span class="comment">// 顶点结点数组</span></span><br><span class="line">    <span class="keyword">int</span> v_count;             <span class="comment">// 顶点数量</span></span><br><span class="line">    <span class="keyword">int</span> e_count;             <span class="comment">// 边/弧数量</span></span><br><span class="line">    GraphKind kind;          <span class="comment">// 图类型</span></span><br><span class="line">&#125; AdjListGraph;</span><br></pre></td></tr></table></figure><h3 id="十字链表-Orthogonal-List"><a href="#十字链表-Orthogonal-List" class="headerlink" title="十字链表 Orthogonal List"></a>十字链表 Orthogonal List</h3><div class="note quote"><p>十字链表主要针对有向图，适用于需要<strong>频繁获取顶点的入度和出度，频繁地判断一个点是不是另一个点</strong>的邻接点等的情况。</p><p>其核心思想是<strong>将出边表和入边表整合起来</strong>。</p></div><p>有向图的邻接表只有表示出度的出边表，或者表示入度的入边表，鱼和熊掌不可兼得。</p><p>对于这种情况，小孩子才做选择，大人全都要！</p><p>于是我们可以改造一下顶点数组，让一个顶点数组的元素包含 <code>顶点</code>、<code>出边表的首邻接点域</code>、<code>入边表的首邻接点域</code></p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201223125912346_19343.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201223125912346_19343.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><code>data</code> 表示顶点，<code>iFirst</code> 表示入边表的首邻接点域，<code>oFirst</code> 表示出边表的首邻接点域。</p><p>于是我们可以得到一个这样的双邻接表：</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload" src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201223132930617_4233.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201223132930617_4233.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="←图结构，↑出边表，↓入边表，→双邻接表"/></div><span class="image-caption">←图结构，↑出边表，↓入边表，→双邻接表</span></div><p>最左边是图结构，中间上面是出边表，中间下面是入边表，将它们结合，就成了最右边的双邻接表</p><p>下一步我们改造一下边链表的结点，让它由 <code>弧尾下标</code> + <code>弧尾边链的指针域</code> + <code>弧头下标</code> + <code>弧头边链的指针域</code> 构成。<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201223130924330_32433.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201223130924330_32433.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><code>oVex</code> 表示弧中出边的结点，即弧尾结点，的下标；<code>oNext</code> 替代了原出边表结点里的指针域；<br><code>iVex</code> 表示弧中入边的结点，即弧头结点，的下标；<code>iNext</code> 替代了原入边表结点里的指针域；</p><p>现在对双邻接表进行改造：<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201223133027047_23264.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201223133027047_23264.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="改造边链表结点"></p><p>然后我们会发现有很多重复的结点，我们保留一个，删除一个：<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201223133122257_6587.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201223133122257_6587.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="删除重复结点"></p><p>接着把被删除的地方的链指向保留下来的那个结点：</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201223135115072_2208.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201223135115072_2208.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="改链"></p><p>例如 v1 的出边表第一个结点（v1 红色线条指向的那个 0 和 1 的结点） 和 v2 的入边表的第一个节点（v2 蓝色线条指向的那个 0 和 1 的结点），</p><p>这两个结点相同，</p><p>于是我删掉其中 v2 的那个，然后让 v2 的蓝色线指向 v1 的第一个结点，其他结点也是同样操作。</p><p>最后整理一下就是下图的样子：</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201223135135896_26333.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201223135135896_26333.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="十字链表"></p><p>对比一下该图的顶点 v2 的出边表和十字链表：<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201223140240032_28522.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201223140240032_28522.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="出边表 VS 十字链表"></p><p>可以看到没有损失任何信息。</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 顶点类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* Vertex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 十字链表结点 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    Vertex oVex;        <span class="comment">// 弧头下标</span></span><br><span class="line">    Vertex iVex;        <span class="comment">// 弧尾下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">oNext</span>;</span> <span class="comment">// 出边表指针域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">iNext</span>;</span> <span class="comment">// 入边表指针域</span></span><br><span class="line">    <span class="keyword">int</span> weight;         <span class="comment">// 权值</span></span><br><span class="line">&#125; OrthoNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 顶点数组元素类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Vertex data;        <span class="comment">// 顶点</span></span><br><span class="line">    OrthoNode iFirst;   <span class="comment">// 入边表的首个结点</span></span><br><span class="line">    OrthoNode oFirst;   <span class="comment">// 出边表的首个节点</span></span><br><span class="line">&#125; VertexNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 图结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VertexNode vexArray[MAX];    <span class="comment">// 顶点数组</span></span><br><span class="line">    <span class="keyword">int</span> v_count;                 <span class="comment">// 顶点数量</span></span><br><span class="line">    <span class="keyword">int</span> a_count;                 <span class="comment">// 弧的数量</span></span><br><span class="line">    GraphKind kind;              <span class="comment">// 图的类型（有向图/有向网）</span></span><br><span class="line">&#125; OrthoGraph;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><div class="note done"><p>十字链表5步走：</p><ol><li>生成有向图的出边表和入边表</li><li>组合成双邻接表</li><li>改造链表结点</li><li>删除重复结点</li><li>连接</li></ol></div><h3 id="邻接多重表-Adjacent-Multilist-List"><a href="#邻接多重表-Adjacent-Multilist-List" class="headerlink" title="邻接多重表 Adjacent Multilist List"></a>邻接多重表 Adjacent Multilist List</h3><div class="note quote"><p>邻接多重表主要是针对无向图。</p></div><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222185711829_15128.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222185711829_15128.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="无向图的邻接表表示法"></p><p>从图中可以发现边链结点很多都是重复的。当删除一条边时，需要到两条边链中删除。<br>例如删除 边(v1, v3)，需要找到 v1 的边链，删除第二个结点，然后还要找到 v3 的边链，然后删除第一个结点。显然这是比较繁琐的。</p><p>所以邻接多重表就在邻接表的基础上对边链的结点进行改造。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222191259613_26797.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222191259613_26797.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>邻接表的结点由 <code>邻接点的下标</code> <strong>+</strong> <code>下一结点指针</code> 构成<br>邻接多重表的结点由 <code>顶点下标</code> <strong>+</strong> <code>顶点的下一结点的指针</code> <strong>+</strong> <code>邻接点下标</code> <strong>+</strong> <code>邻接点的下一结点的指针</code> 构成</p><div class="note quote"><p>其思想是<strong>将所有顶点的边链整合起来</strong>，即节省空间，也提高了操作效率。</p></div><p>下面介绍一下如何将邻接表改为邻接多重表：</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222224547724_28766.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222224547724_28766.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="改造边链结点"></p><ol><li>首先将 边链的结点进行改造：边链结点中不仅要填入邻接点的下标，还要填入顶点自己的下标。</li></ol><p>例如 顶点 v1 有两个邻接点 v2 和 v3，所以要在两个结点中的 ivex 处填入 v1 的下标 0。其他结点同理。看不懂可以对比两个图的边链。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222225410133_12444.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222225410133_12444.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="删除重复结点"></p><ol start="2"><li>例如 v1 的第一个边链结点中有 0 和 1，代表 v1 的地址和 v2 的地址；v2 的第一个边链结点也有 1 和 0，所以随便保留哪一个都可以。</li></ol><p>图中将 v2 的第一个边链结点删除，然后让 v1 的第一个边链结点也成为 v2 的边链结点。</p><p>这一步怎么删，删完指向谁可能有点乱，请看下面的图。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222225336253_30848.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222225336253_30848.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="对比图"></p><ol start="3"><li>这里左侧两个图结构是同一个，第二个图结构多做了4条辅助线用来对照，实际真正的图是第一个的图结构，不要混淆。<br>对照第二个的图结构，和右侧的邻接多重表：</li></ol><p>顶点 v1 有两条边，邻接 v2 和 v3，在邻接多重表中用红色线连接起来了。单独观察 <code>VertexNode[0]</code> 和 <code>红色线连接的两个结点</code>，是不是跟邻接表相似？</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222230310803_2534.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222230310803_2534.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="左：邻接多重表 右：邻接表"></p><p>同样道理可以继续观察 v2、v3、v4。</p><p>我们会发现邻接多重表的结点数少了，而且<strong>结点总数刚好就是边数</strong>。</p><p>现在再来体会那句：<strong>将所有边链整合起来</strong>，再体会体会为什么要增加 <code>inext</code> 和 <code>jnext</code> 两个元素在结点中，其实就是为了保留原本的信息。</p><p>邻接多重表中边链的结点不分是谁的，只记录边两头两个顶点的下标。</p><div class="note quote"><p>扩展一下，如果无向网使用邻接多重表表示，是不是只要将边链结点多加一个 权值 的成员即可？如果还要再来个是否被搜索过的标记，是不是再加个 布尔值 的成员即可？</p></div><h3 id="边集数组-Edgeset-Array"><a href="#边集数组-Edgeset-Array" class="headerlink" title="边集数组 Edgeset Array"></a>边集数组 Edgeset Array</h3><div class="note quote"><p>边集数组是由两个一维数组构成，一个是存储顶点的信息，另一个是存储边的信息。这个边数组的每个元素由一条边的起点下标 (begin) 、终点下标 (end) 和权 (weight) 组成。</p><p>边集数组关注的是边的集合。</p><p>在边集数组中要查找一个顶点的度需要扫描整个边数组，效率不高，因此更适合对边依次进行处理的操作，而不适合对顶点相关的操作。</p></div><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222233340163_16644.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201222233340163_16644.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="边集数组"></p><h3 id="适用情况总结"><a href="#适用情况总结" class="headerlink" title="适用情况总结"></a>适用情况总结</h3><ul><li>邻接矩阵适合处理稠密图</li><li>邻接表适合处理稀疏图</li><li>十字链表适合于需要频繁获取顶点的入度和出度，频繁地判断一个点是不是另一个点的邻接点等的情况</li><li>邻接多重表主要是针对无向图</li><li>边集数组适合对边依次进行处理的操作，而不适合对顶点相关的操作</li></ul><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h3><div class="note quote"><p>深度优先遍历 (Depth-First-Search) 是仿树的前序遍历，该算法是利用栈来实现，也就是递归，所以在 DFS 中会有<strong>递归</strong>和<strong>回溯</strong>的说法。</p></div><p>DFS 需要借助一个数组来记录访问状态，这里将其称作<strong>状态数组（Status Array）</strong>；该数组长度为顶点总数，次序与顶点数组相同。</p><p>从某一个顶点 vi 出发，则当前顶点为 vi；</p><p>先将该顶点标记为已访问，然后遍历其所有邻接点，找到 <strong>第一个未访问的邻接点 vj</strong> 并置为当前顶点；</p><p>接着从该顶点 vj 出发，先标记为已访问，然后遍历找到 <strong>第一个未访问的邻接点 vk</strong> 并置为当前顶点… 以此类推</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201227104338200_15211.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201227104338200_15211.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>例如上图左边是一个图，我们可以转换一下思维，像右图一样把那两条边当作没有，就可以看成一棵二叉树</p><p>运用树的前序遍历法可以得到：<strong>v0 -&gt; v1 -&gt; v5 -&gt; v2 -&gt; v4 -&gt; v3</strong>，而这正好就是 DFS 的结果。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201227104426654_6400.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201227104426654_6400.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br>回过头来重新看着左边的图，假设从 v0 出发（其实图是无序的，从任何一点出发都可以）；</p><ul><li>v0 有两个邻接点 v1 和 v3，我们先选择 v1，然后从 v1 出发；</li><li>v1 有两个邻接点 v5 和 v0，v0 已经访问过了，只能选择 v5，然后从 v5 出发；</li><li>v5 有三个邻接点 v1、v2、v3，v1 已经访问过了，我们先选择 v2 ，然后从 v2 出发；</li><li>v2 有两个邻接点 v5 和 v4，v5 已经访问过了，只能选择 v4，然后从 v4 出发；</li><li>v4 有两个邻接点 v2 和 v3，v2 已经访问过了，只能选择 v3，然后从 v3 出发；</li><li>v3 有三个邻接点 v4、v5、v0，全都访问过了，到此遍历也就结束了。</li></ul><p>如果仔细阅读上面6个步骤会发现，当我们遍历时，我们需要知道这个顶点是不是被访问过了，所以我们需要一个状态数组来记录；</p><p>而当有多个邻接点可以访问时，我们选择的依据，其实是顶点在顶点数组中存储的顺序所决定的。</p><p>例如在 v5 的时候，选择了 v2 而不是 v3，其实是我们默认顶点数组是按照 <code>v0、v1、v2、v3、v4、v5</code> 的顺序存储，假设是按照 <code>v0、v1、v3、v2、v4、v5</code> 存储，v3 在 v2 前，则会先访问 v3。</p><h4 id="邻接矩阵的-DFS"><a href="#邻接矩阵的-DFS" class="headerlink" title="邻接矩阵的 DFS"></a>邻接矩阵的 DFS</h4><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201227102907217_22966.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201227102907217_22966.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="邻接矩阵的 DFS"></p><p>先将图的边用矩阵表示，在计算机中使用二维数组存储。<br>然后设置一个状态数组，长度和顶点数组相同。</p><p>接下来就可以执行 DFS 了。</p><p>第一步：先初始化状态数组为未访问状态，即最开始所有顶点都未访问。<br>第二步：遍历顶点数组，让数组里每个顶点都放入遍历执行函数中，不过在调用遍历执行函数之前要先判断顶点是否已被访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> visited[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** DFS begin */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 深度优先遍历算法</span></span><br><span class="line"><span class="comment"> * @param G 需要被遍历的图</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse_AMG</span><span class="params">(MatrixGraph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化状态数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;v_count; i++)</span><br><span class="line">        visited[i] = UNVISITED;</span><br><span class="line">    <span class="comment">// DFS 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;v_count; i++)</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) <span class="comment">// 如果某个顶点未访问</span></span><br><span class="line">            DFS_AMG(G, i); <span class="comment">// 调用遍历执行函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历执行函数就是 DFS 的核心算法了。<br>该函数接收顶点的下标，并做3件事：</p><ol><li>访问当前顶点</li><li>更改顶点的访问状态</li><li>获取第一个未访问的邻接点下标，然后递归进去，找不到则回溯</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 深度优先搜索的核心算法</span></span><br><span class="line"><span class="comment"> * @param G 要搜索的图</span></span><br><span class="line"><span class="comment"> * @param index 要搜索的顶点的下标</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_AMG</span><span class="params">(MatrixGraph* G, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %s &quot;</span>, G-&gt;vexes[index]); <span class="comment">// 访问当前顶点</span></span><br><span class="line">    visited[index] = VISITED; <span class="comment">// 更改当前顶点的访问状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G-&gt;v_count; j++)</span><br><span class="line">        <span class="keyword">if</span> (G-&gt;matrix[index][j] &amp;&amp; !visited[j]) <span class="comment">// 获取第一个未访问的邻接点下标然后递归进去</span></span><br><span class="line">            DFS_AMG(G, j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** DFS end */</span></span><br></pre></td></tr></table></figure><p>在邻接矩阵中，获取某个顶点的所有邻接点就是遍历其所在的行，找到第一个未访问的邻接点。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201227111845411_7573.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201227111845411_7573.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>从邻接矩阵中看如上图</p><ul><li>最开始从第 0 行进行（箭头1），找到第一个邻接点的下标，其列标为 1，于是跳到第 1 行（箭头2）</li><li>第 1 行第一个邻接点是 v0 ，已经访问过，所以跳过（箭头3），一直找到 v5 这个邻接点，其列标为 5，于是跳到第 5 行（箭头4）</li><li>第 5 行第一个邻接点的 v1，已经访问过，所以跳过（箭头5），接下去找到第二个邻接点 v2，其列标为 2，于是跳到第 2 行（箭头6）</li><li>接下去的步骤都是这个思路，画出来太乱就没画了。</li></ul><h4 id="邻接表的-DFS"><a href="#邻接表的-DFS" class="headerlink" title="邻接表的 DFS"></a>邻接表的 DFS</h4><p>邻接表的具体代码实现跟邻接矩阵稍稍不同而已，只不过把数组处理换成了链表处理<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201227115455825_10282.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201227115455825_10282.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ul><li>最开始从 v1 开始（箭头1），访问 v1 的边链上第一个结点（箭头2），得到了 v2 的下标，于是跳到 v2（箭头3）</li><li>接着从 v2 开始，先访问 v2，然后遍历 v2 的边链上的结点（箭头4），第一个结点 0 是 v1 的下标，已经访问过了，于是继续下一个结点，得到了 v3 的下标，于是跳到 v3（箭头5）</li><li>接着从 v3 开始，先访问 v3，然后遍历 v3 的边链上的结点（箭头6），第一和第二个结点是 v1 和 v2 的下标，已经访问过，所以接着下一个结点，得到 v4 的下标，于是跳到 v4（箭头7）</li><li>接着从 v4 开始，先访问 v4，然后遍历 v4 的边链上的结点，发现得到的是 v3 的下标，已经访问过了，再下去没有了，于是结束。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse_ALG</span><span class="params">(AdjListGraph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  初始化状态数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;v_count; i++)</span><br><span class="line">        visited[i] = UNVISITED;</span><br><span class="line">    <span class="comment">// DFS遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;v_count; i++)</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) <span class="comment">// 如果顶点没有被访问，就递归调用</span></span><br><span class="line">            DFS_ALG(G, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_ALG</span><span class="params">(AdjListGraph* G, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; -&gt; %s&quot;</span>, G-&gt;vexes[index].data);    <span class="comment">// 访问顶点</span></span><br><span class="line">    visited[index] = VISITED;                  <span class="comment">// 更改状态</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 寻找邻接点</span></span><br><span class="line">    EdgeNode* eNode = G-&gt;vexes[index].firstEdge;</span><br><span class="line">    <span class="keyword">while</span> (eNode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[eNode-&gt;adjvex]) <span class="comment">// 如果邻接点未访问就递归访问</span></span><br><span class="line">            DFS_ALG(G, eNode-&gt;adjvex);</span><br><span class="line">        eNode = eNode-&gt;nextEdge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DFSTraverse_ALG()</code> 和 <code>DFSTraverse_AMG()</code> 是一样的，初始化状态数组，然后遍历顶点数组，调用 DFS 算法</p><p><code>DFS_AMG()</code> 中是遍历某一行，<code>DFS_ALG()</code> 中是遍历某一条链表，执行的逻辑都是如果邻接点为访问就递归。<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201227114050613_21706.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201227114050613_21706.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>在遍历图时，对图中每个顶点至多调用一次 DFS 函数，因为一旦某个顶点被标志成已访问后，就不再从它出发进行搜索。<br>因此，深度遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费时间取决于所采用的存储结构。</p><ul><li>当用邻接矩阵时，使用的是二位数组，查找每个顶点的邻接点所需时间为 $O(n^2)$，n 为图中顶点数。</li><li>当用邻接表时，使用的是链表，查找每个顶点的邻接点所需时间为 $O(e)$，e 为无向图中边的数量，或有向图中弧的数量。</li></ul><p>由此，<br>邻接矩阵的 DFS 时间复杂度为 $O(n^2 + n) = O(n^2)$<br>邻接表的 DFS 时间复杂度为 $O(n+e)$</p><h3 id="广度优先-BFS"><a href="#广度优先-BFS" class="headerlink" title="广度优先 BFS"></a>广度优先 BFS</h3><div class="note quote"><p>广度优先遍历 (Breadth-First-Search) 是仿树的层次遍历。该算法是利用队列实现的。</p></div><p>BFS 的思想是，把顶点都放到队列中，当访问一个顶点，即为出队一个元素；当出队一个元素时，需将其所有未访问的邻接点入队。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201227214919073_23879.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201227214919073_23879.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ol><li>先从 v0 开始遍历，打印 v0，然后 v0 入队</li><li>队列不为空，v0 出队，同时 v0 的未入队且未访问的邻接点 v1、v3 入队，然后访问 v1、v3</li><li>队列不为空，v1 出队，同时 v1 的未入队且未访问的邻接点 v5、v6 入队，然后访问 v5、v6</li><li>队列不为空，v3 出队，同时 v3 的未入队且未访问的邻接点 v4 入队，然后访问 v4</li><li>队列不为空，v5 出队，同时 v5 的未入队且未访问的邻接点 v2 入队，然后访问 v2</li><li>队列不为空，v6 出队，同时 v6 已经没有未入队且为访问的邻接点了，不做入队操作</li><li>队列不为空，v4 出队</li><li>队列不为空，v2 出队<br>队列为空，结束<br>到此 BFS 执行完毕</li></ol><p>所以该图的 BFS 顺序为 <code>v0 -&gt; v1 -&gt; v3 -&gt; v5 -&gt; v6 -&gt; v4 -&gt; v2</code>。</p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>BFS 需要借助队列实现，下面是队列的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkQueue.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LINK_QUEUE_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINK_QUEUE_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GraphModel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Vertex Element;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    Element data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    QueueNode* front;</span><br><span class="line">    QueueNode* rear;</span><br><span class="line">&#125; LinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitLinkedQueue</span><span class="params">(LinkedQueue* q)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkedQueue* q, Element e)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkedQueue* q, Element* e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmptyQueue</span><span class="params">(LinkedQueue* q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintLinkedQueue</span><span class="params">(LinkedQueue* q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LINK_QUEUE_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkQueue.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;LinkQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitLinkedQueue</span><span class="params">(LinkedQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkedQueue* q, Element e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QueueNode* <span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    <span class="keyword">new</span>-&gt;data = e;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEmptyQueue(q)) &#123; <span class="comment">// 处理空队情况</span></span><br><span class="line">        q-&gt;front = q-&gt;rear = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 处理非空队情况</span></span><br><span class="line">        q-&gt;rear-&gt;next = <span class="keyword">new</span>; <span class="comment">// 原队尾结点的next指向新结点</span></span><br><span class="line">        q-&gt;rear = <span class="keyword">new</span>; <span class="comment">// 更新队尾指针</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkedQueue* q, Element* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmptyQueue(q)) &#123; <span class="comment">// 空队直接返回</span></span><br><span class="line">        e = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == q-&gt;rear) &#123; <span class="comment">// 处理队中只有一个结点的情况</span></span><br><span class="line">        *e = q-&gt;front-&gt;data;</span><br><span class="line">        <span class="built_in">free</span>(q-&gt;front);</span><br><span class="line">        q-&gt;front = q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理队中不止一个结点的情况</span></span><br><span class="line">    QueueNode* del = q-&gt;front; <span class="comment">// 标记队头结点</span></span><br><span class="line">    q-&gt;front = del-&gt;next; <span class="comment">// 队头指针指向下一个结点</span></span><br><span class="line">    *e = del-&gt;data; <span class="comment">// 取数据</span></span><br><span class="line">    <span class="built_in">free</span>(del); <span class="comment">// 删除原队头结点</span></span><br><span class="line">    del = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmptyQueue</span><span class="params">(LinkedQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span> || q-&gt;rear == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintLinkedQueue</span><span class="params">(LinkedQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmptyQueue(q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Queue Empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QueueNode* p = q-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t%s &quot;</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邻接矩阵的-BFS"><a href="#邻接矩阵的-BFS" class="headerlink" title="邻接矩阵的 BFS"></a>邻接矩阵的 BFS</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** BFS begin */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse_AMG</span><span class="params">(MatrixGraph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;v_count; i++)</span><br><span class="line">        visited[i] = UNVISITED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历每个顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;v_count; i++)</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) <span class="comment">// 如果没有访问过就遍历访问</span></span><br><span class="line">            BFS_AMG(G, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_AMG</span><span class="params">(MatrixGraph* G, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %s &quot;</span>, G-&gt;vexes[index]);    <span class="comment">// 访问顶点</span></span><br><span class="line">    visited[index] = VISITED;             <span class="comment">// 更改访问状态</span></span><br><span class="line"></span><br><span class="line">    LinkQueue <span class="built_in">queue</span>;</span><br><span class="line">    InitLinkedQueue(&amp;<span class="built_in">queue</span>);            <span class="comment">// 初始化队列</span></span><br><span class="line">    EnQueue(&amp;<span class="built_in">queue</span>, G-&gt;vexes[index]);   <span class="comment">// 当前顶点入队，对应上图中第一步的 v0 入队</span></span><br><span class="line">    <span class="keyword">while</span> (!isEmptyQueue(&amp;<span class="built_in">queue</span>)) &#123;    <span class="comment">// 取出队头元素，遍历队头顶点的所有邻接点</span></span><br><span class="line"></span><br><span class="line">        Vertex vex;</span><br><span class="line">        DeQueue(&amp;<span class="built_in">queue</span>, &amp;vex);     <span class="comment">// 取出的队头顶点</span></span><br><span class="line">        <span class="comment">// 获取该顶点的所有邻接点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = FirstAdjVex_AMG(G, vex); i; i = SecondAdjVex_AMG(G, vex, G-&gt;vexes[i])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %s &quot;</span>, G-&gt;vexes[i]);    <span class="comment">// 遇到顶点的邻接点先访问</span></span><br><span class="line">                visited[i] = VISITED;</span><br><span class="line">                EnQueue(&amp;<span class="built_in">queue</span>, G-&gt;vexes[i]);     <span class="comment">// 再入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstAdjVex_AMG</span><span class="params">(MatrixGraph* G, Vertex v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> defaultWeight = G-&gt;kind &lt;= <span class="number">1</span> ? <span class="number">0</span> : INT_MAX; <span class="comment">// 图/网 的默认权重</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> vex_index = LocateVex(G, v); <span class="comment">// 获取顶点下标</span></span><br><span class="line">    <span class="keyword">if</span> (vex_index == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索图的邻接矩阵中域顶点v的第一个邻接点下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G-&gt;v_count; j++)</span><br><span class="line">        <span class="keyword">if</span> (G-&gt;matrix[vex_index][j] != defaultWeight)</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SecondAdjVex_AMG</span><span class="params">(MatrixGraph* G, Vertex v1, Vertex v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> defaultWeight = G-&gt;kind &lt;= <span class="number">1</span> ? <span class="number">0</span> : INT_MAX; <span class="comment">// 图/网 的默认权重</span></span><br><span class="line">    <span class="keyword">int</span> index1 = LocateVex(G, v1);</span><br><span class="line">    <span class="keyword">int</span> index2 = LocateVex(G, v2);</span><br><span class="line">    <span class="keyword">if</span> (index1 == <span class="number">-1</span> || index2 == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index2 + <span class="number">1</span>; i &lt; G-&gt;v_count; i++)</span><br><span class="line">        <span class="keyword">if</span> (G-&gt;matrix[index1][i] != defaultWeight)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** BFS end */</span></span><br></pre></td></tr></table></figure><h4 id="邻接表的-BFS"><a href="#邻接表的-BFS" class="headerlink" title="邻接表的 BFS"></a>邻接表的 BFS</h4><p>按理来说邻接矩阵的 BFS 和邻接表的 BFS 应该是一样的，至少在无向图中是一样的。<br>但是如果邻接表是用的头插法，那可能结果是不一样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse_ALG</span><span class="params">(AdjListGraph* G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;v_count; i++)    <span class="comment">// 初始化状态数组</span></span><br><span class="line">        visited[i] = UNVISITED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;v_count; i++)    <span class="comment">// 遍历顶点数组，逐一对每一个未访问的顶点执行 BFS</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[i])</span><br><span class="line">            BFS_ALG(G, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_ALG</span><span class="params">(AdjListGraph* G, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %s &quot;</span>, G-&gt;vexes[index].data);    <span class="comment">// 访问顶点</span></span><br><span class="line">    visited[index] = VISITED;                  <span class="comment">// 更改顶点状态</span></span><br><span class="line"></span><br><span class="line">    LinkQueue <span class="built_in">queue</span>;</span><br><span class="line">    InitLinkedQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    EnQueue(&amp;<span class="built_in">queue</span>, G-&gt;vexes[index].data);     <span class="comment">// 当前顶点入队</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmptyQueue(&amp;<span class="built_in">queue</span>)) &#123;    <span class="comment">// 取出队头元素，遍历队头顶点的所有邻接点</span></span><br><span class="line">        Vertex vex;</span><br><span class="line">        DeQueue(&amp;<span class="built_in">queue</span>, &amp;vex);    <span class="comment">// 取出队头元素</span></span><br><span class="line">        <span class="comment">// 遍历所有邻接点</span></span><br><span class="line">        EdgeNode* node = G-&gt;vexes[LocateVex_ADJ(G, vex)].firstEdge;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[node-&gt;adjvex]) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %s &quot;</span>, G-&gt;vexes[node-&gt;adjvex].data);    <span class="comment">// 邻接点先访问</span></span><br><span class="line">                visited[node-&gt;adjvex] = VISITED;</span><br><span class="line">                EnQueue(&amp;<span class="built_in">queue</span>, G-&gt;vexes[node-&gt;adjvex].data);    <span class="comment">// 再入队</span></span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;nextEdge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>在遍历图时，每个顶点最多进一次队列，遍历图的过程实质上是通过边或弧找邻接点的过程。<br>因此，广度优先搜索、深度优先搜索，在遍历图时的时间复杂度是相同的。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li><p>存储结构：</p><ul><li><strong>邻接矩阵</strong>：一维数组存储顶点集+二维数组存储边/弧</li><li><strong>邻接表</strong>：一维数组存储顶点集+单链表存储边/弧<ul><li><strong>出边表</strong>：链表的结点存储的是弧头的下标</li><li><strong>入边表</strong>：链表的结点存储的是弧尾的下标</li></ul></li><li><strong>十字链表</strong>：将出边表和入边表整合起来，主要针对有向图</li><li><strong>邻接多重表</strong>：将所有边链的结点整合起来，去除重复的结点，主要针对无向图</li><li><strong>边集数组</strong>：一维数组存储顶点集+一维数组存储边集，关注的是边</li></ul></li><li><p>图的遍历：</p><ul><li><strong>深度优先搜索 DFS</strong> 和 <strong>广度优先搜索 BFS</strong> 是图的最基本的遍历方式。</li><li>DFS 是仿树的前序遍历，利用栈做辅助，具体实现是不断将当前顶点的第一个未访问邻接点拿去递归。</li><li>BFS 是仿树的层序遍历，利用队列做辅助，具体实现是每当出队一个元素时，就访问其所有未访问且未入队的邻接点，并将这些邻接点入队。</li><li>使用邻接矩阵存储和使用邻接表存储的图在做 DFS 或 BFS 时没什么区别，只不过邻接矩阵是操作二维数组，邻接表是操作链表。</li></ul></li></ol><hr><p>[^1]: 对称矩阵：n 阶矩阵的元满足 $a_{ij} = a_{ji}, (0 \leq i, j \leq n)$，即从矩阵左上角到右下角的主对角线为轴，右上角的元与左下角相对应的元完全相等。</p>]]></content>
      
      
      <categories>
          
          <category> DataStruction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> DataStruction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStruction 0x07 图-1</title>
      <link href="posts/55674.html"/>
      <url>posts/55674.html</url>
      
        <content type="html"><![CDATA[<p>什么是图？</p><span id="more"></span><h1 id="7-图"><a href="#7-图" class="headerlink" title="7-图"></a>7-图</h1><p>图 是有顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：<strong>G（ V, E ）</strong><br>其中 G 表示一个图，V 是顶点集合，E 是边的集合。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201218174755925_13428.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201218174755925_13428.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>线性表的数据元素 -&gt; 元素 Element<br>树中的数据元素 -&gt; 结点 Node<br>图中的数据元素 -&gt; <span class='p blue'>顶点 Vertex</span>[^0]</p><p>线性表没有数据元素 -&gt; 空表<br>树中没有数据元素 -&gt; 空树<br>图中没有数据元素 -&gt; <emp>不行！</emp></p><p>线性表中，相邻的元素之间具有线性关系<br>树中，相邻的两层之间具有层次关系<br>图中，任意两个顶点之间都可能有关系。顶点之间的逻辑关系用边来表示。边集可以为空。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="无向边"><a href="#无向边" class="headerlink" title="无向边"></a>无向边</h3><p>若顶点 vi 到 vj 之间的边没有方向，则称这条边为<span class='p blue'>无向边（Edge）</span>[^1]，用<strong>无序偶对（vi, vj）</strong> 来表示。<br>如果图中任意两个顶点之间的边都是无向边，则称该图为<span class='p blue'>无向图（Undirected graphs）</span>[^2]。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220094008757_30834.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220094008757_30834.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>上图就是一个无向图，K 到 T 之间的边可以表示成无序对（K, T）或者（T, K）。<br>而整个图可以描述成为: <span class='p green'>G1 = (V1，{E1})</span>，<br>其中顶点集合 <code>V1=&#123;G, Z, K, T, C&#125;</code>；<br>边集合 <code>E1 = &#123; (G, Z), (G, K), (Z, K), (Z, T), (K, T), (K, C), (T, C) &#125;</code>；</p><h3 id="有向边"><a href="#有向边" class="headerlink" title="有向边"></a>有向边</h3><p>若顶点 vi 到 vj 之间的边有方向，则称这条边为<span class='p blue'>弧（Arc）</span>[^3]。<br>用<strong>无序偶对 &lt;vi, vj&gt;</strong> 来表示： $v_i \to v_j$，</p><p>vi 称为弧尾（Tail），即指出去的那个；<br>vj 称为弧头（Head），即被指的那个。</p><p>如果图中任意两个顶点之间的边都是有向边，则称该图为<span class='p blue'>有向图（Directed graphs）</span>[^4]。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220094650808_9267.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220094650808_9267.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>上图就是一个有向图，连接 G 到 K 的边就是弧，K 是弧头，被指向的那个，G 是弧尾，指出去的那个。<br>&lt;G, k&gt; 表示弧，不能写为 &lt;K, G&gt;。<br>而整个图可以描述成为 <span class='p green'>G2 = (V2，{E2})</span>，<br>其中顶点集合 <code>V2 = &#123;G, Z, K, T, C&#125;</code>；<br>弧集合 <code>E2 = &#123; &lt;G, K&gt;, &lt;Z, G&gt;, &lt;Z, K&gt;, &lt;K, T&gt;, &lt;T, Z&gt;, &lt;T, C&gt;, &lt;C, K&gt; &#125;</code>；</p><div class="note warning"><p>注意：无向边用 () 表示， 有向边用 &lt; &gt; 表示。</p></div><h3 id="简单图"><a href="#简单图" class="headerlink" title="简单图"></a>简单图</h3><p>在图中若不存在<span class='p red'>顶点到其自身的边</span>，且同一条边不重复出现，则称这样的图为<span class='p blue'>简单图</span>[^5]。<br>在无向图中，如果任意两个顶点之间都存在边，则称该图为<span class='p blue'>无向完全图（Undirected Completed graph）</span>[^6]<br>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为<span class='p blue'>有向完全图（Directed graph）</span>。[^7]<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220104816617_23813.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220104816617_23813.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>含有 n 个顶点的无向完全图有 $\frac {n(n-1)} 2$ 条边，如上图的无向完全图有4个顶点，边数为 $4 \times 3 \div 2 = 6$</p><p>含有 n 个顶点的有向完全图有 $n \times (n-1)$ 条边，如上图的有向完全图有4个顶点，边数为 $4 \times 3 = 12$</p><div class="note quote blue"><p>推广一下：</p><p>在非完全的图中，设图具有 n 个顶点和 e 条边，</p><p>若该图为无向图则 $0 \leq e \leq \frac {n(n-1)} 2$</p><p>若该图为有向图则 $0 \leq e \leq n(n-1)$</p></div><p>有很少条边或弧称为<strong>稀疏图（Sparse greph）</strong>，反之称为<strong>稠密图（Dense greph）</strong>。稀疏和稠密的相对的概念，没有严格定义。</p><h3 id="权、网"><a href="#权、网" class="headerlink" title="权、网"></a>权、网</h3><p>图的边或弧有相关的数值，这个数叫做<span class='p blue'>权（Weight）</span>[^8]，可以表示一个顶点到另一个顶点的距离或耗费等等。<br>这种带全的图通常称为<span class='p blue'>网（Network）</span>[^9]。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220111713099_20823.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220111713099_20823.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p>假设两个图 $G = (V, {E})$ 和 $G’ = (V’, {E’})$，如果 $V’ \subseteq V$ 且 $E’ \subseteq E$，则称 G’ 为 G 的<span class='p blue'>子图（Subgraph）</span>[^10]。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220112758881_17487.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220112758881_17487.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h2 id="图的顶点和边间的关系"><a href="#图的顶点和边间的关系" class="headerlink" title="图的顶点和边间的关系"></a>图的顶点和边间的关系</h2><h3 id="度"><a href="#度" class="headerlink" title="度"></a>度</h3><h4 id="无向图的度"><a href="#无向图的度" class="headerlink" title="无向图的度"></a>无向图的度</h4><p>对于无向图 <strong>G = (V, {E})</strong></p><ul><li>如果边 $(v, v’) \in E$，则称顶点 v 和 v’ 互为 <strong>邻接点（Adjacent）</strong>，即 v 和 v’ 相邻接。</li><li>边 (v, v’)  <strong>依附（Incident）</strong> 于顶点 v 和 v’，即边（v, v’）与顶点 v 和 v’ 相关联。</li><li>顶点 v 的<span class='p blue'>度（Degree）</span>[^11] 是和 v 相关的边的数量，记为 <strong>TD（v）</strong>。</li></ul><p>eg: <img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220113706946_13545.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220113706946_13545.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>例如这个图，顶点 G 和 K 互为邻接点，边 （G, K）依附于 G 和 K 上，K顶点的度为 3。</p><p>图的边数为 5，各个顶点的度的和 = 3+3+2+2 = 10，其中重复两次计数，所以<strong>边数应为个顶点度数之和的一半</strong>。</p><p>记作 </p><p>$$e= \frac 1 2 \sum_{i=1}^n TD(v_i)$$</p><h4 id="有向图的度"><a href="#有向图的度" class="headerlink" title="有向图的度"></a>有向图的度</h4><p>对于有向图 <strong>G = (V, {E})</strong></p><ul><li>如果弧 $\langle v, v’ \rangle \in E$，则称：顶点 v 邻接到 v’，顶点 v’ 邻接自 v。顶点 v 和 v’ 互为<strong>邻接点（Adjacent）</strong>。</li><li>弧 &lt;v, v’&gt; <strong>依附（incident）</strong> 于顶点 v 和 v’，即弧 &lt;v, v’&gt; 与 顶点 v 和 v’ 相关联。</li><li>以顶点 v 为头的弧的数量称为 v 的<span class='p blue'>入度（InDegree）</span>[^12]，记为 <strong>ID（v）</strong>;</li><li>以顶点 v 为尾的弧的数量称为 v 的<span class='p blue'>出度（OutDegree）</span>[^13]，记为 <strong>OD（v）</strong>;</li><li>顶点 v 的<strong>度（Degree）</strong> 为 <strong>TD（v） = ID（v） + OD（v）</strong>。</li></ul><p>eg: <img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220134157213_390.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220134157213_390.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>例如这个图，顶点 G 和 K 互为邻接点，顶点 G 邻接到 K，K 邻接自 G。</p><p>边 （G, K）依附于 G 和 K 上，顶点 K 的入度为 2，$ID(K) = 2$，出度为 1，$OD(K) = 1$，度为 $TD(K) = ID(K) + OD(K) = 3$</p><p>图的弧数为 5，各个顶点的入度和 = 1+2+2+0 = 5，出度和 = 1+1+0+3 = 5；</p><p>由此可得有向图的弧数: </p><p>$$e= \sum_{i=1}^n ID(V_i) = \sum_{i=1}^n OD(v_i)$$</p><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>无向图**G = (V, {E})**中从顶点 v 到顶点 v’ 的<span class='p blue'>路径（Path）</span>[^14]是一个顶点序列 $(v = v_{i,0}, v_{i,1}, …, v_{i,m} = v’)$，其中 $(v_{i,j-1}, v_{i,j}) \in E, 1\leq j \leq m$。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220141655092_23529.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220141655092_23529.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="G到T的四种路径"><br>G 到 T 有四种路径。</p><p>如果 G 是有向图，则路径也是有向的，顶点序列应满足 $\langle v_{i,j-1}, v_{i,j}\rangle \in E, 1 \leq j \leq m$。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220142137334_4928.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220142137334_4928.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="G到T只有一种路径"></p><p>上图种 G 到 T 只有一种路径，其他路径都不行。因为 G 到 Z 不存在路径。</p><span class='p blue'>路径的长度</span>[^15]是路径上的边或弧的数量。例如上图的有向图，G到T的路径长度为2。<p>第一个顶点到最后一个顶点相同的路径称为<span class='p blue'>回路（circuit）或环（Cycle）</span>[^16]。</p><p>序列种顶点不重复出现的路径为<span class='p blue'>简单路径</span>[^17]。</p><p>除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为<strong>简单回路（Simple circuit）</strong>或<strong>简单环（Simple Cycle）</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220142923502_21890.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220142923502_21890.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>左边图路径为 {B, C, D, A, B}，第一个顶点和最后一个顶点都是 B，且 C、D、A没有重复出现，所以是一个简单环<br>右边图路径为 {B, C, D, A, C, B}，由于 C 重复，所以不是简单环。</p><h2 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h2><h3 id="无向连通图"><a href="#无向连通图" class="headerlink" title="无向连通图"></a>无向连通图</h3><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220150322079_7679-2.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220150322079_7679-2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>无向图中：<br>任意两个顶点之间都有<strong>直接或间接</strong>的路径，即都能到达，则称这个图为<span class='p blue'>连通图（Connected Graph）</span>[^18]。<br>例如 图1 就是非连通图，应为顶点 5 和 6 没有路径到顶点 1、2、3、4，而图2、3、4 就是连通图。</p><p>无向图中的<strong>极大连通子图（Great Connected Subgraph）</strong>称为<span class='p blue'>连通分量（Connected Component）</span>[^19]，它强调：</p><ul><li>必须是子图（<strong>子图</strong>）</li><li>子图是连通的（<strong>连通</strong>）</li><li>连通子图含有极大顶点数（<strong>有极大顶点数</strong>）</li><li>具有极大顶点数的连通子图包含依附于这些顶点的所有边。（<strong>含有边</strong>）</li></ul><p>例如 图1就是一个无向非连通图，但是它有两个连通分量 图2 和 图3，而 图4 虽然是 图1 的子图，但是不满足连通子图的极大顶点数（图2 满足），所以不是连通分量。</p><h3 id="有向连通图"><a href="#有向连通图" class="headerlink" title="有向连通图"></a>有向连通图</h3><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220152619974_29235.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201220152619974_29235.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>有向图中：<br>任意两个顶点都有直接路径或间接路径，则称这个图为<span class='p blue'>强连通图（Strong Connected Graph）</span>[^20]。<br>有向图中的<strong>极大强连通子图（Great Strong Connected Subgraph）</strong>称作有向图的<span class='p blue'>强连通分量（Strong Connected Component）</span>[^21]。</p><p>例如 图1 就不是一个强连通图，因为 1 到 4 有路径，而 4 到 1 没路径。而 图2 就是 图1 的极大强连通子图，即它的强连通分量。</p><h3 id="生成树、生成森林"><a href="#生成树、生成森林" class="headerlink" title="生成树、生成森林"></a>生成树、生成森林</h3><h4 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h4><blockquote><p>对连通图进行遍历，过程中所经过的边和顶点的组合可看做是一棵普通树，通常称为<span class='p blue'>生成树（Spanning Tree）</span>[^22]。 </p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201221061510102_9801.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201221061510102_9801.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="连通图及其对应的生成树"></p><p>左边是一张连通图，右边则是其对应的两种生成树。<br>连通图中，任意两顶点之间可能还有多条路径，遍历连通图的方式有多种，往往一张连通图可能有多种不同的生成树与之对应。</p><div class="note quote blue"><p>连通图中的生成树必须满足以下2个条件：</p><ol><li>包含连通图中所有的顶点；</li><li>任意两顶点之间有且仅有一条通路；</li></ol><p>因此，连通图的生成树具有这样的特征：生成树中 <code>边的数量 = 顶点数 - 1</code>。</p><p>$$<br>\begin{cases}<br>非连通图, &amp;  顶点个数 = n;边数 \lt n-1 \\<br>生成树,   &amp;  顶点个数 = n;边数 = n-1 \\<br>一定有环, &amp;  顶点个数 = n;边数 \gt n-1 \\<br>\end{cases}<br>$$</p></div><h4 id="生成森林"><a href="#生成森林" class="headerlink" title="生成森林"></a>生成森林</h4><div class="note quote blue"><p>生成树的对于连通图来说的，而生成森林则是对应非连通图来说的。<br>非连通图可以分解为多个连通分量，而每个连通分量又各自对应多棵生成树，因此与整个非连通图相对应的，是由多棵生成树组成的<span class='p blue'>生成森林（Spanning Forest）</span>[^23]。</p></div><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201221062312094_8712.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201221062312094_8712.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="非连通图和连通分量"></p><p>上图左边是一张非连通图，可以分解为右边三个连通分量，其中各个连通分量对应的生成树如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201221062901311_2544.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201221062901311_2544.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="生成森林"><br>上图只是列出各个连通分量的其中一种生成树。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>图由顶点和边组成，<span class='p green'>无向图由 顶点 和 边 构成</span>；<span class='p red'>有向图由 顶点 和 弧 构成，弧分 弧头弧尾</span>。</li><li>任两个顶点之间都存在边叫<strong>完全图</strong>，分<strong>有向完全图</strong>和<strong>无向完全图</strong>。同一条边不重复出现的图叫<strong>简单图</strong>。</li><li>顶点之间有<strong>邻接点</strong>、<strong>依附</strong>的概念，<span class='p green'>无向图的顶点的边数叫 度</span>，<span class='p red'>有向图的顶点分 出度 和 入度 ，度 = 出+入</span>。</li><li>从图的顶点集和边集中取一小部分组成新的图，称为原图的<strong>子图</strong>。</li><li>带数值的边叫<strong>权</strong>，顶点和权构成<strong>网</strong></li><li>图中顶点间存在<strong>路径</strong>，两顶点存在路径则说明是<strong>连通</strong>的，如果路径最终回到起始点则称为<strong>环</strong>，当中顶点没有重复过称为<strong>简单路径</strong>。若任意两顶点都是连通的，则图是<strong>连通图</strong>，有向则是<strong>强连通图</strong>。图中有子图，若子图极大连通则称<strong>连通分量</strong>，有向则称<strong>强连通分量</strong>。</li><li>无向图中连通且<code>边数 = 顶点数 - 1</code> 的树叫<strong>生成树</strong>，无向非连通图的连通分量生成的生成树一起构成<strong>生成森林</strong>。</li><li>有向图中一个顶点入度为 0，其他顶点的入度为1的叫<strong>有向树</strong>。一个有向图由若干棵有向树构成生成森林。</li></ul><p>[^0]: 顶点 -&gt; 图的数据元素</p><p>[^1]: 无向边 -&gt; 边没有方向</p><p>[^2]: 无向图 -&gt; 边没有方向的图，n个顶点的无向图最多有 $\frac {n(n-1)} 2$ 条边</p><p>[^3]: 弧 -&gt; 边有方向；弧有弧头弧尾之分</p><p>[^4]: 有向图 -&gt; 边有方向的图，n个顶点的有向图最多有 $n(n-1)$ 条边</p><p>[^5]: 简单图 -&gt; 同一条边不重复出现的图</p><p>[^6]: 无向完全图 -&gt; 任意两个顶点之间都有边，共有 $\frac {n(n-1)} 2$ 条边</p><p>[^7]: 有向完全图 -&gt; 任意两个顶点之间都有弧，共有 $n(n-1)$ 条弧</p><p>[^8]: 权 -&gt; 有数值的边</p><p>[^9]: 网 -&gt; 顶点+权</p><p>[^10]: 子图 -&gt; 从原图中拆出来的图</p><p>[^11]: 度 -&gt;顶点的边数</p><p>[^12]: 入度 -&gt; 邻接到顶点的边的数量</p><p>[^13]: 出度 -&gt; 顶点邻接出去的边的数量</p><p>[^14]: 路径 -&gt; 两个顶点之间的直接线路或间接线路的边集序列，注意是序列，所以可能不止一条</p><p>[^15]: 路径长度 -&gt; 两个顶点之间的线路的边数</p><p>[^16]: 回路或环 -&gt; 从起始点离开最后到达起始点的路径</p><p>[^17]: 简单路径 -&gt; 回路上没有重复的点的路径</p><p>[^18]: 连通图 -&gt; 任意两顶点都是连通的无向图</p><p>[^19]: 连通分量 -&gt; 无向图的极大连通的子图</p><p>[^20]: 强连通图 -&gt; 任意两顶点都是连通的有向图</p><p>[^21]: 强连通分量 -&gt; 有向图的极大连通的子图</p><p>[^22]: 生成树 -&gt; 无向连通图生成的 边的数量 = 顶点数 -1 的树</p><p>[^23]: 生成森林 -&gt; 无向非连通图的连通分量生成的生成树一起构成生成森林 </p>]]></content>
      
      
      <categories>
          
          <category> DataStruction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> DataStruction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStruction 0x06 树</title>
      <link href="posts/48872.html"/>
      <url>posts/48872.html</url>
      
        <content type="html"><![CDATA[<p>什么是树？</p><span id="more"></span><h1 id="6-树"><a href="#6-树" class="headerlink" title="6-树"></a>6-树</h1><p>前面的线性表、广义表、栈、队、串，都是一对一的数据结构。<br>现在开始我们要讨论一种一对多的数据结构: <span class='p blue'>树</span>。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>树是 n 个结点的有限集。</p></blockquote><p>n=0 时称为 <span class='p blue'>空树</span>。<br>n&gt;1 时，有且仅有一个特定的根节点 root，其余结点可分为 m（m&gt;0）个互不相交的有限集 $T_1、T_2、…、T_m$，其中每个集合本身又是一棵树，称为 <span class='p blue'>子树</span>。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201215140616085_25463.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201215140616085_25463.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="树"></p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><table><thead><tr><th align="left">名词</th><th align="left">解释</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><strong>结点</strong></td><td align="left">树中的一个独立单元。包含一个数据元素及若干指向其他子树的分支。</td><td align="left">eg：图中每一个圆圈都是结点。</td></tr><tr><td align="left"><strong>结点的度</strong></td><td align="left">结点拥有的子树的数量。</td><td align="left">eg：A的度为3，B的度为2，C的度为1。</td></tr><tr><td align="left"><strong>树的度</strong></td><td align="left">树内各结点的度的最大值。</td><td align="left">eg：上面的树的度为3。</td></tr><tr><td align="left"><strong>树的高度（深度）</strong></td><td align="left">树中的最大层数。</td><td align="left">eg：图中树的深度（高度）为 4。</td></tr><tr><td align="left"><strong>叶子结点</strong></td><td align="left">度为0的结点，也称终端结点。</td><td align="left">eg：K、L、F、G、M、I、J 都是叶子结点。</td></tr><tr><td align="left"><strong>分支结点</strong></td><td align="left">度不为0的结点，也称非终端结点。</td><td align="left">eg： A、B、C、D、E、H 都是非终端结点。</td></tr><tr><td align="left"><strong>双亲结点</strong></td><td align="left">一个结点的直接前驱结点称为其双亲结点。</td><td align="left">eg：E的双亲为B，G的双亲为C。</td></tr><tr><td align="left"><strong>孩子结点</strong></td><td align="left">一个结点的所有直接后继结点称为其孩子结点。</td><td align="left">eg：B的子结点为E、F，H的子结点为M。</td></tr><tr><td align="left"><strong>兄弟结点</strong></td><td align="left">同一个双亲的子结点之间互称兄弟结点。</td><td align="left">eg：H的兄弟结点为I、J。</td></tr><tr><td align="left"><strong>祖先</strong></td><td align="left">从一个结点到根节点所经分支上的所有结点。</td><td align="left">eg：K的祖先为E、B、A。</td></tr><tr><td align="left"><strong>子孙</strong></td><td align="left">一个结点所有直接和间接后继结点。</td><td align="left">eg：D的子孙为H、I、J、M。</td></tr><tr><td align="left"><strong>堂兄弟</strong></td><td align="left">双亲在同一层的结点互为堂兄弟。</td><td align="left">eg：G与E、F、H、I、J 互为堂兄弟。</td></tr><tr><td align="left"><strong>层</strong></td><td align="left">根为第一层，根的孩子为第二层，以此类推</td><td align="left">eg：A为1层，B、C、D为2层，K、L、M为3层。</td></tr></tbody></table><span class='p blue'>有序树、无序树</span>：树中的结点从左至右依次有序不能互换，称为有序，否则称为无序。有序树中最左边的子树称为根节点的第一个孩子，最右边称为根节点的最后一个孩子。<span class='p blue'>森林</span>：m棵不相交的树的集合。<h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ADT Tree</span><br><span class="line">Data</span><br><span class="line">    树是由一个根结点和若干子树构成。树中结点具有相同数据类型及层次关系。</span><br><span class="line">Operation</span><br><span class="line">    InitTree(<span class="built_in">T</span>*): 构造空树<span class="built_in">T</span></span><br><span class="line">    DestoryTree(<span class="built_in">T</span>*): 销毁树<span class="built_in">T</span></span><br><span class="line">    CreateTree(<span class="built_in">T</span>*, definition): 按definition中给出的树的定义来构造树</span><br><span class="line">    ClearTree(<span class="built_in">T</span>*): 若树<span class="built_in">T</span>存在，则将树<span class="built_in">T</span>清空为空树</span><br><span class="line">    TreeEmpty(<span class="built_in">T</span>): 若<span class="built_in">T</span>为控诉，返回true，否则返回false</span><br><span class="line">    TreeDepth(<span class="built_in">T</span>): 返回树<span class="built_in">T</span>的深度</span><br><span class="line">    Root(<span class="built_in">T</span>): 返回<span class="built_in">T</span>的根节点</span><br><span class="line">    Value(<span class="built_in">T</span>, cur_e): cur_e 是树<span class="built_in">T</span>中一个结点，返回此结点的值</span><br><span class="line">    Assign(<span class="built_in">T</span>, cur_e, value): 给树<span class="built_in">T</span>的结点cur_e赋值为 value</span><br><span class="line">    Parent(<span class="built_in">T</span>, cur_e): 若 cur_e 是树<span class="built_in">T</span>的非根结点，则返回它的双亲，否则返回空</span><br><span class="line">    LeftChild(<span class="built_in">T</span>, cur_e): 若 cur_e 是树<span class="built_in">T</span>的非叶结点，则返回它的最左孩子，否则返回空</span><br><span class="line">    RightSibling(<span class="built_in">T</span>, cur_e): 若 cur_e 有右兄弟，则返回它的右兄弟，否则返回空</span><br><span class="line">    InsertChild(<span class="built_in">T</span>*, p*, i, <span class="built_in">c</span>): 其中p指向树<span class="built_in">T</span>的某个结点，i为所指结点p的度+<span class="number">1</span>，非空树<span class="built_in">c</span>与<span class="built_in">T</span>不相交，操作结果为插入<span class="built_in">c</span>为树<span class="built_in">T</span>中p指结点的第i棵子树</span><br><span class="line">    DeleteChild(<span class="built_in">T</span>*, p*, i): 其中p指向树<span class="built_in">T</span>的某个结点，i为所指结点p的度，操作结果为删除<span class="built_in">T</span>中p所指结点的第i棵子树</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p>除了根节点，其他结点一定有双亲结点</p><p>双亲表示法有两种：</p><ol><li>只能简单的记录结点关系的一维数组</li><li>带数据域和指示域的多维数组</li></ol><p>我们利用<strong>一维数组</strong>，下标表示树中的结点，数组元素的内容表示该结点的双亲结点。<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201215175910605_32586.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201215175910605_32586.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="简单双亲表示法"></p><p>用<strong>结构数组</strong>，每个结点附设一个指示器指示其双亲结点在表中的位置。<br>上图的树用多维数组表示为：</p><table><thead><tr><th>下标</th><th>数据</th><th>双亲</th></tr></thead><tbody><tr><td>0</td><td>A</td><td>-1</td></tr><tr><td>1</td><td>B</td><td>0</td></tr><tr><td>2</td><td>C</td><td>0</td></tr><tr><td>3</td><td>D</td><td>1</td></tr><tr><td>4</td><td>E</td><td>1</td></tr><tr><td>5</td><td>F</td><td>2</td></tr><tr><td>6</td><td>G</td><td>2</td></tr><tr><td>7</td><td>H</td><td>3</td></tr></tbody></table><p>用代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> Element;    <span class="comment">// 数据元素类型，暂定为字符型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Element data;    <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">int</span> parent;      <span class="comment">// 双亲位置</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];    <span class="comment">// 结点数组</span></span><br><span class="line">    <span class="keyword">int</span> root, node_count;    <span class="comment">// 根的位置和结点数</span></span><br><span class="line">&#125; PTree;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">insert</span><span class="params">(PTree* pt, Element e, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    pt-&gt;nodes[pt-&gt;node_count].data = e;</span><br><span class="line">    pt-&gt;nodes[pt-&gt;node_count].parent = p;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">-1</span>) pt-&gt;root = pt-&gt;node_count;</span><br><span class="line">    pt-&gt;node_count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种结构的话很容易找到一个结点的双亲结点，如果parent为-1即表示此结点为根节点。<br>但是如果要找结点的孩子，只能遍历整个数组。</p><h3 id="链式结构"><a href="#链式结构" class="headerlink" title="链式结构"></a>链式结构</h3><h2 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树 Binary Tree"></a>二叉树 Binary Tree</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><span class='p blue'>二叉树</span> 是 n（n >= 0）个结点的有限集合，该集合或者为空集，或者有一个根结点和两棵不相交的分别称为根结点的左子树和右子树的二叉树组成。<p>一棵树的度为 n 时，又称 <span class='p blue'>n 叉树</span>。所以二叉树的度为2，即每个结点最多有2个子结点。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216081239101_25443.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216081239101_25443.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="二叉树"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>每个结点<strong>最多</strong>有两棵子树，所以二叉树中不存在度 &gt; 2 的结点。</li><li>左子树和右子树是有顺序的，次序不能任意颠倒。就像左手是左手，右手是右手，不能互换。</li><li>即使树中某结点只有一棵子树，也要区分是左子树还是右子树。就像摔伤了左手还是右手，对你生活的影响程度是不一样的。</li></ol><p>二叉树有5种基本形态：</p><ol><li>空二叉树</li><li>只有根节点</li><li>根节点+左子树</li><li>根节点+右子树</li><li>根节点+左子树+右子树</li></ol><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216082358074_31113.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216082358074_31113.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="5种状态"></p><h3 id="斜树"><a href="#斜树" class="headerlink" title="斜树"></a>斜树</h3><p>所有结点都只有左子树的二叉树叫<span class='p blue'>左斜树</span><br>所有结点都只有右子树的二叉树叫<span class='p blue'>右斜树</span></p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216082826369_2489.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216082826369_2489.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>斜树有很明显的特点，每一层都只有一个结点，结点的个数与二叉树的深度相同。</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216083439113_16887.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216083439113_16887.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="满二叉树"></p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216084807345_31935.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216084807345_31935.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="满二叉树"></p><p>在一棵二叉树中，所有分支节点都有左子树和右子树，且所有叶结点都在同一层，则称为 <span class='p blue'>满二叉树</span>。</p><p>注意单是每个结点都存在左右子树还不够，那样只算完全二叉树，还需要叶子节点都在同一层。<br>满二叉树的特点有：</p><ol><li>叶结点只能出现在最下层，其他层出现就不可能达成平衡</li><li>分支结点的度必须 = 2，否则就是缺胳膊少腿了。</li><li>在同样深度的二叉树中，满二叉树的结点树最多，叶子最多。</li></ol><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>对一棵具有 n 个结点的二叉树按层序编号，如果<code>编号为 i（1 &lt;= i &lt;= n）的结点</code>与<code>同样深度的满二叉树中编号为i的结点</code>在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216084851875_2060.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216084851875_2060.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>一棵满二叉树一定是完全二叉树，一棵完全二叉树不一定是满二叉树。</p><p>注意完全二叉树是<strong>按层序编号</strong></p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216091502929_18400.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216091502929_18400.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>第 2 棵树虽然有些结点没有连续，但是因为每个结点都是按层序编号，和满二叉树能对应，所以<strong>是</strong>完全二叉树</p><p>第 3 棵树由于叶结点出现在最后一层（编号 8、9、10）和倒数第三层（编号 3），叶子结点层数差超过 1，所以<strong>不是</strong>完全二叉树</p><p>第 4 棵树应为 12 的结点编号为 11，所以<strong>不是</strong>完全二叉树。</p><p>完全二叉树的特点：</p><ol><li>叶子结点只能出现在最下面两层。</li><li>最下层的叶子一定集中在左部连续位置。</li><li>倒数两层，若有叶子结点，一定都在右部连续位置</li><li>如果结点度为 1，则该结点只有左孩子，不能只有右孩子。</li><li>同样结点数的二叉树，完全二叉树的深度最小。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216091948123_5948.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216091948123_5948.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>上图这两颗就是正确的完全二叉树。<br>左边为满二叉树，右边为完全二叉树。</p><p>看右边那棵，叶结点只在最下两层（7、8、9、10、11、12），度为1时只有左孩子（6 -&gt; 12）</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216091948123_5948.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216091948123_5948.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><div class="note radiation"><div class="note guide blue"><p>性质1：在二叉树的第 i 层上最多有 $2^{i-1}$ 个结点。</p></div><details yellow><summary>  </summary>              <div class='content'>              <p>第一层是根结点，只有1个结点，$2^{1-1} = 2^0 = 1$</p><p>第二层最多有2个结点，$2^{2-1} = 2^1 = 2$</p><p>第三层最多有4个结点，$2^{3-1} = 2^2 = 4$</p><p>第四层最多有8个结点，$2^{4-1} = 2^3 = 8$</p><p>通过归纳法，可以得出：二叉树的第i层最多有 $2^{i-1}$ 个结点。</p><div class="note green"><p>推广一下：一棵树的度为 n 时，又称<strong>n 叉树</strong>。</p><p>如果一棵三叉树、四叉树，在第i层上最多有 $3^{i-1}$、$4^{i-1}$ 个结点。</p><p>由此可得：一棵 n 叉树在第i层上最多有 $n^{i-1}$个结点。</p></div>              </div>            </details></div><div class="note radiation"><div class="note guide blue"><p>性质2：深度为 k 的二叉树总结点数最多有 $2^k - 1$个（k &gt;= 1）。</p></div><details yellow><summary>  </summary>              <div class='content'>              <p>如果有一层，最多共1个结点。$2^1 - 1 = 1$</p><p>如果有两层，最多共3个结点。$2^2 - 1 = 3$</p><p>如果有三层，最多共7个结点。$2^3 - 1 = 7$</p><p>如果有四层，最多共15个结点。$2^4 - 1 = 15$</p><p>通过归纳法，可以得出：深度为 k 的二叉树总结点数最多有 $2^k - 1$ 个。</p>              </div>            </details></div><div class="note radiation"><div class="note guide blue"><p>性质3：对任何一棵二叉树 T，如果其叶子结点总数为 $n_0$，度为 2 的结点总数为 $n_2$，则 $n_0 = n_2 + 1$。</p></div><details yellow><summary>  </summary>              <div class='content'>              <p>例如上图右边的完全二叉树，叶子结点为7、8、9、10、11、12共6个，</p><p>所以 $n_0 = 6$；而度为2的结点1、2、3、4、5共5个，$n_2 = 5$。</p><p>所以 $n_0 = n_2 + 1 = 5 + 1 = 6$。</p>              </div>            </details></div><div class="note radiation"><div class="note guide blue"><p>性质4：总结点数为 n 的完全二叉树的深度为 $⌊log_2 n⌋ + 1$。 ⌊x⌋ 表示对 x 向下取整。</p></div>    例如上图左边的满二叉树，总结点数为 15，深度为 $⌊log_2 15⌋ + 1 = 4$。</div><div class="note radiation"><div class="note guide blue"><p>性质5：若对一颗总结点数为 n 的完全二叉树（其深度为 $⌊log_2 n⌋ + 1$）的结点按层序编号，对任一结点 i （1 &lt;= i &lt;= n）有：</p></div><details yellow><summary>  </summary>              <div class='content'>              <ul><li>如果  i = 1，则结点 i 是二叉树的根，无双亲；</li><li>如果  i &gt; 1，则其双亲结点是第 $⌊i/2⌋$ 个；</li><li>如果 2i &gt; n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点 2i；</li><li>如果 2i+1 &gt; n，则结点 i 无右孩子；否则其右孩子是结点 2i+1。</li></ul>              </div>            </details></div><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216185120293_12261.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201216185120293_12261.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>例如这样一棵完全二叉树。总结点数 10；高度 4。</p><ul><li>如果 i = 1，根节点。</li><li>如果 i = 7，双亲就是 $⌊7/2⌋ = ⌊3.5⌋ = 3$；</li><li>如果 i = 6，(2i = 2*6 = 12) &gt; (10 = n)，所以6无左孩子；</li><li>如果 i = 4，(2i + 1 = 9) &gt; 10，所以4的右孩子是9。</li></ul><p>总结一下就是：</p><ul><li>i = 1，为根结点</li><li>i 的双亲是 <span class='p green'>⌊i/2⌋</span></li><li>i 的左孩子是 <span class='p green'>2i</span></li><li>i 的右孩子是 <span class='p green'>2i + 1</span></li></ul><h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p>顺序结构适用性不强，还是用链表结构比较好。</p><p>每个结点包含一个数据域和两个左右孩子指针域，当然也可以包含一个双亲域。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">&#125; Elem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line">    Elem data;            <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>* <span class="title">lchild</span>;</span> <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>* <span class="title">rchild</span>;</span> <span class="comment">// 右孩子</span></span><br><span class="line">&#125; BTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    BTNode* root; <span class="comment">// 根结点</span></span><br><span class="line">    <span class="keyword">int</span> depth;    <span class="comment">// 树的度</span></span><br><span class="line">    <span class="keyword">int</span> count;    <span class="comment">// 总结点数</span></span><br><span class="line">&#125; BTree;</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217115357875_24759.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217115357875_24759.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h4 id="前序遍历法-DLR"><a href="#前序遍历法-DLR" class="headerlink" title="前序遍历法 DLR"></a>前序遍历法 DLR</h4><p>即先打印根结点，再打印左孩子，最后打印右孩子，以此类推</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217120423042_26566.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217120423042_26566.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>上面的打印顺序为：ABDHKECFIGJ</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BTNode T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">    PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">    PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历法-LDR"><a href="#中序遍历法-LDR" class="headerlink" title="中序遍历法 LDR"></a>中序遍历法 LDR</h4><p>即先打印左孩子，再打印根结点，最后打印右孩子，以此类推</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217120428740_15744.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217120428740_15744.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>上面的打印顺序为：HKDBEAIFCGJ</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BTNode T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    InOrderTraverse(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">    InOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历法-LRD"><a href="#后序遍历法-LRD" class="headerlink" title="后序遍历法 LRD"></a>后序遍历法 LRD</h4><p>即先打印左孩子，再打印右孩子，最后打印根结点，以此类推</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217120431843_22415.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217120431843_22415.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>上面的打印顺序为：KHDEBIFJGCA</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BTNode T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">    PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序遍历法"><a href="#层序遍历法" class="headerlink" title="层序遍历法"></a>层序遍历法</h4><p>即按层从左到右依次打印<br>上面打印顺序为：ABCDEFGHIJK</p><p>层序遍历时需要借助一个队列来完成。从根结点开始，当一个结点出队时，将其所有孩子结点入队。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SequenceTraverse</span><span class="params">(BTree T)</span> </span>&#123;</span><br><span class="line">    EnQueue(T-&gt;root);</span><br><span class="line">    BTNode* root = DeQueue()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T-&gt;count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;data);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lchild) EnQueue(root-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rchild) EnQueue(root-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>前序就是根结点在前面<br>中序就是根结点在中间<br>后序就是根结点在后面</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217124341220_25563.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217124341220_25563.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>像这棵比较小的树，<br><strong>前序 DLR</strong>：ABDEC<br><strong>中序 LDR</strong>：DBEAC<br><strong>后序 LRD</strong>：DEBCA<br><strong>层次遍历</strong>：ABCDE</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>如果一棵二叉树的前序遍历序列为 ABCDEF，中序遍历序列为 CBAEDF，请问后序遍历序列为？<br><strong>解题思路：</strong></p><ol><li><p>前序的第一位或后序的最后一位，一定是根节点，所以这题的根结点就是 A。</p></li><li><p>接着看 A 在中序序列的位置，可以看出 CB 是 A 的左孩子，EDF是 A 的右孩子；然后在前序中就可以确定 BC 为一组，DEF 为一组。<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217132726225_29810.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217132726225_29810.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p><strong>二叉树的子树也是二叉树</strong>。根据这个道理，从前序中可以知道 B是左子树的根结点，同理D是右子树的根结点。<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217132708350_15611.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217132708350_15611.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>拿着 B 和 D 到中序序列中分析，分出左右子树，以此类推。</p></li></ol><p>核心就是：<strong>从前序的第一个 或 后序的最后一个确定根结点，然后到中序里区分左右子树。</strong></p><p>所以这道题应该是这样一棵树：</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217133358914_31623.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217133358914_31623.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>后序应该为： CBEFDA</p><h2 id="线索二叉树-Threading-Tree"><a href="#线索二叉树-Threading-Tree" class="headerlink" title="线索二叉树 Threading Tree"></a>线索二叉树 Threading Tree</h2><div class="note radiation blue"><p><strong>线索二叉树 = （前 | 中 | 后）遍历 + 二叉树</strong>。</p></div><p>虽然采用链式结构存储，每个结点存储本身数据和左右孩子的指针，但还是会带来一个问题：<strong>叶子结点没有子树，它们的孩子指针必然为 NULL，叶子越多，NULL 越多，这就导致不管什么树，都必然会浪费一定的空间。</strong></p><p>例下图：<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201218083935575_13596.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201218083935575_13596.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>现在思考如何将那些 <code>^</code> 利用起来。<br>如果一个结点没有孩子，则让孩子指针指向双亲？这样有的指有的不指，很奇怪，且实现起来很不方便。<br>如果结合遍历顺序怎么样？可以。</p><p>因为在没有遍历的情况下，我们不知道一个结点的前驱是谁，后继是谁，不如在创建树时，如果没有子树，就换成记录前驱元素或后继元素。</p><p>这样创建出来的树，就叫 <span class='p blue'>线索二叉树</span>。</p><p>线索二叉树的核心思想为：</p><ul><li><span class='p blue'>如果有左子树，则左指针域指向左子树</span>；<span class='p green'>如果没有左子树，则左指针指向**遍历前驱元素**</span></li><li><span class='p blue'>如果有右子树，则右指针域指向右子树</span>；<span class='p green'>如果没有右子树，则右指针指向**遍历后继元素**</span></li></ul><p>这里的前驱和后继指的是 <span class='p green'>某个结点在</span><span class='p cyan'>遍历后得到的序列中</span><span class='p green'>的前驱和后继</span>。</p><p>例如：<img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217133358914_31623.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217133358914_31623.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>后序遍历得到序列：CBEFDA。其中 E 是 F 的前驱，D 是 F 的后继。</p><p>即：<strong>线索二叉树 = （前 | 中 | 后）遍历 + 二叉树</strong>。</p><p>我们在将左右指针指向子树还是前驱后继这个行为叫做<strong>线索化</strong>。</p><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>定义了二叉树，我们需要讨论：如何知道一个结点的孩子指针是指向子树还是指向前驱后继？<br>为了解决这个问题，还需要在每个结点中增加两个变量 <code>ltag</code> 、<code>rtag</code>。<br>当 ltag 或 rtag 为 true 时表示有孩子，指针域指向子树；<br>当 ltag 或 rtag 为 false 时表示没有孩子，指针域指向前驱或后继。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span></span><br><span class="line">    Elem data;             <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>* <span class="title">lchild</span>;</span> <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>* <span class="title">rchild</span>;</span> <span class="comment">// 右孩子</span></span><br><span class="line">    <span class="keyword">bool</span> ltag;</span><br><span class="line">    <span class="keyword">bool</span> rtag;</span><br><span class="line">&#125; BTNode;</span><br></pre></td></tr></table></figure><p>这样在创建一棵树时，如果某个结点有左子树，ltag 为 true，lchild 指向左子树；如果没有左子树，ltag 为 false，lchild 指向前驱。<br>eg：<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217133358914_31623.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201217133358914_31623.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br>这样一棵二叉树，经过中序线索化以后，变成下面这样：<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201218094820883_2791.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201218094820883_2791.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">TTNode* pre;     <span class="comment">// 全局变量，指向刚刚访问过的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(TTNode* T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T) &#123;</span><br><span class="line">        InThreading(T-&gt;lchild);    <span class="comment">// 递归左子树线索化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 线索化 begin */</span></span><br><span class="line">        <span class="keyword">if</span>(!T-&gt;lchild) &#123;    <span class="comment">// 没有左孩子</span></span><br><span class="line">            T-&gt;ltag = <span class="literal">false</span>;        <span class="comment">// 线索标志</span></span><br><span class="line">            T-&gt;lchild = pre;    <span class="comment">// 指向前驱元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!pre-&gt;rchild) &#123;    <span class="comment">// 前驱结点没有右孩子</span></span><br><span class="line">            pre-&gt;rtag = <span class="literal">false</span>;      <span class="comment">// 线索标志</span></span><br><span class="line">            pre-&gt;rchild = T;    <span class="comment">// 前驱右指针指向当前指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = T;    <span class="comment">// 保持 pre 指向 T 的前驱</span></span><br><span class="line">        <span class="comment">/** 线索化 end */</span></span><br><span class="line"></span><br><span class="line">        InThreading(T-&gt;rchild);    <span class="comment">// 递归右子树线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="树转二叉树"><a href="#树转二叉树" class="headerlink" title="树转二叉树"></a>树转二叉树</h3><p>一棵不规则的树，在一定程度上可以转换为一棵二叉树。</p><p>转换方法：</p><ol><li>连接：兄弟之间连线</li><li>断开：双亲结点只保留最左孩子，其余都断开</li><li>旋转：调整好位置</li><li>保留的做左子树，连接的做右子树</li></ol><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201218100403895_1715.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201218100403895_1715.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="树"></p><p>将这样一棵树转成二叉树。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201218100321786_8010.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201218100321786_8010.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="树转二叉树"></p><p>第一步：兄弟结点之间连接起来。例如 BCD 之间都连接起来了。<br>第二步：除了双亲跟左孩子，其他联系都断开。例如A只保留与 B，断开与 CD 的关系。<br>第三步：旋转调整。保留下来的作为左子树，连接得来的作为右子树。例如 B 是保留下来的，作为左子树，CD 是连接出来的，作为右子树。</p><div class="note done"><p>口诀：<strong>一连接、二断开、三旋转、保留左子树、连接右子树。</strong></p></div><h3 id="二叉树转树"><a href="#二叉树转树" class="headerlink" title="二叉树转树"></a>二叉树转树</h3><p>二叉树转树 是 树转二叉树的逆过程</p><p>一旋转、二断开、三连接即可。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201218105149339_15021.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201218105149339_15021.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="二叉树转树"></p><p>第一步：旋转，将右子树都旋转都同一层<br>第二步：连接右子树结点与双亲结点<br>第三步：断开兄弟间的连线</p><h3 id="二叉树转森林"><a href="#二叉树转森林" class="headerlink" title="二叉树转森林"></a>二叉树转森林</h3><p>判断一棵树是普通树还是二叉树，看它根结点有没有右子树。有就是二叉树，没有就是普通树。</p><p>二叉树转森林只需要把每个<strong>有孩子的右子树</strong>拆开作为单独一棵树即可。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201218110535205_14643.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201218110535205_14643.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="二叉树转森林"></p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><blockquote><p>哈夫曼树是一类带权路径长度最短的树，又称赫夫曼树、最优树、最优二叉树。</p></blockquote><p>哈夫曼树的应用非常广泛，特别是在大文本编码方面，压缩比非常可观。</p><p>首先解释一下带权路径：</p><ul><li><strong>路径</strong>：两个结点之间那根线就叫路径</li><li><strong>权</strong>：路径上的数字。</li><li><strong>带权路径</strong>：两个结点之间那根线带数字</li></ul><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210713122800.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210713122800.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="带权树"><br>权值可以用来表示某些含义，而在哈夫曼编码中，权值只有 0 和 1 两种。</p><ul><li><strong>路径长度</strong>：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称作<span class='p blue'>路径长度</span></li><li><strong>树的路径长度</strong>：从树根到每一个结点的<span class='p blue'>路径长度之和</span>。</li><li><strong>树的带权路径长度</strong>：树中所有叶子结点的<span class='p blue'>带权路径长度之和</span>，通常记作 $WPL=\sum^n_{k=1}{w_kl_k}$。（$l$ 为结点 $k$ 的层数，从 0 开始计算）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210713125941.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210713125941.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>上图中的 3 棵二叉树，都有 4 个叶子结点 A、B、C、D，分别带权 11、7、6、9。<br>他们的带权路径长度分别为：</p><ol><li>$WPL = 11 \times 2 + 7 \times 2 + 6 \times 2 + 9 \times 2 = 66$</li><li>$WPL = 11 \times 2 + 7 \times 1 + 6 \times 3 + 9 \times 3 = 74$</li><li>$WPL = 11 \times 1 + 7 \times 2 + 6 \times 3 + 9 \times 3 = 70$</li></ol><p>假设有一棵二叉树，其有 n 个叶子结点，并有 n 个权值 ${w_1, w_2, …, w_n}$，每个叶子结点带权为 $w_i$，则其中带权路径长度 WPL 最小的二叉树称作<span class='p blue'>最优二叉树</span>或<span class='p blue'>哈夫曼树</span>。</p><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><blockquote><p>哈夫曼编码是一种变长的编码方式，在大文本压缩方面有着出色的表现。</p></blockquote><p>相对比<span class='p blue'>变长</span>，另一种编码方式为<span class='p red'>定长</span>。</p><p>假设现在有一串文本 <code>aaabbaacdeefdeaeff</code>，共 18 个字符。<br>现在要进行远距离传输，我们需要先进行编码，也就是编成二进制形式。</p><p>可以看到总共是 abcdef 这几个字符，那么我们可以用 001 表示 a，010 表示 b，011 表示 c… 以此类推。</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th></tr></thead><tbody><tr><td>001</td><td>010</td><td>011</td><td>100</td><td>101</td><td>110</td></tr></tbody></table><p>这就是<span class='p blue'>定长编码</span>，每一个字符编码后都是同样的位数 3 位。</p><p><code>aaabbaacdeefdeaeff</code> 编码后为 <code>001001001010010001001011100101101110100101001101110110</code>。18 个字符共编成 54 个二进制位。</p><p>这种方式有个缺点：现在只有 6 种字符，所以每个字符编码后的位数占了 3 位，如果有 17 种字符，那么每个字符编码后需要占用 5 位，非常浪费空间。</p><p>所以哈夫曼教授提出了现在的哈夫曼编码，核心就是一句话：让出现次数越高的字符占用越少的位数。</p><h3 id="编码步骤"><a href="#编码步骤" class="headerlink" title="编码步骤"></a>编码步骤</h3><p>这是一种变长的编码方式，具体步骤如下：</p><ol><li>统计各种字符的出现次数构成一个序列</li><li>对序列进行排序</li><li>选取 2 个最小的作为叶子结点，父结点为两次数之和</li><li>将选出的两个数从序列中删除，将父结点加入序列</li><li>重复步骤 2，直到序列为空。</li></ol><p>注意事项：</p><ul><li>保持任何左侧结点都比右侧的兄弟结点小/大。</li><li>构造完成以后，给每一条路径填充权值 0 或 1。</li></ul><p>上面的例子用哈夫曼编码，应该是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210713175510.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210713175510.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>最终会生成一颗这样的树：</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210713180824.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210713180824.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>然后从根结点开始，直到字符那个结点，这一路的权值拼接起来就得到了变长编码。</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th></tr></thead><tbody><tr><td>00</td><td>011</td><td>0101</td><td>0100</td><td>10</td><td>11</td></tr></tbody></table><p>现在，<code>aaabbaacdeefdeaeff</code> 编码后为 <code>00000001101100000101010010101101001000101111</code>。18 个字符共编成 44 个二进制位。压缩比为 $44 \div 54 = 81$%。看起来不多，但是计算机中一个字符需要 8 个位存储，18 个字符共 144 位。这样算下来压缩比直接达到 $44 \div 144 = 30$%！</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>伪代码</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="comment">(序列长度 &gt;= 1)</span> &#123;</span><br><span class="line">    将序列排序</span><br><span class="line">    栈顶 <span class="number">2</span> 个元素出栈</span><br><span class="line">    构造子树</span><br><span class="line">    将父结点的值入栈</span><br><span class="line">&#125;</span><br><span class="line">填充权值</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataElement.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">lNode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">rNode</span>;</span></span><br><span class="line">    <span class="keyword">int</span> lWeight;</span><br><span class="line">    <span class="keyword">int</span> rWeight;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    Node* datas[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> times;</span><br><span class="line">&#125; seq;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Huffman.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HUFFMAN_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUFFMAN_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DataElement.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> len(x) sizeof(x)/sizeof(x[0])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将序列排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sort</span><span class="params">(Stack*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈两个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(Stack* s, Node* nodeArr[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造子树</span></span><br><span class="line"><span class="function">Node* <span class="title">buildSubTree</span><span class="params">(Node* nodeArr[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父结点入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Stack* s, Node* parent)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initStack</span><span class="params">(Stack* s, seq arr[], <span class="keyword">int</span> arrLen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStack</span><span class="params">(Stack* s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">frontPrint</span><span class="params">(Node* root)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">midPrint</span><span class="params">(Node* root)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stuffWeight</span><span class="params">(Node* root)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Huffman.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Huffman.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将序列排序</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @name 直接插入排序算法</span></span><br><span class="line"><span class="comment"> * 循环数组长度 -1 次，每次循环将当前目标数与前面部分（已排好序）比较</span></span><br><span class="line"><span class="comment"> * 前一个数大于当前数则交换位置，一直比较一直换，直到前面的数小于当前数时，退出比较，换下一个目标数继续比较。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sort</span><span class="params">(Stack* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; s-&gt;top + <span class="number">1</span>; i++) &#123; <span class="comment">// 一共循环数组长度 -1 次</span></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            Node* prev = s-&gt;datas[i - <span class="number">1</span>];</span><br><span class="line">            Node* curr = s-&gt;datas[i];</span><br><span class="line">            <span class="keyword">if</span> (prev-&gt;value &lt; curr-&gt;value) &#123; <span class="comment">// 若前一个小于后一个，则交换两个结点，当前目标数位置-1</span></span><br><span class="line">                Node* tmp = s-&gt;datas[i - <span class="number">1</span>];</span><br><span class="line">                s-&gt;datas[i - <span class="number">1</span>] = s-&gt;datas[i];</span><br><span class="line">                s-&gt;datas[i] = tmp;</span><br><span class="line">                tmp = <span class="literal">NULL</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈两个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(Stack* s, Node* nodeArr[<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nodeArr[<span class="number">0</span>] = s-&gt;datas[s-&gt;top--];</span><br><span class="line">    nodeArr[<span class="number">1</span>] = s-&gt;datas[s-&gt;top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造子树</span></span><br><span class="line"><span class="function">Node* <span class="title">buildSubTree</span><span class="params">(Node* nodeArr[<span class="number">2</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* parent = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    parent-&gt;data = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    parent-&gt;value = nodeArr[<span class="number">0</span>]-&gt;value + nodeArr[<span class="number">1</span>]-&gt;value;</span><br><span class="line">    parent-&gt;lNode = nodeArr[<span class="number">0</span>];</span><br><span class="line">    parent-&gt;rNode = nodeArr[<span class="number">1</span>];</span><br><span class="line">    parent-&gt;lWeight = parent-&gt;rWeight = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父结点入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(Stack* s, Node* parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s-&gt;datas[++s-&gt;top] = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充每条路径上的权值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stuffWeight</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;lNode)</span><br><span class="line">            root-&gt;lWeight = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;rNode)</span><br><span class="line">            root-&gt;rWeight = <span class="number">0</span>;</span><br><span class="line">        stuffWeight(root-&gt;lNode);</span><br><span class="line">        stuffWeight(root-&gt;rNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initStack</span><span class="params">(Stack* s, seq arr[], <span class="keyword">int</span> arrLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXSIZE; i++)</span><br><span class="line">        s-&gt;datas[i] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数组填充进栈里</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">        Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        node-&gt;data = arr[i].data;</span><br><span class="line">        node-&gt;value = arr[i].times;</span><br><span class="line">        node-&gt;lNode = node-&gt;rNode = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;lWeight = node-&gt;rWeight = <span class="number">-1</span>;</span><br><span class="line">        push(s, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">frontPrint</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c %2d; %2d, %2d\n&quot;</span>, root-&gt;data, root-&gt;value, root-&gt;lWeight, root-&gt;rWeight);</span><br><span class="line">        frontPrint(root-&gt;lNode);</span><br><span class="line">        frontPrint(root-&gt;rNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">midPrint</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        midPrint(root-&gt;lNode);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c %2d; %2d, %2d\n&quot;</span>, root-&gt;data, root-&gt;value, root-&gt;lWeight, root-&gt;rWeight);</span><br><span class="line">        midPrint(root-&gt;rNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Huffman.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tools.c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildHuffman</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    seq arr[] = &#123; &#123; <span class="string">&#x27;a&#x27;</span>, <span class="number">6</span> &#125;, &#123; <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span> &#125;, &#123; <span class="string">&#x27;c&#x27;</span>, <span class="number">1</span> &#125;, &#123; <span class="string">&#x27;d&#x27;</span>, <span class="number">2</span> &#125;, &#123; <span class="string">&#x27;e&#x27;</span>, <span class="number">4</span> &#125;, &#123; <span class="string">&#x27;f&#x27;</span>, <span class="number">3</span> &#125; &#125;;</span><br><span class="line">    Stack s;</span><br><span class="line">    initStack(&amp;s, arr, len(arr));</span><br><span class="line">    Node* popArr[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (s.top &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        sort(&amp;s);</span><br><span class="line">        pop(&amp;s, popArr);</span><br><span class="line">        Node* parent = buildSubTree(popArr);</span><br><span class="line">        push(&amp;s, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    stuffWeight(s.datas[s.top]);</span><br><span class="line">    printStack(&amp;s);</span><br><span class="line">    frontPrint(s.datas[s.top]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    midPrint(s.datas[s.top]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BuildHuffman();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DataStruction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> DataStruction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStruction 0x05 串</title>
      <link href="posts/42822.html"/>
      <url>posts/42822.html</url>
      
        <content type="html"><![CDATA[<p>什么是串？</p><span id="more"></span><h1 id="5-串"><a href="#5-串" class="headerlink" title="5-串"></a>5-串</h1><blockquote><p><strong>串</strong>：0或N个字符组成的有限序列，一种限定了元素为字符的线性表。</p></blockquote><p><strong>长度</strong>：字符个数<br><strong>空串</strong>：0个元素<br><strong>子串</strong>：串中任意连续字符组成的子序列<br><strong>主串</strong>：包含子串的串</p><p>存储结构：串的实现可以用定长数组，也可以用变长的动态数组实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定长数组</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> str[MAX_SIZE + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;Str;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变长动态数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *str; <span class="comment">// 串</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">// 串长度</span></span><br><span class="line">&#125;Str;</span><br></pre></td></tr></table></figure><p>基本操作：<strong>赋值、取长度、比较、连接、复制、求子串、清空</strong></p><p>当然串的操作还有非常多，比如返回字符在字符串中的位置，返回子串在字符串中的位置等等。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataElement.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 串结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>* str;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125; Str;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DATAELEMENT_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Assign</span><span class="params">(Str* s, <span class="keyword">char</span>* ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch_length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>* c = ch;</span><br><span class="line">    <span class="keyword">while</span> (*c) &#123; <span class="comment">// 计算ch字符串长度</span></span><br><span class="line">        ++ch_length;</span><br><span class="line">        ++c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ch_length == <span class="number">0</span>) &#123; <span class="comment">// 如果是空串</span></span><br><span class="line">        s-&gt;str = <span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 开辟一块空间，+1 是为了放 \0 结束符</span></span><br><span class="line">        s-&gt;str = (<span class="keyword">char</span>*)<span class="built_in">calloc</span>(ch_length + <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="comment">// 分配失败返回ERROR</span></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;str == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐个将ch的字符复制到s-&gt;str</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= ch_length; i++)</span><br><span class="line">            s-&gt;str[i] = *(ch + i);</span><br><span class="line"></span><br><span class="line">        s-&gt;length = ch_length;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取长度"><a href="#取长度" class="headerlink" title="取长度"></a>取长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(Str* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Str* s1, Str* s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历时将两个字符串逐个比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1-&gt;length &amp;&amp; i &lt; s2-&gt;length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1-&gt;str[i] != s2-&gt;str[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> s1-&gt;str[i] - s2-&gt;str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历是串中较为重要的操作。</p><p>逐个比较字符的ASCII码，</p><ul><li>若s1 &lt; s2，返回负数；</li><li>若s1 &gt; s2，返回正数；</li><li>若s1 = s2，返回0.</li></ul><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接分两种情况讨论</p><ol><li><p>一种是定长数组实现的字符串的连接</p><ul><li>如果A有剩余空间且剩余空间大于B长度，循环B长度逐个复制到A</li><li>如果A无剩余空间或剩余空间小于B长度，将A扩容，再循环B长度逐个复制到A</li></ul></li><li><p>一种是变长数组实现的字符串的连接</p><p> 变长数组一般没有剩余空间的情况，后面的空间是否是空闲空间也无从得知，所以变长数组的字符串在连接时，通常是开辟一块新的空间，长度为<code>A的长度+B的长度</code>，然后遍历A，逐个复制到新字符串，遍历B，逐个复制到新字符串A的后面，最后补<code>\0</code>。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 s2 连接到 s1 后面</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">contact</span><span class="params">(Str* s1, Str* s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一块新字符串空间，长度为 s1 + s2</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">new</span> = (<span class="keyword">char</span>*)<span class="built_in">calloc</span>(s1-&gt;length + s2-&gt;length, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s1-&gt;length) &#123; <span class="comment">// 把 s1 逐个字符赋值给新字符串</span></span><br><span class="line">        <span class="keyword">new</span>[i] = s1-&gt;str[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s2-&gt;length) &#123; <span class="comment">// 把 s2 逐个字符赋值给新字符串</span></span><br><span class="line">        <span class="keyword">new</span>[s1-&gt;length + i] = s2-&gt;str[i];</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span>[s1-&gt;length + s2-&gt;length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    s1-&gt;length += s2-&gt;length;</span><br><span class="line">    s1-&gt;str = <span class="keyword">new</span>; <span class="comment">// 让 s1 指向新字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">copy</span><span class="params">(Str* dest, Str* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = src-&gt;length &lt; dest-&gt;length ? src-&gt;length : dest-&gt;length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        dest-&gt;str[i] = src-&gt;str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dest-&gt;str[count] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> dest-&gt;str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制的时候，逐个将 src 字符串的字符 复制到 dest 字符串。</p><p>要注意的是，假设 dest 的长度为10，src 的长度为5，则将 src 覆盖到 dest 上，dest 上后面的几个字符但是不会被读取到</p><p>反过来则是 src 将 dest 整个覆盖，但是只能覆盖 dest 的字符个数，src 超出 dest 长度的字符会被丢弃。</p><p>所以在调用时要保证 dest 的长度比 src 的长。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201120171858449_17718.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201120171858449_17718.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201120171918369_7581.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201120171918369_7581.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="取子串"><a href="#取子串" class="headerlink" title="取子串"></a>取子串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description 从主串 base 的第 idx+1 个开始截取 len 个字符组成新的字符串</span></span><br><span class="line"><span class="comment"> * @param base 主串</span></span><br><span class="line"><span class="comment"> * @param idx 截取的起始下标</span></span><br><span class="line"><span class="comment"> * @param len 截取字符数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">sub</span><span class="params">(Str* base, <span class="keyword">int</span> idx, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 越界或主串为空</span></span><br><span class="line">    <span class="keyword">if</span> (idx + len &gt; base-&gt;length || base-&gt;length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间，然后逐字符复制</span></span><br><span class="line">    <span class="keyword">char</span>* substring = (<span class="keyword">char</span>*)<span class="built_in">calloc</span>(len, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        substring[i] = base-&gt;str[idx + i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> substring;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">clear</span><span class="params">(Str* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s-&gt;length; i++) &#123;</span><br><span class="line">        s-&gt;str[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="串的模式匹配"><a href="#串的模式匹配" class="headerlink" title="串的模式匹配"></a>串的模式匹配</h2><blockquote><p>对某子串的定位操作。</p><p>主串也称作<strong>目标串</strong></p><p>子串也称作<strong>模式串</strong></p><p>思想：从主串首个位置起和模式串的首个字符比较，若相等，则逐一比较后续字符，否则从主串第二个字符开始，逐一比较后续字符，以此类推。匹配成功则返回模式串在主串中的位置，匹配失败则返回0.</p></blockquote><h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h3><p>模式匹配主要有 <code>BF 算法</code> 和 <code>KMP 算法</code>。</p><p>BF 算法主要是一种暴力穷举，和上面介绍的思想一致。</p><p>KMP 算法就聪明多了，该算法充分体现了“失败是成功他妈”的道理，积极从上一次失败匹配中汲取信息，并应用到下一次匹配中，比起 BF 那种穷举法，KMP 会将模式串与失败位置对其再重新匹配。</p>]]></content>
      
      
      <categories>
          
          <category> DataStruction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> DataStruction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStruction 0x04 队列</title>
      <link href="posts/50917.html"/>
      <url>posts/50917.html</url>
      
        <content type="html"><![CDATA[<p>什么是队列？</p><span id="more"></span><h1 id="4-队列"><a href="#4-队列" class="headerlink" title="4-队列"></a>4-队列</h1><blockquote><p>队列是只允许在一端进行插入操作，在另一端进行删除操作的受限的线性表。</p></blockquote><p>队列是一种 <strong>先进先出(FIFO)</strong> 的线性表，就像水管一样，从一头进去，从另一头出来</p><p>队列有两个指针，一个指向<strong>队头</strong>，只允许删除；一个指向<strong>队尾</strong>，只允许插入。</p><p>对于队列的操作有插入和删除，也称作<strong>入队</strong>和<strong>出队</strong>，不能从中间取。</p><ul><li><span class='p blue'>顺序队</span>：队列的每一个元素在一段连续的内存空间，用数组实现。</li><li><span class='p blue'>链队</span>：队列的每一个元素不一定紧挨着，用链表实现。</li><li><span class='p blue'>循环队</span>：队头连接着队尾。</li></ul><p>队的主要操作包括：<strong>创建、初始化、入队、出队、判空、判满、清空队列</strong>。</p><h2 id="循环队"><a href="#循环队" class="headerlink" title="循环队"></a>循环队</h2><p>顺序队是基于数组实现的，当入队一个元素的时候，队尾指针+1，当<code>队尾指针=MAX_SIZE</code>时队满；当出队一个元素的时候，队头指针+1，当<code>队头指针=MAX_SIZE</code>时，说明队空。</p><p>但是！！</p><p>当<code>队头和队尾都 = MAX_SIZE</code> 时，实际上队空，但是却无法入队新元素，这种现象称之为<strong>假溢出</strong>。</p><p>所以为了解决这个问题，我们可以用<strong>循环队列</strong>。</p><div class="gallery stretch" col='3'>              <p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119211542211_9577.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119211542211_9577.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="由空队入队两个元素，此时 fron == 0, rear == 2"><br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119211613695_31001.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119211613695_31001.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="入队4个元素，出队3个元素，此时 front == 3, rear == 6"><br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119211651596_11557.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119211651596_11557.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="入队2个元素，出队4个元素，此时 front == 7, rear == 0"></p>            </div><div class="gallery stretch" col='2'>              <p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119212126618_6232.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119212126618_6232.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="队空条件：front == rear"><br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119212315473_17063.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119212315473_17063.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="队满条件：(rear + 1)%MAX_SIZE == front"></p>            </div><p>要实现循环队列，最重要的是怎么做才能让队头队尾指针在一个周期中循环。</p><p>答案是 <span class='p green'>front = (front + 1) % MAX_SIZE</span>、<span class='p red'>rear = (rear + 1) % MAX_SIZE</span>。</p><p>假设 <code>MAX_SIZE == 8, front == 1</code>，<code>(front + 1) % MAX_SIZE</code>等价于<code>2 % 8 == 2</code></p><p>所以这条表达式，可以让队头队尾指针在 <code>0~MAX_SIZE-1</code> 这个周期中循环，也就是在 <code>0, 1, 2, ... MAX_SIZE-1</code> 中循环。</p><h3 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h3><p>循环队列的两个状态</p><p>队空： <span class='p blue'>q->rear == q->front</span></p><p>队满： <span class='p red'>(q->rear + 1) % MAX_SIZE == q->front</span></p><p>入队：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q-&gt;rear = (q-&gt;rear + <span class="number">1</span>) % MAX_SIZE; </span><br><span class="line">q-&gt;data[q-&gt;rear] = x;</span><br></pre></td></tr></table></figure><p>出队：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q-&gt;front = (q-&gt;front + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">X = q-&gt;data[q-&gt;front];</span><br></pre></td></tr></table></figure><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataElement.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">&#125; Element;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Element datas[MAX_SIZE];</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DATAELEMENT_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Create</span><span class="params">(SqQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q-&gt;front = <span class="number">0</span>;</span><br><span class="line">    q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Init</span><span class="params">(SqQueue* q, Element* datas, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &gt; MAX_SIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(q-&gt;front &amp;&amp; q-&gt;rear))</span><br><span class="line">        Create(q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        EnQueue(q, datas[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue* q, Element e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果队满, 无法入队</span></span><br><span class="line">    <span class="keyword">if</span> (isFull(q))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    q-&gt;rear = (q-&gt;rear + <span class="number">1</span>) % MAX_SIZE; <span class="comment">// 先把队尾移动一格</span></span><br><span class="line">    q-&gt;datas[q-&gt;rear] = e; <span class="comment">// 再把数据放进去</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为队尾指针 rear 一直指着最后一个元素，如果直接放数据会覆盖掉原本队尾的数据，所以需要先把队尾指针向后挪一格，再放数据。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119211613695_31001.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119211613695_31001.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue* q, Element* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果队空，无法出队</span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    q-&gt;front = (q-&gt;front + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">    *e = q-&gt;datas[q-&gt;front];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为队头指针 front 一直指着第一个元素前面一格，直接拿数据就不对了，所以需要先把队头指针先向后挪一个，指向真正的队头元素，再取数据。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119211613695_31001.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119211613695_31001.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bool <span class="title">isEmpty</span><span class="params">(SqQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == q-&gt;rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判满"><a href="#判满" class="headerlink" title="判满"></a>判满</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bool <span class="title">isFull</span><span class="params">(SqQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == (q-&gt;rear + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印队列"><a href="#打印队列" class="headerlink" title="打印队列"></a>打印队列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(SqQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = q-&gt;front + <span class="number">1</span>; i &lt; q-&gt;rear + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \t %s \n&quot;</span>, q-&gt;datas[i].id, q-&gt;datas[i].name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SqQueue.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> len(X) sizeof(X) / sizeof(X[0])</span></span><br><span class="line"></span><br><span class="line">Element datas[] = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="string">&quot;Iron Man&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">2</span>, <span class="string">&quot;Thor&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">3</span>, <span class="string">&quot;Captain&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">4</span>, <span class="string">&quot;Green Man&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqQueue q;</span><br><span class="line">    Create(&amp;q);</span><br><span class="line">    Init(&amp;q, datas, len(datas));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After Init(): \n&quot;</span>);</span><br><span class="line">    Print(&amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n-------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Element el = &#123; <span class="number">5</span>, <span class="string">&quot;Big Man&quot;</span> &#125;;</span><br><span class="line">    EnQueue(&amp;q, el);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After EnQueue(): \n&quot;</span>);</span><br><span class="line">    Print(&amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n-------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DeQueue(&amp;q, &amp;el);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After DeQueue(): \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \t %s&quot;</span>, el.id, el.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h2><p>链队相比循环队则简单多了，入队就是链表的插入，出队就是链表的删除，队空就是队头指针和队尾指针都为 NULL ，没有队满。</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataElement.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">&#125; Element;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Element data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链队结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Node* front;</span><br><span class="line">    Node* rear;</span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DATAELEMENT_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Create</span><span class="params">(LinkStack* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建的时候，将两个队头队尾两个指针置空</p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Init</span><span class="params">(LinkQueue* q, Element* datas, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(q)) Create(q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        EnQueue(q, datas[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue* q, Element e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* <span class="keyword">new</span> = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">new</span>-&gt;data = e;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q)) &#123;   <span class="comment">// 如果队列为空，除了让队尾指向新结点，让队头也指向新结点</span></span><br><span class="line">        q-&gt;front = q-&gt;rear = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 如果队列不为空，让旧的队尾元素指向新结点，队尾指针指向新结点</span></span><br><span class="line">        q-&gt;rear-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">        q-&gt;rear = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入队就是让原本的队尾指向新的结点，这一步是让新结点加入链表；<br>然后让队尾指针也指向新的结点，这一步是对队尾指针的更新。</p><p>如果队列为空时，队头指针和队尾指针一起指向新结点。</p><h3 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Element <span class="title">DeQueue</span><span class="params">(LinkQueue* q, )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Element e;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q)) <span class="keyword">return</span> e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == q-&gt;rear) &#123;  <span class="comment">// 链队中只有一个元素时，出队后队空，所以需要恢复队头和队尾指针为空</span></span><br><span class="line">        e = q-&gt;rear-&gt;data;</span><br><span class="line">        <span class="built_in">free</span>(q-&gt;rear);</span><br><span class="line">        q-&gt;front = q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链队中不止一个元素时</span></span><br><span class="line">    <span class="comment">// 1. 取元素</span></span><br><span class="line">    e = q-&gt;front-&gt;data;</span><br><span class="line">    <span class="comment">// 2. 改链</span></span><br><span class="line">    Node* de = q-&gt;front;</span><br><span class="line">    q-&gt;front = de-&gt;next;</span><br><span class="line">    <span class="comment">// 3. 释放空间</span></span><br><span class="line">    <span class="built_in">free</span>(de);</span><br><span class="line">    de = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队的时候要考虑三种情况：</p><ol><li>队空，则返回一个空元素;</li><li>只有一个元素，出队后队头指针和队尾指针都要置空;</li><li>不止一个元素，则取元素、改链、释放空间，最后返回元素。</li></ol><h3 id="判空-1"><a href="#判空-1" class="headerlink" title="判空"></a>判空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(LinkQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span> &amp;&amp; q-&gt;rear == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清空链队"><a href="#清空链队" class="headerlink" title="清空链队"></a>清空链队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Clear</span><span class="params">(LinkQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q)) <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q-&gt;front) &#123;</span><br><span class="line">        DeQueue(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁链队"><a href="#销毁链队" class="headerlink" title="销毁链队"></a>销毁链队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Destory</span><span class="params">(LinkQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Clear(q);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印链队"><a href="#打印链队" class="headerlink" title="打印链队"></a>打印链队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(LinkQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* curr = q-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \t %s \n&quot;</span>, curr-&gt;data.id, curr-&gt;data.name);</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><h3 id="顺序队、循环队"><a href="#顺序队、循环队" class="headerlink" title="顺序队、循环队"></a>顺序队、循环队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataElement.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">&#125; Element;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Element datas[MAX_SIZE];</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DATAELEMENT_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SqQueue.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DQQUEUE_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DQQUEUE_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DataElement.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Create</span><span class="params">(SqQueue* q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Init</span><span class="params">(SqQueue* q, Element* datas, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue* q, Element e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue* q, Element* e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Bool <span class="title">isEmpty</span><span class="params">(SqQueue* q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Bool <span class="title">isFull</span><span class="params">(SqQueue* q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(SqQueue* q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DQQUEUE_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SqQueue.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SqQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Create</span><span class="params">(SqQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q-&gt;front = <span class="number">0</span>;</span><br><span class="line">    q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Init</span><span class="params">(SqQueue* q, Element* datas, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &gt; MAX_SIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(q-&gt;front &amp;&amp; q-&gt;rear))</span><br><span class="line">        Create(q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        EnQueue(q, datas[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue* q, Element e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果队满, 无法入队</span></span><br><span class="line">    <span class="keyword">if</span> (isFull(q))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    q-&gt;rear = (q-&gt;rear + <span class="number">1</span>) % MAX_SIZE; <span class="comment">// 先把队尾移动一格</span></span><br><span class="line">    q-&gt;datas[q-&gt;rear] = e; <span class="comment">// 再把数据放进去</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue* q, Element* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果队空，无法出队</span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q))</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    q-&gt;front = (q-&gt;front + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">    *e = q-&gt;datas[q-&gt;front];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Bool <span class="title">isEmpty</span><span class="params">(SqQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Bool <span class="title">isFull</span><span class="params">(SqQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == (q-&gt;rear + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(SqQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = q-&gt;front + <span class="number">1</span>; i &lt; q-&gt;rear + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \t %s \n&quot;</span>, q-&gt;datas[i].id, q-&gt;datas[i].name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SqQueue.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> len(X) sizeof(X) / sizeof(X[0])</span></span><br><span class="line"></span><br><span class="line">Element datas[] = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="string">&quot;Iron Man&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">2</span>, <span class="string">&quot;Thor&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">3</span>, <span class="string">&quot;Captain&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">4</span>, <span class="string">&quot;Green Man&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqQueue q;</span><br><span class="line">    Create(&amp;q);</span><br><span class="line">    Init(&amp;q, datas, len(datas));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After Init(): \n&quot;</span>);</span><br><span class="line">    Print(&amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n-------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Element el = &#123; <span class="number">5</span>, <span class="string">&quot;Big Man&quot;</span> &#125;;</span><br><span class="line">    EnQueue(&amp;q, el);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After EnQueue(): \n&quot;</span>);</span><br><span class="line">    Print(&amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n-------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DeQueue(&amp;q, &amp;el);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After DeQueue(): \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \t %s&quot;</span>, el.id, el.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链队-1"><a href="#链队-1" class="headerlink" title="链队"></a>链队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataElement.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">&#125; Element;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Element data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Node* front;</span><br><span class="line">    Node* rear;</span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DATAELEMENT_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkQueue.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LINKQUEUE_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINKQUEUE_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DataElement.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Create</span><span class="params">(LinkQueue* q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitLinkQ</span><span class="params">(LinkQueue* q, Element* datas, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue* q, Element e)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Element <span class="title">DeQueue</span><span class="params">(LinkQueue* q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Clear</span><span class="params">(LinkQueue* q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Destory</span><span class="params">(LinkQueue* q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(LinkQueue* q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(LinkQueue* q)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LINKQUEUE_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkQueue.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;LinkQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Create</span><span class="params">(LinkQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitLinkQ</span><span class="params">(LinkQueue* q, Element* datas, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(q)) &#123;</span><br><span class="line">        Create(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        EnQueue(q, datas[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue* q, Element e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* <span class="keyword">new</span> = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">new</span>-&gt;data = e;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队空，让队头也指向新结点</span></span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q)) &#123;</span><br><span class="line">        q-&gt;front = q-&gt;rear = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 队尾元素 指向新结点</span></span><br><span class="line">        q-&gt;rear-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">        <span class="comment">// 队尾指针 指向新结点</span></span><br><span class="line">        q-&gt;rear = <span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Element <span class="title">DeQueue</span><span class="params">(LinkQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Element e;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q))</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="comment">// 如果队中只有一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == q-&gt;rear) &#123;</span><br><span class="line">        e = q-&gt;front-&gt;data;</span><br><span class="line">        <span class="built_in">free</span>(q-&gt;front);</span><br><span class="line">        q-&gt;front = q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 改链</span></span><br><span class="line">    Node* de = q-&gt;front;</span><br><span class="line">    q-&gt;front = de-&gt;next;</span><br><span class="line">    <span class="comment">// 2. 取元素</span></span><br><span class="line">    e = de-&gt;data;</span><br><span class="line">    <span class="comment">// 3. 释放空间</span></span><br><span class="line">    <span class="built_in">free</span>(de);</span><br><span class="line">    de = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(LinkQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span> &amp;&amp; q-&gt;rear == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Clear</span><span class="params">(LinkQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q-&gt;front) &#123;</span><br><span class="line">        DeQueue(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Destory</span><span class="params">(LinkQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Clear(q);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(LinkQueue* q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* curr = q-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \t %s \n&quot;</span>, curr-&gt;data.id, curr-&gt;data.name);</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;LinkQueue.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> len(X) sizeof(X) / sizeof(X[0])</span></span><br><span class="line"></span><br><span class="line">Element datas[] = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="string">&quot;Iron Man&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">2</span>, <span class="string">&quot;Thor&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">3</span>, <span class="string">&quot;Captain&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">4</span>, <span class="string">&quot;Green Man&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkQueue q;</span><br><span class="line">    Create(&amp;q);</span><br><span class="line">    InitLinkQ(&amp;q, datas, len(datas));</span><br><span class="line">    Print(&amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n-------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Element e = &#123; <span class="number">5</span>, <span class="string">&quot;Spider Man&quot;</span> &#125;;</span><br><span class="line">    EnQueue(&amp;q, e);</span><br><span class="line">    Print(&amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n-------------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Element de = DeQueue(&amp;q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Element deleted: %d \t %s \n&quot;</span>, de.id, de.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n-------------------------------------\n&quot;</span>);</span><br><span class="line">    Print(&amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n-------------------------------------\n&quot;</span>);</span><br><span class="line">    Clear(&amp;q);</span><br><span class="line">    Print(&amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n-------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="comment">// Destory(&amp;q);</span></span><br><span class="line">    <span class="comment">// Print(&amp;q);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DataStruction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> DataStruction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStruction 0x03 栈</title>
      <link href="posts/29925.html"/>
      <url>posts/29925.html</url>
      
        <content type="html"><![CDATA[<p>什么是栈？</p><span id="more"></span><h1 id="3-栈"><a href="#3-栈" class="headerlink" title="3-栈"></a>3-栈</h1><blockquote><p>栈是一种只允许在一端进行插入和删除操作的操作受限的线性表。</p></blockquote><p>栈的主要特点是**先进后出 (FILO)**，就像子弹夹一样，最先压进去的子弹最后打出来。</p><p>栈有一个指针，永远指向栈的最顶部，称作<strong>栈顶指针</strong>。</p><p>栈的另外一个概念是<strong>栈底指针</strong>，在顺序栈中可不实现，在链栈中必须实现。</p><p>对于栈的操作有插入和删除，也称作<strong>入栈</strong>和<strong>出栈</strong>，不能从中间取出，因为只有一个口。</p><ul><li><span class='p blue'>顺序栈</span>：栈的每一个元素存储在一段连续的内存空间，用数组实现。</li><li><span class='p blue'>链栈</span>：栈的每一个元素不一定紧挨着，用链表实现。</li></ul><p>栈的主要操作包括：<strong>创建、初始化、入栈、出栈、判空、判满、获取栈顶元素、清空栈</strong>。</p><p>栈的应用非常广，例如函数调用就是用栈实现的。栈这种前进后出的特点非常适合解决匹配问题。</p><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 数据元素 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">&#125; Element;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 栈 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Element datas[MAX_SIZE];</span><br><span class="line">    <span class="keyword">int</span> top;<span class="comment">// 栈顶指针</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DATAELEMENT_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Create</span><span class="params">(Stack *s)</span> </span>&#123;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈空条件有两种：<code>s-&gt;top == -1</code>、<code>s-&gt;top == 0</code></p><p>这里采用 -1 这种，原因是不需要浪费一个元素大小的空间，另外操作起来也方便，因为数组下标是从0开始的。</p><div class="gallery ">              <p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201110215927095_2036.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201110215927095_2036.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201110220021088_9024.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201110220021088_9024.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>            </div><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Init</span><span class="params">(Stack* s, Element* datas, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &gt; MAX_SIZE)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top != <span class="number">-1</span>)</span><br><span class="line">        Create(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        push(s, datas[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">push</span><span class="params">(Stack* s, Element e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top &gt;= MAX_SIZE - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    s-&gt;datas[++s-&gt;top] = e;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们采用的是第一种栈空表示方式，栈顶指针永远指向栈顶元素，所以在将元素赋值压入栈之前，要先把栈顶指针抬起来 1 格，然后再把元素放进去。</p><p><code>s-&gt;datas[++s-&gt;top] = e</code> 等价于 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;top++; </span><br><span class="line">s-&gt;datas[s-&gt;top] = e</span><br></pre></td></tr></table></figure><h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Element <span class="title">pop</span><span class="params">(Stack* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;datas[s-&gt;top--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出栈的道理相同，先把元素取出来，然后栈顶指针降下去1格。</p><p><code>s-&gt;datas[s-&gt;top--]</code> 等价于 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;datas[s-&gt;top]; </span><br><span class="line">s-&gt;top--;</span><br></pre></td></tr></table></figure><h3 id="获取栈顶元素"><a href="#获取栈顶元素" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h3><p>获取栈顶元素不会出栈，就像把弹夹取下来看一眼，并不是打出去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Element <span class="title">get</span><span class="params">(Stack* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;datas[s-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h3><p>我们采用的是第一种栈空表示方式，所以只要判断栈顶指针是不是 <code>s-&gt;top == -1</code>即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bool <span class="title">isEmpty</span><span class="params">(Stack* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判满"><a href="#判满" class="headerlink" title="判满"></a>判满</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bool <span class="title">isFull</span><span class="params">(Stack* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == MAX_SIZE - <span class="number">1</span> ? TRUE : FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清空栈"><a href="#清空栈" class="headerlink" title="清空栈"></a>清空栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Clean</span><span class="params">(Stack* s)</span> </span>&#123;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序栈的清空很简单，只需要把栈顶指针指向栈底即可，虽然原本的数据没有被销毁，但是后续push的数据会将其覆盖。即使没有覆盖，在栈中我们只需要关注栈顶指针 top 的指向即可，top 所指即为栈顶，不论 top 之上有没有数据。</p><p>至于销毁栈，需要在定义 <code>Stack s</code> 的地方 <code>free(s)</code> 。</p><h3 id="打印栈"><a href="#打印栈" class="headerlink" title="打印栈"></a>打印栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(Stack* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s-&gt;top; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \t %s \n&quot;</span>, s-&gt;datas[i].id, s-&gt;datas[i].name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SqStack.c&quot;</span></span></span><br><span class="line"></span><br><span class="line">Element datas[] = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="string">&quot;Iron Man&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">2</span>, <span class="string">&quot;Green Man&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">3</span>, <span class="string">&quot;Thor&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">4</span>, <span class="string">&quot;Doctor&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    Create(&amp;s);</span><br><span class="line">    Init(&amp;s, datas, <span class="keyword">sizeof</span> datas / <span class="keyword">sizeof</span> datas[<span class="number">0</span>]);</span><br><span class="line">    Show(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n----------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Element e = &#123; <span class="number">5</span>, <span class="string">&quot;Big Man&quot;</span> &#125;;</span><br><span class="line">    push(&amp;s, e);</span><br><span class="line">    Show(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n----------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Element pe = pop(&amp;s);</span><br><span class="line">    pop(&amp;s);</span><br><span class="line">    Show(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="number">1</span>  Iron Man </span><br><span class="line"><span class="number">2</span>  Green Man </span><br><span class="line"><span class="number">3</span>  Thor </span><br><span class="line"><span class="number">4</span>  Doctor </span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="number">1</span>  Iron Man </span><br><span class="line"><span class="number">2</span>  Green Man </span><br><span class="line"><span class="number">3</span>  Thor </span><br><span class="line"><span class="number">4</span>  Doctor </span><br><span class="line"><span class="number">5</span>  Big Man </span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="number">1</span>  Iron Man </span><br><span class="line"><span class="number">2</span>  Green Man </span><br><span class="line"><span class="number">3</span>  Thor </span><br></pre></td></tr></table></figure><h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 数据元素 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">&#125; Element;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 链栈结点 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Element data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 链栈 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; LStack;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DATAELEMENT_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure><p>链栈稍微比顺序栈复杂一点点，但是换来不限栈大小的好处，所以在链栈中没有栈满的概念。</p><p>同时，链栈在入栈的时候需要手动分配空间，在出栈的时候需要把结点中的数据保存起来，销毁结点，再把数据返回。</p><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Create</span><span class="params">(LStack* s)</span> </span>&#123;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Init</span><span class="params">(LStack* s, Element* datas, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top != <span class="number">-1</span>)</span><br><span class="line">        Create(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) </span><br><span class="line">        push(s, datas[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入栈-1"><a href="#入栈-1" class="headerlink" title="入栈"></a>入栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">push</span><span class="params">(LStack* s, Element e)</span> </span>&#123;</span><br><span class="line">4<span class="comment">// 建立新结点，分配空间</span></span><br><span class="line">    Node* <span class="keyword">new</span> = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="comment">// 判断分配空间是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">new</span>-&gt;data = e;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入到链表的首元结点，成为栈顶元素</span></span><br><span class="line">    <span class="keyword">new</span>-&gt;next = s-&gt;next;</span><br><span class="line">    s-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">    s-&gt;top++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的入栈使用的是头插法，即每个新插入的元素都会插在链表的首元结点的位置。</p><h3 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Element <span class="title">pop</span><span class="params">(LStack* s)</span> </span>&#123;</span><br><span class="line">    Element res;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Element res = s-&gt;next-&gt;data;<span class="comment">// 将栈顶元素的数据复制一份</span></span><br><span class="line">    <span class="comment">// 改链，原本指向栈顶元素，现在指向栈顶的下一个元素，使其成为新的栈顶</span></span><br><span class="line">    Node* p = s-&gt;next;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="comment">// 将旧的栈顶元素释放空间</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    s-&gt;top--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链栈的出栈操作要记得把被弹出栈的旧栈顶元素释放。</p><h3 id="获取栈顶元素-1"><a href="#获取栈顶元素-1" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Element <span class="title">get</span><span class="params">(LStack* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判空-1"><a href="#判空-1" class="headerlink" title="判空"></a>判空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bool <span class="title">isEmpty</span><span class="params">(LStack* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清空栈-1"><a href="#清空栈-1" class="headerlink" title="清空栈"></a>清空栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Clean</span><span class="params">(LStack* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node* deleted = s-&gt;next;</span><br><span class="line">    Node* p;</span><br><span class="line">    <span class="keyword">while</span> (deleted) &#123;</span><br><span class="line">        p = deleted-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(deleted);</span><br><span class="line">        deleted = p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// s-&gt;next = NULL;</span></span><br><span class="line">    <span class="comment">// s-&gt;top = -1;</span></span><br><span class="line">    Create(s);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空链栈和销毁链表的操作是相同的，需要定义两个结点指针，相互配合实现整表销毁。</p><p>最后将栈置空，栈顶指针恢复到初试状态，所以这里调用了 <code>Create()</code>，等价于其上面两句表达式。</p><h3 id="打印链栈"><a href="#打印链栈" class="headerlink" title="打印链栈"></a>打印链栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(LStack* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Stack is EMPTY!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* p = s-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s-&gt;top; i &gt; <span class="number">-1</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d \t %s \n&quot;</span>, p-&gt;data.id, p-&gt;data.name);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试数据-1"><a href="#测试数据-1" class="headerlink" title="测试数据"></a>测试数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;LinkStack.c&quot;</span></span></span><br><span class="line"></span><br><span class="line">Element datas[] = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="string">&quot;Iron Man&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">2</span>, <span class="string">&quot;Green Man&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">3</span>, <span class="string">&quot;Thor&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">4</span>, <span class="string">&quot;Doctor&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LStack s;</span><br><span class="line">    Init(&amp;s, datas, <span class="number">4</span>);</span><br><span class="line">    Show(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n----------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Element e = &#123; <span class="number">5</span>, <span class="string">&quot;Big Man&quot;</span> &#125;;</span><br><span class="line">    push(&amp;s, e);</span><br><span class="line">    Show(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n----------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Element pe = pop(&amp;s);</span><br><span class="line">    pop(&amp;s);</span><br><span class="line">    Show(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n----------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Clean(&amp;s);</span><br><span class="line">    Show(&amp;s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="number">4</span>  Doctor </span><br><span class="line"><span class="number">3</span>  Thor </span><br><span class="line"><span class="number">2</span>  Green Man </span><br><span class="line"><span class="number">1</span>  Iron Man </span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="number">5</span>  Big Man </span><br><span class="line"><span class="number">4</span>  Doctor </span><br><span class="line"><span class="number">3</span>  Thor </span><br><span class="line"><span class="number">2</span>  Green Man </span><br><span class="line"><span class="number">1</span>  Iron Man </span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line"><span class="number">3</span>  Thor </span><br><span class="line"><span class="number">2</span>  Green Man </span><br><span class="line"><span class="number">1</span>  Iron Man </span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line">Stack is EMPTY!</span><br></pre></td></tr></table></figure><h2 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h2><blockquote><p>共享栈：指的是两个栈共用一个内存空间的一种栈结构。<br>共享栈不需要用链式结构，因为共享栈为的是<strong>节省空间</strong>，用链式没有意义。</p></blockquote><p>两个栈的栈底固定不变，讲两个栈顶设置在数组的两端，即 左边的栈 s0 的栈底设在 <code>0</code> 处，右边的栈 s1 的栈底设在 <code>MAX_SIZE - 1</code> 处。<br>创建共享栈时，左栈的栈顶指针 <code>topL = -1</code>，右栈的栈顶指针 <code>topR = MAX_SIZE</code>，当两个栈顶相遇时栈满，这样可以尽可能地利用空间。</p><p>栈空 ↓ （topL == -1 &amp;&amp; topR == MAX_SIZE）<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119150331892_8784.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119150331892_8784.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="栈空"></p><p>栈满 ↓ (topL == topR - 1)<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119150520115_25332.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119150520115_25332.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="栈满"></p><p>普通状态 ↓<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119150750124_24344.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201119150750124_24344.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="普通状态"></p><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>共享栈的定义稍稍不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATAELEMENT_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT 1    <span class="comment">// 和顺序栈的定义相比多一个 LEFT 和 RIGHT 来标记方向</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 999</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Bool;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">&#125; Element;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Element datas[MAX_SIZE];    <span class="comment">// 栈的存储空间，用数组来存储</span></span><br><span class="line">    <span class="keyword">int</span> topL;    <span class="comment">// 左栈的栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> topR;    <span class="comment">// 右栈的栈顶指针</span></span><br><span class="line">&#125; ShareStack;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DATAELEMENT_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure><h3 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Create</span><span class="params">(ShareStack* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s-&gt;topL = <span class="number">-1</span>;</span><br><span class="line">    s-&gt;topR = MAX_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建时，将两个指针初始化</p><h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Init</span><span class="params">(ShareStack* s, Element* datas, <span class="keyword">int</span> length, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &gt; MAX_SIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (direction == LEFT &amp;&amp; !isEmptyL(s)) &#123;</span><br><span class="line">        s-&gt;topL == <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (direction == RIGHT &amp;&amp; !isEmptyR(s)) &#123;</span><br><span class="line">        s-&gt;topR = MAX_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        push(s, datas[i], direction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享栈需要多一个参数 direction，来指定将元素放入左栈还是右栈。</p><h3 id="入栈-2"><a href="#入栈-2" class="headerlink" title="入栈"></a>入栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">push</span><span class="params">(ShareStack* s, Element e, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> LEFT:</span><br><span class="line">        s-&gt;datas[++s-&gt;topL] = e;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RIGHT:</span><br><span class="line">        s-&gt;datas[--s-&gt;topR] = e;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Direction is ILLEGAL PARAMETER!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出栈-2"><a href="#出栈-2" class="headerlink" title="出栈"></a>出栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Element <span class="title">pop</span><span class="params">(ShareStack* s, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Element e;</span><br><span class="line">    <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> LEFT:</span><br><span class="line">        <span class="keyword">if</span> (isEmptyL(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        e = s-&gt;datas[s-&gt;topL--];</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RIGHT:</span><br><span class="line">        <span class="keyword">if</span> (isEmptyR(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        e = s-&gt;datas[s-&gt;topR--];</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Direction is ILLEGAL PARAMETER!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取栈顶元素-2"><a href="#获取栈顶元素-2" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Element <span class="title">get</span><span class="params">(ShareStack* s, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;datas[direction == LEFT ? s-&gt;topL : s-&gt;topR];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判空-2"><a href="#判空-2" class="headerlink" title="判空"></a>判空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bool <span class="title">isEmpty</span><span class="params">(ShareStack* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;topL == <span class="number">-1</span> &amp;&amp; s-&gt;topR == MAX_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Bool <span class="title">isEmptyL</span><span class="params">(ShareStack* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;topL == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Bool <span class="title">isEmptyR</span><span class="params">(ShareStack* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;topR == MAX_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判满-1"><a href="#判满-1" class="headerlink" title="判满"></a>判满</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bool <span class="title">isFull</span><span class="params">(ShareStack* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;topL == s-&gt;topR - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清空栈-2"><a href="#清空栈-2" class="headerlink" title="清空栈"></a>清空栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Clean</span><span class="params">(ShareStack* s, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> LEFT:</span><br><span class="line">        s-&gt;topL = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RIGHT:</span><br><span class="line">        s-&gt;topR = MAX_SIZE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印栈-1"><a href="#打印栈-1" class="headerlink" title="打印栈"></a>打印栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(ShareStack* s, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(s)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The Whole Share stack is EMPTY!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="comment">// 打印左栈</span></span><br><span class="line">    <span class="keyword">case</span> LEFT:</span><br><span class="line">        <span class="keyword">if</span> (isEmptyL(s)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The Left Share stack is EMPTY!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; i &lt;= s-&gt;topL; i++, j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No. %d is: %d \t %s \n&quot;</span>, j, s-&gt;datas[i].id, s-&gt;datas[i].name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 打印右栈</span></span><br><span class="line">    <span class="keyword">case</span> RIGHT:</span><br><span class="line">        <span class="keyword">if</span> (isEmptyR(s)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The Right Share stack is EMPTY!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s-&gt;topR, j = <span class="number">1</span>; i &lt; MAX_SIZE; i++, j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No. %d is: %d \t %s \n&quot;</span>, j, s-&gt;datas[i].id, s-&gt;datas[i].name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 如果传进来的不是 LEFT 也不是 RIGHT，则打印整个栈</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; s-&gt;topL &amp;&amp; i &lt; s-&gt;topR) &#123;    <span class="comment">// 超过左栈没到右栈的这段空白</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No. %d is EMPTY.\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No. %d is: %d \t %s \n&quot;</span>, i + <span class="number">1</span>, s-&gt;datas[i].id, s-&gt;datas[i].name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试数据-2"><a href="#测试数据-2" class="headerlink" title="测试数据"></a>测试数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ShareStack.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> len(X) sizeof(X) / sizeof(X[0])</span></span><br><span class="line"></span><br><span class="line">Element datas1[] = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="string">&quot;Iron Man&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">2</span>, <span class="string">&quot;Green Man&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">3</span>, <span class="string">&quot;Thor&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">4</span>, <span class="string">&quot;Doctor&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Element datas2[] = &#123;</span><br><span class="line">    &#123; <span class="number">12</span>, <span class="string">&quot;Spider Man&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">24</span>, <span class="string">&quot;Wonder Woman&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">35</span>, <span class="string">&quot;Bat Man&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">40</span>, <span class="string">&quot;Super Man&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ShareStack ss;</span><br><span class="line">    Create(&amp;ss);</span><br><span class="line">    Init(&amp;ss, datas2, len(datas2), RIGHT);</span><br><span class="line">    Show(&amp;ss, RIGHT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n----------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Init(&amp;ss, datas1, len(datas1), LEFT);</span><br><span class="line">    Show(&amp;ss, LEFT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n----------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Show(&amp;ss, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line">No. <span class="number">1</span> is: <span class="number">40</span>  Super Man </span><br><span class="line">No. <span class="number">2</span> is: <span class="number">35</span>  Bat Man </span><br><span class="line">No. <span class="number">3</span> is: <span class="number">24</span>  Wonder Woman </span><br><span class="line">No. <span class="number">4</span> is: <span class="number">12</span>  Spider Man </span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line">No. <span class="number">1</span> is: <span class="number">1</span>  Iron Man </span><br><span class="line">No. <span class="number">2</span> is: <span class="number">2</span>  Green Man </span><br><span class="line">No. <span class="number">3</span> is: <span class="number">3</span>  Thor </span><br><span class="line">No. <span class="number">4</span> is: <span class="number">4</span>  Doctor </span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line">No. <span class="number">1</span> is: <span class="number">1</span>  Iron Man </span><br><span class="line">No. <span class="number">2</span> is: <span class="number">2</span>  Green Man </span><br><span class="line">No. <span class="number">3</span> is: <span class="number">3</span>  Thor </span><br><span class="line">No. <span class="number">4</span> is: <span class="number">4</span>  Doctor </span><br><span class="line">No. <span class="number">5</span> is EMPTY.</span><br><span class="line">No. <span class="number">6</span> is EMPTY.</span><br><span class="line">No. <span class="number">7</span> is: <span class="number">40</span>  Super Man </span><br><span class="line">No. <span class="number">8</span> is: <span class="number">35</span>  Bat Man </span><br><span class="line">No. <span class="number">9</span> is: <span class="number">24</span>  Wonder Woman </span><br><span class="line">No. <span class="number">10</span> is: <span class="number">12</span>  Spider Man </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DataStruction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> DataStruction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStruction 0x02 线性表</title>
      <link href="posts/21668.html"/>
      <url>posts/21668.html</url>
      
        <content type="html"><![CDATA[<p>什么是线性表？</p><span id="more"></span><h1 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2-线性表"></a>2-线性表</h1><blockquote><p>线性表指 0 或 n 个数据元素的有限序列</p></blockquote><p>特点：</p><ol><li>元素之间有序</li><li>元素个数有限</li><li>第一个无直接前驱元素</li><li>最后一个无直接后继元素</li><li>其余元素都有唯一一个直接前驱元素和唯一一个直接后继元素</li></ol><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201018201506104_12047.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201018201506104_12047.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>线性表元素的个数 $n(n&gt;=0)$ 即为<strong>线性表的长度</strong>；当 n=0 时，称为<strong>空表</strong>。</p><p>非空表中每个数据元素都有一个确定的位置，如$a_1$是首个元素，$a_n$是最后元素，$a_i$是第$i$个元素（称 $i$ 为数据元素 $a_i$ 在线性表中的位序）</p><blockquote><p>说句人话就是，像数组一样的数据结构就是线性表。<br>比如拿 5 个苹果排成一行，从左到右依次编号 12345，<br>第一个苹果前面没有苹果，<br>最后一个苹果后面没有其他苹果，<br>中间第 2、3、4 个苹果都有前一个苹果和后一个苹果，<br>例如第 2 个苹果的前一个苹果是 1 号苹果，后一个是 3 号苹果。</p></blockquote><h2 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表(<span class="type">List</span>)</span><br><span class="line">Data</span><br><span class="line">    线性表是数据对象集合为&#123;a1, a2, ..., an&#125;，每个元素的类型均为DataType。</span><br><span class="line">Operation</span><br><span class="line">    InitList(*L):          初始化操作，建立一个空的线性表L。</span><br><span class="line">    ListEmpty(L):          线性表为空返回<span class="literal">True</span>， 否则返回<span class="literal">False</span></span><br><span class="line">    ClearList(*L):         将线性表清空。</span><br><span class="line">    GetElem(L, i, *e):     将线性表L中第i个位置元素的值返回给e。</span><br><span class="line">    LocateElem(L, e):      在线性表L中查找与给定值e相等的元素，查找成功返回元素在表中的序号，失败返回O。</span><br><span class="line">    ListInsert(*L, i, e):  在线性表L中第i个位置插入新元素e。</span><br><span class="line">    ListDelete(*L, i, *e): 删除线性表L中第i个位置元素，并用e返回其值。</span><br><span class="line">    ListLength(L):         返回线性表L的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h2 id="顺序结构的线性表"><a href="#顺序结构的线性表" class="headerlink" title="顺序结构的线性表"></a>顺序结构的线性表</h2><blockquote><p>线性表的顺序存储结构，指的是用一段连续的存储单元一次存储线性表的数据元素。<br>例如数组，知道了第一个元素的地址，后面的元素都可以快速的计算出来。<br>假设第一个元素的<strong>地址为 A</strong>，每个元素<strong>占 k 个字节</strong>，则可知<strong>第 i 个元素</strong>的地址为 <span class='p blue'>A + i * k</span>。</p></blockquote><p>顺序结构在查找时，不论要查找的元素在任何位置，时间复杂度都为 $O(1)$，但在插入和删除时，平均时间复杂度为 $O(n)$。</p><h2 id="顺序结构代码实现"><a href="#顺序结构代码实现" class="headerlink" title="顺序结构代码实现"></a>顺序结构代码实现</h2><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201018171008169_28518.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201018171008169_28518.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>先放上各专业术语的关系图，以做对照。</p><h3 id="数据元素"><a href="#数据元素" class="headerlink" title="数据元素"></a>数据元素</h3><p>各种操作的基本单位是<strong>数据元素</strong>，数据元素又由各<strong>数据项</strong>构成。</p><p>在代码中，用 <strong>结构体类型(C语言中是结构体，Java等语言是类)</strong> 来实现数据元素，<br>用各种 <strong>基本类型(int、char、float、其他结构体等)</strong> 来实现数据项。（注意数据项也可以是结构体）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">Stu</span>;</span>    <span class="comment">// 为结构体起别名，后续写代码的时候比较方便</span></span><br></pre></td></tr></table></figure><p>或者写成这种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;Stu;</span><br></pre></td></tr></table></figure><p>在实际应用中数据元素（结构体）名字以实际业务为准<br>在以下例子中，则用 Element 指代 数据元素结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;Element;</span><br></pre></td></tr></table></figure><h3 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h3><p>这里数据对象指的就是线性表了。<br>线性表中需要包含 N 个数据元素，N 个数据元素要使用数组存放；再加上一个<code>count</code>来统计数据元素个数。</p><p><strong>注意是元素个数 (count of data elemment) 不是数组长度(length of array)。</strong></p><p>数组长度一开始要预留好，是固定不变的；<br>元素个数是变化的，增删插入之后都会变化，而数组长度不会。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataElement.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> len(X) sizeof X / sizeof X[0]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Element elemArr[MAX_SIZE];  <span class="comment">// 用数组存放数据元素</span></span><br><span class="line">    <span class="keyword">int</span> count;                  <span class="comment">// Count of data element.</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Init</span><span class="params">(SqList *L, Stu *studArr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = len(studArr);          <span class="comment">// 获取数组长度</span></span><br><span class="line">    <span class="keyword">if</span>(length &gt; MAX_SIZE) <span class="keyword">return</span> ERROR; <span class="comment">// 检查数组长度是否超出预设长度</span></span><br><span class="line"></span><br><span class="line">    L-&gt;count = <span class="number">0</span>;   <span class="comment">// count 初始化为 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) </span><br><span class="line">        Insert(L, i, studArr[i]);   <span class="comment">// 调用插入方法将元素插入到数组中（插入方法稍后实现）</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DataElement.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个线性表</span></span><br><span class="line">    SqList L;</span><br><span class="line">    SqList *pL = &amp;L;</span><br><span class="line">    <span class="comment">// 定义一份数据集</span></span><br><span class="line">    Stu studArr = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;Boii&quot;</span>, <span class="number">18</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Eva&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 初始化线性表</span></span><br><span class="line">    Init(pL, studArr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获得元素"><a href="#获得元素" class="headerlink" title="获得元素"></a>获得元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> uint Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用pe返回 在线性表L中第position个元素</span></span><br><span class="line"><span class="comment"> * @param *L        要操作是顺序表</span></span><br><span class="line"><span class="comment"> * @param position  要查找的元素位置</span></span><br><span class="line"><span class="comment"> * @param e         负责带回元素的元素指针</span></span><br><span class="line"><span class="comment"> * @return 获得成功返回OK，失败返回ERROR</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList *L, <span class="keyword">int</span> position, Element *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;count == <span class="number">0</span> || position &lt; <span class="number">1</span> || position &gt; L-&gt;count || e == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    *e = L-&gt;data[position<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------</span></span><br><span class="line"><span class="comment">// 调用时</span></span><br><span class="line">SqList L;</span><br><span class="line">SqList *pL = &amp;L;</span><br><span class="line">Element e;</span><br><span class="line">Element *pe = &amp;e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(GetElem(pL, <span class="number">3</span>, pe))</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d&quot;</span>, pe-&gt;name, pe-&gt;age);</span><br></pre></td></tr></table></figure><p>函数中先是判断顺序表是否为空表（空表时 count 为 0），接着对位置进行判断，看看是否在合法范围内，还有指针是否为空；<br>如果满足其中一个条件则返回 ERROR。<br>最后对将目标元素赋值给 pe。</p><p>参数中使用的是 *L，即直接操作目标顺序表<br><code>position</code> 代表的是位置，从1开始的（注意不是下标，下标是从0开始的），所以是将 <code>data[position-1]</code> 返回去<br>例如查找第5个元素，应该1211<br>返回 data[4]</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 e 插入到在线性表L中的第 idx 个元素</span></span><br><span class="line"><span class="comment"> * @param *L   要操作是顺序表</span></span><br><span class="line"><span class="comment"> * @param idx  要插入的元素下标</span></span><br><span class="line"><span class="comment"> * @param e    要插入的元素的指针</span></span><br><span class="line"><span class="comment"> * @return 插入成功返回OK，失败返回ERROR</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(SqList *L, <span class="keyword">int</span> idx, Element *e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果顺序表已满、或下标越界，返回ERROR</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;count == MAX_SIZE || idx &lt; <span class="number">0</span> || idx &gt; L-&gt;count)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="comment">// 如果要插入的位置不在末尾，则从最后一个开始，一个一个往后挪</span></span><br><span class="line">    <span class="keyword">if</span>(idx &lt; L-&gt;count)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = L-&gt;count - <span class="number">1</span>; i &gt;= idx; i--)</span><br><span class="line">            L-&gt;data[i + <span class="number">1</span>] = L-&gt;data[i];</span><br><span class="line">    <span class="comment">// 将元素插入指定的 idx </span></span><br><span class="line">    L-&gt;data[idx] = *e;</span><br><span class="line">    L-count++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：</p><ul><li>表满时，插入失败</li><li>下标小于 0 或大于 count - 1 时，插入失败</li><li>插入位置在表尾，即 idx = count，直接插入</li><li>插入位置不在表尾，即 idx &lt; count，从末尾开始后一位给前一位，直到把 data[idx] 空出来</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将线性表L中的第 position 个元素删除，被删元素保存在 e 中</span></span><br><span class="line"><span class="comment"> * @param *L        要操作是顺序表</span></span><br><span class="line"><span class="comment"> * @param position  要查找的元素位置</span></span><br><span class="line"><span class="comment"> * @param e         要删除的元素的指针</span></span><br><span class="line"><span class="comment"> * @return 删除成功返回OK，失败返回ERROR</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(SqList *L, <span class="keyword">int</span> position, Element *e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果空表或者位置超出范围，返回ERROR</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;count == <span class="number">0</span> || position &lt; <span class="number">1</span> || position &gt; L-&gt;count) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将要删除的元素保存起来</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) *e = L-&gt;data[position - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果删除的不是末尾元素</span></span><br><span class="line">    <span class="keyword">if</span> (position &lt; L-&gt;count)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = position; i &lt; L-&gt;count; i++)</span><br><span class="line">            L-&gt;data[i - <span class="number">1</span>] = L-&gt;data[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素个数-1</span></span><br><span class="line">    L-&gt;count--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：</p><ul><li>如果空表，或者位置超出范围[1, count]，删除失败</li><li>先将要删除的元素保存起来</li><li>如果删除的不是末尾元素，从删除位置开始到顺序表末尾，后一个赋值给前一个，最后元素个数-1</li><li>如果删除的是末尾元素，直接元素个数-1</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>数组在查询时，不管元素在哪个位置，时间复杂度都为 O(1)，<br>在删除和插入时，如果位置靠后则挪动的少，如果位置在最前，则整个数组都要挪动。<br>换言之，插入或删除第 i 个元素，需要移动 i - 1个元素。平均移动次数为 (n - 1)/2。所以时间复杂度为O(n)。</p><p>顺序结构比较适合元素个数不太变化，而是更多存取数据的应用。</p><h2 id="链式结构的线性表"><a href="#链式结构的线性表" class="headerlink" title="链式结构的线性表"></a>链式结构的线性表</h2><blockquote><p>线性表的链式结构是指，指的是用不连续的存储单元存储线性表的数据元素。</p></blockquote><p>在链式结构中，除了存储数据元素之外，还要存储其后继元素的地址。<br>存储数据元素信息的域称为<strong>数据域</strong>，存储后继元素地址的域称为<strong>指针域</strong>；<br>这两部分共同组成一个结点，n个结点链结成一个链表，即为线性表的链式存储结构。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210711154902.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210711154902.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>链表的起始结点称为<strong>头结点</strong>，头结点中的指针域称为<strong>头指针</strong>。<br>头结点的数据域可以不存储任何信息，也可以存储线性表长度等附加信息；<br>头结点的指针域指向第一个结点（第一个结点可以称为<strong>首元结点</strong>）；<br>头结点的指针域为空时（即头指针为空时），为空链表。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210711162258.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210711162258.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>因此，<br>每个结点只包含一个<strong>后继指针域</strong>（指向后继元素的指针域），称为 <span class='p blue'>单向链表</span>；<br>每个结点包含一个<strong>后继指针域</strong>（指向后继元素的指针域）和一个<strong>前驱指针域</strong>（指向前驱元素的指针域），称为<span class='p blue'>双向链表</span>；</p><p>链表的最后一个结点称为<strong>尾结点</strong>，尾结点的指针域可以为空（通常用 <code>NULL</code> 或 <code>^</code> 表示）<br>尾结点的<strong>后继指针域</strong>为空时，称为 <span class='p blue'>单链表</span>；<br>尾结点的<strong>后继指针域</strong>指向首元结点的地址时（指向首元结点不是头结点），称为 <span class='p blue'>循环链表</span>。</p><p>同理，<br>尾结点的<strong>后继指针域</strong>指 $\to$ 向<strong>首元结点</strong>的地址，首元结点的<strong>前驱指针域</strong>指 $\to$ 向<strong>尾结点</strong>时，称为 <span class='p blue'>双向循环链表</span>。</p><h3 id="单链表的代码实现"><a href="#单链表的代码实现" class="headerlink" title="单链表的代码实现"></a>单链表的代码实现</h3><h4 id="定义结点"><a href="#定义结点" class="headerlink" title="定义结点"></a>定义结点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义数据元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Element</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; Element;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Element data;<span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span><span class="comment">// 指针域，指向本身类型定，称为自引用</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为结点指针定义别名</span></span><br><span class="line"><span class="keyword">typedef</span> Node* PNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义头结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeadNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; HeadNode;</span><br></pre></td></tr></table></figure><p>代码中，先是定义了数据元素的结构，然后定义结点。</p><p>定义结点的时候，分别定义了数据域和指针域。可以看到指针域其实是自身的指针，这样的实现称为<strong>自引用</strong>。</p><p>假设 p 是指向第 i 个结点的移动指针，则 p-&gt;data 的值第 i 个结点的数据，而 p-&gt;next 的值为下一个结点（即第 i + 1个结点）的地址。<br>用 <code>p = p-&gt;next;</code> 可以让移动指针移动到第 i + 1 个结点，这时再使用 <code>p-&gt;data</code> 的值就为第 i + 1 个结点的数据。</p><p>最后为了方便表示，为这个结点类型的指针定义了一个类型别名 <code>PNode</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PNode p;</span><br></pre></td></tr></table></figure><h4 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h4><p>创建链表其实就是创建一个头结点，这个头结点很重要，对链表的操作都是从头结点开始的。</p><p>这里形参用的是指针形式，即直接操作该指针。所以在调用 <code>Create()</code> 时取了 link 的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Create</span><span class="params">(HeadNode *head)</span> </span>&#123;</span><br><span class="line">    head-&gt;length = <span class="number">0</span>;</span><br><span class="line">    head-&gt;next = null;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时</span></span><br><span class="line">HeadNode link;</span><br><span class="line">Create(&amp;link);</span><br></pre></td></tr></table></figure><h4 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h4><p>插入节点的思路为：</p><ol><li>创建新结点并给结点的数据域赋值</li><li>如果要插入的位置为 1（即首元节点），则将头结点的 next 给新节点，然后头结点的 next 指向新节点，长度 +1；</li><li>如果要插入的位置不为 1，则利用一个 node 指针遍历链表找到要插入位置的前一个结点，将前一个结点的 next 给新节点，然后前一个结点的 next 指向 新节点，长度 +1；</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(HeadNode *head, Element e, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果插入位置超过数组长度，则返回ERROR</span></span><br><span class="line">    <span class="keyword">if</span>(pos &gt; head-&gt;length) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建新节点并给新结点的数据域赋值</span></span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> Node);</span><br><span class="line">    newNode-&gt;data = e;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 如果插入的位置为首元节点</span></span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">1</span>)&#123;</span><br><span class="line">        newNode-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = newNode;</span><br><span class="line">        head-&gt;length++;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 如果插入的位置不是首元节点</span></span><br><span class="line">    <span class="comment">//    声明一个移动指针遍历遍历直到达到要插入的位置的前一个结点</span></span><br><span class="line">    <span class="comment">//    因为要到达前一个结点，所以这里走到 pos - 1 即可</span></span><br><span class="line">    Node* p = head-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; p &amp;&amp; i &lt; pos - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = newNode;</span><br><span class="line">    head-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时</span></span><br><span class="line">Element e = &#123;<span class="string">&quot;Boii&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">Insert(&amp;head, e, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><blockquote><p> 链表插入的重点在于要先将 <strong>前一个结点的指针域 新节点的指针域 newNode-&gt;next = p-&gt;next</strong> ，然后再把 <strong>新节点的地址给前一个结点的指针域 p-&gt;next = newNode</strong> ，这两者顺序不能颠倒，否则会插入失败。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210711164948.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210711164948.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h4 id="初始化链表"><a href="#初始化链表" class="headerlink" title="初始化链表"></a>初始化链表</h4><p>初始化链表时需要将<strong>头结点</strong>和<strong>元素数组</strong>传给函数</p><p>上面我们已经定义好了 创建链表函数，插入结点函数，所以在初始化时非常方便，只需要调用<code>Create()</code>创建链表，然后遍历元素数组，调用<code>Insert()</code>即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Init</span><span class="params">(HeadNode *head, Element *datas)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建链表</span></span><br><span class="line">    <span class="keyword">if</span>(Create(head))&#123;</span><br><span class="line">        <span class="comment">// 遍历元素数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">sizeof</span> datas / <span class="keyword">sizeof</span> datas[<span class="number">0</span>]); i++)</span><br><span class="line">            Insert(head, datas[i], i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时</span></span><br><span class="line">Element datas = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Boii&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Candy&quot;</span>, <span class="number">22</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HeadNode head;</span><br><span class="line">Init(&amp;head, datas);</span><br></pre></td></tr></table></figure><h4 id="读取结点"><a href="#读取结点" class="headerlink" title="读取结点"></a>读取结点</h4><p>假设现在要读取第 i 个结点，在读取结点之前，要先找到结点，然后把数据保存起来。</p><p>获得链表第 i 个数据的思路：</p><ol><li>声明一个移动指针 p，让 p 指向第一个结点；</li><li>声明一个计数器 j， 初始化 j 从 1 开始（因为 j 是用来和 i 做比较的，i 是从1开始算的）；</li><li>当 j &lt; i 时，就遍历链表，一直让移动指针 p 向后移动并且 j++，直到 j == i；</li><li>若到链表末尾 p 为空，则说明没找到第 i 个数据；</li><li>否则查找成功，返回 p 指向的结点的数据。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(PNode List, <span class="keyword">int</span> i, Element *e)</span> </span>&#123;</span><br><span class="line">    PNode p = List-&gt;next;   <span class="comment">// 指向头结点；</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;              <span class="comment">// 初始化计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(j &lt; i || p ) &#123;</span><br><span class="line">        p = p-&gt;next;    <span class="comment">// 让移动指针指向下一个结点</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 p 为空 或者 j &gt; i, 说明没找到，返回 error</span></span><br><span class="line">    <span class="keyword">if</span>(!p || j &gt; i) <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    *e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h4><p>删除思路：</p><ol><li>创建一个结点指针 <code>Node*</code>来暂存要被删除的结点的地址</li><li>找到要被删除的结点的前一个结点</li><li>让前一个结点的 next 指向被删结点的 下一个结点</li><li>free 释放被删结点的内存</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(HeadNode *head, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; head-&gt;length)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    Node* p = head-&gt;next;</span><br><span class="line">    <span class="comment">/* 1. 如果删除的是首元节点 */</span></span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">1</span>)&#123;</span><br><span class="line">        head-&gt;next = p-&gt;next;</span><br><span class="line">        head-&gt;length--;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 2. 如果删除的不是首元结点 */</span></span><br><span class="line">    <span class="comment">/* 先找到要删除结点的前一个结点 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; p &amp;&amp; i &lt; pos - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 然后删除目标结点 */</span></span><br><span class="line">    Node *q = p-&gt;next;<span class="comment">// 创建一个Node型指针暂存被删结点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;<span class="comment">// 让被删结点的前驱元素的 next 指向被删结点的后驱元素</span></span><br><span class="line">    head-&gt;length--;<span class="comment">// 长度-1</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(q);<span class="comment">// 释放被删结点的空间</span></span><br><span class="line">    q = p = <span class="literal">NULL</span>;<span class="comment">// 指针置空</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>C语言需要自己管理内存，自己管理指针释放指针，所以在删除之前要先将被删除结点保存起来，改链（p-&gt;next = q-&gt;next）之后将被删除结点的内存释放，最后把函数里创建的指针置空。</p><p>删除 i 结点其实就是让 i - 1 结点指向 i + 1.</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210711171703.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210711171703.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210711171957.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20210711171957.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>循环链表与单链表相比多了一个<strong>尾元结点指向首元节点</strong>。可以把尾元结点的指针称为<strong>尾指针</strong>。</p><p>当遍历循环链表时，可以通过判断 <code>尾元结点-&gt;next == 头结点-&gt;next</code>得知是否遍历了一圈了。</p><p>其实循环链表可以有2种实现形式：</p><ol><li>尾指针指向头结点</li><li>尾指针指向首元结点</li></ol><p>可根据需要选择相应的设计。</p><p>在操作上，循环链表和单链表的区别主要在<strong>插入</strong>和<strong>删除</strong>上。</p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>循环链表的插入操作要考虑4种情况</p><ol><li>链表是否为空</li><li>插入位置为首元节点</li><li>插入位置为尾元结点</li><li>插入位置为中间结点</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Insert</span><span class="params">(HeadNode *head, Element e, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pos &gt; head-&gt;length) <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建新结点</span></span><br><span class="line">    Node *newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> Node);</span><br><span class="line">    newNode-&gt;data = e;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 1. 链表为空 */</span></span><br><span class="line">    <span class="keyword">if</span>(!head-&gt;length)&#123;</span><br><span class="line">        newNode-&gt;next = newNode;    <span class="comment">// 让新结点的后继指针指向自己</span></span><br><span class="line">        head-&gt;next = newNode;       <span class="comment">// 让头结点指向新结点</span></span><br><span class="line">        head-&gt;length++;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 链表不为空 */</span></span><br><span class="line">    <span class="comment">/** 2. 插入位置为首元结点 */</span></span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 先把新结点做插入操作</span></span><br><span class="line">        newNode-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = newNode;</span><br><span class="line">        head-&gt;length++;</span><br><span class="line">        <span class="comment">// 找到尾结点</span></span><br><span class="line">        Node *last = head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; head-&gt;length; i++) last = last-&gt;next;</span><br><span class="line">        <span class="comment">// 让尾指针指向新结点</span></span><br><span class="line">        last-&gt;next = newNode;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 3. 插入位置为尾元结点 */</span></span><br><span class="line">    <span class="keyword">if</span>(pos == head-&gt;length)&#123;</span><br><span class="line">        <span class="comment">// 找到尾结点</span></span><br><span class="line">        Node *last = head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; head-&gt;length; i++) last = last-&gt;next;</span><br><span class="line">        <span class="comment">// 让新结点指向头结点，让尾结点指向新结点</span></span><br><span class="line">        newNode-&gt;next = head-&gt;next;</span><br><span class="line">        last-&gt;next = newNode;</span><br><span class="line">        head-&gt;length++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 4. 插入位置为中间结点*/</span></span><br><span class="line">    <span class="keyword">if</span>(pos != head-&gt;length)&#123;</span><br><span class="line">        <span class="comment">// 找到目标位置的前一个</span></span><br><span class="line">        Node *p = head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; p &amp;&amp; i &lt; pos - <span class="number">1</span>; i++) p = p-&gt;next;</span><br><span class="line">        <span class="comment">// 做普通插入操作</span></span><br><span class="line">        newNode-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = newNode;</span><br><span class="line">        head-&gt;length++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>当链表为空时，插入新结点只需要让新结点指向自己，然后让头结点指向新结点即可<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201108141810398_2941.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201108141810398_2941.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>当链表不为空</p><ul><li>插入位置为首元结点时，先做一个普通的插入操作，然后找到尾结点让尾指针指向新结点即可<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201108142944261_12884.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201108142944261_12884.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201108143058806_22741.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201108143058806_22741.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201108143136326_25958.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201108143136326_25958.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201108143218765_26724.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201108143218765_26724.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>插入位置为尾元结点时，找到尾元结点，让新结点指向头结点，让尾指针指向新结点即可<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201108143435454_10891.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201108143435454_10891.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201108143551702_29475.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/20201108143551702_29475.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>插入位置为中间结点时，找到目标位置前一个结点，做一个普通插入操作即可</li></ul></li></ul><h4 id="循环链表删除操作"><a href="#循环链表删除操作" class="headerlink" title="循环链表删除操作"></a>循环链表删除操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeteleCLinkList</span><span class="params">(HeadNode* head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断位置是否正确，或是否为空链表</span></span><br><span class="line">    <span class="keyword">if</span> (isEmptyC(head) || pos &gt; head-&gt;length)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是删除首元结点</span></span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">1</span>) &#123;</span><br><span class="line">        Node* first = head-&gt;next;</span><br><span class="line">        head-&gt;next = first-&gt;next;</span><br><span class="line"></span><br><span class="line">        Node* last = GetLast(head);</span><br><span class="line">        last-&gt;next-&gt;next = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        head-&gt;length--;</span><br><span class="line">        <span class="built_in">free</span>(first);</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是删除尾元结点</span></span><br><span class="line">    <span class="keyword">if</span> (pos == head-&gt;length) &#123;</span><br><span class="line">        Node* last = GetLast(head);</span><br><span class="line">        last-&gt;next = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        head-&gt;length--;</span><br><span class="line">        <span class="built_in">free</span>(last);</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1、找到目标结点</span></span><br><span class="line">    Node* current = head-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pos - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、进行删除操作</span></span><br><span class="line">    Node* q = current-&gt;next;</span><br><span class="line">    current-&gt;next = q-&gt;next;</span><br><span class="line">    head-&gt;length--;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回尾结点的前驱结点 */</span></span><br><span class="line"><span class="function">Node* <span class="title">GetLast</span><span class="params">(HeadNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head-&gt;length) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;链表为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* last = head-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; head-&gt;length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DataStruction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> DataStruction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStruction 0x01 算法</title>
      <link href="posts/17036.html"/>
      <url>posts/17036.html</url>
      
        <content type="html"><![CDATA[<p>什么是算法？</p><span id="more"></span><h1 id="1-算法"><a href="#1-算法" class="headerlink" title="1-算法"></a>1-算法</h1><p><strong>算法</strong>：是解决特定问题求解步骤的描述；在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p><p>算法特性：</p><ol><li><strong>输入</strong>：算法具有0或n个输入；</li><li><strong>输出</strong>：算法至少有1或n个输出；</li><li><strong>有穷性</strong>：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一步骤在可接受的时间内完成；</li><li><strong>确定性</strong>：算法的每一步骤都具有确定的含义，不会出现二义性；</li><li><strong>可行性</strong>：算法的每一步骤都能够通过执行有限次数完成。</li></ol><p>算法设计的要求：</p><ol><li><strong>正确性</strong>：指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能得到问题的正确答案；</li><li><strong>可读性</strong>：算法设计的另一目的是为了便于阅读、理解和交流；</li><li><strong>健壮性</strong>：当输入不合法数据时，算法也能做出相关处理，而不是产生异常；</li><li><strong>高效性</strong>：算法设计应该尽量满足时间效率高和存储量低的需求。</li></ol><h2 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h2><p>一个程序的运行时间，依赖于算法的好坏和问题的输入规模（输入规模：输入量的多少）。</p><p>测定运算时间最可靠的方法就是计算<strong>对运行时间有消耗的基本操作</strong>的执行次数。<br>在分析程序运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。</p><p>当输入规模变大以后，<strong>常数项、非最高阶项</strong>的影响微乎其微，所以判断一个算法的效率时，函数中的参数和其他次要项常常可以忽略，应该更关注主项（最高阶项）的阶数。</p><h2 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h2><blockquote><p>在进行算法分析时，语句总的执行次数 $T(n)$ 是关于问题规模 $n$的函数，进而分析 $T(n)$ 随 $n$ 的变化情况并确定 $T(n)$ 的数量级。<br>算法的时间复杂度，记作：$T(n) = O(f(n))$。表示随着问题规模 $n$ 的增大，算法执行时间的增长率和 $f(n)$ 的增长率相同。</p></blockquote><p>算法时间复杂度常用大O表示法<br>$O(1)$常数阶、$O(n)$线性阶、$O(n^2)$平方阶</p><p>大O阶的推导步骤为：</p><ol><li>用常数1取代运行时间中所有的常数</li><li>只保留最高阶</li><li>除了$O(1)$，去除最高阶的系数</li></ol><p>时间复杂度排序：<br>$O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)$</p>]]></content>
      
      
      <categories>
          
          <category> DataStruction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> DataStruction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataStruction 0x00 绪论</title>
      <link href="posts/44644.html"/>
      <url>posts/44644.html</url>
      
        <content type="html"><![CDATA[<p>什么是数据结构？</p><span id="more"></span><div class="note warning"><p>本系列文章系个人总结所写，执笔上偏于新手向，会有诸多用词不严谨之处，只为了方便理解。欢迎指正，拒绝指责。</p></div><hr><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><div class="note quote"><p><strong>程序</strong> 是一系列指令的集合。程序设计 = 数据结构 + 算法</p></div><p>数据，由 N 个 <span class='p blue'>0</span> 和 <span class='p blue'>1</span> 组成，本质上是一串二进制代码，利于计算机计算，但不利于人类阅读思考。<br>所以在此之上经过层层抽象，将计算机中的数据抽象出诸如 <code>对象、实例、结点、数据对象</code> 等概念。</p><blockquote><p><strong>数据结构</strong>，就是以 <code>对象、实例、结点、数据对象</code> 为<strong>单位</strong>，研究各个单位之间的<strong>关系</strong>。<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/4177948790941.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/4177948790941.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br>由此明确，在数据结构中需要研究两个东西： <span class='p h4 green'>单位、关系</span></p></blockquote><h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><p>数据的单位在数据结构中通常称为 <strong>数据对象</strong>，数据对象可以是一个人、一辆车、一个数字、一个字符、或者多种数据的组合，在代码中表现为<span class='p blue'>结构体变量或对象</span>。</p><p>而一个人，会有多种数据：名字（name）、年龄（age）、学号（ID），在代码中表现为<span class='p blue'>结构体成员变量或对象成员变量</span>。</p><p>而名字、年龄、学号这些，我们称为 <strong>数据项</strong>。</p><blockquote><p>即 N 个数据项构成了数据对象<br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/575267796809.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/575267796809.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></blockquote><p>每个人都有学号、姓名、年龄，例如张三李四王五，但张三不是李四、王五不是赵六，他们都是各自独立的。</p><p>但他们都是人类，所以我们把人类称为 <strong>数据元素</strong>，在代码中表现为 <span class='p blue'>结构体定义或类定义</span>。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/3421217982465.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/3421217982465.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结构体定义 &lt;--&gt; 数据元素</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 结构体成员变量 &lt;--&gt; 数据项</span></span><br><span class="line">    <span class="keyword">long</span> ID;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">&#125; Person;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据对象 &lt;--&gt; 结构体变量</span></span><br><span class="line">Person Zhangsan = &#123;</span><br><span class="line">    <span class="number">1213</span>, </span><br><span class="line">    <span class="number">18</span>, </span><br><span class="line">    <span class="string">&quot;Boii&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>说完单位，剩下就是关系了。</p><p>这些单位之间的关系，理论上有很多种：线性表、广义表、链表、栈、队、树、图；这种我们称为 <span class='p blue'>逻辑结构</span>。</p><p>而在代码、或者说物理上的实现，只有两种：顺序存储结构、链式存储结构；这些我们称为 <span class='p blue'>物理结构</span>。</p><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>逻辑上的各种关系可以分为 4 大类：</p><ol><li>集合结构：各个单位之间，除了同属一个集合，没有别的关系；各个单位是“平等”的。</li><li>线性结构：各个单位之间是<strong>一对一</strong>的关系</li><li>树形结构：各个单位之间是<strong>一对多</strong>的关系</li><li>图形结构：各个单位之间是<strong>多对多</strong>的关系</li></ol><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/3222300666995.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/3222300666995.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>集合结构比较少见，这里暂时不做讨论。<br>我们主要讨论常见的线性、树形、图形结构。</p><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>程序是运行在内存中的，而内存是顺序排列的，没那么多花里胡哨的，而且受计算机物理实现所束缚，物理结构中：</p><p>要么是一个挨着一个的<strong>顺序存储结构</strong>，要么是单位（数据对象）之间并不一定挨着的<strong>链式存储结构</strong>。</p><p>两种结构都有各自的特点。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/4827351761135.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/4827351761135.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><strong>顺序存储结构</strong></p><ul><li><strong>特点</strong>：数据对象之间在物理上一个挨着一个、有序，只要知道了第一个数据对象的地址，可以很快找到后面其他的数据对象。与此同时，为了保持这种一个挨着一个和有序的特点，当插入或者删除某一个数据对象时，后面的数据对象要一个一个往后挪腾出中间的位置，或者一个一个往前挪填补中间的空缺，导致插入和删除很慢。</li><li><strong>优点</strong>：查找速度快。</li><li><strong>缺点</strong>：插入和删除慢。</li></ul><p><strong>链式存储结构</strong></p><ul><li><strong>特点</strong>：数据对象之间在物理上并不一定相互挨着、无序，要查找某一个数据对象时需要从第一个数据对象开始，一个接着一个往后一路查下去才能找到。与此同时，因为物理上不一定相互挨着，所以插入和删除时只需要修改前后的链条即可。</li><li><strong>优点</strong>：插入和删除快。</li><li><strong>缺点</strong>：查找速度慢。</li></ul><p>这里的快慢，指的是计算机需要执行多次计算称为慢，计算机需要执行少量计算称为快。</p><h3 id="ADT-抽象数据类型"><a href="#ADT-抽象数据类型" class="headerlink" title="ADT 抽象数据类型"></a>ADT 抽象数据类型</h3><p>抽象数据类型是用来<span class='p green'>表示某一种逻辑结构（栈、队、树、...）的具体信息，具有什么样的操作</span> 等等。</p><p>描述 ADT 的标准格式：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名</span><br><span class="line">Data</span><br><span class="line">    数据元素之间逻辑关系的定义</span><br><span class="line">Operation</span><br><span class="line">    操作<span class="number">1</span></span><br><span class="line">        初始条件</span><br><span class="line">        操作结果描述</span><br><span class="line">    操作<span class="number">2</span></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    操作n</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">end</span>AD</span><br></pre></td></tr></table></figure><p>ADT 就像一张蓝图。<br>在建房子之前我们需要先设计好房子的功能、结构等，之后再依照图纸开工。<br>ADT 就是数据结构的图纸，事先定义好各种关系和操作，写起代码来才能有条不紊。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/DataStruction/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>]]></content>
      
      
      <categories>
          
          <category> DataStruction </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> DataStruction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-文件下载功能</title>
      <link href="posts/22089.html"/>
      <url>posts/22089.html</url>
      
        <content type="html"><![CDATA[<p>So easy~</p><span id="more"></span><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>效果：<a href="/download/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.pdf">点击下载</a></p><ol><li>在source目录下，新建download目录，和_posts、About、tags、categories等目录并列</li><li>将你需要分享的文件或者需要展示的图片之类，统一放到该download下<br> <img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Hexo-download/1.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Hexo-download/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1"></li><li>在写文章时，通过诸如 <code>[点击下载](/download/xx.exe)</code> 这样的链接，直接写入。其他，照旧<br> <img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Hexo-download/2.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Hexo-download/2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2"></li><li>在 <span class='btn'><a class="button" href='https://volantis.js.org/' title='volantis主题'>volantis主题</a></span>下，可以这样写 <code>&#123;% btn 点击下载, /download/xx.exe, fas fa-download %&#125;</code></li></ol><blockquote><p>注意：</p><ol><li>全半角不要搞错。</li><li>必须是<strong>压缩文件（.exe | .zip | .rar | 7z |…）</strong>，否则跳过去直接给你展示了不会触发下载的。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> HEXO </category>
          
          <category> Git </category>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> note </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE-note-day2</title>
      <link href="posts/37390.html"/>
      <url>posts/37390.html</url>
      
        <content type="html"><![CDATA[<p>Vue 的细节是真的多.</p><span id="more"></span><h2 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 等价于 <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">msg</span>: <span class="string">&#x27;Hello World !&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p> // 显示结果 ==&gt;&gt;</p><p>Hello World 等价于 Hello World.</p><h2 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h2><blockquote><p>形式: v-once</p><p>值: 无</p><p>作用: 限定所在元素只被渲染一次, 完成后即使值更新了也不再渲染</p></blockquote><p>不管是用 v-text = “msg” 还是用  都会实时的更新,也就是当msg 的值改变的时候, 显示的结果也会改变.</p><p>如果只想渲染一次, 可以加上v-once</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> 不等价于 <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">v-once</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">msg</span>: <span class="string">&#x27;Hello World !&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">    app.msg = <span class="string">&quot;Hello&quot;</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示结果 ==&gt;&gt;</p><p>Hello World 不等价于 Hello</p><h2 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h2><blockquote><p>形式: v-html = “variable”</p><p>值: variable -&gt; string, 取自于data{} 里的属性</p><p>! WARN:  容易导致<a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS攻击</a>. 所以, 只在可信内容上使用. <strong>永不</strong>用在用户提交的内容上。</p><p>作用: 更新元素的innerHTML. 内容按普通的HTML插入, 不会被编译</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;dodo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">dodo</span>: <span class="string">&#x27;&lt;h2&gt;Hello&lt;/h2&gt;&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 渲染结果 =&gt;&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;dodo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--显示结果 ==&gt;&gt; --&gt;</span></span><br><span class="line">Hello</span><br></pre></td></tr></table></figure><h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><blockquote><p>形式： v-on:event[.qualifier] = “Function | Inline statements | Object”</p><p>缩写： @event[.qualifier] = “Function | Inline statements | Object”</p><p>值： </p><ul><li>event -&gt; 要监听的事件， 如click， keyup等</li><li>qualifier -&gt; 修饰符，监听事件做一些限定</li><li>methods -&gt; 当所监听的事件触发时的响应方法</li><li>Inline statements -&gt; 内联语句</li><li>Object -&gt; [2.4.0]新增，使用键值对对象作为响应事件，但是不支持任何修饰器</li></ul><p>作用： 绑定监听事件。事件类型由event参数指定，</p><p>修饰符：</p><ul><li><code>.stop</code> - 调用 <code>event.stopPropagation()</code>。</li><li><code>.prevent</code> - 调用 <code>event.preventDefault()</code>。</li><li><code>.capture</code> - 添加事件侦听器时使用 capture 模式。</li><li><code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li><li><code>.&#123;keyCode | keyAlias&#125;</code> - 只当事件是从特定键触发时才触发回调。</li><li><code>.native</code> - 监听组件根元素的原生事件。</li><li><code>.once</code> - 只触发一次回调。</li><li><code>.left</code> - (2.2.0) 只当点击鼠标左键时触发。</li><li><code>.right</code> - (2.2.0) 只当点击鼠标右键时触发。</li><li><code>.middle</code> - (2.2.0) 只当点击鼠标中键时触发。</li><li><code>.passive</code> - (2.3.0) 以 <code>&#123; passive: true &#125;</code> 模式添加侦听器</li></ul></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--方法处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;Function1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态事件（2.6.0+） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:</span>[<span class="attr">event</span>]=<span class="string">&quot;dosth&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 内联语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;dosth(&#x27;hello&#x27;, $event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;dosth&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 停止冒泡 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;dosth&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 阻止默认行为 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;dosth&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 没有表达式的阻止默认行为 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">click.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 串联修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop.prevent</span>=<span class="string">&quot;dosth&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 键修饰符.键名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;onEnter&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 键修饰符.键码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">keyup.13</span>=<span class="string">&quot;onEnter&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 点击回调只触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.once</span>=<span class="string">&quot;dosth&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对象语法（2.4.0+） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on</span>=<span class="string">&quot;&#123;keyup: dosthA, keydown: dosthB&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><blockquote><p>形式： v-bind:AttributeOrProperty[.qualifier] = “value”</p><p>缩写： :AttributeOrProperty=”value”</p><p>值：</p><ul><li>AttributeOrProperty -&gt; 标签的原生属性或特性</li><li>value -&gt; 标签原生属性所对应的值</li></ul><p>作用：将属性或特性与变量绑定在一起，实现动态修改</p><p>修饰符：</p><ul><li><code>.prop</code> - 作为一个 DOM property 绑定而不是作为 attribute 绑定。(<a href="https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028">差别在哪里？</a>)</li><li><code>.camel</code> - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持)</li><li><code>.sync</code> (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 <code>v-on</code> 侦听器。</li></ul></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 绑定一个属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;imageSrc&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态 attribute 名 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:</span>[<span class="attr">key</span>]=<span class="string">&quot;value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imageSrc&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态 attribute 名缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 内联字符串拼接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;&#x27;/path/to/images/&#x27; + fileName&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- class 绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; red: isRed &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[classA, classB]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- style 绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; fontSize: size + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;[styleObjectA, styleObjectB]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 绑定一个有属性的对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123; id: someProp, &#x27;other-attr&#x27;: otherProp &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:text-content.prop</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">:prop</span>=<span class="string">&quot;someThing&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">v-bind</span>=<span class="string">&quot;$props&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- XLink --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">:xlink:special</span>=<span class="string">&quot;foo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><blockquote><p>形式： v-model[.qualifier] = “variable”</p><p>值：variable -&gt; 双向数据绑定的变量，通过这个变量实现数据与视图之间的绑定</p><p>! WARN: 只能在 <code>&lt;input&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;textarea&gt;</code> 和组件上使用</p><p>作用： 实现双向数据绑定</p><p>修饰符：</p><ul><li><a href="https://cn.vuejs.org/v2/guide/forms.html#lazy"><code>.lazy</code></a> - 取代 <code>input</code> 监听 <code>change</code> 事件,  懒加载，会等到失焦才更新</li><li><a href="https://cn.vuejs.org/v2/guide/forms.html#number"><code>.number</code></a> - 输入字符串转为有效的数字，限制只有数字有效， 但是如果先输入字符串则该修饰符无效</li><li><a href="https://cn.vuejs.org/v2/guide/forms.html#trim"><code>.trim</code></a> - 输入首尾空格过滤</li></ul></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>v-model.lazy<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">msg</span>: <span class="string">&#x27;Hello World !&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加了lazy修饰符， 所以会等到input输入框失去焦点才渲染更新</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE-note-day1</title>
      <link href="posts/37710.html"/>
      <url>posts/37710.html</url>
      
        <content type="html"><![CDATA[<p>疫情在家真的无聊 T_T，学点Vue吧</p><span id="more"></span><h2 id="v-if-amp-v-else-if-amp-v-else"><a href="#v-if-amp-v-else-if-amp-v-else" class="headerlink" title="v-if &amp; v-else-if &amp; v-else"></a>v-if &amp; v-else-if &amp; v-else</h2><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><blockquote><p>形式: v-if = “express | variable”</p><p>值:  true -&gt; 渲染[^1] | false -&gt; 不渲染</p><p>作用: vue的一个内部指令, 用在html标签中, 作为标签的一个属性. 用来判断是否渲染所在的标签.</p></blockquote><p>其作用相当于C语言中的 <code>if判断语句</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div v-if=&quot;isLogin&quot;&gt;欢迎来到XXX.&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">            <span class="attr">isLogin</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="v-else-if-2-1-0新增"><a href="#v-else-if-2-1-0新增" class="headerlink" title="v-else-if [2.1.0新增]"></a>v-else-if [2.1.0新增]</h3><blockquote><p>形式: v-else-if = “express | variable”</p><p>值: true -&gt; 渲染 | false -&gt; 不渲染</p><p>! WARN:  必须紧跟在 v-if 或 v-else-if后面, 否则将不被识别.</p><p>作用: 其作用相当于C语言中的 <code>else if 判断语句</code>.</p></blockquote><h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><blockquote><p>形式: v-else</p><p>值: 无</p><p>作用: 同 v-if 一样, vue的一个内部指令, 用在html标签中.</p><p>! WARN: 必须紧跟在 v-if 或 v-else-if后面, 否则将不被识别.</p></blockquote><h3 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;  A  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>  B  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span>  C  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>  Not A/B/C  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="key-管理可复用元素"><a href="#key-管理可复用元素" class="headerlink" title="key 管理可复用元素"></a>key 管理可复用元素</h3><blockquote><p>形式: key = “unique-value”</p><p>值: 不固定, 只要是全局唯一即可</p><p>作用: vue为了高效渲染使得加载速度变快, 会复用已有元素,  有时候有的元素虽然相同但是我们不想被复用, 可以在元素中添加key属性来避免被vue复用. 使用了key属性的元素会被重新渲染而不是复用</p></blockquote><h4 id="官网示例"><a href="#官网示例" class="headerlink" title="官网示例"></a><a href="%5Bhttps://cn.vuejs.org/v2/guide/conditional.html#%E7%94%A8-key-%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%85%83%E7%B4%A0%5D(https://cn.vuejs.org/v2/guide/conditional.html#%E7%94%A8-key-%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%85%83%E7%B4%A0)">官网示例</a></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个例子, 如果input 输入框内有内容, 在切换的时候不会被清空, 因为被vue复用了.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span> <span class="attr">key</span>=<span class="string">&quot;email-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而这个例子, 如果<code>&lt;input&gt;</code>输入框内有内容, 在切换时会被清空, 因为不会被复用而是重新渲染. 但是 <code>&lt;label&gt;</code>依然会被高效复用, 因为没有key属性.</p><blockquote><p>key属性作用: 避免被复用, 使之重新渲染</p></blockquote><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><blockquote><p>形式: v-show = “express | variable”</p><p>值: true -&gt; 显示[^4] | false -&gt; 不显示</p><p>作用: vue的一个内部指令, 用在html标签中,  用于判断所在标签是否显示, 而不是是否渲染</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;right&quot;</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>  <span class="comment">&lt;!--当right为true时, 该标签会被显示, 为false时不显示--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-show</span>=<span class="string">&quot;status === 1&quot;</span>&gt;</span> 当status为1时显示 <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">right</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">status</span>: <span class="number">2</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">渲染后的结果:</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;display:block;&quot;</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span> 当status为1时显示 <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-if-VS-v-show"><a href="#v-if-VS-v-show" class="headerlink" title="v-if   VS   v-show"></a>v-if   VS   v-show</h3><p>渲染:</p><ul><li><p><code>v-if</code> 是<strong>“真正”的条件渲染</strong>，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p></li><li><p><code>v-show</code>只是简单地基于 <strong>CSS 进行切换</strong>。</p></li></ul><p>渲染时机:</p><ul><li><p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p></li><li><p><code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，</p></li></ul><p>开销:</p><ul><li><code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。</li></ul><p>因此:</p><ul><li><p>如果需要非常<strong>频繁地切换</strong>，则使用 <code>v-show</code> 较好；</p></li><li><p>如果在运行时条件<strong>很少改变</strong>，则使用 <code>v-if</code> 较好。</p></li></ul><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><h3 id="数组作为数据源"><a href="#数组作为数据源" class="headerlink" title="数组作为数据源"></a>数组作为数据源</h3><blockquote><p>形式: 渲染一个数组</p><ol><li>v-for = “alias in source” 或 v-for = “alias of source”</li><li>v-for = “(alias, index) in source”</li></ol><p>值: </p><ul><li>source -&gt; 数据源, 是一个数组</li><li>alias -&gt; 别名, 遍历时的临时变量</li><li>index -&gt; 索引(下标), 默认的, 可以取别的名, 但是约定俗成是 index</li></ul><p>! WARN: </p><ul><li>别名和索引的位置不能换. 即使换了解释器也默认按照 <code>第一个参数是临时变量, 第二个参数是索引, in 后面的参数是数据源</code> 的规则来解释</li><li>哪个元素要被循环渲染就写在哪个元素里作为它的属性.</li></ul><p>作用: 将数组里的每一个值渲染到标签的插值[^7]中. </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;age in DemoArray&quot;</span>&gt;</span>&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">DemoArray</span>: [<span class="number">20</span>, <span class="number">30</span>, <span class="number">44</span>, <span class="number">10</span>, <span class="number">33</span>]</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 渲染结果=&gt;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>20<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>30<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>44<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>10<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>33<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>// 显示结果 ==&gt;&gt;</p><ul><li>20</li><li>30</li><li>44</li><li>10</li><li>33</li></ul></blockquote><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><blockquote><p>计算的工作都在computed里完成</p></blockquote><p>排序实现在vue对象中的computed, 但是computed里的键名不能和data里的键名相同. 而我们要按排序后的数组渲染, 所以 html 里要改成 v-for = “age in sortArray”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;age in DemoArray&quot;</span>&gt;</span>&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">4...</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">DemoArray</span>: [<span class="number">20</span>, <span class="number">30</span>, <span class="number">44</span>, <span class="number">10</span>, <span class="number">33</span>]</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">/** 错误写法. 键名重复</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            DemoArray: function()&#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">            return this.DemoArray.sort((a, b) =&gt; a - b);</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        &#125;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        */</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">sortItems</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="built_in">this</span>.DemoArray.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为 <code>javascript</code> 自带的 bug, 对数组排序 DemoArray.sort()是把每个数组元素的最前面的一位[^5], 所以排序出来是有问题的.</p><p>导致这个 bug 的原因我猜想是因为 js 是弱类型语言, 解释器也不知道你这个数组里到底是字符串还是数字还是什么, 又得给你排序, 所以干脆统统按 <code>给字符串排序</code> 的方法处理.</p><blockquote><p>修复方法就是自己实现一个函数. 上述代码中用了<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1031549578462080">箭头函数</a>使得更加简洁. 关键代码即 <code>(a, b) =&gt; a - b</code></p></blockquote><h4 id="数组更新"><a href="#数组更新" class="headerlink" title="数组更新"></a>数组更新</h4><h5 id="会修改原数组的方法-变异方法"><a href="#会修改原数组的方法-变异方法" class="headerlink" title="会修改原数组的方法: 变异方法"></a>会修改原数组的方法: 变异方法</h5><ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ul><p>通过这些方法修改数组, <strong>会触发视图的更新</strong>. </p><h5 id="不会修改原数组的方法-非变异方法"><a href="#不会修改原数组的方法-非变异方法" class="headerlink" title="不会修改原数组的方法: 非变异方法"></a>不会修改原数组的方法: 非变异方法</h5><ul><li>filter()</li><li>concat()</li><li>slice()</li></ul><p>它们不会改变原始数组，而<strong>返回一个新数组</strong>。</p><p>当使用非变异方法时，可以用新数组替换旧数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue (&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">items</span>: [</span><br><span class="line">            &#123;<span class="attr">msg</span>: <span class="string">&quot;m1&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">msg</span>: <span class="string">&quot;m2&quot;</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 替换              </span></span><br><span class="line">app.items = app.items.filter( <span class="function"><span class="params">item</span> =&gt;</span> item.items.match(<span class="regexp">/mmm/</span>) ) ;</span><br></pre></td></tr></table></figure><blockquote><p>? 这里不清楚怎么实现的, 但是<a href="%5Bhttps://cn.vuejs.org/v2/guide/list.html#%E6%9B%BF%E6%8D%A2%E6%95%B0%E7%BB%84%5D(https://cn.vuejs.org/v2/guide/list.html#%E6%9B%BF%E6%8D%A2%E6%95%B0%E7%BB%84)">官网</a>的说法是: 并非丢弃现有DOM而重新渲染整个列表, 因为Vue里有些智能的方法, 所以, 数组在改动不大的情况下去替换原有数组的非常高效的, 不必担心.</p><p>至于怎么个智能法没说, 有待深挖. </p></blockquote><h4 id="数组更新的注意事项"><a href="#数组更新的注意事项" class="headerlink" title="数组更新的注意事项"></a>数组更新的注意事项</h4><h5 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h5><p>由于不靠谱的JavaScript的限制, 以下两种方法的更新Vue是无法检测到的</p><ol><li>利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">array</span>: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.array[<span class="number">3</span>] = <span class="number">10</span><span class="comment">//Vue 检测不到更新, 也不会触发视图更新</span></span><br><span class="line">app.array.length = <span class="number">8</span><span class="comment">//Vue 检测不到更新</span></span><br></pre></td></tr></table></figure><h5 id="解决-问题1"><a href="#解决-问题1" class="headerlink" title="解决: 问题1"></a>解决: 问题1</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.items, indexOfItem, newValue), </span><br><span class="line"><span class="comment">// 例如: Vue.set(app.array, 2, 10)</span></span><br><span class="line"><span class="comment">// ==&gt;&gt; [0,1,10,3,4,5,6,7,8]</span></span><br><span class="line">或</span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue), </span><br><span class="line"><span class="comment">// 例如: app.array.splice(3, 1, 50)</span></span><br><span class="line"><span class="comment">// ==&gt;&gt; [0,1,2,50,4,5,6,7,8]</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 关于这个1,可以是任何数, </span></span><br><span class="line"><span class="comment">// 0则不吃掉任何元素, </span></span><br><span class="line"><span class="comment">// 1则吃掉array[indexOfItem]那个元素,</span></span><br><span class="line"><span class="comment">// 2则吃掉array[indexOfItem] 和 array[indexOfItem + 1]两个元素</span></span><br><span class="line"><span class="comment">// 以此类推</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如: app.array.splice(2,2,30)</span></span><br><span class="line"><span class="comment">// ==&gt;&gt; [0,1,30,5,6,7,8]</span></span><br><span class="line">    </span><br><span class="line">或</span><br><span class="line">vm.$set(vm.items, indexOfItem, newValue)</span><br><span class="line"><span class="comment">// 例如: app.$set(app.array, 2, 10)</span></span><br><span class="line"><span class="comment">// ==&gt;&gt; [0,1,10,3,4,5,6,7,8]</span></span><br></pre></td></tr></table></figure><h5 id="解决-问题2"><a href="#解决-问题2" class="headerlink" title="解决: 问题2"></a>解决: 问题2</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.array.splice(新长度值)</span><br></pre></td></tr></table></figure><h3 id="对象作为数据源"><a href="#对象作为数据源" class="headerlink" title="对象作为数据源"></a>对象作为数据源</h3><blockquote><p>形式: 渲染一个对象</p><ol><li>v-for = “value in object”</li><li>v-for = “(value, key) in object”</li><li>v-for = “(value, key, index) in object”</li></ol><p>值:</p><ul><li>object -&gt; 数据源, 是一个对象, 要遍历的是它的所有属性</li><li>value -&gt; 别名, 遍历时的临时变量, 输出的是每一个属性的值</li><li>key -&gt; 索引(键名), 默认的, 可以取别的名, 但是约定俗成是 key, 输出的是每一个属性(键值对)的键名</li><li>index -&gt; 索引(下标), 默认的, 可以取别的名, 约定俗成是index, 输出的是每一个属性的下标[^6].</li></ul><p>! WARN:</p><ul><li>和遍历数组一样, 键名索引和下标索引的位置不要换. 即使换了解释器也是按照 <code>第一个参数是临时变量,第二个参数是键名索引, 第三个参数是下标索引, in 后面是数据源</code>的规则解释.</li><li>哪个元素要被循环渲染就写在哪个元素里作为它的属性.</li></ul><p>作用: 将对象里的每一个属性(键值对)的值渲染到标签的插值[^7]中.</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(val, key, idx) in obj&quot;</span>&gt;</span>&#123;&#123;idx&#125;&#125;-&#123;&#123;key&#125;&#125;-&#123;&#123;val&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">obj</span>:&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">prop1</span>: <span class="string">&#x27;key1&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">prop2</span>: <span class="number">20</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">prop3</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">         &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 渲染结果 =&gt;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>0-prop1-key1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>1-prop2-20<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>2-prop3-true<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>// 显示结果 ==&gt;&gt;</p><ul><li>0-prop1-key1</li><li>1-prop2-20</li><li>2-prop3-true</li></ul></blockquote><h4 id="对象更新的注意事项"><a href="#对象更新的注意事项" class="headerlink" title="对象更新的注意事项"></a>对象更新的注意事项</h4><h5 id="问题-1"><a href="#问题-1" class="headerlink" title="问题:"></a>问题:</h5><p>由于不靠谱的JavaScript的限制, 对象属性的添加或删除 Vue是检测不到的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.b = <span class="number">2</span> <span class="comment">// Vue检测不到, 不会更新视图</span></span><br></pre></td></tr></table></figure><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>app.a   app.b    这里a和b叫做根级别响应式属性, 是不允许动态添加的, 但是根级别属性的属性是可以动态添加的.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">root</span>:&#123; <span class="attr">child</span>: <span class="number">1</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.root 不允许动态添加, app.root.child允许动态添加</span></span><br></pre></td></tr></table></figure><p>添加单个属性的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(rootAttribute, childKey, childValue)</span><br><span class="line"><span class="comment">// 例如: Vue.set(app.root, &#x27;age&#x27;, 10)</span></span><br><span class="line"><span class="comment">// ==&gt;&gt; data: &#123;</span></span><br><span class="line"><span class="comment">//root: &#123; child: 1, age: 10&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">或</span><br><span class="line">vm.$set(rootAttribute, childKey, childValue)</span><br><span class="line"><span class="comment">// 例如: app.$set(app.root, &#x27;age&#x27;, 10)</span></span><br></pre></td></tr></table></figure><p>添加多个属性的方法: 使用 <code>Object.assign()</code> 或 <code>_.extend()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.root = <span class="built_in">Object</span>.assign(&#123;&#125;, app.root, &#123; <span class="attr">age</span>: <span class="number">27</span>, <span class="attr">favoriteColor</span>: <span class="string">&#x27;Vue Green&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="数组对象作为数据源的排序"><a href="#数组对象作为数据源的排序" class="headerlink" title="数组对象作为数据源的排序"></a>数组对象作为数据源的排序</h3><blockquote><p>计算处理同样是在computed中.</p><p>重新定义一个函数, 并作出处理</p><p>在v-for调用时 把数据源换成刚刚定义的函数名</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">4...</span><br><span class="line">4<span class="comment">//数组对象方法排序:</span></span><br><span class="line">4<span class="attr">sortStudents</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">4    <span class="keyword">var</span> key = <span class="string">&quot;age&quot;</span>;</span><br><span class="line">4    <span class="keyword">return</span> <span class="built_in">this</span>.students.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[key] &lt; b[key] ? -<span class="number">1</span> : (a[key] &gt; b[key] ? <span class="number">1</span> : <span class="number">0</span>))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="范围作为数据源"><a href="#范围作为数据源" class="headerlink" title="范围作为数据源"></a>范围作为数据源</h3><p>形式: 渲染一个对象</p><ol><li>v-for = “value in object”</li><li>v-for = “(value, key) in object”</li><li>v-for = “(value, key, index) in object”</li></ol><p>值:</p><ul><li>object -&gt; 数据源, 是一个对象, 要遍历的是它的所有属性</li><li>value -&gt; 别名, 遍历时的临时变量, 输出的是每一个属性的值</li><li>key -&gt; 索引(键名), 默认的, 可以取别的名, 但是约定俗成是 key, 输出的是每一个属性(键值对)的键名</li><li>index -&gt; 索引(下标), 默认的, 可以取别的名, 约定俗成是index, 输出的是每一个属性的下标[^6].</li></ul><p>! WARN:</p><ul><li>和遍历数组一样, 键名索引和下标索引的位置不要换. 即使换了解释器也是按照 <code>第一个参数是临时变量,第二个参数是键名索引, 第三个参数是下标索引, in 后面是数据源</code>的规则解释.</li><li>哪个元素要被循环渲染就写在哪个元素里作为它的属性.</li></ul><p>作用: 将对象里的每一个属性(键值对)的值渲染到标签的插值[^7]中.</p><blockquote><p>形式:  v-for=” n in range”</p><p>值: </p><ul><li>n -&gt; 别名, 遍历时的临时变量</li><li>range -&gt; 数据源, 遍历的范围</li></ul></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;n in 10&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示结果 ==&gt;&gt;</p><p>1 2 3 4 5 6 7 8 9 10</p><h3 id="v-for-和-v-if-一起用时"><a href="#v-for-和-v-if-一起用时" class="headerlink" title="v-for 和 v-if 一起用时"></a>v-for 和 v-if 一起用时</h3><p>尽量不要把v-for 和 v-if 放在同一个标签里</p><blockquote><p>但他们处在同一个标签内时, v-for 的优先级比 v-if 高</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--尽量不要--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--上面是特殊情况下的写法,  下面是正常情况下的规范写法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;todos.length&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No todos left!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>[^1]:渲染, 加载完DOM树之后就开始在页面上加载, 这个过程叫做渲染<br>[^2]:加载, 当浏览器接收到服务器返回的html文件时, 会读取所有html标签形成一颗DOM树[^3]<br>[^3]:DOM树, 全部html标签的树状结构<br>[^4]:display: block<br>[^5]:如果是字符串就,第一位就是第一个字符; 如果是数字,第一位就是最大位的那个数字, 比如39的第一位是3<br>[^6]:对象中的属性都是键值对, 属性的下标从0开始, 先定义的属性(键值对)下标就靠前<br>[^7]:插值, HTML标签中间用 <code>&#123;&#123; 插值 &#125;&#125;</code> 包起来的地方</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全站变灰的实现</title>
      <link href="posts/43293.html"/>
      <url>posts/43293.html</url>
      
        <content type="html"><![CDATA[<h1 id="哀悼日-全站变灰的实现"><a href="#哀悼日-全站变灰的实现" class="headerlink" title="哀悼日-全站变灰的实现"></a>哀悼日-全站变灰的实现</h1><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个关心家国大事的青年，在国家有难时因争相出手付出举手之劳，虽然现在时和平年代，但是也会经历 918公祭日、哀悼日等。</p><p>每到这些日子，警报响彻神州, 江水呜咽，山川悲鸣; 大江南北，长城内外，国家以最高的祭奠向英雄哀悼，人民以最深的怀念为英雄送行。</p><p>除了现场祭奠，线上我们也想表达自己对那些烈士、英雄和逝世同胞的深切哀悼，那么可以通过全站变灰的方式，遮去往日绚烂的色彩，跳脱的动效为他们沉寂。</p><p>下面将介绍如何让全站变灰。</p><h2 id="青铜操作"><a href="#青铜操作" class="headerlink" title="青铜操作"></a>青铜操作</h2><p>作为 <code>铂金CV工程师</code> </p><div class="note green"><p>先来一顿 青铜段 操作:</p></div><ol><li>用最广告的引擎搜索: <code>全站变灰</code></li><li>点进广告最多的论坛, 将关键代码进行数据读取: <code>Ctrl + C</code></li><li>来到自己的站点启动全站检测: <code>F12</code></li><li>找到html标签, 在style面板中进行数据写入: <code>Ctrl + V</code></li></ol><p>完美~</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Mourn/grey.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Mourn/grey.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="全站变灰"></p><h2 id="白银操作"><a href="#白银操作" class="headerlink" title="白银操作"></a>白银操作</h2><div class="note gray"><p>接下来就要进行 白银段 操作了:</p></div><p>这里我用的是<a href="https://volantis.js.org/">Volantis</a>这个主题, 你要找到你自己主题里生成 <code>&lt;head&gt;&lt;/head&gt;</code>标签的那个文件.</p><ol><li><p>进入网站根目录, 找到 themes\volantis\layout_partial\head.ejs</p></li><li><p>在 <code>&lt;head&gt;&lt;/head&gt;</code> 标签内添加</p><figure class="highlight css"><figcaption><span>themes\volantis\layout\_partial\head.ejs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">    -moz-<span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">    -ms-<span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">    -o-<span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">    <span class="attribute">filter</span>: progid:DXImageTransform.Microsoft.<span class="built_in">BasicImage</span>(grayscale=<span class="number">1</span>);</span><br><span class="line">    _filter: none;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>保存,推送: <code>hexo g -d</code></p></li></ol><p>做到这里其实就够了. 但是你也可以进阶一下</p><h2 id="黄金操作"><a href="#黄金操作" class="headerlink" title="黄金操作"></a>黄金操作</h2><div class="note yellow"><p>再来顿 黄金段 操作:</p></div><ol><li><p>在刚刚添加 <code>&lt;style&gt;...&lt;/style&gt;</code> 标签外面再套上一句ejs的判断语句</p><figure class="highlight css"><figcaption><span>themes\volantis\layout\_partial\head.ejs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line marked">&lt;% if (theme<span class="selector-class">.style</span><span class="selector-class">.mourn</span>) &#123; %&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    -webkit-<span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">    -moz-<span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">    -ms-<span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">    -o-<span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">    <span class="attribute">filter</span>: progid:DXImageTransform.Microsoft.<span class="built_in">BasicImage</span>(grayscale=<span class="number">1</span>);</span><br><span class="line">    _filter: none;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line marked">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></li><li><p>在你的主题目录的配置文件 <code>themes\volantis\_config.yml</code> 中, </p></li><li><p>添加 <code>mourn: true</code></p><figure class="highlight yaml"><figcaption><span>themes\volantis\_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">style:</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line marked">    <span class="attr">mourn:</span> <span class="literal">true</span>    <span class="comment"># 哀悼: 全站变灰</span></span><br></pre></td></tr></table></figure></li><li><p>保存,推送: <code>hexo g -d</code></p></li></ol><p>这样当你要关掉的时候就不用再跑去head.ejs中删除了, 直接在主题配置文件中把<code>mourn: false</code> 就行了. </p><span class='p green'>开启 -> mourn: true</span> <span class='p red'>关闭 -> mourn: false</span> <p>也可以把mourn放到最外层, 只要让 <code>mourn字段</code> 前面没有空格就行, 相应的 <code>&lt;% if (theme.style.mourn) &#123; %&gt;</code> 要改成 <code>&lt;% if (theme.mourn) &#123; %&gt;</code></p><p>这是yaml的语法, 不懂的<a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html">出门左转</a></p><h2 id="铂金操作"><a href="#铂金操作" class="headerlink" title="铂金操作"></a>铂金操作</h2><div class="note cyan"><p>最后是 铂金段 操作</p></div><p>推送毕竟需要时间, 如果我们想要实现准时准点时间一到自动全站变灰,那就要升级下操作了.<br>只需要把刚刚的代码修改一下.</p><figure class="highlight css"><figcaption><span>themes\volantis\layout\_partial\head.ejs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line marked">&lt;% if (theme<span class="selector-class">.style</span><span class="selector-class">.mourn</span><span class="selector-class">.switch</span>)&#123; %&gt;</span><br><span class="line marked">&lt;%  <span class="selector-tag">var</span> startTime = Date<span class="selector-class">.parse</span>(theme<span class="selector-class">.style</span><span class="selector-class">.mourn</span><span class="selector-class">.startTime</span><span class="selector-class">.replace</span>(/-/g, &quot;/&quot;));  %&gt;</span><br><span class="line marked">&lt;%  <span class="selector-tag">var</span> endTime = Date<span class="selector-class">.parse</span>(theme<span class="selector-class">.style</span><span class="selector-class">.mourn</span><span class="selector-class">.endTime</span><span class="selector-class">.replace</span>(/-/g, &quot;/&quot;));     %&gt;</span><br><span class="line marked">&lt;%  <span class="selector-tag">var</span> currentTime = Date<span class="selector-class">.now</span>(); %&gt;</span><br><span class="line marked">&lt;% &#125; %&gt;</span><br><span class="line marked">&lt;% if (currentTime &gt; startTime &amp;&amp; currentTime &lt; endTime) &#123; %&gt;</span><br><span class="line marked">    &lt;style&gt;</span><br><span class="line">      <span class="selector-tag">html</span> &#123;</span><br><span class="line">        -webkit-<span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">        -moz-<span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">        -ms-<span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">        -o-<span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line">        <span class="attribute">filter</span>: progid:DXImageTransform.Microsoft.<span class="built_in">BasicImage</span>(grayscale=<span class="number">1</span>);</span><br><span class="line">        _filter: none;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>然后配置中改成:</p><figure class="highlight yaml"><figcaption><span>themes\volantis\_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">style:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">mourn:</span>  <span class="comment"># 哀悼: 全站变灰</span></span><br><span class="line marked">    <span class="attr">switch:</span> <span class="literal">true</span></span><br><span class="line marked">    <span class="attr">startTime:</span> <span class="string">&#x27;2020-4-4 0:0:0&#x27;</span></span><br><span class="line marked">    <span class="attr">endTime:</span> <span class="string">&#x27;2020/4/5 0:0:0&#x27;</span></span><br></pre></td></tr></table></figure><p>这样只需要填写好开启关闭的时间, 然后打开开关<span class='p green'>switch: true</span>即可</p><div class="note guide red"><ol><li>日期用-或者/分隔都可以, 因为ejs中有做格式化</li><li>时间一定要用(英文)冒号:分隔</li><li>日期和时间之间要有空格隔开</li><li>个位数不要添加前缀, 比如凌晨三点要写 3:0:0, 不要写成 <del>03:00:00</del></li></ol></div><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>之前配置主题的时候小心翼翼, 生怕一不小心弄错了就头大.<br>折腾了一段时间积攒了一些经验</p><div class="note guide blue"><p class='p subtitle'>一. 边预览边修改</p>1. 可以使用命令<span class='p blue'>hexo s</span> 开启本地预览, 在浏览器输入<span class='p cyan'>localhost:4000</span>开启本地预览2. 开启后cmd窗口放在一旁, 在编辑器中做修改, hexo server 一直监听着变化, 每次保存都会自动编译3. 只需要在浏览器里刷新一下就可以看到结果. 有什么编译错误cmd窗口里也会实时的显示出来.<p class='p subtitle'>二. 学会看报错信息</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Mourn/debug1.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Mourn/debug1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Debug"><br><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Mourn/debug2.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Mourn/debug2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Debug"></p><p>常见的报错信息就那么几个单词, 不懂的翻译一下, 知道错在哪里, 然后思考为什么会错误, 一步步修改, 慢慢的一点点积累就会成长.</p><p class='p subtitle'>三. YAML是个好东西</p>掌握了yaml语法以后, 就可以自由的添加自己想要的配置.就上面的修改全站变灰为例, 说白了就是找到自己想要的效果的代码, 然后在ejs里做判断, ejs和yaml配合, 就可以作出自己想要的效果了.</div>]]></content>
      
      
      <categories>
          
          <category> HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> YAML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Electron Note</title>
      <link href="posts/34681.html"/>
      <url>posts/34681.html</url>
      
        <content type="html"><![CDATA[<p>Note</p><span id="more"></span><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>在项目文件夹下新建两个文件:  <code>main.html</code> &amp; <code>main.js</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--main.html--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">        Hello World !</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> electron = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>);  <span class="comment">// 引入electron模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = electron.app;  <span class="comment">// 创建electron引用</span></span><br><span class="line"><span class="keyword">const</span> BrowserWindow = electron.BrowserWindow; <span class="comment">// 创建窗口引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mainWindow = <span class="literal">null</span>; <span class="comment">// 声明要打开的主窗口</span></span><br><span class="line"></span><br><span class="line">app.on(<span class="string">&#x27;ready&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    mainWindow = <span class="keyword">new</span> BrowserWindow(&#123; <span class="comment">// 设置打开的窗口大小</span></span><br><span class="line">        <span class="attr">width</span>: <span class="number">800</span>,</span><br><span class="line">        <span class="attr">heigth</span>: <span class="number">500</span></span><br><span class="line">    &#125;);</span><br><span class="line">    mainWindow.loadFile(<span class="string">&#x27;main.html&#x27;</span>); <span class="comment">// 加载html页面</span></span><br><span class="line">    mainWindow.on(<span class="string">&#x27;closed&#x27;</span>, <span class="function">() =&gt;</span> &#123;<span class="comment">// 监听窗口关闭事件</span></span><br><span class="line">        mainWindow = <span class="literal">null</span><span class="comment">// 一定要把窗口设置为null,否则会一直占内存</span></span><br><span class="line">    &#125;);<span class="comment">// 如同C语言申请内存后一定要free释放内存</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后打开cmd命令行, cd到项目的根目录, 执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>项目根目录就会生成一个 <code>package.json</code> 文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Hello-World&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;electron .&quot;</span><span class="comment">// 这句要自己添加</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在 <code>cmd命令行</code> 中执行命令来启动项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start 或者 electron .</span><br></pre></td></tr></table></figure><p>效果如下:</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Electron-Note/1.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Electron-Note/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Hello world"></p><p>也可以自己添加 <code>main.css</code> 编写样式, 让界面更好看.</p><p>所有命名不固定.</p><h1 id="主进程与渲染进程"><a href="#主进程与渲染进程" class="headerlink" title="主进程与渲染进程"></a>主进程与渲染进程</h1><h3 id="主进程"><a href="#主进程" class="headerlink" title="主进程"></a>主进程</h3><ol><li><p>Electron 运行 <code>package.json</code> 的 <code>main属性</code> 的进程被称为主进程</p></li><li><p>每个应用只有一个主进程</p></li><li><p><strong>作用</strong>:</p><ol><li>管理原生GUI , 典型的窗口(BrowserWindow , Tray, Dock, Menu)</li><li>创建渲染进程</li><li>控制应用生命周期 (app)</li></ol></li><li><p><strong>模块</strong>:</p><ol><li>**(常用): **app , BrowserWindow , ipcMain , Menu , Tray , MenuItem , dialog , Notification , webContents , autoUpdater , globalShortcut , <strong>clipboard , crashReporter</strong></li><li>SystemPreferences , TouchBar , netLog , powerMonitor , inAppPurchase , net , powerSaveBlocker , contentTracing , BrowserView ,  session , protocol , Screen , <strong>shell , nativelmage</strong></li></ol></li></ol><h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3><ol><li>展示web页面的进程称为渲染进程</li><li>一个应用可以有多个渲染进程</li><li><strong>作用</strong>: 通过Node.js,  Electron提供的API可以跟系统底层打交道</li><li><strong>常用模块</strong>: <ol><li>**(常用): **ipcRenderer , remote , desktopCapture , <strong>clipboard , crashReporter</strong> </li><li>webFrame , <strong>shell , nativelmage</strong></li></ol></li></ol><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>通信工具: <strong>IPC通信模块</strong></p><ul><li>Electron 提供了IPC通信模块, 主进程的 <code>ipcMain</code> 和渲染进程的 <code>ipcRenderer</code> </li><li><code>ipcMain</code> 和 <code>ipcRenderer</code> 都是<code>EventEmitter</code> 对象</li></ul><h3 id="从渲染进程到主进程-render-to-main"><a href="#从渲染进程到主进程-render-to-main" class="headerlink" title="从渲染进程到主进程 (render to main)"></a>从渲染进程到主进程 (render to main)</h3><ul><li>Callbake写法:<ul><li>ipcRenderer.send( channer, …args)      // 渲染进程中发送</li><li>ipcMain.on(channel, handler)                // 主进程中响应</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Render-process.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;ipcRenderer&#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>);</span><br><span class="line">ipcRenderer.send(<span class="string">&#x27;通信频段名&#x27;</span>, <span class="number">0</span>或N个参数);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Main-process.js</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleIPC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ipcMain.on(<span class="string">&#x27;通信频段名&#x27;</span>, <span class="function">(<span class="params">err, <span class="number">0</span>或N个参数</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something to reply</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(handleIPC, <span class="number">500</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>Promise写法 (Electron 7.0之后, 处理请求 + 响应模式):<ul><li>ipcRenderer.invoke(channel, …args)    // 渲染进程中发送</li><li>ipcMain.handle(channel, handler)        // 主进程中响应</li></ul></li></ul><h3 id="从主进程到渲染进程-main-to-render"><a href="#从主进程到渲染进程-main-to-render" class="headerlink" title="从主进程到渲染进程 (main to render)"></a>从主进程到渲染进程 (main to render)</h3><ul><li>ipcRenderer.on(channel, handler)    // 渲染进程中响应</li><li>webContents.send(channel)              // 主进程中发送</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main-process.js</span></span><br><span class="line">...</span><br><span class="line">mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;......&#125;);</span><br><span class="line">mainWindow.webContents.send(<span class="string">&#x27;通信频段名&#x27;</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Render-process.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;ipcRenderer&#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>);</span><br><span class="line">ipcRenderer.on(<span class="string">&#x27;通信频段名&#x27;</span>, <span class="function">(<span class="params">err, <span class="number">0</span>或N个参数</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something to reply</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="从渲染进程到渲染进程-render-to-render-页面间通信"><a href="#从渲染进程到渲染进程-render-to-render-页面间通信" class="headerlink" title="从渲染进程到渲染进程 (render to render)   页面间通信"></a>从渲染进程到渲染进程 (render to render)   页面间通信</h3><p>页面之间的通信主要做两件事情: 1. 通知事件;  2. 数据共享</p><h4 id="通知事件"><a href="#通知事件" class="headerlink" title="通知事件"></a>通知事件</h4><ul><li>ipcRenderer.sendTo( webContentsId, channel, …args )</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main-process.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;app, BrowserWindow, Notification, ipcMain&#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> win1 = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> win2 = <span class="literal">null</span>;</span><br><span class="line">app.on(<span class="string">&#x27;ready&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    win1 = <span class="keyword">new</span> BrowserWindow(&#123; </span><br><span class="line">        <span class="attr">width</span>:<span class="number">500</span>, </span><br><span class="line">        <span class="attr">heigth</span>:<span class="number">500</span>, </span><br><span class="line">        <span class="attr">webPreferences</span>:&#123;<span class="attr">nodeIntegration</span>:<span class="literal">true</span>&#125; </span><br><span class="line">    &#125;);</span><br><span class="line">    win1.loadFile(<span class="string">&#x27;./win1.html&#x27;</span>);</span><br><span class="line">    win2 = <span class="keyword">new</span> BrowserWindow(&#123; </span><br><span class="line">        <span class="attr">width</span>:<span class="number">500</span>, </span><br><span class="line">        <span class="attr">heigth</span>:<span class="number">500</span>, </span><br><span class="line">        <span class="attr">webPreferences</span>:&#123;<span class="attr">nodeIntegration</span>:<span class="literal">true</span>&#125; </span><br><span class="line">    &#125;);</span><br><span class="line">    win2.loadFile(<span class="string">&#x27;./win2.html&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">global</span>.sharedObject = &#123; <span class="attr">win2WebContentsId</span>: win2.webContents.id &#125;<span class="comment">//把win2的id放在全局对象中</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render1-process.js</span></span><br><span class="line"><span class="comment">// sender</span></span><br><span class="line"><span class="keyword">const</span> &#123;ipcRenderer, remote&#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> win2Id = remote.getGlobal(<span class="string">&#x27;sharedObject&#x27;</span>).win2WenContentsId<span class="comment">//获取win2的id</span></span><br><span class="line">ipcRenderer.sendTo(win2Id, <span class="string">&#x27;通信频段名&#x27;</span>, <span class="number">0</span>或N个参数)<span class="comment">// 与win2进行通信</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render2-process.js</span></span><br><span class="line"><span class="comment">// responser</span></span><br><span class="line"><span class="keyword">const</span> &#123;ipcRenderer&#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line">ipcRenderer.on(<span class="string">&#x27;通信频段名&#x27;</span>, <span class="function">(<span class="params">err, <span class="number">0</span>或N个参数</span>) =&gt;</span> &#123;<span class="comment">// 响应</span></span><br><span class="line">    <span class="comment">// do something to reply</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h4><ul><li>使用web技术( localStorage , sessionStorage , indexedDB )</li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><h4 id="渲染进程的调试"><a href="#渲染进程的调试" class="headerlink" title="渲染进程的调试"></a>渲染进程的调试</h4><ol><li>用代码打开 Chromiun的开发者工具</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> win = <span class="keyword">new</span> BrowserWindow();</span><br><span class="line">win.webContents.openDevTools();</span><br></pre></td></tr></table></figure><ol start="2"><li>输入命令行 <code>electron .</code> 之后, 在窗口按下快捷键 <code>Ctrl + Shift + i</code></li></ol><h4 id="主进程的调试"><a href="#主进程的调试" class="headerlink" title="主进程的调试"></a>主进程的调试</h4><p>Electron 主进程是一个 Node.js 进程。Node.js 在 8 之后引入了 <code>--inspect</code> 参数用于调试，同样也适用于 Electron 主进程：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">electron . --inspect</span><br></pre></td></tr></table></figure><p>默认会监听 9229 端口，应用启动后，在 Chrome 浏览器（或其他基于 Chromium 开发的浏览器）中打开 <code>chrome://inspect</code> 即可看到对应的调试会话，点击会话链接即可打开 devtools 进行调试。</p><p>另外，可以在命令行参数中指定端口号，实现同时调试多个应用中的多个进程而不产生冲突：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">electron . --inspect=1234</span><br></pre></td></tr></table></figure><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p>1.开启命令行开关</p><p>启动electron的时候需要带上inspect开关，并配置调试端口.</p><p>有两个开关，分别是 <code>--inspect=[port]</code> 和 <code>--inspect-brk=[port]</code>，区别在于后者会暂停在第一行js代码</p><p>这里建议在 <code>package.json</code> 的 <code>script</code> 字段添加如下内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">       <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">       <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;electron .&quot;</span>,</span><br><span class="line">       <span class="attr">&quot;debug&quot;</span>: <span class="string">&quot;electron . --inspect=5858&quot;</span>    <span class="comment">// 添加这行</span></span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure><p>2.设置chrome调试器</p><p>打开chrome，然后新开一个标签进入<a href="chrome://inspect">chrome://inspect</a> ，这里我们要先配置监听的端口，不然的话，Remote Target列表里是不会出现要调试的electron程序的</p><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Electron-Note/chrome-inspect.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Electron-Note/chrome-inspect.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="chrome://inspect"></p><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Electron-Note/chrome-port.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Electron-Note/chrome-port.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="chrome-port"></p><p>然后在项目目录下就可以直接使用命令 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run debug</span><br></pre></td></tr></table></figure><p>就可以看到如下画面:</p><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Electron-Note/chrome-run.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Electron-Note/chrome-run.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="chrome-run"></p><p>3.调试</p><p>点击 inspect 就可以进行调试了.</p><h5 id="在-VSCode-中调试"><a href="#在-VSCode-中调试" class="headerlink" title="在 VSCode 中调试"></a>在 VSCode 中调试</h5><p>上述方法均会打开 devtools 界面，所有的调试操作均在 devtools 中进行。对于某些操作比如代码断点调试，可以进一步与编辑器或 IDE 相结合，提升开发体验。以下将简要介绍如何在 VSCode 进行调试。</p><p>以 Electron 官方的模板 <a href="https://github.com/electron/electron-quick-start">electron-quick-start</a> 为例，首先需要为 VSCode 安装一个扩展：<a href="https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome">Debugger for Chrome</a>（用于调试渲染进程）。克隆代码仓库到本地并安装依赖：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/electron/electron-quick-start.git</span><br><span class="line"><span class="built_in">cd</span> electron-quick-start</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>然后在仓库中添加文件 <code>.vscode/launch.json</code>，内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Main&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;runtimeExecutable&quot;</span>: <span class="string">&quot;C:\\Users\\用户名\\AppData\\Roaming\\npm\\electron&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;runtimeArgs&quot;</span>: [<span class="string">&quot;--remote-debugging-port=9222&quot;</span>, <span class="string">&quot;.&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;windows&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;runtimeExecutable&quot;</span>: <span class="string">&quot;C:\\Users\\用户名\\AppData\\Roaming\\npm\\electron.cmd&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Renderer&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;chrome&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;attach&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;port&quot;</span>: <span class="number">9222</span>,</span><br><span class="line">      <span class="attr">&quot;webRoot&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;compounds&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;All&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;configurations&quot;</span>: [<span class="string">&quot;Main&quot;</span>, <span class="string">&quot;Renderer&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意: Windows系统的路径分隔符要写作 “\\“ </p><p>if  普通安装electron </p><p>​    then 把”用户名”改成”你系统的用户名”;</p><p>else 自定义安装electron </p><p>​    then 找到你的 electron.cmd; </p><p>​             复制路径; </p><p>​             到 json中修改;</p><p>if  Linux用户</p><p>​    then 系统.路径分隔符 = “/“</p><p>if  (项目根目录/node_modules/.bin/electron).isExist</p><p>​    then </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;runtimeExecutable&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/node_modules/.bin/electron&quot;</span>,</span><br><span class="line"><span class="string">&quot;windows&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;runtimeExecutable&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/node_modules/.bin/electron.cmd&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>然后在 VSCode 左侧选择 debug 面板，启动 <code>All</code> 这一项开始调试，此时就可以在 <code>main.js</code> 或 <code>renderer.js</code> 文件中添加断点了：</p><p>配置文件中的一些要点解释如下：</p><ol><li><code>configurations</code> 中的两项分别对应主进程和渲染进程。<code>compounds</code> 中指定了一个组合会话 <code>All</code>，选择 <code>All</code> 将会同时启动这两个会话。</li><li>Renderer 配置中的 <code>webRoot</code> 参数直接使用了 <code>$&#123;workspaceFolder&#125;</code>，是因为在这个工程中，HTML 引用的静态资源位于根目录下。实际使用的时候需要更新到对应的路径才会生效。</li><li>实际开发中可能会有编译的流程，比如使用 TypeScript 配合打包工具 Webpack，最终生成的代码与源代码并不在一个路径下。这种情况下需要产出 source map 来建立映射关系。</li></ol><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Electron-Note/debug.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Electron-Note/debug.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="debug"></p><h3 id="经验技巧"><a href="#经验技巧" class="headerlink" title="经验技巧"></a>经验技巧</h3><ul><li><p>少用remote模块</p><p>  因为每次remote会触发底层的同步IPC事件, 特别影响性能, 处理的不好容易进程卡死</p></li><li><p>不要用sync模式</p><p>  一旦写的不好就会整个应用卡死</p></li><li><p>在请求+响应的通信模式下,需要自定义超时限制</p><p>  在响应的时候需要设置一个时长限制, 当应用响应超时, 需要response一个异常的超时事件让业务处理, 然后去做对应的交互</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Electron </category>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Electron </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git-基本操作说明</title>
      <link href="posts/42006.html"/>
      <url>posts/42006.html</url>
      
        <content type="html"><![CDATA[<p>Git Yes!</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/git%E8%AF%B4%E6%98%8E.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/git%E8%AF%B4%E6%98%8E.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="git"></p><p>经典git关系图</p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>刚新建一个项目的时候需要来几条初始化命令</p><h5 id="生成本地仓库"><a href="#生成本地仓库" class="headerlink" title="生成本地仓库"></a>生成本地仓库</h5><p>git init </p><h5 id="把工作区的文件提交到暂存区"><a href="#把工作区的文件提交到暂存区" class="headerlink" title="把工作区的文件提交到暂存区"></a>把工作区的文件提交到暂存区</h5><p>git add .<br>或者<br>git add 文件名</p><h5 id="把暂存区的文件提交到本地仓库"><a href="#把暂存区的文件提交到本地仓库" class="headerlink" title="把暂存区的文件提交到本地仓库"></a>把暂存区的文件提交到本地仓库</h5><p>git commit -m “描述”<br>这里的描述就是到时候看到的下面的这些</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/1.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1"></p><h5 id="先给你要提交的远程仓库起个别名"><a href="#先给你要提交的远程仓库起个别名" class="headerlink" title="先给你要提交的远程仓库起个别名"></a>先给你要提交的远程仓库起个别名</h5><p>git remote add 仓库别名 Git地址<br>Git地址如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/2.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2"></p><h5 id="把本地仓库的文件提交到远程仓库（就是github上能看到的那种）"><a href="#把本地仓库的文件提交到远程仓库（就是github上能看到的那种）" class="headerlink" title="把本地仓库的文件提交到远程仓库（就是github上能看到的那种）"></a>把本地仓库的文件提交到远程仓库（就是github上能看到的那种）</h5><p>git push -u 仓库别名 分支名<br>分支就是….算了这里是傻瓜备忘不想解释</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/3.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="3"></p><p>到这就可以上去github看看了。文件内容都在里面</p><h2 id="第二次提交"><a href="#第二次提交" class="headerlink" title="第二次提交"></a>第二次提交</h2><p>第二次提交的时候一般不是整个项目都有变动对吧？<br>没事git会自动识别修改过的和没修改过的文件</p><h5 id="可以看看git识别到哪些"><a href="#可以看看git识别到哪些" class="headerlink" title="可以看看git识别到哪些"></a>可以看看git识别到哪些</h5><p>git status</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/gitstatus.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/gitstatus.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="gitstatus"></p><p>红色的，Umerged，表示工作区有改动的文件，还没提交到暂存区<br>git文件的四种状态</p><ul><li>untracked   未被追踪的。就是还没添加过的</li><li>unmodified 工作区里已经被追踪了，还没修改</li><li>modified     工作区的文件修改了但还没提交到暂存区</li><li>staged        添加到了暂存区倒是还没提交到远程仓库</li></ul><h5 id="把它提交到暂存区去"><a href="#把它提交到暂存区去" class="headerlink" title="把它提交到暂存区去"></a>把它提交到暂存区去</h5><p>git add .</p><h5 id="把它提交到本地仓库去"><a href="#把它提交到本地仓库去" class="headerlink" title="把它提交到本地仓库去"></a>把它提交到本地仓库去</h5><p>git commit -m “描述”</p><h5 id="把它提交到远程仓库去"><a href="#把它提交到远程仓库去" class="headerlink" title="把它提交到远程仓库去"></a>把它提交到远程仓库去</h5><p>git push -u 远程仓库别名 分支名</p><p>搞定！</p><h5 id="拉取远程仓库的文件到本地"><a href="#拉取远程仓库的文件到本地" class="headerlink" title="拉取远程仓库的文件到本地"></a>拉取远程仓库的文件到本地</h5><p>git pull 远程仓库别名 分支名</p><p>多用户共同开发的时候，新用户可能会在本地新建一个文件夹，然后git init, 接着pull<br>可能会出现拉取失败，因为git认为这是两个不同的项目，所以拒绝拉取合并，可以加上<code>--allow-unrelated-histories</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull 仓库别名 分支名 --allow-unrelated-histories</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>要把代码写完放在github上就等于 你要从山旮旯里寄东西到北京</p><p>工作区 =&gt; 就是你项目的文件夹，你经营的这家客栈<br>暂存区 =&gt; 就是你这个项目的git索引，你这个村里的驿站<br>本地仓库 =&gt; 就是你电脑里的一个存储库，你市里的驿站<br>远程仓库 =&gt; 就是github服务器上面，北京</p><p>你东西收拾好了的时候  得找村里的快递站帮你保管和寄送到市里的快递站<br><code>git add .</code><br>等你说commit的时候    市里的快递站 就给你 送到省里的快递站<br><code>git commit -m &quot;描述&quot;</code><br>等你说push的时候        省里的快递站 就给你 送到北京<br><code>git push -u 远程仓库别名 分支名</code></p><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/git%E5%B8%B8%E7%94%A8.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/git%E5%B8%B8%E7%94%A8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="GIT常用命令"></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM-配置文件</title>
      <link href="posts/25425.html"/>
      <url>posts/25425.html</url>
      
        <content type="html"><![CDATA[<p>先把配置文件捋清楚</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SSM框架中有几个比较重要的配置文件，一开始学起来会很模糊，这里做一下整理</p><blockquote><p> 当一个web程序启动时，Tomcat服务器最先会读取 <strong><code>web.xml</code></strong> 文件，这个文件中会启动一些配置，还会启动Spring配置文件**<code>applicationContext.xml</code>** 和SpringMVC配置文件 <strong><code>springMVC-servlet.xml</code></strong> 这两个文件，在运行 <strong><code>applicationContext.xml</code></strong> 的时候会启动MyBatis的配置文件 **<code>myBatis.xml</code>**，并且会调用到 <strong><code>jdbc.properties</code></strong> 和 <strong><code>log4J.properties</code></strong> 两个资源属性文件里的属性。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-config/2.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-config/2.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="SSM机制"></p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-config/J2EE.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-config/J2EE.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="J2EE"></p><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><p>接下来先看看最先启动的 <strong><code>web.xml</code></strong> 是都怎么配置。</p><p>在Spring配置中和在Servlet配置中，就启动了applicationContext 和 SpringMVC-servlet 两个配置文件</p><ul><li>启动applicationContext</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>启动SpringMVC-servlet</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--部署Servlet分发器 DispatcherServlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springer<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注册DispatcherServlet的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springer-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行到这的时候就会调用到上述两个文件。</p><p>整个文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">&quot;WebApp_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;3.1&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--以下配置的加载顺序:先 ServletContext &gt;&gt; context-param &gt;&gt; listener &gt;&gt; filter &gt;&gt; servlet &gt;&gt;  spring--&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- ==================== 欢迎页配置 ==================== --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置欢迎页--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ==================== Spring配置 ==================== --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--启动Spinrg 配置文件 applicationContext.xml--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置监听器，加载Spring 配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ==================== Serlvet配置 ==================== --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--部署Servlet分发器 DispatcherServlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springer<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注册DispatcherServlet的配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springer-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置DispatcherServlet的作用范围，这里作用于整个web目录--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springer<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ==================== 过滤器配置 ==================== --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置过编码滤器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--编码格式：UTF-8--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--是否全部过滤，包括符合格式的文件/请求--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置过滤器的作用范围，这里作用于整个WEB目录--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ==================== 错误页面配置 ==================== --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--404错误页面注册--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/WEB-INF/jsp/404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="applicationContext-xml"><a href="#applicationContext-xml" class="headerlink" title="applicationContext.xml"></a>applicationContext.xml</h3><p>这个文件是第二个启动的配置文件</p><p>在这个文件里主要做了几件事情：</p><ol><li>加载jdbc.properties资源属性文件</li><li>配置数据源</li><li>配置Mybatis工厂<ol><li>指定数据源</li><li>指定Mybatis配置文件</li></ol></li><li>批量配置Mapper接口<ol><li>设置需要扫描的dao包</li><li>配置sqlSessionFactory对象</li></ol></li><li>添加事务支持<ol><li>配置事务管理器</li><li>配置通知</li><li>配置切面</li></ol></li><li>扫描service包</li></ol><p>下面一个一个解释：</p><h4 id="1-加载jdbc-properties"><a href="#1-加载jdbc-properties" class="headerlink" title="1.加载jdbc.properties"></a>1.加载jdbc.properties</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>把连接数据库的一些数据分离出来写在jdbc.properties这个文件中，加载了这个文件就可以使用这些属性</p><p>而在 jdbc.properties 文件中的内容如下（这里演示的是MySQL8.0）:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/transactional?useSSL=false?serverTimezone=Hongkong?characterEncoding=utf-8?autoReconnect=true</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">jdbc.maxTotal</span>=<span class="string">30</span></span><br><span class="line"><span class="meta">jdbc.maxIdle</span>=<span class="string">10</span></span><br><span class="line"><span class="meta">jdbc.initialSize</span>=<span class="string">5</span></span><br></pre></td></tr></table></figure><p>至于如何调用，则在下面的配置数据源中演示</p><h4 id="2-配置数据源"><a href="#2-配置数据源" class="headerlink" title="2.配置数据源"></a>2.配置数据源</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp2.BasicDataSource&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 最大连接数 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.maxTotal&#125;&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 最大空闲连接数 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.maxIdle&#125;&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 初始化连接数 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.initialSize&#125;&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面已经加载了jdbc.properties，所以在配置数据源的时候直接用 <strong><code>$&#123;属性名&#125;</code></strong> 就可以使用该属性。这样做的好处是，在多处调用 <code>jdbc.properties</code> 里的那些属性的时候，如果要该一个属性比如数据库密码，只需要修改jdbc.properties 中的 jdbc.password 的值就行了。</p><h4 id="3-配置Mybatis工厂"><a href="#3-配置Mybatis工厂" class="headerlink" title="3.配置Mybatis工厂"></a>3.配置Mybatis工厂</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4<span class="comment">&lt;!-- 配置MyBatis工厂，同时指定数据源，并与MyBatis完美整合 --&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--指定数据源--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dSource&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- configLocation的属性值为MyBatis的核心配置文件 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意指定数据源的 <code>&lt;property&gt;</code> 标签中的 <code>ref</code> 属性，要和数据源的 id 对应</p><p>在第二个 <code>&lt;property&gt;</code>  中指定和启动了Mybatis的配置文件</p><h4 id="4-配置数据映射接口"><a href="#4-配置数据映射接口" class="headerlink" title="4.配置数据映射接口"></a>4.配置数据映射接口</h4><p>数据映射接口，也就是dao，通过Mybatis配置文件映射到数据库操作文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!-- mybatis-spring组件的扫描器 ，必须写全dao的包名，且只能扫描一个dao包 --&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dao&quot;</span>/&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置以后，Spring会自动扫描MyBatis的接口并装配（Spring将指定包中所有被@Mapper注解标注的接口自动装配为MyBatis的映射接口）</p><p>在Eclipse中的进行项目的话要写全dao 的包名，比如 com.github.java.dao 这样，而在IDEA中一般会配置好项目的source root 根目录 和 resource root 资源目录，所以写dao包名就好。</p><p>例如我的目录结构，我设置了java为source root 根目录，所以不用写全包名</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-config/3.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-config/3.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="3"></p><h4 id="5-添加事务支持"><a href="#5-添加事务支持" class="headerlink" title="5.添加事务支持"></a>5.添加事务支持</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">4<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启事务注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>事务支持有很多种方法，这种是基于@Transactional注解的事务管理。</p><p>还有一种是声明式事务管理</p><h4 id="6-扫描service包"><a href="#6-扫描service包" class="headerlink" title="6.扫描service包"></a>6.扫描service包</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;service&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="完整文件"><a href="#完整文件" class="headerlink" title="完整文件"></a>完整文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line">4</span><br><span class="line">    <span class="comment">&lt;!--=================== 加载jdbc.properties ===================--&gt;</span></span><br><span class="line">4<span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--======================== 配置数据源 ========================--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp2.BasicDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxTotal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.maxTotal&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大空闲连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxIdle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.maxIdle&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 初始化连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;initialSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.initialSize&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--======================== 配置MyBatis工厂 ========================--&gt;</span></span><br><span class="line">4<span class="comment">&lt;!-- 配置MyBatis工厂，同时指定数据源，并与MyBatis完美整合 --&gt;</span></span><br><span class="line">4<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">44<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">44<span class="comment">&lt;!-- configLocation的属性值为MyBatis的核心配置文件 --&gt;</span></span><br><span class="line">44<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/mybatis/mybatis-config.xml&quot;</span> /&gt;</span></span><br><span class="line">4<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--======================== Mapper代理 ========================--&gt;</span></span><br><span class="line">    </span><br><span class="line">4<span class="comment">&lt;!--Mapper代理开发，使用Spring自动扫描MyBatis的接口并装配（Spring将指定包中所有被@Mapper注解标注的接口自动装配为MyBatis的映射接口） --&gt;</span></span><br><span class="line">4<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">44<span class="comment">&lt;!-- mybatis-spring组件的扫描器 ，必须写全dao的包名，且只能扫描一个dao包 --&gt;</span></span><br><span class="line">44<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.dao&quot;</span> /&gt;</span></span><br><span class="line">44<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line">4<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">4<span class="comment">&lt;!--======================== 扫描Service包 ========================--&gt;</span></span><br><span class="line">    </span><br><span class="line">4<span class="comment">&lt;!-- dao包在mybatis-spring组件中已经扫描，这里不再需要扫描 --&gt;</span></span><br><span class="line">4<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.service&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--======================== 配置事务支持 ========================--&gt;</span></span><br><span class="line">    </span><br><span class="line">4<span class="comment">&lt;!-- 添加事务支持 --&gt;</span></span><br><span class="line">4<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">44<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">4<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">4<span class="comment">&lt;!-- 开启事务注解 --&gt;</span></span><br><span class="line">4<span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SpringMVC-servlet-xml"><a href="#SpringMVC-servlet-xml" class="headerlink" title="SpringMVC-servlet.xml"></a>SpringMVC-servlet.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;converter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;formatter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;utils&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;po&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/**&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/html/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/html/**&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">&quot;/images/&quot;</span> <span class="attr">mapping</span>=<span class="string">&quot;/images/**&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--==================== 配置视图解析器 ====================--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--==================== 注册类型转换器 ====================--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;converter.GoodsConverter&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--启动类型转换器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--==================== 注册格式化转换器 ====================--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;formattingConversionService&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;formatters&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;formatter.GoodsFormatter&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--启动格式化转换器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;formattingConversionService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--==================== 配置校验器 ====================--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置错误消息资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;msgSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basenames&quot;</span> <span class="attr">value</span>=<span class="string">&quot;errorMessages&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--资源文件编码格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;fileEncodings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--对资源文件内容缓存时间，单位秒--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cacheSeconds&quot;</span> <span class="attr">value</span>=<span class="string">&quot;120&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注册校验器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;validator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--hibernate校验器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;providerClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.hibernate.validator.HibernateValidator&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定校验使用的资源为将，在文件中配置校验错误信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;validationMessageSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;msgSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--启动spring的valid校验功能--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">validator</span>=<span class="string">&quot;validator&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--==================== 配置拦截器 ====================--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;bean class=&quot;interceptor.AllInterceptor&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;interceptor.Interceptor1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/five&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;interceptor.Interceptor2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--==================== 配置文件上传和下载 ====================--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:defaultEncoding</span>=<span class="string">&quot;UTF-8&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:maxUploadSize</span>=<span class="string">&quot;5400000&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:uploadTempDir</span>=<span class="string">&quot;fileUpload/temp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--==================== 配置异常处理 ====================--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用@ExceptionHandler注解时注释掉，因为@ExceptionHandler注解方法不能有任何配置--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--统一异常处理，托管MyExceptionHandler--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean class=&quot;exception.MyExceptionHandler&quot;/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--统一异常处理，使用SimpleMappingExceptionResolver异常处理器处理异常--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&amp;lt;!&amp;ndash;定义默认的异常处理页面，当该异常类型注册时使用&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;defaultErrorView&quot; value=&quot;error&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&amp;lt;!&amp;ndash;定义异常处理页面用来获取异常信息的变量名，默认名为exception&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&amp;lt;!&amp;ndash;定义需要特殊处理的异常，用类名活完全路径名为key，异常页名为值&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;exceptionMappings&quot;&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;props&gt;--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&lt;prop key=&quot;exception.MyException&quot;&gt;my-error&lt;/prop&gt;--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&lt;prop key=&quot;java.sql.SQLException&quot;&gt;sql-error&lt;/prop&gt;--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&amp;lt;!&amp;ndash;这里还可以继续扩展对不同异常类型的处理&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;/props&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;/property&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/bean&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SSM </tag>
            
            <tag> SSM配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM-8-Spring事务管理</title>
      <link href="posts/3844.html"/>
      <url>posts/3844.html</url>
      
        <content type="html"><![CDATA[<p>有了事务好管理</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>事务：也就是一个用户操作中，需要包含哪些具体操作。这些操作集合在一起，就是事务。这些操作必须是具体的，必要的，不可分割的。要么全部完成，要么全部失败。</p><p>比如你给你朋友转账1000块的操作，分成几个步骤就是：</p><ol><li>自己的账户扣1000块钱</li><li>对方的账户加1000块钱</li><li>把这笔转账行为记录在服务器中</li></ol><p>这三个步骤就具备了<strong>原子性，一致性，隔离性，持久性</strong>。</p><p>原子性：<strong>要么全部完成，有一个完成不了就全部回滚。</strong>比如自己的账户扣钱成功，但是对方的账户加钱失败，那么就回滚，自己的账户的钱恢复到转账钱的余额。</p><p>一致性： <strong>一致性代表了底层数据存储的完整性。</strong>例如你转账给朋友1000块，那你的账户要扣1000块，你朋友的账户得增加1000块，如果只增加了500块，那就是不一致。</p><p>隔离性：<strong>隔离性意味着事务必须在不干扰其他进程或事务的前提下独立执行。</strong>也就是，在事务或工作单元执行完毕之前，其所访问的数据不能受系统其他部分的影响。比如你在给朋友转账的时候，别人给你转账是转不了的。因为要确保你的账户的隔离。</p><p>持久性：<strong>持久性表示在某个事务的执行过程中，对数据所作的所有改动都必须在事务成功结束前保存至某种物理存储设备。</strong>转账后要把这次转账记录在服务器里，不管过了多久都可以查。</p><p>事务的三个主要方法：<code>开启事务 BeginTranscation()</code>，<code>提交 commit()</code> ，<code>回滚 rollback()</code></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SSM </tag>
            
            <tag> 事务管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM-7-统一异常处理</title>
      <link href="posts/59097.html"/>
      <url>posts/59097.html</url>
      
        <content type="html"><![CDATA[<p>遇到异常不要慌～</p><span id="more"></span><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>程序运行过程中总会遇到一些可预知的，不可预知的异常。如果不对这些异常进行捕捉和处理，就会导致程序崩溃、停止运行、闪退等诸多令人体验极差的现象。如果对这些异常一个一个单独处理，则代码显得很臃肿，耦合度高（独立性差），所以要用统一异常处理对所有的代码进行异常处理</p><p>SpringMVC处理异常有三种方式：</p><ol><li>简单异常处理SimpleMappingExceptionResolver</li><li>实现HandlerExceptionResolver接口自定义异常</li><li>使用@ExceptionHandler注解实现异常处理</li></ol><p>在程序中可能出现异常的地方进行捕捉，程序发生异常被捕捉到后，就会调用我们编写的统一异常处理类进行处理</p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-7/1.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-7/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1"></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>由于我们太完美了程序暂时没有什么异常，所以我们得自己制造点异常。</p><p>我们先做一个列表，把控制层，业务层，模型层的各种异常集中链接在这里。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String path = request.getContextPath();</span><br><span class="line">    String basePath = request.getScheme() + <span class="string">&quot;://&quot;</span> + request.getServerName() + <span class="string">&quot;:&quot;</span> + request.getServerPort() + path + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;base href=<span class="string">&quot;&lt;%=basePath%&gt;&quot;</span>/&gt;</span><br><span class="line">    &lt;title&gt;Exception&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;body&quot;</span>&gt;</span><br><span class="line">    &lt;h3&gt;&lt;a href=<span class="string">&quot;db&quot;</span>&gt;控制器中数据库异常&lt;/a&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;h3&gt;&lt;a href=<span class="string">&quot;my&quot;</span>&gt;控制器中自定义异常&lt;/a&gt;&lt;/h3&gt;</span><br><span class="line">    &lt;h3&gt;&lt;a href=<span class="string">&quot;no&quot;</span>&gt;控制器中未知异常&lt;/a&gt;&lt;/h3&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-7/2.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-7/2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2"></p><p>这些链接点击后跳转到控制层里进行处理。而程序不会无端端的就异常，所以我们得先在控制器里弄点异常：自己<strong>主动</strong>抛出一个<em>异常</em> 。</p><h3 id="先主动搞个异常"><a href="#先主动搞个异常" class="headerlink" title="先主动搞个异常"></a>先主动搞个异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;控制器中数据库异常&quot;</span>);</span><br></pre></td></tr></table></figure><p>这句话就是主动抛出一个异常。</p><p>整体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span></span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/db&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">db</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;控制器中数据库异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/my&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">my</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">&quot;控制器中自定义异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/no&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">no</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;控制器中未知异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了制造好了异常，现在开始来处理。一共有三种方法</p><h3 id="实现HandlerExceptionResolver接口"><a href="#实现HandlerExceptionResolver接口" class="headerlink" title="实现HandlerExceptionResolver接口"></a>实现HandlerExceptionResolver接口</h3><h4 id="1-编写一个类实现HandlerExceptionResolver接口"><a href="#1-编写一个类实现HandlerExceptionResolver接口" class="headerlink" title="1.编写一个类实现HandlerExceptionResolver接口"></a>1.编写一个类实现HandlerExceptionResolver接口</h4><p>异常抛出后，就会被捕捉，捕捉后就要进行处理啦。我们编写一个类，这个类要实现 <code>HandlerExceptionResolver接口</code>里的 <code>resolveException()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionHandler</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写接口方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg0 servlet请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg1 servlet响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj  目标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex   异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回相应的视图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object obj, Exception ex)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; model = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        model.put(<span class="string">&quot;ex&quot;</span>, ex);</span><br><span class="line">        <span class="comment">// 根据不同错误转向不同页面（统一处理），即异常与view的对应关系</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果异常属于自定义异常类型</span></span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> MyException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">&quot;exception/my-error&quot;</span>, model);</span><br><span class="line">            <span class="comment">// 如果异常属于数据库异常类型</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> SQLException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">&quot;exception/sql-error&quot;</span>, model);</span><br><span class="line">            <span class="comment">// 如果异常属于未知类型</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">&quot;exception/error&quot;</span>, model);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制层里制造了三种不同的异常 ，这些异常被捕捉后会被送到这里进行处理。这里主要就是根据异常的不同类型返回不同的视图页面。</p><h3 id="3-在SpringMVC配置文件中配置"><a href="#3-在SpringMVC配置文件中配置" class="headerlink" title="3. 在SpringMVC配置文件中配置"></a>3. 在SpringMVC配置文件中配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;exception.MyExceptionHandler&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用-ExceptionHandler注解实现异常处理"><a href="#使用-ExceptionHandler注解实现异常处理" class="headerlink" title="使用@ExceptionHandler注解实现异常处理"></a>使用@ExceptionHandler注解实现异常处理</h3><p>这种是最容易的一种方式，集成简单，扩展性好。</p><h4 id="1-创建一个BaseController类"><a href="#1-创建一个BaseController类" class="headerlink" title="1.创建一个BaseController类"></a>1.创建一个BaseController类</h4><p>创建一个抽象类，并在类中使用@ExceptionHandler注解声明异常处理方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常处理方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request Servlet请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex 异常实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个视图页面的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">exception</span><span class="params">(HttpServletRequest request, Exception ex)</span></span>&#123;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;ex&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> SQLException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;404&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( ex <span class="keyword">instanceof</span> MyException) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;exception/my-error&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;exception/error&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-让其他控制器继承这个类"><a href="#2-让其他控制器继承这个类" class="headerlink" title="2.让其他控制器继承这个类"></a>2.让其他控制器继承这个类</h4><p>让其他需要处理异常的类继承这个BaseController类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionController</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-注意使用这种方法是配置文件中不要配置任何其他异常处理方法。"><a href="#3-注意使用这种方法是配置文件中不要配置任何其他异常处理方法。" class="headerlink" title="3. 注意使用这种方法是配置文件中不要配置任何其他异常处理方法。"></a>3. 注意使用这种方法是配置文件中不要配置任何其他异常处理方法。</h4><p><strong>注意使用这种方法是配置文件中不要配置任何其他异常处理方法！！！</strong></p><p><strong>注意使用这种方法是配置文件中不要配置任何其他异常处理方法！！！</strong></p><p><strong>注意使用这种方法是配置文件中不要配置任何其他异常处理方法！！！</strong></p><h3 id="简单异常处理SimpleMappingExceptionResolver"><a href="#简单异常处理SimpleMappingExceptionResolver" class="headerlink" title="简单异常处理SimpleMappingExceptionResolver"></a>简单异常处理SimpleMappingExceptionResolver</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--定义默认的异常处理页面，当该异常类型注册时使用--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultErrorView&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--定义异常处理页面用来获取异常信息的变量名，默认名为exception--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--定义需要特殊处理的异常，用类名活完全路径名为key，异常页名为值--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;exception.MyException&quot;</span>&gt;</span>my-error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.sql.SQLException&quot;</span>&gt;</span>sql-error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--这里还可以继续扩展对不同异常类型的处理--&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<strong>SpringMVC配置文件</strong>中配置 <code>SimpleMappingExceptionResolver异常处理器</code> ，即可实现对异常的统一处理。</p><p>主要分默认异常处理页面，获取异常信息的变量名，还有一些需要特殊处理的异常。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最简单的使用@ExceptionHandler注解的方法，虽然有集成简单，可扩展性好等优点，但是该方法对已有代码存在入侵性，需要修改已有代码，是相关类继承于BaseController。</p><p>而第一种写一个HandlerExceptionResolver的实现类的方法则比较温和，不会对代码进行入侵。记得要在SpringMVC配置文件中托管这个实现类：<code>&lt;bean class=&quot;exception.MyExceptionHandler&quot;/&gt;</code></p><p>最后一种其实最方便啦，配置好就OK，不用增加什么文件。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SSM </tag>
            
            <tag> 统一异常处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM-6-上传和下载</title>
      <link href="posts/4950.html"/>
      <url>posts/4950.html</url>
      
        <content type="html"><![CDATA[<p>来了，上下都来了～</p><span id="more"></span><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>文件上传和下载是web经常要面对的问题。</p><p>上传的方式有多种，包括：</p><ol><li>使用文件流手工编程上传</li><li>基于commons-fileupload组件的文件上传</li><li>基于Servlet3及以上版本文件上传</li></ol><p>下载经常有两种方式：</p><ol><li>通过超链接实现下载，但是会暴露下载文件的真实位置，并且只能下载存放在web应用所在的目录下的文件。</li><li>利用程序编码实现下载，可以增加安全访问控制，还可以从任意位置提供下载的数据，比如数据库。</li></ol><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/1.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1"></p><p>选择文件前</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/2.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2"></p><p>选择文件后</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/3.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="3"></p><p>上传文件后</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/4.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="4"></p><p>可以被下载的文件列表</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/5.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="5"></p><p>选择文件存储位置</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h4 id="导入jar包"><a href="#导入jar包" class="headerlink" title="导入jar包"></a>导入jar包</h4><p>SpringMVC框架的文件上传是基于commons-fileupload组件，所以需要commons-fileupload和commons-io的jar包。</p><p>maven项目：配置pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--上传下载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>非maven项目：将下载好的 <code>commons-fileupload</code> 和 <code>commons-io</code> 的jar放到 <code>webapps\WEB-INF\lib</code> 目录下</p><h3 id="单文件上传"><a href="#单文件上传" class="headerlink" title="单文件上传"></a>单文件上传</h3><h4 id="1-编写领域模型"><a href="#1-编写领域模型" class="headerlink" title="1. 编写领域模型"></a>1. 编写领域模型</h4><p>文件上传后保存在服务器里是一个对象，这个对象我们得定义它的属性。文件上传的时候的文件描述（备注），文件的创建时间等等，最重要的文件本身的类型是 <code>MultipartFile</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDomain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> MultipartFile myFile;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultipartFile <span class="title">getMyFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyFile</span><span class="params">(MultipartFile myFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myFile = myFile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-编写一个提交页面"><a href="#2-编写一个提交页面" class="headerlink" title="2. 编写一个提交页面"></a>2. 编写一个提交页面</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String path = request.getContextPath();</span><br><span class="line">    String basePath = request.getScheme() + <span class="string">&quot;://&quot;</span> + request.getServerName() + <span class="string">&quot;:&quot;</span> + request.getServerPort() + path + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;base href=<span class="string">&quot;&lt;%=basePath%&gt;&quot;</span>/&gt;</span><br><span class="line">    &lt;title&gt;onFile&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;six/oneFileUpLoad&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    选择文件：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;myFile&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">    文件描述：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;description&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>input标签的type属性为file时，就变成选择文件了。</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/6.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="6"></p><p>**要注意的是：表单form的enctype属性应设置为 <code>multipart/form-data</code>**。然后就可以把表单提交到控制器了： <code>action=&quot;six/oneFileUpload&quot;</code></p><h4 id="3-编写控制器"><a href="#3-编写控制器" class="headerlink" title="3. 编写控制器"></a>3. 编写控制器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/six&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SixController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(SixController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/oneFileUpLoad&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">oneFileUpload</span><span class="params">(<span class="meta">@ModelAttribute</span> FileDomain fileDomain, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取存储路径</span></span><br><span class="line">        String realpath = request.getServletContext().getRealPath(<span class="string">&quot;fileUpload&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取文件名</span></span><br><span class="line">        String fileName = fileDomain.getMyFile().getOriginalFilename();</span><br><span class="line">        <span class="comment">// 如果文件名不为null &amp;&amp; 目标文件夹不存在，则新建文件夹</span></span><br><span class="line">        <span class="keyword">assert</span> fileName != <span class="keyword">null</span>;</span><br><span class="line">        File targetFile = <span class="keyword">new</span> File(realpath, fileName);</span><br><span class="line">        <span class="keyword">if</span> (!targetFile.exists()) &#123;</span><br><span class="line">            targetFile.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始上传文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileDomain.getMyFile().transferTo(targetFile);</span><br><span class="line">            logger.info(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;6/showOne&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表单提交到控制器后就由控制器进行处理。</p><ul><li>先获取realPath：文件保存到服务器的哪个地方，也叫存储路径。文件上传后都是存在服务器的，所以这里说的路径是指在服务器上的存储路径。</li><li>然后获取文件的文件名</li><li>如果realPath这个目录不存在，就创建目录</li><li>然后就开始上传文件。上传的关键方法就是 <code>transferTo()</code> </li></ul><p>这里上传成功就会跳转到 <code>/WEB-INF/jsp/6/showOne</code> 页面</p><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/3.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="3"></p><h4 id="4-编写结果页面"><a href="#4-编写结果页面" class="headerlink" title="4. 编写结果页面"></a>4. 编写结果页面</h4><p>也就是上面要跳转的 <code>/WEB-INF/jsp/6/showOne</code> 页面</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String path = request.getContextPath();</span><br><span class="line">    String basePath = request.getScheme() + <span class="string">&quot;://&quot;</span> + request.getServerName() + <span class="string">&quot;:&quot;</span> + request.getServerPort() + path + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;base href=<span class="string">&quot;&lt;%=basePath%&gt;&quot;</span>/&gt;</span><br><span class="line">    &lt;title&gt;ShowOne&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;fileDomain.description&#125;&lt;br&gt;</span><br><span class="line">$&#123;fileDomain.myFile.originalFilename&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h3><p>多文件上传和单文件的上传过程是相同的，但是他们的模型是不同的。多文件上传的模型是列表list</p><h4 id="1-领域模型"><a href="#1-领域模型" class="headerlink" title="1.领域模型"></a>1.领域模型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiFileDomain</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> List&lt;String&gt; description;</span><br><span class="line">   <span class="keyword">private</span> List&lt;MultipartFile&gt; myFile;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(List&lt;String&gt; description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;MultipartFile&gt; <span class="title">getMyFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyFile</span><span class="params">(List&lt;MultipartFile&gt; myFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myFile = myFile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟单文件上传的类型差不多，不同在于用list去装载。</p><h4 id="2-编写提交页面"><a href="#2-编写提交页面" class="headerlink" title="2.编写提交页面"></a>2.编写提交页面</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String path = request.getContextPath();</span><br><span class="line">    String basePath = request.getScheme() + <span class="string">&quot;://&quot;</span> + request.getServerName() + <span class="string">&quot;:&quot;</span> + request.getServerPort() + path + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;base href=<span class="string">&quot;&lt;%=basePath%&gt;&quot;</span>/&gt;</span><br><span class="line">    &lt;title&gt;MultiFile&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;six/mutliFile&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    选择文件<span class="number">1</span>：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;myFile&quot;</span>/&gt; &lt;br&gt;</span><br><span class="line">    文件描述<span class="number">1</span>：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;description&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">    选择文件<span class="number">2</span>：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;myFile&quot;</span>/&gt; &lt;br&gt;</span><br><span class="line">    文件描述<span class="number">2</span>：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;description&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">    选择文件<span class="number">3</span>：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;myFile&quot;</span>/&gt; &lt;br&gt;</span><br><span class="line">    文件描述<span class="number">3</span>：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;description&quot;</span>/&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>同样是enctype属性要设置成 <code>multipart/form-data</code> ，通过action属性提交到控制器</p><h4 id="3-控制器"><a href="#3-控制器" class="headerlink" title="3.控制器"></a>3.控制器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/six&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SixController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(SixController.class);</span><br><span class="line">    </span><br><span class="line">4<span class="meta">@RequestMapping(&quot;/mutliFile&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiFile</span><span class="params">(<span class="meta">@ModelAttribute</span> MultiFileDomain multiFileDomain, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取真实路径</span></span><br><span class="line">        String realpath = request.getServletContext().getRealPath(<span class="string">&quot;fileUpload&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果目标文件夹不存在则新建文件夹</span></span><br><span class="line">        File targetDir = <span class="keyword">new</span> File(realpath);</span><br><span class="line">        <span class="keyword">if</span> (!targetDir.exists()) &#123;</span><br><span class="line">            targetDir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将文件放置到list中</span></span><br><span class="line">        List&lt;MultipartFile&gt; files = multiFileDomain.getMyFile();</span><br><span class="line">        <span class="comment">// 将list中的文件逐个上传</span></span><br><span class="line">        <span class="keyword">for</span> (MultipartFile file : files) &#123;</span><br><span class="line">            String fileName = file.getOriginalFilename();</span><br><span class="line">            <span class="keyword">assert</span> fileName != <span class="keyword">null</span>;</span><br><span class="line">            File targetFile = <span class="keyword">new</span> File(realpath, fileName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                file.transferTo(targetFile);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;6/showMulti&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器里前部分也是相同的，获取存储路径，获取文件名，检查目标目录是否存在。</p><p>区别在于：将传过来的文件放在一个新的List中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;MultipartFile&gt; files = multiFileDomain.getMyFile();</span><br></pre></td></tr></table></figure><p>然后循环遍历整个List，将文件一个一个上传，然后返回 <code>/WEB-INF/jsp/6/showMulti</code> 页面</p><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><p>利用程序实现下载需要设置两个报头：</p><ol><li><strong>设置Content-Type的值为：application/x-msdownload</strong>，因为web服务器需要告诉浏览器所输出内容的类型不是普通文件文件或是HTML，而是一个要保存到本地的下载文件。</li><li><strong>设置Content-Disposition的值为：attachment</strong>，后面还可以指定filename参数。filename参数就是那个默认保存文件名。如下图红框所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/6.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="6"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-msdownload&quot;</span>);</span><br><span class="line">response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + toUTF8(filename));</span><br></pre></td></tr></table></figure><h4 id="1-编写跳转页面"><a href="#1-编写跳转页面" class="headerlink" title="1. 编写跳转页面"></a>1. 编写跳转页面</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String path = request.getContextPath();</span><br><span class="line">    String basePath = request.getScheme() + <span class="string">&quot;://&quot;</span> + request.getServerName() + <span class="string">&quot;:&quot;</span> + request.getServerPort() + path + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;base href=<span class="string">&quot;&lt;%=basePath%&gt;&quot;</span>/&gt;</span><br><span class="line">    &lt;title&gt;MultiFile&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;a href=<span class="string">&quot;six/showDownFiles&quot;</span>&gt;文件下载&lt;/a&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>整个页面只有一个a标签的链接。点击之后会跳转到 <code>showDownFiles</code> 控制器</p><h4 id="2-编写列表控制器"><a href="#2-编写列表控制器" class="headerlink" title="2.编写列表控制器"></a>2.编写列表控制器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/six&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SixController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(SixController.class);</span><br><span class="line">    </span><br><span class="line">4<span class="meta">@RequestMapping(&quot;/showDownFiles&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showDown</span><span class="params">(HttpServletRequest request, Model model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取存储目录</span></span><br><span class="line">        String realpath = request.getServletContext().getRealPath(<span class="string">&quot;fileUpload&quot;</span>);</span><br><span class="line">        <span class="comment">// 实例化为一个File对象</span></span><br><span class="line">        File dir = <span class="keyword">new</span> File(realpath);</span><br><span class="line">        <span class="comment">// 将目录下的文件放到File数组中</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="comment">// 创建一个数组列表，用于返回到前台页面</span></span><br><span class="line">        ArrayList&lt;String&gt; fileName = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">assert</span> files != <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 逐一将目录下的文件添加到数组列表中</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            fileName.add(file.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数组列表返回给前台页面</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;files&quot;</span>, fileName);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;6/showDownFiles&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>列出控制器还是比较简单的：</p><ol><li>获取存储位置</li><li>将路径实例化成一个File对象</li><li>将存储位置里的文件放到File数组中</li><li>创建一个数组列表，然后将文件逐个添加到数组列表中</li><li>将数组列表返回给前台页面</li></ol><h4 id="3-编写下载列表展示页面"><a href="#3-编写下载列表展示页面" class="headerlink" title="3. 编写下载列表展示页面"></a>3. 编写下载列表展示页面</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String path = request.getContextPath();</span><br><span class="line">    String basePath = request.getScheme() + <span class="string">&quot;://&quot;</span> + request.getServerName() + <span class="string">&quot;:&quot;</span> + request.getServerPort() + path + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;base href=<span class="string">&quot;&lt;%=basePath%&gt;&quot;</span>/&gt;</span><br><span class="line">    &lt;title&gt;ShowDownFiles&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;被下载文件名&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">    &lt;c:forEach items=<span class="string">&quot;$&#123;files&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;filename&quot;</span>&gt;&lt;%--<span class="meta">@elvariable</span> id=<span class="string">&quot;filesname&quot;</span> type=<span class="string">&quot;po.six.FileDomain&quot;</span>--%&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;a href=<span class="string">&quot;six/down?filename=$&#123;filename&#125;&quot;</span>&gt;$&#123;filename&#125;&lt;/a&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这里用了表单标签库中的 <code>&lt;c:forEach&gt;</code> 标签，将存储目录中的文件列出来，列出来的每一项都是一个超链接，链接指向 <code>six/down</code> 这个下载控制器。效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/4.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="4"></p><h4 id="4-编写下载控制器"><a href="#4-编写下载控制器" class="headerlink" title="4.编写下载控制器"></a>4.编写下载控制器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/six&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SixController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(SixController.class);</span><br><span class="line">    </span><br><span class="line">4<span class="meta">@RequestMapping(&quot;/down&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">down</span><span class="params">(<span class="meta">@RequestParam</span> String filename, HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取存储位置</span></span><br><span class="line">            String savePath = request.getServletContext().getRealPath(<span class="string">&quot;fileUpload&quot;</span>);</span><br><span class="line">            <span class="comment">// 设置报头</span></span><br><span class="line">            response.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-msdownload&quot;</span>);</span><br><span class="line">            response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + toUTF8(filename));</span><br><span class="line">            <span class="comment">// 读取服务器上的文件并写入到输出对象中，也就是下载</span></span><br><span class="line">            FileInputStream in = <span class="keyword">new</span> FileInputStream(savePath + <span class="string">&quot;\\&quot;</span> + filename);</span><br><span class="line">            ServletOutputStream out = response.getOutputStream();</span><br><span class="line">            out.flush();</span><br><span class="line">            <span class="keyword">int</span> aRead;</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((aRead = in.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(b, <span class="number">0</span>, aRead);</span><br><span class="line">            &#125;</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;下载成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载控制器则做了几件事情：</p><ol><li>获取存储目录</li><li>设置报头</li><li>将目标文件从输入流读取出来，转移到Servlet输出流写入进去，完成下载这个动作</li></ol><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/5.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-6/5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="5"></p><p>因为报头的 Content-Disposition 设置为 attachment，所以下载之前浏览器会询问保存位置。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上传和下载是web中很重要的一项功能，需要彻底掌握。上传的方式有多种，基于commons-fileupload的文件上传还是比较容易的，关键代码就是transferTo()方法。而下载选择用编码实现是为了不暴露文件的真实位置，还有就是可以下载任意位置的文件，所以可以将文件放在数据库中，然后让下载控制器去数据库中读取下载。虽然步骤比较麻烦，但是安全，规范。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SSM </tag>
            
            <tag> 上传下载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM-5-拦截器</title>
      <link href="posts/46719.html"/>
      <url>posts/46719.html</url>
      
        <content type="html"><![CDATA[<p>拦截器其实就是一种中间件</p><span id="more"></span><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>拦截器 Interceptor 主要用于在 <code>请求到达控制器之前进行验证</code> ，有点类似过滤器。主要用于拦截用户请求并做出相应的处理。通常应用在<strong>权限验证，记录请求信息的日志，判断用户是否登录等</strong>功能上。</p><p>主要的实现方法有两种：</p><ol><li>通过实现 <code>HandlerInterceptor接口</code> 或继承 <code>HandlerInterceptor接口</code> 的实现类来定义。</li><li>通过实现 <code>WebRequestInterceptor接口</code> 或继承<code>WebRequestInterceptor接口</code> 的实现类来定义。</li></ol><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>拦截器的拦截时间点在这里面分三种：</p><ol><li>请求到达控制器之前调用，比如点击我的购物车的时候，判断用户有没有登录先</li><li>控制器调用之后，返回视图之前。</li><li>解析试图之后。比如访问了XXX的QQ空间，就在视图解析完后记录到访问记录中</li></ol><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-4/1.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-4/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1"></p><p>这里的案例只是在这些方法里打印了一些话来表示出拦截器在什么时间点做了什么</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="1-配置"><a href="#1-配置" class="headerlink" title="1. 配置"></a>1. 配置</h3><p>先在springmvc-servlet.xml中配置拦截器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;interceptor.AllInterceptor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样的配置方式默认对所有请求拦截，也就是任何请求要到达控制器之前都会经过拦截器。</p><p>这种方式的话就是拦截所有的请求，但是请求如果是到<code>/abc</code>这个控制器的话就例外，不拦截。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/abc&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;interceptor.Interceptor1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种呢就是对发送到<code>/6</code>这个控制器的请求，进行指定的拦截器拦截。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/6&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;interceptor.Interceptor2&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-实现接口"><a href="#2-实现接口" class="headerlink" title="2. 实现接口"></a>2. 实现接口</h3><p>HandlerInterceptor接口中已经有默认的实现方法了，所以implements之后并不会提醒重写方法。</p><p>preHandle：在<strong>请求到达控制器之前</strong>进行拦截</p><p>postHandle：<strong>控制器调用之后，解析试图之前</strong>进行拦截</p><p>afterCompletion：在<strong>解析试图之后</strong>进行拦截</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle，请求到达控制器之前&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle,控制器调用之后，解析试图之前&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion,解析视图之后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>拦截器是一个比较重要的东西。使用也简单，主要是两点</p><ol><li>编写拦截器的工作，preHandle要干嘛，postHandle要干嘛，afterCompletion要干嘛。</li><li>在springmvc配置文件里编写拦截规则，是全部都拦截用一个全局拦截器？还是某个控制器用某个拦截器？</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SSM </tag>
            
            <tag> 拦截器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM-4-数据绑定</title>
      <link href="posts/41307.html"/>
      <url>posts/41307.html</url>
      
        <content type="html"><![CDATA[<p>先把数据绑定起来</p><span id="more"></span><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>数据绑定是将用户参数输入值绑定到领域模型（POJO）的一种特性，在SpringMVC的Controller和View参数传递数据的过程中，所有HTTP请求参数的类型均为字符串，如果模型需要绑定的类型为double或int，则需要手动进行类型转换，而有了数据绑定后：</p><ol><li>不需要手动转型数据了。</li><li>当表单输入验证失败时，会重新生成一个HTML表单，无需重新填写已输入字段。</li></ol><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>第一次加载的样子</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-4/1.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-4/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1"></p><p>验证失败后重新加载的样子，前面填过的数据依然保留着</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-4/2.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-4/2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2"></p><p>验证成功后进入这个页面</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-4/3.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/SSM-4/3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="3"></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="1-导入jar包"><a href="#1-导入jar包" class="headerlink" title="1. 导入jar包"></a>1. 导入jar包</h3><p>maven项目：配置pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>非maven项目：将下载好的 <code>taglibs</code> 和 <code>jstl</code> 的jar放到 <code>webapps\WEB-INF\lib</code> 目录下</p><h3 id="2-web-xml中配置编码过滤器"><a href="#2-web-xml中配置编码过滤器" class="headerlink" title="2. web.xml中配置编码过滤器"></a>2. web.xml中配置编码过滤器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-编写领域模型"><a href="#3-编写领域模型" class="headerlink" title="3. 编写领域模型"></a>3. 编写领域模型</h3><p>定义各种属性和getter&amp;setter方法，太简单，不赘述</p><h3 id="4-编写控制层Controller"><a href="#4-编写控制层Controller" class="headerlink" title="4. 编写控制层Controller"></a>4. 编写控制层Controller</h3><p>因为视图层用的都是表单标签库，所以数据要在controller层定义</p><p>然后通过model.addAttribute()方法将数据传送出去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/four&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FourController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(FourController.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FourUserService fourUserService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FourController</span><span class="params">(FourUserService fourUserService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fourUserService = fourUserService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一次加载表单会触发这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/input&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">inputUser</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; hobbys = getMap();</span><br><span class="line">44<span class="comment">// 虽然是第一次加载，但是也要在model添加一个领域模型的对象，否则表单标签无法找到modelAttribute属性指定的form backing object</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, <span class="keyword">new</span> User());</span><br><span class="line">        </span><br><span class="line">        model.addAttribute(<span class="string">&quot;hobbys&quot;</span>, hobbys);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;carrers&quot;</span>, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;教师&quot;</span>, <span class="string">&quot;学生&quot;</span>, <span class="string">&quot;码农&quot;</span>, <span class="string">&quot;民工&quot;</span>&#125;);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;houseRegister&quot;</span>, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;userAdd&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表单提交的时候会触发这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(<span class="meta">@ModelAttribute</span> User user, Model model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 进入业务层验证业务逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (fourUserService.addUser(user)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 重定向到本控制器里的list控制方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:list&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">        <span class="comment">// 验证失败的时候就到了这里，相当于重新加载，但是会带着已经填过的数据，用户就不用再次填写已经填写过的输入，注意这里没有在model.addAttribute()中new bean()。看不懂请对比上面的input方法</span></span><br><span class="line">        HashMap&lt;String, String&gt; hobbys = getMap();</span><br><span class="line">        model.addAttribute(<span class="string">&quot;hobbys&quot;</span>, hobbys);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;carrers&quot;</span>, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;教师&quot;</span>, <span class="string">&quot;学生&quot;</span>, <span class="string">&quot;码农&quot;</span>, <span class="string">&quot;民工&quot;</span>&#125;);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;houseRegister&quot;</span>, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;广州&quot;</span>, <span class="string">&quot;深圳&quot;</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;userAdd&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">listUsers</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; users = fourUserService.getUsers();</span><br><span class="line">        model.addAttribute(<span class="string">&quot;users&quot;</span>, users);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;userList&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> HashMap&lt;String, String&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; hobbys = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        hobbys.put(<span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;篮球&quot;</span>);</span><br><span class="line">        hobbys.put(<span class="string">&quot;乒乓球&quot;</span>, <span class="string">&quot;乒乓球&quot;</span>);</span><br><span class="line">        hobbys.put(<span class="string">&quot;电玩&quot;</span>, <span class="string">&quot;电玩&quot;</span>);</span><br><span class="line">        hobbys.put(<span class="string">&quot;游泳&quot;</span>, <span class="string">&quot;游泳&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> hobbys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-编写业务逻辑层Service"><a href="#5-编写业务逻辑层Service" class="headerlink" title="5. 编写业务逻辑层Service"></a>5. 编写业务逻辑层Service</h3><p>业务层，业务逻辑都在这里判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> service.four;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> po.four.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pr919</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FourUserServiceImpl</span> <span class="keyword">implements</span> <span class="title">FourUserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addUser</span><span class="params">(User u)</span> </span>&#123;</span><br><span class="line">        String magicValue = <span class="string">&quot;民工&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!magicValue.equals(u.getCarrer()) &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(u.getUsername()))&#123;</span><br><span class="line">            users.add(u);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-编写视图层View"><a href="#6-编写视图层View" class="headerlink" title="6. 编写视图层View"></a>6. 编写视图层View</h3><p>视图层的<strong>表单标签</strong>通过<strong>控制层</strong>和<strong>领域模型</strong>绑定在一起，实现了数据绑定。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&lt;%-- userAdd.jsp --%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;form&quot;</span> uri=<span class="string">&quot;http://www.springframework.org/tags/form&quot;</span> %&gt;</span><br><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: pr919</span><br><span class="line">  Date: <span class="number">2019.6</span><span class="number">.24</span></span><br><span class="line">  Time: <span class="number">14</span>:<span class="number">41</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String path = request.getContextPath();</span><br><span class="line">    String basePath = request.getScheme() + <span class="string">&quot;://&quot;</span> + request.getServerName() + <span class="string">&quot;:&quot;</span> + request.getServerPort() + path + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;base href=<span class="string">&quot;&lt;%=basePath%&gt;&quot;</span>/&gt;</span><br><span class="line">    &lt;title&gt;dataBind&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%--<span class="meta">@elvariable</span> id=<span class="string">&quot;user&quot;</span> type=<span class="string">&quot;po.four.User&quot;</span>--%&gt;</span><br><span class="line">&lt;form:form modelAttribute=<span class="string">&quot;user&quot;</span> mothod=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;four/save&quot;</span>&gt;</span><br><span class="line">    &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;添加一个用户&lt;/legend&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;label&gt;用户名：&lt;/label&gt;</span><br><span class="line">            &lt;form:input path=<span class="string">&quot;username&quot;</span>/&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;label&gt;爱好：&lt;/label&gt;</span><br><span class="line">            &lt;%--<span class="meta">@elvariable</span> id=<span class="string">&quot;hobbys&quot;</span> type=<span class="string">&quot;java.util.List&quot;</span>--%&gt;</span><br><span class="line">            &lt;form:checkboxes items=<span class="string">&quot;$&#123;hobbys&#125;&quot;</span> path=<span class="string">&quot;hobby&quot;</span>/&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;label&gt;朋友：&lt;/label&gt;</span><br><span class="line">            &lt;form:checkbox path=<span class="string">&quot;friends&quot;</span> value=<span class="string">&quot;张三&quot;</span>/&gt;<span class="number">1</span></span><br><span class="line">            &lt;form:checkbox path=<span class="string">&quot;friends&quot;</span> value=<span class="string">&quot;李四&quot;</span>/&gt;<span class="number">2</span></span><br><span class="line">            &lt;form:checkbox path=<span class="string">&quot;friends&quot;</span> value=<span class="string">&quot;王五&quot;</span>/&gt;<span class="number">3</span></span><br><span class="line">            &lt;form:checkbox path=<span class="string">&quot;friends&quot;</span> value=<span class="string">&quot;赵六&quot;</span>/&gt;<span class="number">4</span></span><br><span class="line">        &lt;/p&gt;</span><br><span class="line"></span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;label&gt;职业：&lt;/label&gt;</span><br><span class="line">            &lt;form:select path=<span class="string">&quot;carrer&quot;</span>&gt;</span><br><span class="line">                &lt;option&gt;&lt;/option&gt;</span><br><span class="line">                请选择职业</span><br><span class="line">                &lt;%--<span class="meta">@elvariable</span> id=<span class="string">&quot;carrers&quot;</span> type=<span class="string">&quot;java.util.List&quot;</span>--%&gt;</span><br><span class="line">                &lt;form:options items=<span class="string">&quot;$&#123;carrers&#125;&quot;</span>/&gt;</span><br><span class="line">            &lt;/form:select&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;label&gt;户籍：&lt;/label&gt;</span><br><span class="line">            &lt;form:select path=<span class="string">&quot;houseRegister&quot;</span>&gt;</span><br><span class="line">                &lt;option&gt;&lt;/option&gt;</span><br><span class="line">                请选择户籍</span><br><span class="line">                &lt;%--<span class="meta">@elvariable</span> id=<span class="string">&quot;houseRegister&quot;</span> type=<span class="string">&quot;java.util.List&quot;</span>--%&gt;</span><br><span class="line">                &lt;form:options items=<span class="string">&quot;$&#123;houseRegister&#125;&quot;</span>/&gt;</span><br><span class="line">            &lt;/form:select&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;label&gt;个人描述：&lt;/label&gt;</span><br><span class="line">            &lt;form:textarea path=<span class="string">&quot;remark&quot;</span> rows=<span class="string">&quot;5&quot;</span>/&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p id=<span class="string">&quot;buttons&quot;</span>&gt;</span><br><span class="line">            &lt;input id=<span class="string">&quot;reset&quot;</span> type=<span class="string">&quot;reset&quot;</span> /&gt;</span><br><span class="line">            &lt;input id=<span class="string">&quot;submit&quot;</span> type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;添加&quot;</span>&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">    &lt;/fieldset&gt;</span><br><span class="line">&lt;/form:form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;%-- userAdd.jsp --%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: pr919</span><br><span class="line">  Date: <span class="number">2019.6</span><span class="number">.24</span></span><br><span class="line">  Time: <span class="number">15</span>:<span class="number">18</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String path = request.getContextPath();</span><br><span class="line">    String basePath = request.getScheme() + <span class="string">&quot;://&quot;</span> + request.getServerName() + <span class="string">&quot;:&quot;</span> + request.getServerPort() + path + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;base href=<span class="string">&quot;&lt;%=basePath%&gt;&quot;</span>/&gt;</span><br><span class="line">    &lt;title&gt;dataList&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;用户列表&lt;/h1&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;&lt;c:url value=&quot;</span>four/input<span class="string">&quot;/&gt;&quot;</span>&gt;继续添加&lt;/a&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;用户名&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;兴趣爱好&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;朋友&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;职业&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;户籍&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;个人描述&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;c:forEach items=<span class="string">&quot;$&#123;users&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;user&quot;</span>&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;$&#123;user.username&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;c:forEach items=<span class="string">&quot;$&#123;user.hobby&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span><br><span class="line">                    $&#123;hobby&#125;&amp;nbsp;</span><br><span class="line">                &lt;/c:forEach&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;c:forEach items=<span class="string">&quot;$&#123;user.friends&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;friend&quot;</span>&gt;</span><br><span class="line">                    $&#123;friend&#125;&amp;nbsp;</span><br><span class="line">                &lt;/c:forEach&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;user.carrer&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;user.houseRegister&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;user.remark&#125;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前来说，除了不用手动转型之外，我还没想到这个数据绑定有什么用。如果是为了验证输入的话，用javaScript或ajax就够了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SSM </tag>
            
            <tag> 数据绑定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C-Note</title>
      <link href="posts/60258.html"/>
      <url>posts/60258.html</url>
      
        <content type="html"><![CDATA[<p>C语言笔记</p><span id="more"></span><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>定义指针：<code>dataType * pointerName = NULL</code>;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr_a = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>指针赋值：<code>pointerName = &amp;varName</code>;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">ptr_a = &amp;a;</span><br></pre></td></tr></table></figure><p>对于指针，其实就是存放地址的变量</p><p><code>int a = 10;</code> 这句话等于申请了一块内存，放了个值10进去，起个别命叫<code>a</code> 。那这个空间的地址假设是 0028FF，那<code>ptr_a = &amp;a</code> 这句话就是再申请一块内存，把0028FF放进去，起个别名叫<code>ptr_a</code> 。</p><p><code>&amp;</code> 这个符号是取地址的意思</p><p><code>*</code> 这个符号则是取这个指针变量中，那个地址的内存中的 值，也就是直接操作内存，修改内存里的内容</p><h3 id="值传递-引用传递"><a href="#值传递-引用传递" class="headerlink" title="值传递  引用传递"></a>值传递  引用传递</h3><p>值传递：传递一份副本，传递后操作的只是副本，也就是对变量的副本进行操作，变量本身不会变化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">4<span class="keyword">int</span> num = <span class="number">9</span>;</span><br><span class="line">4change(num);</span><br><span class="line">4<span class="built_in">printf</span>(<span class="string">&quot;num = %d&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：9</span></span><br></pre></td></tr></table></figure><p>引用传递：<code>&amp;var</code>， 传递的是地址，传递后操作的是该地址中的值，也就是对变量本身进行操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> * num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">4*num ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">4<span class="keyword">int</span> num = <span class="number">9</span>;</span><br><span class="line">    change(&amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num = %d&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果：10</span></span><br></pre></td></tr></table></figure><p>值传递就是普通操作，引用传递就是操作指针（骚操作）</p><h3 id="变量的生存周期"><a href="#变量的生存周期" class="headerlink" title="变量的生存周期"></a>变量的生存周期</h3><table><thead><tr><th>存储类型说明符</th><th>存储类型</th><th>说明</th></tr></thead><tbody><tr><td>auto</td><td>自动存储</td><td>只能用于块作用域中的变量，局部变量默认情况下归为自动存储类型</td></tr><tr><td>register</td><td>寄存器存储</td><td>只能用于块作用域中的变量，请求速度快，适用在循环次数多的循环变量/反复使用的变量。</td></tr><tr><td>static</td><td>静态存储</td><td>载入程序时创建对象，程序结束时对象消失。</td></tr><tr><td>extern</td><td>外部变量</td><td>说明符表示生命的变量定义在别处。作用域是整个程序，生存周期贯穿应用程序的开始和结束。跟static一样。</td></tr></tbody></table><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADFILENAME_H_INCLUDE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADFILENAME_H_INCLUDE</span></span><br><span class="line">4</span><br><span class="line">4<span class="comment">// TODO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
          <category> C Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
            <tag> C Language </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-About-Hash</title>
      <link href="posts/33205.html"/>
      <url>posts/33205.html</url>
      
        <content type="html"><![CDATA[<p>Hash 是一种很神奇的数据结构</p><span id="more"></span><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p><strong>HashTable 散列表 哈希表：</strong> 是一种数据结构，它提供快速的插入和查找操作，不管表中有多少数据，插入删除和查找的时间都接近O(1)</p><p><strong>优点：</strong>HashTable其实是基于数组的，所以在查询方面非常的快，同时它不像普通数组那样紧密排列，在数值未满的时候所有的值其实是散部在数组中的某个位置上的，所以在插入和删除的时候不用像普通数组一样让余下的值一个个的挪。</p><p><strong>缺点：</strong>同时也因为它的基于数组的，所以创建以后难以扩展，当HashTable被基本填满的时候，性能严重下降，而且不能顺序遍历。</p><p>一个输入传进来的时候会经过<strong>散列函数</strong>，计算出一个值，这个值就是这个输入在HashTable中的位置，称为<strong>HashCode 哈希值 散列值</strong>。</p><p>当HashTable中的值还不多的时候各种操作的效率是非常高的，但是HashTable快满的时候各种操作的效率就开始变低了</p><h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><h3 id="线性探测方法"><a href="#线性探测方法" class="headerlink" title="线性探测方法"></a>线性探测方法</h3><blockquote><p>比如一个HashTable的长度是8，现在只剩下 <del>6</del> 这个位置是空的</p><p>而一个输入经过散列函数计算之后得到的结果是 <del>7</del> ，一看 <del>7</del> 上面有人占了，怎么办呢？</p><p>往下找空位咯，<del>7</del> 下面是 <del>0</del> ，有人了，下一个 <del>1</del> ，有人了，下一个 <del>2</del> ，有人了…下一个 <del>6</del> ，耶没人，上去！ </p><p>这样几乎遍历了一整个数组，效率是非常低的，HashTable小的时候还能忍受，如果HashTable长度是2000呢?20000呢？</p></blockquote><p>上述的方法其实就是当散列函数计算出来的值上面已经有值的时候的解决方法之一，<strong>开放寻址法</strong>中的<strong>线性探测</strong>，往下找空位，找到进填进去。最坏的情况下就是几乎遍历整个数组。</p><h3 id="二次探测方法"><a href="#二次探测方法" class="headerlink" title="二次探测方法"></a>二次探测方法</h3><p>另一种的思路有那么点像二分查找法，叫做<strong>二次探测方法</strong></p><blockquote><p>比如表中只有 <del>3</del> 是有空位的，其余都是满的</p><p>而一个输入经过散列函数计算之后得到的结果是 <del>7</del>，一看 <del>7</del> 上面有人了，怎么办呢？</p><p>CurrentCode + 0，CurrentCode + 1^2^ ，CurrentCode - 1 ^2^，CurrentCode + 2^2^，CurrentCode - 2^2^，……</p><p>7不行就 + 1^2^ = 8，8还是不行，那就7 - 1^2^ = 6，6还是不行，那就7 - 2^2^ = 3，3可以，上去！</p></blockquote><p>因为进行试探的步长都是二次方，所以叫 <strong>二次探测方法</strong></p><h3 id="双重散列方法"><a href="#双重散列方法" class="headerlink" title="双重散列方法"></a>双重散列方法</h3><p>还有一种方法叫做 <strong>双重散列方法</strong></p><blockquote><p>就是使用第一个哈希函数计算的值如果被占用了，就找第二个哈希函数，直到找到空闲的存储位置</p></blockquote><p>不管用那种方法，只要HashTable空位不多的时候散列冲突的概率就会大大提高，尽可能保证HashTable中有一定比例的空位。</p><p>一般用<strong>加载因子</strong>来表示空位的多少。加载因子越大表示约满，反之亦然。</p><h2 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h2><p>HashTable中每个元素对应一条链表，所有散列值相同的元素放到相同的链表中。如下图</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Java-about-hash/HashMap.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Java-about-hash/HashMap.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="链表法"></p><p>查找的时候先通过HashCode找到位置，然后将值与链表中的值逐个使用 equals() 对比。</p><h2 id="But"><a href="#But" class="headerlink" title="But"></a>But</h2><p>但其实HashTable是元素数量不能超过总容量的一半，当HashTable太满的时候，一个选择是扩容数组，创建一个新的容量为 <code>CurrentCapacity * 1.34 + n = 2^m </code>  的数组，把值放到新数组，但是元素的索引没法复制，会被重新哈希化。<br>$$<br>CurrentCapacity * 1.34 + n = 2^m = NewCapacity<br>$$</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>一本字典有1000页，当你要查找Link这个词的时候，肯定想去翻目录，目录显示在第666页，那么你是不是可以直接翻到666页找这个单词？也就是所Link这个单词在<code>散列表[666]</code>，但是第666页可能不止这一个单词哦，那你是不是要一个一个进行equals才能知道是哪个呢？因为知道在哪一条链表上，所以尽管遍历看起来很慢，但总比遍历所有链表快吧？</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-反射</title>
      <link href="posts/13406.html"/>
      <url>posts/13406.html</url>
      
        <content type="html"><![CDATA[<p>Java 神器：反射</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**获取*/</span></span><br><span class="line">Class&lt;?&gt; clazz = p.getClass(); <span class="comment">// 得知道类对象</span></span><br><span class="line">Class&lt;?&gt; clazz =  Person.class;<span class="comment">//得知道类名</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.tcp404.Person&quot;</span>);<span class="comment">//得知道类的全路径名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 获取方法 */</span></span><br><span class="line">Method method = clazz.getDeclaredMethod(<span class="string">&quot;方法名&quot;</span>, <span class="keyword">new</span> Class()&#123;[参数类型.class, 参数类型.class, ...]&#125;);</span><br><span class="line">Methods[] methods = clazz.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 获取属性 */</span></span><br><span class="line">Field field = clazz.getDeclaredField(<span class="string">&quot;属性名字&quot;</span>);</span><br><span class="line">Field[] fields = clazz.getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 获取构造器 */</span></span><br><span class="line">Constructor&lt;?&gt; con = clazz.getDeclaredConstructor(<span class="keyword">new</span> Class()&#123;[参数类型.class, 参数类型.class, ...]&#125;);</span><br><span class="line">Constructor&lt;?&gt;[] cs = clazz.getDeclaredConstructors();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令大全</title>
      <link href="posts/18012.html"/>
      <url>posts/18012.html</url>
      
        <content type="html"><![CDATA[<p>One more thing</p><span id="more"></span><h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/git%E8%AF%B4%E6%98%8E.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/git%E8%AF%B4%E6%98%8E.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="git"></p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><p><strong>先放上一张常用Git 命令导航图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/git%E5%B8%B8%E7%94%A8.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/git%E5%B8%B8%E7%94%A8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="GIT"></p><h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在当前目录新建一个Git代码库（常用）</span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">新建一个目录，将其初始化为Git代码库</span><br><span class="line">git init [project-name]</span><br><span class="line"></span><br><span class="line">下载一个项目和它的整个代码历史（常用）</span><br><span class="line">git clone [url]</span><br></pre></td></tr></table></figure><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">显示当前的Git配置</span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line">编辑Git配置文件</span><br><span class="line">git config -e [--global]</span><br><span class="line"></span><br><span class="line">设置提交代码时的用户信息</span><br><span class="line">git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure><h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">添加指定文件到暂存区（常用）</span><br><span class="line">git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line">添加指定目录到暂存区，包括子目录</span><br><span class="line">git add [dir]</span><br><span class="line"></span><br><span class="line">添加当前目录的所有文件到暂存区（常用）</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">添加每个变化前，都会要求确认</span><br><span class="line">对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">git add -p</span><br><span class="line"></span><br><span class="line">删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line">停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">git rm --cached [file]</span><br><span class="line"></span><br><span class="line">改名文件，并且将这个改名放入暂存区</span><br><span class="line">git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">提交暂存区到仓库区（常用）</span><br><span class="line">git commit -m [message]</span><br><span class="line"></span><br><span class="line">提交暂存区的指定文件到仓库区（常用）</span><br><span class="line">git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line">提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">git commit -a</span><br><span class="line"></span><br><span class="line">提交时显示所有diff信息</span><br><span class="line">git commit -v</span><br><span class="line"></span><br><span class="line">使用一次新的commit，替代上一次提交</span><br><span class="line">如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line">重做上一次commit，并包括指定文件的新变化</span><br><span class="line">git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">列出所有本地分支（常用）</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line">列出所有远程分支</span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line">列出所有本地分支和远程分支（常用）</span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line">新建一个分支，但依然停留在当前分支（常用）</span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line">新建一个分支，并切换到该分支（常用）</span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line">新建一个分支，指向指定commit</span><br><span class="line">git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line">新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line">切换到指定分支，并更新工作区（常用）</span><br><span class="line">git checkout [branch-name]</span><br><span class="line"></span><br><span class="line">切换到上一个分支（常用）</span><br><span class="line">git checkout -</span><br><span class="line"></span><br><span class="line">建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line">合并指定分支到当前分支</span><br><span class="line">git merge [branch]</span><br><span class="line"></span><br><span class="line">选择一个commit，合并进当前分支</span><br><span class="line">git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line">删除分支（常用）</span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line">删除远程分支</span><br><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">列出所有tag</span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line">新建一个tag在当前commit</span><br><span class="line">git tag [tag]</span><br><span class="line"></span><br><span class="line">新建一个tag在指定commit</span><br><span class="line">git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line">删除本地tag</span><br><span class="line">git tag -d [tag]</span><br><span class="line"></span><br><span class="line">删除远程tag</span><br><span class="line">git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line">查看tag信息</span><br><span class="line">git show [tag]</span><br><span class="line"></span><br><span class="line">提交指定tag</span><br><span class="line">git push [remote] [tag]</span><br><span class="line"></span><br><span class="line">提交所有tag</span><br><span class="line">git push [remote] --tags</span><br><span class="line"></span><br><span class="line">新建一个分支，指向某个tag</span><br><span class="line">git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">显示有变更的文件（常用）</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">显示当前分支的版本历史（常用）</span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line">显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">git log --stat</span><br><span class="line"></span><br><span class="line">搜索提交历史，根据关键词</span><br><span class="line">git log -S [keyword]</span><br><span class="line"></span><br><span class="line">显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">git log [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line">显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line">显示某个文件的版本历史，包括文件改名</span><br><span class="line">git log --follow [file]</span><br><span class="line">git whatchanged [file]</span><br><span class="line"></span><br><span class="line">显示指定文件相关的每一次diff</span><br><span class="line">git log -p [file]</span><br><span class="line"></span><br><span class="line">显示过去5次提交</span><br><span class="line">git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line">显示所有提交过的用户，按提交次数排序</span><br><span class="line">git shortlog -sn</span><br><span class="line"></span><br><span class="line">显示指定文件是什么人在什么时间修改过</span><br><span class="line">git blame [file]</span><br><span class="line"></span><br><span class="line">显示暂存区和工作区的代码差异（常用）</span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line">显示暂存区和上一个commit的差异</span><br><span class="line">git diff --cached [file]</span><br><span class="line"></span><br><span class="line">显示工作区与当前分支最新commit之间的差异</span><br><span class="line">git diff HEAD</span><br><span class="line"></span><br><span class="line">显示两次提交之间的差异</span><br><span class="line">git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line">显示今天你写了多少行代码</span><br><span class="line">git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line">显示某次提交的元数据和内容变化（常用）</span><br><span class="line">git show [commit]</span><br><span class="line"></span><br><span class="line">显示某次提交发生变化的文件</span><br><span class="line">git show --name-only [commit]</span><br><span class="line"></span><br><span class="line">显示某次提交时，某个文件的内容</span><br><span class="line">git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line">显示当前分支的最近几次提交</span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line">从本地master拉取代码更新当前分支：branch 一般为master</span><br><span class="line">git rebase [branch]</span><br></pre></td></tr></table></figure><h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">git remote update  --更新远程仓储（常用）</span><br><span class="line">下载远程仓库的所有变动</span><br><span class="line">git fetch [remote]</span><br><span class="line"></span><br><span class="line">显示所有远程仓库</span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line">显示某个远程仓库的信息</span><br><span class="line">git remote show [remote]</span><br><span class="line"></span><br><span class="line">增加一个新的远程仓库，并命名</span><br><span class="line">git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line">取回远程仓库的变化，并与本地分支合并（常用）</span><br><span class="line">git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line">上传本地指定分支到远程仓库（常用）</span><br><span class="line">git push [remote] [branch]</span><br><span class="line"></span><br><span class="line">强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">git push [remote] --force</span><br><span class="line"></span><br><span class="line">推送所有分支到远程仓库</span><br><span class="line">git push [remote] --all</span><br></pre></td></tr></table></figure><h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">恢复暂存区的指定文件到工作区</span><br><span class="line">git checkout [file]</span><br><span class="line"></span><br><span class="line">恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line">恢复暂存区的所有文件到工作区</span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line">重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">git reset [file]</span><br><span class="line"></span><br><span class="line">重置暂存区与工作区，与上一次commit保持一致(取消所有修改)（常用）</span><br><span class="line">git reset --hard</span><br><span class="line"></span><br><span class="line">重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">git reset [commit]</span><br><span class="line"></span><br><span class="line">重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">git reset --hard [commit]</span><br><span class="line"></span><br><span class="line">重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">git reset --keep [commit]</span><br><span class="line"></span><br><span class="line">新建一个commit，用来撤销指定commit</span><br><span class="line">后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">git revert [commit]</span><br><span class="line"></span><br><span class="line">暂时将未提交的变化移除，稍后再移入（常用）</span><br><span class="line">git stash</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">生成一个可供发布的压缩包（常用）</span><br><span class="line">git archive</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多端同步管理Hexo博客</title>
      <link href="posts/41079.html"/>
      <url>posts/41079.html</url>
      
        <content type="html"><![CDATA[<p>多端管理其实很简单。</p><span id="more"></span><p>hexo 其实是帮我们编译好放在<code>博客根目录\public</code>目录下的，然后把<code>public目录</code>推送到github上的，所以说github.io上面都是编译过的文件，他们是光鲜亮丽的演员，但离不开默默付出的后台人员。这些默默付出的后台人员就是除了public之外的所有的文件。</p><p>我们的博客是发布到master主分支的，那就建另一个分支，把所有文件都传上去，在别的电脑上都拉下去就可以了。</p><h3 id="1-首先填写忽略声明文件-gitignore"><a href="#1-首先填写忽略声明文件-gitignore" class="headerlink" title="1. 首先填写忽略声明文件.gitignore"></a>1. 首先填写忽略声明文件<code>.gitignore</code></h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.DS_Store</span></span><br><span class="line">Thumbs<span class="number">.</span><span class="built_in">db</span></span><br><span class="line"><span class="built_in">db</span><span class="number">.</span>json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line"><span class="meta">public</span>/</span><br><span class="line"><span class="meta">.deploy</span>*/</span><br><span class="line">_config<span class="number">.</span>yml</span><br></pre></td></tr></table></figure><ul><li>public  每次都会编译覆盖，所以不需要它</li><li>.deploy*   编译产生的文件，也不需要</li><li>_config.yml  配置文件里会有一些id/key的重要信息，所以不上传</li></ul><h3 id="2-初始化仓库和提交"><a href="#2-初始化仓库和提交" class="headerlink" title="2. 初始化仓库和提交"></a>2. 初始化仓库和提交</h3><p>之前我以为hexo就是帮我们操作git，所以不明白为什么还能再初始化git</p><p>后来才知道不是那么回事。但是hexo是怎么操作我还是没明白。这里不管</p><p>像往常一样，在根目录右键 git bash here</p><blockquote><p>注意！！！大坑！！！</p><p>如果你用的是第三方的主题theme，是使用git clone下来的话，要把主题文件夹下面把.git文件夹删除掉，不然主题无法push到远程仓库，导致你发布的博客是一片空白。所以先去检查你使用的主题有没有.git这个目录</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init  //初始化本地仓库</span><br><span class="line">git add . //添加本地所有文件到仓库        </span><br><span class="line">git commit -m &quot;blog源文件&quot; //添加commit</span><br><span class="line">git branch backup //添加本地仓库分支hexo</span><br><span class="line">git remote add origin &lt;server&gt;  //添加远程仓库 &lt;server&gt; 是指在线仓库的地址 origin是本地分支,remote add操作会将本地仓库映射到云端</span><br><span class="line">git push origin backup //将本地仓库的源文件推送到远程仓库hexo分支</span><br></pre></td></tr></table></figure><h3 id="在另一台电脑的操作"><a href="#在另一台电脑的操作" class="headerlink" title="在另一台电脑的操作"></a>在另一台电脑的操作</h3><p>首先肯定要搭建环境啦（Node 和 Git）</p><p>完了后用这个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;server&gt; hexo //&lt;server&gt; 是指在线仓库的地址</span><br><span class="line">cd hexo </span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>npm install的时候会根据package.json中的插件列表自动加载相应插件。<br> 本机的同步完成。</p><blockquote><p>因为在上传博客源文件的时候忽略了配置文件（_config.yml这是站点的配置文件）的上传，也就是没有上传配置文件的，在克隆下来的时候记得把配置文件拿过来，不然会报错。主题里面的配置文件也要（themes/next/_config.yml这是主题配置文件）</p></blockquote><p>这里贴一张常用Git命令</p><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/git%E5%B8%B8%E7%94%A8.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Git-basic-operation/git%E5%B8%B8%E7%94%A8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="git常用命令"></p>]]></content>
      
      
      <categories>
          
          <category> HEXO </category>
          
          <category> Git </category>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> note </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几句话区分并行和并发</title>
      <link href="posts/38965.html"/>
      <url>posts/38965.html</url>
      
        <content type="html"><![CDATA[<p>吃饭和打电话你选择哪个？</p><span id="more"></span><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><ul><li>你在吃饭，电话进来，你等到吃完了才接电话 –&gt; 你<strong>不支持</strong>【并行或者并发】</li></ul><p>（1个CPU，队列式执行任务，这个做完了才做下一个，不允许插队）</p><ul><li>你在吃饭，电话进来，接一下电话，吃一下饭，交替进行，说明你<strong>支持</strong>【并发】 </li></ul><p>（一个CPU，多个任务同时进行，这个做一下，那个做一下，回过来这个再做一下…，允许插队）</p><ul><li>你在吃饭，电话进来，你继续吃饭，秘书帮你接电话，说明你<strong>支持</strong>【并行】</li></ul><p>（多于一个CPU，多个任务同时进行，各忙各的）</p><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/cover/parallel-concurrent.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/cover/parallel-concurrent.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1"></p><h3 id="正儿八经的胡说一下"><a href="#正儿八经的胡说一下" class="headerlink" title="正儿八经的胡说一下"></a>正儿八经的胡说一下</h3><p><strong>并发主要是指：同一时间 【段】 “同时”做多件事</strong></p><p>比如一边打电话一边吃饭。人脑肯定是没法同时专注在两个事情上的，所以你的注意力会一下在电话上（听电话里说什么），一下在吃饭上（大脑下达抬手张嘴咀嚼的指令），CPU也是如此。</p><p>吃饭一个线程，接电话一个线程。分给吃饭线程一点时间片，分给接电话一点时间片，吃饭的时间片执行完了切到电话线程执行，电话线程的时间片执行完了切到吃饭线程，因为切换的快，所以感觉像同时进行。</p><p>这里时间片不懂的话就姑且理解为能量条，CPU切过来执行吃饭线程，吃饭线程的能量条就开始消耗，消耗完了CPU就走了去消耗电话线程的能量条了。与此同时吃饭线程的能量条在CPU切走的时候瞬间满了，CPU那边消耗完了又过来吃饭线程消耗这边的能量条，耗完了又走了。如此往复直到任务执行完毕。</p><p><strong>并行只要是指：同一时间 【点】 “同时”做多件事</strong></p><p>还是上面吃饭打电话的例子，电话来了你吃你的，电话秘书帮你接。你处理吃饭的事情，秘书处理电话的事情，所以就不用CPU切来切去的。因为有两个CPU了嘛（你 和 秘书）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>一个收银员，只能排一条队伍，一个一个来，就是<strong>不支持并发并行</strong></p></li><li><p>一个收银员，可以排多条队伍，这边忙忙那边忙忙，就是<strong>支持并发</strong></p></li><li><p>多个收银员，可以排多条队伍，一个收银员处理一条队伍，就是<strong>支持并行</strong></p></li></ul><p>可见CPU只有一个的时候，就是假同时；多个CPU的时候，才是真正意义上的同时。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并行与并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当小程序开发完成后</title>
      <link href="posts/6343.html"/>
      <url>posts/6343.html</url>
      
        <content type="html"><![CDATA[<p>开发小程序后的一点总结</p><span id="more"></span><p>本来没想搞小程序的，谁知道寒假突然脑子发热，看了点视频和文章，就着现成的点子开始搞起来。</p><p>从1月20日到4月2日，平均每天投入10+小时，历经三次改版，一次阉割，无数次和UI吵架，总算把GoTE小程序做出来了。</p><h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">小程序名：GoTE行程发布小程序</span><br><span class="line">样式库：ColorUI</span><br><span class="line">插件：<span class="module-access"><span class="module"><span class="identifier">WxValidate</span>.</span></span>js（表单验证）</span><br><span class="line">外部API：高德地图开放平台（用于获取打车费用&lt;已阉割&gt;）</span><br><span class="line">前端：小程序原生</span><br><span class="line">后端：小程序云开发环境</span><br><span class="line">数据库：云开发 -&gt; 云数据库</span><br></pre></td></tr></table></figure><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/After-develop-minipro/%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A11.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/After-develop-minipro/%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A11.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="index"></p><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/After-develop-minipro/%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A12.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/After-develop-minipro/%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A12.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="index"></p><p>项目最初的出发点是由于学校地处偏僻，出行不便，坐公车经常拥挤且一站到底。打车费用又十分昂贵，且独自出行来往于学校这偏僻之地具有一定危险性。校外非法黑车趁机拉帮结派，用略低于滴滴的价格拉拢学生乘坐。为了大幅盈利设置了拼车一项，一行4人35元，但是单人拼车费用要17元！</p><p>所以我决定自己开发一个小程序供同学们发布行程信息，有相同行程的人可以互相联系一同出行，即节省了出行成本，又避免单独外出。</p><p>于是1月20日正式开动，在此后的不间断每天投入10+小时在其中，从产品定位，功能定义，开发，测试等等，历经73天最终定版，提交审核。</p><p>正当我满心欢喜的提交审核两天之后，审核团队冷冰冰的打回，再之后不管多少次修改都只有冷冰冰的这么一句话</p><p>&gt;_</p><p><img src="%E5%BD%93%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%AE%8C%E6%88%90%E5%90%8E/1.png" class="lazyload" data-srcset="%E5%BD%93%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%AE%8C%E6%88%90%E5%90%8E/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="审核回复"></p><p>我只是一个单纯的行程发布平台，连个车字都没有哪来的涉及拼车？不管是反馈还是重新提交都只有这么冷冰冰的一句话。</p><p>此项目对我来说有非凡的意义，</p><ol><li>第一个完整的个人项目</li><li>第一次完成想法落地实现的完整执行</li><li>第一次靠自学完成一个项目</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在被腾讯审核团队冷冰冰的打回N次之后，开始有些心灰意冷。在这次项目中，还是有一些体会的。</p><ol><li><p>在开发过程中慢慢明白了，小程序其实可以理解为一个微信内置浏览器，开发小程序的过程就跟开发网页类似。不过小程序封装了很多接口，提供了很多实现。如果是有开发经验的程序员，稍微熟悉语法就可以快速开发出一个完整的小程序，不夸张的说，一个商城，从零开始，快则半月，慢则一月。</p></li><li><p>小程序本身的局限性所致，小程序注定无法完全替代App。作为分销引流可以，要完全替代不太现实。小程序开发完全部资源包括代码不能超过2M，且运行载荷不能太大，否则会被微信的机制强制退出。如果你手机太老，还会把你的微信给强制退出（闪退）。所以承担一点分销展示的任务可以，完全搬上小程序会导致体验极其的差。参考 微信支付 -&gt; 酒店 -&gt; 同程艺龙小程序。大量的网络请求，实测 Iphone6 plus IOS 10.2 上运行体验很差.</p></li><li><p>像微信小程序，支付宝小程序，百度小程序等这种开发都是寄人篱下。用人家的平台，人家接口，享受人家封装好带来的便利，需要付出的代价就是非常严格的审核。这种情况下只能祈福于客服，出了问题或是疑问有个靠谱的客服或者回应显得尤为重要。像微信这种机器人只能说(ta)呵(ma)呵(de)了。</p></li><li><p>做成一件事情很难，特别是这种涉及很多用户，用户之间产生交流的事情，你要够专业，够团结，够投入，够拼，能力够强。GoTE是一个面向学生的，开放的平台，也就是说用户与用户之间会产生交流。在涉及到这种用户之间交流（社交）的时候就需要格外小心。比如GoTE：</p><ul><li><strong>第一</strong>要面临的问题就是用户身份验证。怎么确定你是学生？哪个学校的学生？目前能想到的就是利用超级课程表的方式，利用爬虫接入各学校教务系统，学生提供账号密码验证码，登录到教务系统中验证。</li><li><strong>第二</strong>怎么保障共同出行过程的顺利？怎么尽量确保双方之间不会发生矛盾（因为路费或是任何问题）？</li></ul><p> 看似简单的两个问题其实需要大量的工作。不过我只有一个人，很需要帮手。</p></li></ol><p>此文作为第一次实际行动的总结记录</p><p>谨此</p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通信中的加密与解密-详细版</title>
      <link href="posts/12119.html"/>
      <url>posts/12119.html</url>
      
        <content type="html"><![CDATA[<p>换个详细点的捋一捋</p><span id="more"></span><p>首先，用户的操作系统会内置一些CA机构的CA证书</p><blockquote><p>CA证书：CA机构颁发给自己的证书</p></blockquote><p>组成：</p><ul><li>CA的公钥</li><li>颁发者</li><li>颁发机构</li><li>有效期</li><li>其他内容</li><li>签名（CA私钥加密过）：<ul><li>对以上内容进行hash=&gt;hash值</li><li>hash的算法</li></ul></li></ul><p>这里签名是CA私钥加密过的，如果黑客用公钥解开签名，然后篡改信息再Hash，带上hash算法，就没办法加密回去，因为没CA私钥。</p><p>如果篡改成自己的公钥，再hash，带上hash算法，用自己的私钥加密（签名），这就是伪造CA证书，这样等于白干，因为操作系统会提示这个证书不可信，不过CA证书一般都是操作系统内置的，不需要网络请求，所以没机会拦截篡改。一般问题都出在CA机构内部。</p><p>那一个网站，它首先要找CA机构认证，认证完CA机构会给一张证书，这个就是网站证书了</p><blockquote><p>网站证书：CA机构给网站颁发的证书</p></blockquote><p>组成：</p><ul><li>网站的公钥</li><li>颁发者（CA机构）</li><li>颁发机构（网站）</li><li>有效期</li><li>其他内容</li><li>CA签名，也就是指纹（CA私钥加密过的）：<ul><li>对以上内容进行hash=&gt;hash值</li><li>hash的算法</li></ul></li></ul><p>这里的CA签名也是用CA私钥加密过的，如果黑客用CA公钥解开签名，然后篡改网站的公钥再hash，带上hash算法，就没法加密回去，因为没CA私钥。用黑客自己的私钥加密回去的话，用户拿到证书，根据颁发者（CA机构）拿出CA公钥，它解不开黑客的私钥。那就通信终止了。</p><h2 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h2><ul><li>首先用户请求网站给个证书看看</li><li>网站给了网站证书</li><li>用户就根据证书的颁发者去操作系统找颁发者的证书（也就是操作系统中的CA证书），去拿到CA公钥出来</li><li>然后用CA公钥解开CA签名拿到hash值1和hash算法</li><li>然后用hash算法自己计算整个证书的内容得到hash值2</li><li>对比hash值1和hash值2来验证网站证书有没有被篡改</li><li>验证通过后会生成一串随机字符串，自己保留一份，然后发一份让网站用网站的私钥加密这串随机字符串</li><li>网站把这串随机字符串用网站的私钥加密，发回给客户</li><li>用户再用证书上的网站的公钥去解，能解开，解开后对比回来的随机字符串和自己保留的那份随机字符串是不是一致</li><li>一致则说明对方就是服务器，而不是黑客瞎搞</li></ul><blockquote><p>为了服务器安全所以用户先hash一下再发，服务器加密就行了。用户解密完对比回来的hash跟自己留着的hash是不是一直就行了。hash过才能防止黑客发送一些有规律的字符串给服务器，从而寻找加密的规律。以此保护服务器私钥的安全</p></blockquote><p>如果证书没问题，对方却是黑客，那字符串用黑客的私钥加密，用户用网站的公钥是解不开的。<br>除非黑客能弄到网站的私钥，才能在这插一脚，像上面说的黑客发送有规律的字符串<br>不过被hash解决了，接下来就要传输密钥了。</p><hr><p>用户验证了一直，就用自己生成一串密钥，然后用网站的公钥加密，发给网站<br>网站用网站的私钥解密，得到密钥。<br>然后双方开始用密钥加密信息通信。</p><hr><p>通信的时候用户的数据写完，会先把内容hash一下生成摘要，再用密钥加密<br>网站收到之后会先用密钥解密，然后网站自己hash一下内容生成摘要，对比传过来的摘要看看是否一致<br><code>是</code>就没问题，<code>不一致</code>则说明黑客在中间捣乱。则断开连接</p><p>所以用密钥的时候，其实是 信息内容本身+hash出来的信息摘要，然后才加密</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/1.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="总结"></p>]]></content>
      
      
      <categories>
          
          <category> RSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-笔记【No-4】0x09-回文数</title>
      <link href="posts/13460.html"/>
      <url>posts/13460.html</url>
      
        <content type="html"><![CDATA[<p>LeetCode 第9题</p><span id="more"></span><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><blockquote><p>示例 1:<br>输入: 121<br>输出: true</p></blockquote><blockquote><p>示例 2:<br>输入: -121<br>输出: false</p></blockquote><p>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p><blockquote><p>示例 3:<br>输入: 10<br>输出: false</p></blockquote><p>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p><blockquote><p>进阶:<br>你能不将整数转为字符串来解决这个问题吗？</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>首先根据题意，负数肯定是不符合要求的。那第一步先判断给进来的数是不是小于0，是直接返回出去。</li><li>要达成回文数一般都要三位数，但是0~9，11，22，33…也可以是回文数，所以小于100的数也要处理一下</li><li>现在开始解题，会有两种情况，数字长度为奇数 和 偶数</li><li>如果是偶数，只要后半段 == 前半段，return ture</li><li>如果是奇数，只要前半段 == 后半段 / 10，return ture</li></ul><p>代码过程和计算水仙花数类似</p><p>把传进来的数x取余数k赋值给res，然后x 自除 10，第二轮res自乘10再＋取余数k</p><p>res向上迭代，x向下迭代，最后进行比较。如果遇到数字位数是奇数位就比较前半段是否等于后半段÷10</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x % <span class="number">10</span> == <span class="number">0</span> )  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; res)&#123;</span><br><span class="line">            res = res * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x == res || x == res / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入 1221，我们可以将数字“1221”的后半部分从“21”反转为“12”，并将其与前半部分“12”进行比较，因为二者相同，我们得知数字 1221 是回文。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-笔记【No-3】0x0D-罗马数字转整数</title>
      <link href="posts/64290.html"/>
      <url>posts/64290.html</url>
      
        <content type="html"><![CDATA[<p>LeetCode 第13题</p><span id="more"></span><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><table><thead><tr><th>字符</th><th>数值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><blockquote><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p></blockquote><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><blockquote><p>示例 1:</p></blockquote><p>输入: “III”</p><p>输出: 3</p><blockquote><p>示例 2:</p></blockquote><p>输入: “IV”</p><p>输出: 4</p><blockquote><p>示例 3:</p></blockquote><p>输入: “IX”</p><p>输出: 9</p><blockquote><p>示例 4:</p></blockquote><p>输入: “LVIII”</p><p>输出: 58</p><p>解释: L = 50, V= 5, III = 3.</p><blockquote><p>示例 5:</p></blockquote><p>输入: “MCMXCIV”</p><p>输出: 1994</p><p>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>首先建立一个HashMap来映射符号和值</li><li>然后对字符串从左到右来，如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。</li><li>以此类推到最右边的数，最终得到的结果即是答案</li></ol><p>这是LeetCode评论上的一条思路。非常简单粗暴。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&#x27;I&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;V&#x27;</span>,<span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;X&#x27;</span>,<span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;L&#x27;</span>,<span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;C&#x27;</span>,<span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;D&#x27;</span>,<span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;M&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = s.length();</span><br><span class="line">        <span class="comment">//最后一位不需要判断所以循环次数是size-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">            <span class="comment">//如果左边的数字小于右边的数字</span></span><br><span class="line">            <span class="keyword">if</span> (map.get(s.charAt(i)) &gt;= map.get(s.charAt(i+<span class="number">1</span>)))&#123;</span><br><span class="line">                 res += map.get(s.charAt(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果左边数字小于右边的数字（也就是通常4和9的情况）</span></span><br><span class="line">                res -= map.get(s.charAt(i)); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一位没被判断到，所以没被加上，记得加上去</span></span><br><span class="line">        res += map.get(s.charAt(size - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的if判断先写多数的情况，也就是左边的数大于右边的数。</p><p>这样才不会把时间浪费在 先判断少数情况（左边 小于右边），再执行多数情况的运算</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-笔记【No-2】0x07-整数反转</title>
      <link href="posts/45196.html"/>
      <url>posts/45196.html</url>
      
        <content type="html"><![CDATA[<p>LeetCode 第7题</p><span id="more"></span><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br>示例 1: 输入:  123  输出: 321<br>示例 2: 输入: -123 输出: -321<br>示例 3: 输入: 120   输出: 21<br>注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一开始的思路是把数字取模然后放到int数组里，但是这样复杂又难实现，时间复杂度上也没优势</p><p>后来看到网络上的答案，思路是这样的： 首先把要判断这个数是否超范围 然后再把这个数x拿来取模，获得最后一个数并赋值给一个新的变量 然后x自除10，进入下一次循环 第二次循环的时候新变量自乘10再加取模得到的数。最后返回这个新变量</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;            <span class="comment">//新变量</span></span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断我们取得的数是否超范围</span></span><br><span class="line">            <span class="comment">// 2^31-1 = 2147483647   |  -2^31 = -2147483648</span></span><br><span class="line">            <span class="keyword">if</span> (rev &gt; Integer.MAX_VALUE/<span class="number">10</span> || (rev == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (rev &lt; Integer.MIN_VALUE/<span class="number">10</span> || (rev == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; pop &lt; -<span class="number">8</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">int</span> pop = x % <span class="number">10</span>;        <span class="comment">//取模拿到个位数</span></span><br><span class="line">             rev = rev * <span class="number">10</span> + pop;      <span class="comment">//自身×10空出个位，然后加上刚刚取模出来的数</span></span><br><span class="line">             x /= <span class="number">10</span>;                   <span class="comment">//迭代条件。因为x是int类型，所以÷10以后小数点就被省略了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种思路，就不需要把数字切成一个一个再拼接。直接利用数字的特性，通过取模和乘除运算带达到效果。</p><ul><li>时间复杂度：O(log(x))，x 中大约有 log{10}(x)位数字。</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-笔记【No-1】0x01-两数之和</title>
      <link href="posts/52628.html"/>
      <url>posts/52628.html</url>
      
        <content type="html"><![CDATA[<p>LeetCode 第1题</p><span id="more"></span><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组  <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[<strong>0</strong>] + nums[<strong>1</strong>] = 2 + 7 = 9</p><p>所以返回 [<strong>0, 1</strong>]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路非常简单，就是把要找的数字target，减去第一个的差，是否等于第二个数</p><p>如果是，返回这两个数的下标，如果不是，循环继续。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == target - nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i , j &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一层循环取第一个数i，然后进入第二层循环，</p><p>第二层循环从第二个数j 开始，判断要找的数-第一个数i 的差 是否等于 第二个数 j</p><p>如果不是第二层取第三个数，再进行比较。</p><p>如果第二层遍历完还没结果说明第一层的第一个数i不对，所以第一层取第二个数</p><p>再次进入第二层依次遍历。</p><p>当差等于第二层的某个数的时候，说明找到了，返回i和j的下标。</p><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通信中的加密与解密</title>
      <link href="posts/42106.html"/>
      <url>posts/42106.html</url>
      
        <content type="html"><![CDATA[<p>怎么和聊天才能不被人看到信息内容？</p><span id="more"></span><h1 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h1><blockquote><p>应用场景：通信</p></blockquote><h3 id="传统的通信场景：明文"><a href="#传统的通信场景：明文" class="headerlink" title="传统的通信场景：明文"></a>传统的通信场景：明文</h3><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/1.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1"></p><p>如果这时候有个Hacker在中间嗅探他们的通信链路，那他们的内容就全都被看到了，甚至会被篡改</p><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/2.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2"></p><h3 id="加密-amp-解密"><a href="#加密-amp-解密" class="headerlink" title="加密&amp;解密"></a>加密&amp;解密</h3><p>明文有问题，那就加密，让中间的Hacker看不懂</p><h4 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h4><p><strong>通过约定的偏移和回正，达到A、B都看得懂，中间人看不懂的目的</strong></p><p>加密：A发送的信息，全部右偏移3个字母</p><p>解密：B接收后左回正3个字母，就得到正确信息了。</p><p><strong>例如</strong>：<code>Hello world</code></p><p>右偏移后变成 <code>Khnnr zrung</code></p><p><strong>但是</strong>这样的加密太容易被破解了。凯撒密码是一种很古老的在战争中使用过的一种加密信件的方式，这里不说汉字，就说英文26个字母，最多进行（回正1，回正2，回正3…回正25,回正-1，回正-2…回正-25）共50次就可以破解。</p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p><strong>A、B都将信息异或运算</strong></p><p>如果将信息转成二进制，然后和另一个二进制(这里用E表示)，得到加密结果</p><p>那加密结果和E异或就能得到原本的信息的二进制，再转换成文字就得到了信息。</p><p><code>A ^ E = C</code>    <code>C ^ E = A</code></p><p><strong>例如</strong>：</p><blockquote><p>加密的一方</p></blockquote><p>假设 Hello world 的二进制是 0110 0101 1101 </p><p>E 是：                    0101 1001 1010</p><p>加密（异或）的结果就是:    0011 1100 0111</p><blockquote><p>解密的一方</p></blockquote><p>收到了加密的信息:        0011 1100 0111</p><p>E 是：                    0101 1001 1010</p><p>解密（异或）的结果就是：0110 0101 1101</p><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/3.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="对称加密"></p><p>这就是利用异或的特性来进行信息的加密。所以关键的E 就叫做<strong>密钥</strong>（所以拿到密钥就能破解了）。</p><p>要确保双方都有 E 这把密钥。</p><p>对称加密有3个特点：</p><ul><li>仅做XOR（异或）运算，速度快    –优点</li><li>密钥跟数据长度相等     –缺点</li><li>双方需要提前拥有密钥</li></ul><h5 id="加密分片"><a href="#加密分片" class="headerlink" title="加密分片"></a>加密分片</h5><p>对称加密的缺点也明显，密钥长度跟数据长度相等。</p><p>解决的办法是：</p><p>把信息分组，每组对应一段密钥，分别做异或运算就可以得到<strong>密文分片</strong>，再合并到一起就得到密文（加密的信息）了。</p><p>接收的一方分别做异或运算得到<strong>明文分片</strong>，在合并到一起就得到原本的信息了。</p><p>加密分片的特点：</p><ul><li>数据按密钥长度分组，不足的填充</li><li>可以并行计算各个分组，优化了性能</li><li>密文跟明文的序列存在规律对应关系</li></ul><p>上面说的就是DES的ECB模式加密</p><p>不过这种简单的分组模式也是很容易发现规律</p><p>一般的改进思路是：信息第一次分组、加密、合并得到了一次密文，然后再进行第二次分组、加密、合并得到二次密文。</p><p>或者第一次分组，一次加密、二次加密、合并。</p><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p><strong>请求方请求公钥，接收方发送公钥，请求方加密后发送，接收方用私钥解密</strong></p><blockquote><p>那密钥这么好，但是有个问题：E（密钥）怎么传输？明文还是密文？</p></blockquote><p>答案是：明文。</p><p>那密钥是明文的，被Hacker嗅探到了，那上面那些不都白费了。</p><p>所以就有了 <strong>非对称加密</strong></p><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/4.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="非对称加密"></p><p>简单说就是：我先要个保险箱，然后把密钥放进去，关上。这个保险箱只有你开的了，所以被Hacker截获了他也开不了。</p><p>这就是非对称加密。谁都可以跟B拿保险箱，只有B自己才开得了保险箱。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">打开状态的<span class="comment">[保险箱]</span> == 公钥</span><br><span class="line"></span><br><span class="line">关闭状态的<span class="comment">[保险箱]</span> == 密文</span><br><span class="line"></span><br><span class="line">保险箱钥匙 == 私钥</span><br></pre></td></tr></table></figure><p>他们的特点就是：</p><ul><li>任何人都可以请求并拿到公钥</li><li>用公钥加密明文变成密文</li><li>仅能用私钥解开密文得到明文</li><li>私钥不能丢失</li></ul><p>RSA就是这样一个公钥（保险箱）私钥（钥匙）的算法，具体的数学应用利用了 <em>大质数相乘难以分解</em>，<em>费马小定理</em> 等数学理论，使得它难以破解（思考：所以从质数、小定理这些数学理论入手，是不是有机会破解非对称加密？）。</p><blockquote><p>非对称加密需要做乘法模除等运算，性能效率比对称加密差很多。</p><p>对称加密需要做异或预算，性能效率比较高。</p><p>那么就综合起来，用非对称加密传输密钥E，然后再用对称加密传输数据。</p></blockquote><h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p><strong>找个我们都信得过的组织来保证我们不会被骗走密钥</strong></p><p>接上面的思考，其实不用那么麻烦，硬刚刚不赢，可以曲线救国嘛~~</p><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/5.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="认证"></p><p>如上，因为Hacker在中间截胡，所以他两边欺骗，然后只是做一个转发的工作。这个过程中，信息就给他看完了，而A、B都以为自己在跟对方通信，其实都被Hacker欺骗了。接下来开始传输数据的时候，Hacker前面拿到了密钥，所以他能解密任何数据，这样就绕过了非对称加密，保险箱不起作用了。</p><h5 id="CA证书"><a href="#CA证书" class="headerlink" title="CA证书"></a>CA证书</h5><blockquote><p>那要怎么保证A请求B的公钥（保险箱）后，对方发过来的公钥（保险箱）就一定是B的呢？</p></blockquote><p>这里就需要一个彼此信任的组织，给每个人发身份证。就好像我们信任政府发的个人身份证（假设身份证没法伪造），所以我们看到个人身份证的时候就相信这个叫身份证上的名字。</p><p><strong>在加密中，这个政府就是CA，身份证就是CA证书、CA数字签名。</strong></p><p>大家都信任CA，所以检查CA证书后我们就相信B 是 B。</p><p>这个证书里面有两个重要的内容：<strong>B的公钥+CA做的数字签名</strong></p><p>CA证书是<strong>反过来的</strong>，用私钥加密，用公钥解密。</p><p>CA用自己的私钥加密B的信息，A手里都有CA的公钥，在收到信息的时候，用CA的公钥解密，如果能解开，就证明B就是B。</p><p>换句话说，A请求B发保险箱过来，B先把保险箱给CA做个记号（CA认证加密），然后再发给A，A收到后看看记号跟CA约定的一不一样（CA的公钥解不解得开），如果Hacker发一个自己的保险箱，上面是没记号的（或者记号跟约定的不一样），那就说明这个保险箱是假的。</p><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/6.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="CA证书"></p><p>以上就是一个简单的过程，Hacker发的假保险箱（公钥）跟CA约定的不一样（CA公钥解不开），A就停止发送密钥，Hacker欺骗失败</p><h4 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h4><p>非对称加密 和 认证 解决了保密性和真实性，但是完整性还没有一个保障。</p><blockquote><p>如果Hacker等A、B非对称加密传输完密钥之后，在对称加密传输数据这个环节入手，篡改信息怎么办？</p></blockquote><p>答案是：哈希一下</p><p>单向哈希（Hash）可以把一个输入变成一个定长的输出串，它的特点就是无法从这个输入逆向还原输入内容，并且输入只要有一点改变，哪怕是那么一丢丢，输出串都会完全不同。</p><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/7.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="完整性"></p><p>这里哈希并不是这么简单，只需要知道哈希不可逆，一点点改变都会导致结果完全不同。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>安全可靠的通信：</p><ol><li>B让CA用 # CA私钥 # 签名 [B的公钥]（给B的保险箱做个记号）</li><li>A请求B给 [B的公钥]（打开的保险箱）</li><li>B发送签名过的 [[B的公钥]]（带记号的保险箱）给A</li><li>A用 ## CA的公钥 ## 校验B发来的 [[ B的公钥 ]]（检查记号）</li><li>用 [ B的公钥 ] 加密 “密钥E”（密钥放进保险箱关上门）</li><li>B用【B的私钥】解密 “密钥E”</li><li>A 用 “密钥E” 加密后传输数据</li><li>B 用 “密钥E” 解密数据</li></ol><p>&gt;_</p><p><img src="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/8.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/illustration-pic/Encrypt-Decrypt/8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="总结"></p>]]></content>
      
      
      <categories>
          
          <category> RSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA加密原理</title>
      <link href="posts/35371.html"/>
      <url>posts/35371.html</url>
      
        <content type="html"><![CDATA[<p>数学是一种很奇妙的东西</p><span id="more"></span><p>质数：只能<strong>被1和自身整除</strong>的数</p><p>互质数：两个数的<strong>公约数只有1</strong>，这两个为互质数</p><p>欧拉函数：OL(n)=x，x：从0到n的范围内，和n互质的数 的 <strong>个数</strong>，也就是从0到n的范围内，和n的公约数只有1的数的个数</p><h1 id="RSA加密原理"><a href="#RSA加密原理" class="headerlink" title="RSA加密原理"></a>RSA加密原理</h1><blockquote><p>P：质数1    Q：质数2    N：最小公倍数    OL(N)=X  -&gt; X：小于N &amp; 和N互质 的数的<strong>个数</strong></p><p>E：公钥    D：私钥    M：明文    C：密文</p></blockquote><ol><li><p>找出P、Q</p><p> 比如：P = 3    Q=11</p></li><li><p>找公共模数（求最小公倍数）</p><p> N = P * Q = 3 * 11 = 33    N=33</p></li><li><p>欧拉函数</p><p> OL(N) = (P - 1)(Q - 1)</p><p> OL(33) = (3 - 1)(11 - 1) = 20</p></li><li><p>计算公钥E</p><p> 1 &lt; E &lt; OL(N)    =    1 &lt; (1,20) &lt; 20</p><blockquote><p>E的取值范围{3，5，7，11，13，17，19}</p><p>E必须是整数，E必须和**OL(N)**互质</p><p>假设E=3，3是整数，3和20互质</p></blockquote></li><li><p>计算私钥D</p><p> E * D % OL(N) = 1    =    3 * D % 20 = 1，得出D=7</p></li></ol><p>到这我们就计算出公钥和密钥了，现在我们开始用公钥加密，然后用私钥解密</p><h3 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h3><ol><li><p>公钥加密</p><p> 比如我们加密数字2：M=2</p><p> C = M<sup>E</sup> mod N; 即    密文 = 明文<sup>公钥</sup> % 最小公倍数</p><p> C = 2<sup>3</sup> % 33 = 8    C = 8 </p><blockquote><p>明文2经过RSA加密后变成密文8</p></blockquote></li><li><p>私钥解密</p><p> M = C<sup>d</sup> mod N; 即 明文 = 密文<sup>私钥</sup> % 最小公倍数</p><p> M = 8<sup>7</sup> % 33 = 2    M = 2</p><blockquote><p>密文8经过RSA解密后变成明文2</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> RSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="posts/16107.html"/>
      <url>posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Hello world !</p><span id="more"></span><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
