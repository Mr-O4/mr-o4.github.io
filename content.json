{"meta":{"title":"Boii","subtitle":"Mr.Boii","description":"Talk is cheap, Show me the code!","author":"Mr.Boii","url":"https://www.boii.xyz","root":"/"},"pages":[{"title":"","date":"2021-06-10T04:49:04.505Z","updated":"2021-06-10T04:49:04.505Z","comments":true,"path":"404.html","permalink":"https://www.boii.xyz/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":" ","date":"2020-08-22T16:00:00.000Z","updated":"2021-06-13T03:50:18.591Z","comments":false,"path":"about/index.html","permalink":"https://www.boii.xyz/about/","excerpt":"","text":"Profile Mr.Boii 男 95后 菜鸡小学生 不爱搞事 不爱刷圈 拒绝IE 拥抱开源 喜欢的书《Python 语言从入门到上天》 —— Python是世界上最好的语言《颈椎腰椎康复指南》 —— 别治了，没救的。 喜欢的影视《让子弹飞》 —— 姜文《3 Idiot》 —— 阿米尔·汗 喜欢的话Talk is cheap. Show me the code！ 屁话少说，放码过来！ Standards are paper. I use paper to wipe my butt every day. That how much that paper is worth. 标准就是一堆纸。我每天用这堆纸擦屁股。这就是这些纸的价值所在。 I’m allways right. This time I’m just even more right than usual. 我总是正确的。这次我比平时更正确一些。 finally,My name is Linus Torvalds and I am your god. 我的名字叫Linus Torvalds，我是你们的上帝。 联系i@tcp404.com 经常不在线，有事发了也没用哈哈哈哈哈！ 声明本博客所有内容均为原创，如有雷同，算你抄我。"},{"title":"","date":"2021-05-22T16:24:30.999Z","updated":"2021-05-22T16:24:30.999Z","comments":false,"path":"artitalk/index.html","permalink":"https://www.boii.xyz/artitalk/","excerpt":"","text":""},{"title":"分类","date":"2020-08-22T10:17:14.000Z","updated":"2021-05-22T13:37:47.800Z","comments":true,"path":"categories/index.html","permalink":"https://www.boii.xyz/categories/","excerpt":"","text":""},{"title":"","date":"2021-06-14T07:44:42.035Z","updated":"2021-06-14T07:44:42.035Z","comments":true,"path":"friends/index.html","permalink":"https://www.boii.xyz/friends/","excerpt":"你在，便足矣 F R I E N D S","text":"你在，便足矣 F R I E N D S 如何添加友链 添加方式友链要求第一步：先将本站链接添加至贵站title: Boiiurl: https://www.boii.xyzavatar: https://cdn.jsdelivr.net/gh/TCP404/HEXO-CDN/images/icon/bolgger.pngscreenshot: https://cdn.jsdelivr.net/gh/TCP404/Picgo/blog/cover/site-screenshot.pngdescription: 一切皆零，万物归一第二步：复制下面的内容，按照格式填写并提交评论123456- title: &quot;博客站名&quot;, url: &quot;博客站点链接&quot;, avatar: &quot;站主头像外链&quot;, screenshot: &quot;博客截图外链&quot;, description: &quot;形容自己的博客&quot;, group: &quot;可以选&#x27;技术大佬&#x27;或者&#x27;憨憨铁&#x27;&quot;除了 “group”，其他都是必填项哦 为提高图片加载速度，建议优化头像和截图：打开 压缩图 上传自己的截图，将图片大小压缩到 1Mb以下。[在线压缩图片]将压缩后的图片上传到自己搭建的图床、去不图床 等，并使用此图片链接作为截图第三步：下方评论区留言，等待博主审核评论区记得填写QQ邮箱，博主会收到微信及邮件通知，待审核通过后刷新本页面即可显示 请确保您的博客站点能够正常访问， 拒绝死链 原则上只接收博客类网站友链，资源站、视频站等一切非博客类网站不予交换 网站不应有繁杂的广告、推广信息或者违规违法的内容"},{"title":"标签","date":"2020-04-07T02:20:07.000Z","updated":"2021-05-22T13:37:47.800Z","comments":true,"path":"tags/index.html","permalink":"https://www.boii.xyz/tags/","excerpt":"","text":""}],"posts":[{"title":"Golang [nil] 选项设计模式","slug":"Go/nil/Golang-nil-选项设计模式","date":"2021-07-28T08:20:43.000Z","updated":"2021-07-28T08:20:43.000Z","comments":true,"path":"posts/f0e2800f.html","link":"","permalink":"https://www.boii.xyz/posts/f0e2800f.html","excerpt":"用函数式编程的方法解决多成员结构体的初始化问题","text":"用函数式编程的方法解决多成员结构体的初始化问题 选项设计模式在编写程序时，经常会遇到这样一类场景： 定义一个包内可见的结构体，对外提供一个 NewSTRUCT() 方法来创建。 而创建时要求使用者给出结构体变量的值作为参数。当结构体变量很多的时候，会写出一堆很丑很可怕的代码。例如： 12345678910111213141516171819202122232425262728type student struct &#123; name string // *必填 age int // *必填 height int // 选填 weight int // 选填 score float32 // 选填&#125;func NewStudent (name string, age int) *student &#123; return &amp;student&#123;name: name, age: age&#125;&#125;func NewStudentWithHight (name string, age, height int) *student &#123; return &amp;student&#123;name: name, age: age, height: height&#125;&#125;func NewStudentWithWeight (name string, age, weight int) *student &#123; return &amp;student&#123;name: name, age: age, weight: weight&#125;&#125;func NewStudentWithScore (name string, age int, score float32) *student &#123; return &amp;student&#123;name: name, age: age, score: score&#125;&#125;func NewStudentWithHightAndWeight(name string, age, height, weight int) *student &#123; return &amp;student&#123;name: name, age: age, height: height, weight: weight&#125;&#125;... 这样的代码真的… 又臭又长。 因为 Golang 不支持函数重载，所以你不得不使用不同的函数名来对应不同的配置选项。 解决方法有两种：Builder 模式 和 Function Option 模式 Builder 模式Builder 模式又称生成器模式，通过为目标结构体多创建一个 Builder 结构体 来负责创建 student 这件事，一般以目标结构体的名称 + Builder 命名。 使用 Builder 模式的步骤如下： 定义一个 Builder 结构体，并在结构体中携带一个目标结构体的指针 并在构造 Builder 的函数里要求一些 必填 的参数，然后返回一个 Builder 对象 逐一为目标结构体的 选填 参数定义属于 Builder 结构体的方法，注意这些方法的返回值只能是 Builder结构体，这样才可以链式调用 最后编写 Builder 结构体的 Build() 方法，返回目标结构体 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 目标结构体：studenttype student struct &#123; name string // *必填 age int // *必填 height int // 选填 weight int // 选填 score float32 // 选填&#125;// 目标结构体的 builder：studentBuildertype studentBuilder struct &#123; stu *student // 携带一个目标结构体 student 的指针&#125;// 学生 builder 的创建方法，要求输入必填项func NewStudentBuilder (name string, age int) *studentBuilder&#123; s := student&#123;name: name, age: age&#125; return &amp;studentBuilder&#123;stu: &amp;s&#125;&#125;// 其他选填项，重点在于这是 builder 的方法，返回值是 builder 自己，这样才可以链式调用func (b *studentBuilder) Height (h int) *studentBuilder &#123; b.stu.height = h return b&#125;func (b *studentBuilder) Weight (w int) *studentBuilder &#123; b.stu.weight = w return b&#125;func (b *studentBuilder) Score (s float32) *studentBuilder &#123; b.stu.score = s return b&#125;// 最重要的一步：通过 Build 方法把 student 结构体返回出去func (b *studentBuilder) Build () *student &#123; return b.stu&#125;// 把 student 的构建函数也代理过来，这一步可选可不选func NewStudent(name string, age int) *studentBuilder &#123; s := student&#123;name: name, age: age&#125; return &amp;studentBuilder&#123;stu: &amp;s&#125;&#125; 这样在创建 student 的时候可以这样调用： 12345func main() &#123; s1 := NewStudentBuilder(&quot;Boii&quot;, 18).Height(180).Weight(150).Score(100.0).Build() // 或者 s2 := NewStudent(&quot;Boii&quot;, 18).Height(180).Weight(150).Score(100.0).Build()&#125; 简洁清晰！ Function Option 模式上面的 Builder 模式其实是设计模式中的一种创建型模式，在 Java 中可以使用内部类把 Builder 嵌在目标类中，但是在 Golang 就得多搞出一个结构体。但是使用 Function Option 模式则不需要多余的结构体，还可以发挥函数式编程的优点。 使用 Function Option 模式的步骤如下： 自定义一个 Option 类型，以一个函数为基础，该函数接收一个目标结构体指针为参数 逐一为目标结构体的每一个变量定义一个选项函数，接收变量的值，返回 Option 类型；在返回的 Option 中将变量的值赋给目标结构体 定义目标结构体的构造函数，在构造函数中： 参数：将 必填 选项作为普通参数，外加 Option 类型的可变参数 返回值：目标结构体 函数体：构造目标结构体对象，遍历可变参数并执行，最后返回目标结构体对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 目标结构体：studenttype student struct &#123; name string // *必填 age int // *必填 height int // 选填 weight int // 选填 score float32 // 选填&#125;// 自定义一个 Option 类型，以一个函数为基础，函数结构一个目标结构体 student 指针作为参数type Option func(s *student) // 逐一为目标结构体的每一个变量定义一个选项函数，结构变量的值 n ，返回 Option 类型func Name(n string) Option &#123; return func(s *student) &#123; // 在返回的 Option 中将变量赋值 s.name = n &#125;&#125;func Age(a int) Option &#123; return func(s *student) &#123; s.age = a &#125;&#125;func Height(h int) Option &#123; return func(s *student) &#123; s.height =h &#125;&#125;func Weight(w int) Option &#123; return func(s *student) &#123; s.weight = w &#125;&#125;func Score(sc float32) Option &#123; return func(s *student) &#123; s.score = sc &#125;&#125;// 定义目标结构体的构造函数// 必填选项作为普通参数，Option 作为可变参数// 返回目标结构体对象func NewStudent(name string, age int, options ... Option) *student &#123; s := student&#123; // 构造一个目标结构体对象 name: name, age: age, height: 180, &#125; for _, option := range options &#123; // 遍历 options 得到传进来的一堆选项函数 option(&amp;s) // 执行这些选项函数 &#125; return &amp;s // 返回目标结构体对象&#125; 这样我们就可以像这样创建目标结构体： 12345func main() &#123; s1 := NewStudent(&quot;Boii&quot;, 18, Height(177), Weight(150), Score(100.00)) s2 := NewStudent(&quot;Boii&quot;, 18, Height(177), Weight(150)) s3 := NewStudent(&quot;Boii&quot;, 18, Score(100.00))&#125; 结语最推荐的还是 Function Option 模式，直接使用函数式编程，代码读起来也优雅。 它能带来一下好处（摘自左耳朵耗子叔）： 直觉式的编程 高度的可配置化 很容易维护和扩展 自文档 对于新来的人很容易上手 没有什么令人困惑的事（是nil 还是空）","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"nil","slug":"Golang/nil","permalink":"https://www.boii.xyz/categories/Golang/nil/"}],"tags":[{"name":"函数式编程","slug":"函数式编程","permalink":"https://www.boii.xyz/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"},{"name":"选项设计模式","slug":"选项设计模式","permalink":"https://www.boii.xyz/tags/%E9%80%89%E9%A1%B9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Function Option","slug":"Function-Option","permalink":"https://www.boii.xyz/tags/Function-Option/"},{"name":"生成器模式","slug":"生成器模式","permalink":"https://www.boii.xyz/tags/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"name":"Builder 模式","slug":"Builder-模式","permalink":"https://www.boii.xyz/tags/Builder-%E6%A8%A1%E5%BC%8F/"}]},{"title":"Golang [nil] 交叉编译","slug":"Go/nil/Golang-nil-交叉编译","date":"2021-07-27T04:42:33.000Z","updated":"2021-07-27T04:42:33.000Z","comments":true,"path":"posts/c8f1d592.html","link":"","permalink":"https://www.boii.xyz/posts/c8f1d592.html","excerpt":"编译多平台程序的必备技能","text":"编译多平台程序的必备技能 交叉编译Golang 支持交叉编译，可以在一个平台上生成另一个平台的可执行程序。 Mac 下编译 Linux 和 Windows 64位可执行程序 12CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.goCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go12 Linux 下编译 Mac 和 Windows 64位可执行程序 12CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.goCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go12 Windows 下编译 Mac 和 Linux 64位可执行程序 123456789SET CGO_ENABLED=0SET GOOS=darwinSET GOARCH=amd64go build main.goSET CGO_ENABLED=0SET GOOS=linuxSET GOARCH=amd64go build main.go 上面的命令编译 64 位可执行程序，也可以使用 386 编译 32 位可执行程序。 条件编译Golang 虽然能跨平台编译但是也无法完全解决平台之间的差异，不过 Golang 能够选择性编译。 当我们写的程序在不同的平台上调用的东西不同时，比如编译 Linux 平台的可执行文件的时候要编译这个文件，编译 Windows 平台的可执行文件的时候要编译那个文件。这种情况下就可以使用选择性编译。 选择性编译有两种方式： 编译注释（构建约束） 和 文件后缀。 编译注释（构建约束）编译注释长这样： 1234// +build darwin freebsd// sort package is used to sort.package sort 第一行就是编译注释，或者叫构建约束（build constraint）、构建标记（build tag）。 格式为： 1// +build [$GOOS] [$GOARCH] 这是 Go 一开始就有的特性，在 Go 源码中有很多这样的注释行。上面注释行的意思，这个文件只在 darwin 系统或 freebsd 系统下会包含在包中，其他系统会忽略这个文件。 它需要遵循以下几点： 必须在文件顶部附近，它的前面只能有空行或其他注释行；可见包子句也在约束之后 约束可以出现在任何源文件中，比如 .go、.s 等 约束可以有多行 为了区别约束和包文档，在约束之后必须有空行 // 后面必须留一个空格 +build 是关键字，声明这是一个编译注释 逻辑关系: !: 非（感叹号） ,: 与（逗号） : 或（空格） $GOOS 取值： darwin dragonfly freebsd linux netbsd openbsd plan9 solaris windows $GOARCH 取值： 386 amd64 arm GOOS 和 GOARCH 的取值可以通过命令 go tool dist list 查看 示例123// +build A,B !C,D 代表编译此文件需符合 (A且B) 或 ((非C)且D) 。 12// +build !windows,arm代表此文件在 系统不是windows，并且处理器架构是arm时编译 文件后缀通过在文件名后加上 _$GOOS.go 的方式也可以实现条件编译。 后缀有3种形式： _$GOOS.go _$GOARCH.go _$GOOS_$GOARCH.go 示例1234color_windows.go // 该文件仅在编译 windows 可执行文件时编译color_linux.go // 该文件仅在编译 linux 可执行文件时编译color_darwin.go // 该文件仅在编译 darwin 可执行文件时编译color_linux_arm.go // 该文件仅在编译 linux 可执行文件时，且处理器架构为 arm 时编译 如何选择如果是排除某一两个平台的情况如果是在很多个平台都可用的情况则使用 编译注释 如果是指定某一个平台的情况如果是指定某一种架构的情况则使用 文件后缀 其他文件名以 下划线 或 点 开头的文件不会被编译。 12_file.cfg.set.vm 这两个文件在编译时不会被编译。 新版构建约束自 Go1.17 开始，Golang 调整了构建约束，也就是编译注释。 1//go:build [$GOOS] [$GOARCH] 对比旧版： 1// +build linux,amd64 新版： 1//go:build linux &amp;&amp; amd64 主要改变： // +build 改成 //go:build，双斜杠后没有空格！！ 一个文件只能有一行构建语句。（旧版可以多行） gofmt 工具会自动根据旧版语法生成对应的新版语法，并且为了兼容两者都保留，新版在支持的环境下会覆盖旧版。 1// +build !freebsd, !plan9 gofmt 后： 12//go:build !freebsd &amp;&amp; !plan9// +build !freebsd, !plan9","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"nil","slug":"Golang/nil","permalink":"https://www.boii.xyz/categories/Golang/nil/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"},{"name":"交叉编译","slug":"交叉编译","permalink":"https://www.boii.xyz/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"name":"条件编译","slug":"条件编译","permalink":"https://www.boii.xyz/tags/%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/"}]},{"title":"Golang [nil] 类型转换","slug":"Go/Basic/Golang-类型转换","date":"2021-07-19T15:40:51.000Z","updated":"2021-07-19T15:40:51.000Z","comments":true,"path":"posts/2c39f343.html","link":"","permalink":"https://www.boii.xyz/posts/2c39f343.html","excerpt":"类型转换的三种方式","text":"类型转换的三种方式 类型转换Go 不会对数据进行隐式转换，只能显式的手动转换 简单的转换1T(expression) eg： 123456int(time.Now().Weekday()) // 星期转intint(time.now().Month()) // 月份转intvar a float32a = 3.14b := int(a) // float32 转 int 注意：这种方式不是所有数据类型都能转换的。 例如 string 类型的 &quot;Boii&quot; 转 int 就会失败 低精度转高精度时是安全的，高精度转低精度则会丢失精度，例如 float64转float32 不能对 int、float 同 string 互转，跨大类型转换，可以使用 strconv 包 提供的函数 strconv 包strconv 包提供了基本数据类型之间的类型转换功能。 string -&gt; int : Atoi()将 string 转换为 int：Atoi() Atoi() 函数签名： 1func Atoi(s string) (int, error) 由于 string 有可能无法转换为 int，所以提供了两个返回值 第一个是转换成 int 的值 第二个是返回是否转换成功 eg： 123456789// successi, err := strconv.Atoi(&quot;3&quot;)fmt.Print(i + 5) // 8// faili, err := strconv.Atoi(&quot;a&quot;)if err != nil &#123; fmt.Print(&quot;Converted FAILED!&quot;)&#125; int -&gt; string : Itoa()1func Itoa(i int) string eg： 123a := strconv.Itoa(18)fmt.Println(a) // 18fmt.Printf(&quot;%T \\n&quot;, a) // string string -&gt; T : ParseT()Parse 类函数用于将字符转转换为给定类型的值 ParseBool(str string)eg： 1234b, err := strconv.ParseBool(&quot;true&quot;)if err == nil &#123;4fmt.Println(b) // true&#125; ParseBool 的内部实现非常简单 123456789func ParseBool(str string) (bool, error) &#123;4switch str &#123;4case &quot;1&quot;, &quot;t&quot;, &quot;T&quot;, &quot;true&quot;, &quot;TRUE&quot;, &quot;True&quot;:44return true, nil4case &quot;0&quot;, &quot;f&quot;, &quot;F&quot;, &quot;false&quot;, &quot;FALSE&quot;, &quot;False&quot;:44return false, nil4&#125;4return false, syntaxError(&quot;ParseBool&quot;, str)&#125; ParseInt(s string, base int, bitSize int) s：要解析 int 的字符串 base：指定字符串中数字的进制（2到36），如果为0，会从字符串前置判断： 0b代表2进制 0o代表8进制 0x代表16进制 否则是10进制。 bitSize：指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64 eg： 12345i, err := strconv.ParseInt(&quot;-C&quot;, 16, 0)if err == nil &#123;4fmt.Println(i) // -124fmt.Printf(&quot;%T \\n&quot;, i) // int64&#125; 十六进制中，C代表12，例子中传递的是 -C ，也就是-12 ParseUint(s string, base int, bitSize int)和 Parseuint 一样，不过是针对 无符号整型的，如果传递一个有符号的数字字符串，会转换失败 eg： 123456789101112// successu, err := strconv.ParseUint(&quot;45&quot;, 7, 0)if err == nil &#123;4fmt.Println(u) // 334fmt.Printf(&quot;%T \\n&quot;, u) // uint64&#125;// failu, err := strconv.ParseUint(&quot;-10&quot;, 10, 0)if err != nil &#123; fmt.Print(&quot;Converted FAILED!&quot;)&#125; 7进制的 45 等于 10进制的33 ParseFloat(s string, bitSize int) s：要解析成 float 的字符串， bitSize：指定了期望的接收类型，32是float32（返回值可以不改变精确值的赋值给float32），64是float64。 eg： 12345f, err := strconv.ParseFloat(&quot;3.14&quot;, 64)if err == nil &#123;4fmt.Println(f) // 3.144fmt.Printf(&quot;%T \\n&quot;, f) // float64&#125; bitSize 表示位数，只能填 64或32，不过 ParseFloat 只能接收64位类型的浮点数，即使 bitSize 你填32，依然会返回一个 float64 类型的数据给你，因为其内部实现是调用了一个 atof32() 的函数，然后 return float64(f) 123456789101112131415func ParseFloat(s string, bitSize int) (float64, error) &#123;4f, n, err := parseFloatPrefix(s, bitSize)4if err == nil &amp;&amp; n != len(s) &#123;44return 0, syntaxError(fnParseFloat, s)4&#125;4return f, err&#125;func parseFloatPrefix(s string, bitSize int) (float64, int, error) &#123;4if bitSize == 32 &#123;44f, n, err := atof32(s)44return float64(f), n, err4&#125;4return atof64(s)&#125; ParseComplex(s string, bitSize int) s：要解析成 float 的字符串， bitSize：指定了期望的接收类型，64是complex64（返回值可以不改变精确值的赋值给float32），128是complex128。 eg： 12345c, err := strconv.ParseComplex(&quot;3+4i&quot;, 128)if err == nil &#123;4fmt.Println(c) // (3+4i)4fmt.Printf(&quot;%T \\n&quot;, c) // complex128&#125; T -&gt; string : FormatT()FormatT 系列函数用于将 T 类型数据转成字符串 FormatBool函数签名： 1FormatBool(b bool) string eg： 12b := strconv.FormatBool(true)fmt.Println(b) // true FormatInt函数签名： 1FormatInt(i int64, base int) string i：要转成字符串的数字，必须是 int64 类型 base：要转成什么进制再转字符串 eg： 12345i1 := strconv.FormatInt(31, 16)fmt.Println(i1) // 1f ,将 10进制的31 转成 16进制的1f 然后转成字符串返回i2 := strconv.FormatInt(-0x1E, 8)fmt.Println(i2) // -36, 将 16进制的-1E 转成 8进制的-36 然后转成字符串返回 FormatUint函数签名： 1FormatUint(i uint64, base int) string i：要转成字符串的数字，必须是 uint64 类型 base：要转成什么进制再转字符串 eg： 12u := strconv.FormatUint(12, 8)fmt.Println(u) // 14, 将 10进制的12 转成 8进制的14 然后转成字符串返回 FormatFloat函数签名： 1FormatFloat(f float64, fmt byte, prec, bitSize int) string f：要转成字符串的浮点数 fmt：[‘f’, ‘b’, ‘e’, ‘E’, ‘g’, ‘G’]；表示格式 f：000.000 b：000p±000 二进制指数 e：0.0000e±00 十进制指数 E：0.0000E±00 十进制指数 g：指数很大时用e格式，不大时用f格式 G：指数很大时用E格式，不大时用f格式 prec： 对于 f格式、e格式、E格式：控制小数点后位数 对于 g格式、G格式：控制中数字个数 为-1时，代表使用最少数量的、但又必需的数字来表示f bitSize：表示浮点数来源类型（32：float32、64：float64） eg： 123456789101112131415v := 4.12345678ff64 := strconv.FormatFloat(v, &#x27;f&#x27;, 30, 64)ff32 := strconv.FormatFloat(v, &#x27;f&#x27;, 30, 32)fb := strconv.FormatFloat(v, &#x27;b&#x27;, 10, 32)fe := strconv.FormatFloat(v, &#x27;e&#x27;, -1, 32)fe10 := strconv.FormatFloat(v, &#x27;e&#x27;, 10, 32)fg := strconv.FormatFloat(v, &#x27;g&#x27;, 10, 32)fmt.Println(ff64) // 4.123456779999999710639713157434fmt.Println(ff32) // 4.123456954956054687500000000000fmt.Println(fb) // 8647516p-21fmt.Println(fe) // 4.123457e+00fmt.Println(fe10) // 4.1234569550e+00fmt.Println(fg) // 4.123456955 FormatComplex函数签名： 1FormatComplex(c complex128, fmt byte, prec, bitSize int) string f：要转成字符串的复数 fmt：[‘f’, ‘b’, ‘e’, ‘E’, ‘g’, ‘G’]；表示格式 f：000.000 b：000p±000 二进制指数 e：0.0000e±00 十进制指数 E：0.0000E±00 十进制指数 g：指数很大时用e格式，不大时用f格式 G：指数很大时用E格式，不大时用f格式 prec： 对于 f格式、e格式、E格式：控制小数点后位数 对于 g格式、G格式：控制中数字个数 为-1时，代表使用最少数量的、但又必需的数字来表示f bitSize：表示复数来源类型（64：complex64、128：complex128） eg： 12c := strconv.FormatComplex(3+8i, &#x27;e&#x27;, 10, 64)fmt.Println(c) // (3.0000000000e+00+8.0000000000e+00i) T -&gt; string &amp; append to slice : AppendT()AppendT 系列函数用于将 T 转成字符串后 append 到一个 切片 slice 中 12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;strconv&quot;)func main() &#123; // 声明一个slice b10 := []byte(&quot;int (base 10):&quot;) // 将转换为10进制的string，追加到slice中 b10 = strconv.AppendInt(b10, -42, 10) fmt.Println(string(b10)) // int (base 10):-42 b16 := []byte(&quot;int (base 16):&quot;) b16 = strconv.AppendInt(b16, -42, 16) fmt.Println(string(b16)) // int (base 16):-2a&#125; 类型断言类型断言分两种形式：Type Assertion 和 Type Switch。 Type Assertion1expression.(Type) eg： 12t := i.(T)t, ok := i.(T) Type Assertion 的作用有两个： 检查 i 是否为 nil 检查 i 的值是否为 T 类型 使用方式有两种: t := i.(T)： 说明：可以断言一个接口对象 i 的值不是 nil，并且值是 T 类型。 断言成功：返回 i 的值给 t 断言失败：引发 panic t, ok := i.(T) 说明：可以断言一个接口对象 i 的值不是 nil，并且值是 T 类型。 断言成功：返回 i 的值给 t，ok 的值置为 true 断言失败：返回 T 的零值给 t，ok 的值置为 false eg： t := i.(T) 12345678910111213141516func main() &#123;4var i interface&#123;&#125; = 104t1 := i.(int)4fmt.Println(t1) // 104fmt.Println(&quot;+++++++++++++++++++++&quot;)4t2 := i.(string) // 这里会引发 panic4fmt.Println(t2)&#125;// --------------------------------------// Output:10+++++++++++++++++++++panic: interface conversion: interface &#123;&#125; is int, not string 接口值为 nil 时，断言会引发 panic 12345678func main() &#123;4var i interface&#123;&#125; // i 的值为 nil4t := i.(interface&#123;&#125;) // 这里会引发 panic4fmt.Println(t)&#125;// --------------------------------------// Output:panic: interface conversion: interface is nil, not interface &#123;&#125; t, ok := i.(T) 12345678910111213141516171819202122232425262728func main() &#123;4var i1 interface&#123;&#125; = 104t1, ok := i1.(interface&#123;&#125;)4fmt.Printf(&quot;t1: %d, %v\\n&quot;, t1, ok) // t1: 10, true4t2, ok := i1.(int)4fmt.Printf(&quot;t2: %v, %v\\n&quot;, t2, ok) // t2: 10, true4t3, ok := i1.(string)4fmt.Printf(&quot;t3: %v, %v\\n&quot;, t3, ok) // t3: , false4var i2 interface&#123;&#125;4t4, ok := i2.(interface&#123;&#125;)4fmt.Printf(&quot;t4: %v, %v\\n&quot;, t4, ok) // t4: &lt;nil&gt;, false4i2 = &quot;Boii&quot;4t5, ok := i2.(int)4fmt.Printf(&quot;t5: %v, %v\\n&quot;, t5, ok) // t5: 0, false4t6, ok := i2.(string)4fmt.Printf(&quot;t6: %v, %v\\n&quot;, t6, ok) // t6: Boii, true&#125;// --------------------------------------// Output:t1: 10, truet2: 10, truet3: , falset4: &lt;nil&gt;, falset5: 0, falset6: Boii, true 虽然 t3、t4、t5 断言失败，但没有引发 panic Type Switch上面的方式适合 断言指定一种类型，如果需要断言 接口对象 i 是多种类型中的一种，则需要用 Type Switch。 123456switch t := 接口对象.(type) &#123; case T1: ... case T2: ... case nil: ... default: ...&#125; 接口对象.(type) 中的 .(type) 是固定格式，不要修改。 1234567891011121314151617181920212223func typeSwitch(i interface&#123;&#125;) &#123; switch t := i.(type) &#123; case int: fmt.Println(t, &quot;is int.&quot;) case string: fmt.Println(t, &quot;is string.&quot;) case float64: fmt.Println(t, &quot;is float64&quot;) case nil: fmt.Println(t, &quot;is nil&quot;) default: fmt.Println(t, &quot;啥也不是&quot;) &#125;&#125;func main() &#123;4var i interface&#123;&#125;4typeSwitch(i) // &lt;nil&gt; is nil4typeSwitch(&quot;Boii&quot;) // Boii is string.4typeSwitch(3.14) // 3.14 is float644typeSwitch(true) // true 啥也不是&#125; t 是什么类型就走什么分支，t 是 nil 就走 case nil 分支，没有一个满足就走 default 分支。default 分支是可选的。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [nil] Go Module","slug":"Go/Basic/Golang-Go-Module","date":"2021-07-19T15:28:48.000Z","updated":"2021-07-19T15:28:48.000Z","comments":true,"path":"posts/5bdd8b42.html","link":"","permalink":"https://www.boii.xyz/posts/5bdd8b42.html","excerpt":"开启 Go Module 来管理你的模块","text":"开启 Go Module 来管理你的模块 Go Module启用 GO111MODULE版本要求：go 1.11+，1.13起默认开启 启用 go module 支持首先要设置环境变量，有三个可选值：auto、on、off，默认是 auto。 GO111MODULE=off 禁用模块支持，编译时会从 GOPATH 和 vendor 文件夹中查找包。 GO111MODULE=on 开启模块支持，编译时会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。 GO111MODULE=auto，当项目在 $GOPATH/src 外且项目根目录有 go.mod 文件时，开启模块支持。 设置 GO111MODULE=on 之后就可以使用 go module 了，以后就没必要在 GOPATH 中创建项目了。 使用 go module 管理依赖后会在项目根目录下生成两个文件 go.mod 和 go.sum。 开启方式： windows：在环境变量中添加一条值 Linux：直接执行命令到 /etc/profile 或 $HOME/.profile 1$ echo &quot;export GO111MODULE=auto&quot; &gt;&gt; /etc/profile 或者 1$ go env -w GO111MODULE=auto go mod 命令常用 go mod 命令如下： 12345678go mod init 初始化当前文件夹，创建 go.mod 文件go mod download 下载依赖的 module 到本地cache（默认为 $GOPATH/pkg/mod，使用命令 go env GOMODCACHE 可查看）go mod edit 编辑 go.mod 文件go mod graph 打印模块依赖图go mod tidy 增加缺少的 module，删除无用的 modulego mod vendor 将依赖复制到 vendor 下，vendor 目录不存在时会自动创建go mod verify 检验依赖go mod why 解释为什么要依赖 go mod init 初始化初始化当前文件夹，创建 go.mod 文件。 第一步，切换到项目目录中第二步，执行命令 go mod init module名 eg： go mod tidy 整理依赖我们在代码中删除依赖代码后，相关的依赖库并不会在 go.mod 文件中自动移除。这种情况下我们可以使用 go mod tidy 命令更新 go.mod 中的依赖关系。 1$ go mod tidy go mod edit 编辑mod文件格式化因为我们可以手动修改go.mod文件，所以有些时候需要格式化该文件。Go提供了一下命令： 1$ go mod edit -fmt 添加依赖项1$ go mod edit -require=要添加的模块 eg： 1$ go mod edit -require=rsc.io/quote 移除依赖项1$ go mod edit -droprequire=要移除的模块 eg： 1$ go mod edit -require=github.com/sirupsen/logrus@v1.7.1 go get在项目中执行 go get 命令可以下载依赖包，并且还可以指定下载的版本。 运行 go get -u 将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号) 运行 go get -u=patch 将会升级到最新的修订版本 运行 go get package@version 将会升级到指定的版本号 version 1$ go get 如果下载所有依赖可以使用 go mod download 命令。 go.mod 文件go.mod 有 5 种指令：module、go、require、exclude、replace module：定义模块路径 go：设置预期的语言版本 require：依赖包列表及版本 exclude：禁止依赖包列表（仅在当前模块为主模块时生效） replace：替换依赖包列表（仅在当前模块为主模块时生效） 1234567891011121314module my/thinggo 1.16require other/thing v1.0.2 // 这是注释require new/thing/v2 v2.3.4 // indirectrequire（ new/thing v2.3.4 old/thing v0.0.0-20190603091049-60506f45cf65）exclude old/thing v1.2.3replace bad/thing v1.4.5 =&gt; good/thing v1.4.5 语义化版本语义化版本号格式为：X.Y.Z（主版本号.次版本号.修订号），使用方法如下： 进行不向下兼容的修改时，递增主版本号。 API 保持向下兼容的新增及修改时，递增次版本号。 修复问题但不影响 API 时，递增修订号。 例如：有一个语义化版本号为：v0.1.2，则其主版本号为 0，次版本为 1，修订号为 2。 而前面的 v 是 version（版本）的首字母，是 Go 语言惯例使用的，标准的语义化版本没有这个约定。 所以在使用 Go 命令行工具或 go.mod 文件时，就可以使用语义化版本号来进行模块查询，具体规则如下： 默认值（@latest）：将匹配最新可用的标签版本或源码库的最新未标签版本。 指定某个 commit（@c854792）：将匹配该 commit 时的版本。 指定某个分支（@master）：将匹配该分支版本。 完全指定版本（@v1.2.3）：将匹配该指定版本。 版本前缀（@v1 或 @v1.2）：将匹配具有该前缀的最新可用标签版本。 版本比较（@&lt;v1.2.3 或 @&gt;=v1.5.6）：将匹配最接近比较目标的可用标签版本。&lt; 则为小于该版本的最新版本，&gt; 则为大于版本的最旧版本。当使用类 Unix 系统时，需用引号将字符串包裹起来以防止大于小于号被解释为重定向。 如：go get &#39;github.com/gin-gonic/gin@&lt;v1.2.3&#39;。 如上图所示，为了能让 Go Modules 的使用者能够从旧版本更方便地升级至新版本，Go 语言官方提出了两个重要的规则： 导入兼容性规则（import compatibility rule）：如果旧包和新包具有相同的导入路径，则新包必须向后兼容旧包。 语义化导入版本规则（semantic import versioning rule）：每个不同主版本（即不兼容的包 v1 或 v2）使用不同的导入路径，以主版本结尾，且每个主版本中最多一个。如：一个 rsc.io/quote、一个 rsc.io/quote/v2、一个 rsc.io/quote/v3。 而与 Git 分支的集成如下： 参考 Go Modules 详解 在项目中使用 go module既有项目如果需要对一个已经存在的项目启用 go module，可以按照以下步骤操作： 在项目目录下执行 go mod init，生成一个go.mod文件。 执行 go get，查找并记录当前项目的依赖，同时生成一个go.sum记录每个依赖库的版本和哈希值。 新项目对于一个新创建的项目，我们可以在项目文件夹下按照以下步骤操作： 执行 go mod init 项目名 命令，在当前项目文件夹下创建一个 go.mod 文件。 手动编辑 go.mod 中的 require 依赖项或执行 go get 自动发现、维护依赖。 如果没反应，可以试试 go mod tidy VSCode-go 的坑开启 GOMODULE 就报错 报错信息：found module &quot;golang.org/x/tools&quot; twice in the workspace 一开始的时候我是在 VSC 里建了一个工作区，把 GOPATH 所在目录添加在工作区里，然后开启 GO111MODULE=auto，结果就一直报错。后来新建一个工作区，把自己放项目的文件夹添加到工作区，就没事了。 我的 GOPATH：GOPATH=E:\\---CODE\\GO\\root GOPATH 放进去的工作区： 没有 GOPATH 的工作区 相安无事 go tools 下载失败解决办法：把 GOPROXY 改到 https://goproxy.cn。阿里云那个有时候不行，官网被墙。我试了只有这个地址一次过。 第一步：修改环境变量 GOPROXY 第二步：确保 GOPATH 下有bin、pkg、src 三个目录 第三步：在 VSC 中按下 Ctrl+Shift+P 唤醒快捷命令行，输入：Go:install/Update Tools，回车。 第四步：全选，然后点击 OK 开始下载 第四步：丝滑顺畅一次过","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Gin [0-Get Start]","slug":"Go/Framework/gin/Gin-0-Get-Start","date":"2021-07-19T10:12:21.000Z","updated":"2021-07-19T10:12:21.000Z","comments":true,"path":"posts/451cd62.html","link":"","permalink":"https://www.boii.xyz/posts/451cd62.html","excerpt":"Hello Gin.","text":"Hello Gin. GetStart要求 &gt;= Go v1.13 安装前提： 安装 Golang 设置 Go 工作区 下载并安装 gin： 1$ go get -u github.com/gin-gonic/gin 在代码中引入12import &quot;github.com/gin-gonic/gin&quot;import &quot;net/http&quot; 开始先创建一个go文件 1$ touch demo.go 接着编写下面的代码： 12345678910111213141516package mainimport ( &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func main() &#123; app := gin.Default() app.GET(&quot;/hi&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;Hello Gin!&quot;, &#125;) &#125;) app.Run() // 默认运行在 8080 端口&#125; 然后执行 go run demo.go 命令运行代码： 1$ go rum demo.go 最后打开浏览器访问 http://localhost:8080/hi","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Framework","slug":"Golang/Framework","permalink":"https://www.boii.xyz/categories/Golang/Framework/"}],"tags":[{"name":"gin","slug":"gin","permalink":"https://www.boii.xyz/tags/gin/"}]},{"title":"Gin [5-中间件]","slug":"Go/Framework/gin/Gin-5-中间件","date":"2021-07-19T10:11:45.000Z","updated":"2021-07-19T10:11:45.000Z","comments":true,"path":"posts/a55bf0d2.html","link":"","permalink":"https://www.boii.xyz/posts/a55bf0d2.html","excerpt":"中间件的创建和使用","text":"中间件的创建和使用 中间件用在 客户端 与 服务端 之间的插件，我们称之为 中间件。 中间件是一个概念，其实质就是一些遵循一定规范的函数，也称做 钩子函数(Hook)。 中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。 定义中间件定义一个中间件，其实就是定义一个 gin.HandlerFunc 这个 HandlerFunc 其实是一个函数，例如前面我们已经写了很多次的 GET请求、POST请求，第一个参数为路由路径，第二个参数写的就是这种格式的处理函数。 1func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes 对于这个 HandlerFunc，源码中是这样定义的： 1234//gin.go// HandlerFunc defines the handler used by gin middleware as return value.type HandlerFunc func(*Context) 形参列表只有一个 *gin.Context 类型的参数，没有返回值。 这样的函数就是一个 HandlerFunc，就可以作为一个中间件。 eg：定义一个计时中间件 1234567func timer(c *gin.Context) &#123; start := time.Now() c.Next() end := time.Since(start) fmt.Println(end)&#125; 简简单单，上面的栗子就已经定义了一个名为 timer 的中间件，用于计时。 这里的 c.Next() 是主动调用后面的 HandlerFunc，它还有一个兄弟：c.Abort()，这个我们放在后面讲。 局部注册中间件使用中间件也很简单，我们在接收请求的时候，即编写 Handler()、或者 GET() 这些方法时，最后一个参数就可以传入一个或多个 HandlerFunc。 eg: 1234567891011121314151617181920func sleep(c *gin.Context) &#123; start := time.Now() time.Sleep(time.Second) // 睡眠一秒 end := time.Since(start) fmt.Println(&quot;sleep middleware: &quot;, end)&#125;func indexHandler(c *gin.Context) &#123; fmt.Println(&quot;Index handler&quot;) c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;Here is index.&quot; &#125;)&#125;func main() &#123; r := gin.Default() r.GET(&quot;/&quot;, sleep, indexHandler) // 局部注册中间件到此路由 r.Run(&quot;:9090&quot;)&#125; 输出： 上面的栗子中可以看出，局部注册就是把中间件写在需要使用该中间件的路由中。 这里 timer 和 indexHandler 本质上都是一样的，但是被调用顺序不同。 客户端请求 / 这个路径时，会先调用 timer 这个中间件，等它执行完后再去执行 indexHandler。 全局注册中间件全局注册中间件，会使得该作用域下所有路由都会执行对应的中间件。注册时使用Use() 方法。 啥意思呢？ 就是说，假设你定义了 r := gin.Default()， 然后你写 r.Use(timer)，这样你的网站所有的路由都会执行 timer 这个中间件。 如果你是用 userG := r.Group(&quot;/user&quot;)，然后写 userG.Use(timer)，这样 userG 这个路由组下所有路由都会执行 timer 这个中间件 而组外的其他路由并不一定会执行 timer。 eg： 123456789101112131415161718192021222324252627282930// 定义一个中间件func timer(c *gin.Context) &#123; start := time.Now() c.Next() end := time.Since(start) fmt.Println(end)&#125;func main() &#123; r := gin.Default() userG := r.Group(&quot;/user&quot;) // 定义一个路由组 userG userG.Use(timer) // 绑定 timer 中间件 &#123; // 以下两个路由会执行 timer 中间件 userG.POST(&quot;/register&quot;, Register) userG.POST(&quot;/login&quot;, Login) &#125; // 定义一个路由组 boogG bookG := r.Group(&quot;/book&quot;) &#123; // 以下两个路由不会执行 timer 中间件 bookG.GET(&quot;/search/:id&quot;, SearchBook) bookG.DELETE(&quot;/remove/:id&quot;, RemoveBook) &#125; r.Run(&quot;:9090&quot;)&#125;... 可以清楚看到，请求 /user 组下的路径时，调用了 timer 打印了时间，而请求 /book 组时没有。 中间链（职责链模式）c.Next()上面的栗子中，我们使用到了 c.Next() 函数，这会改变程序的执行流。 中间件里没有使用到 c.Next() 的时候，其执行流如下 没有 c.Next() 的时候会执行完前一个中间件，就执行下一个中间件。 而在中间件中使用 c.Next() 时则会改变其执行流。 其实就是将下一个中间件的执行时机提前了，但是下一个中间件执行完以后还会回到当前的中间件。 其执行流如下图： eg： 123456789101112131415161718192021222324252627282930313233// 中间件1func m1(c *gin.Context) &#123; fmt.Println(&quot;m1 in...&quot;) c.Next() fmt.Println(&quot;m1 out...&quot;)&#125;// 中间件2func m2(c *gin.Context) &#123; fmt.Println(&quot;m2 in...&quot;) c.Next() fmt.Println(&quot;m2 out...&quot;)&#125;// 首页处理函数func indexHandler(c *gin.Context) &#123; fmt.Println(&quot;Index handler in...&quot;) c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;Here is index.&quot;, &#125;) c.Next() fmt.Println(&quot;Index handler out...&quot;)&#125;func main() &#123; r := gin.Default() r.GET(&quot;/&quot;, m1, m2, indexHandler) // 依次局部注册三个中间件 r.Run(&quot;:9090&quot;)&#125; 三个 HandlerFunc 的注册顺序依次是 m1、m2、indexHandler 每个都调用了 c.Next()， 所以他们的执行流应该是： c.Abort()c.Abort() 是 c.Next() 的兄弟。 c.Next() 调用下一个 HandlerFunc;c.Abort() 阻止调用下一个 HandlerFunc。一旦阻止了，则后面不管有多少个 HandlerFunc，它们都没有机会执行了。 eg： 12345678910111213141516171819202122232425262728293031323334353637383940// 中间件1func m1(c *gin.Context) &#123; fmt.Println(&quot;m1 in...&quot;) c.Next() fmt.Println(&quot;m1 out...&quot;)&#125;// 中间件2func m2(c *gin.Context) &#123; fmt.Println(&quot;m2 in...&quot;) c.Abort() // 阻止调用后面的 HandlerFunc fmt.Println(&quot;m2 out...&quot;)&#125;// 中间件3func m3(c *gin.Context) &#123; fmt.Println(&quot;m3 in...&quot;) c.Next() fmt.Println(&quot;m3 out...&quot;)&#125;// 首页处理函数func indexHandler(c *gin.Context) &#123; fmt.Println(&quot;Index handler in...&quot;) c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;Here is index.&quot;, &#125;) c.Next() fmt.Println(&quot;Index handler out...&quot;)&#125;func main() &#123; r := gin.Default() r.GET(&quot;/&quot;, m1, m2, m3, indexHandler) // 依次局部注册四个中间件 r.Run(&quot;:9090&quot;)&#125; 在 m2 的时候调用了 c.Abort()，所以后面的 m3、indexHandler 都没有机会执行了。 中间件之间数据传递中间件之间要传递数据，可以通过 c.Set(key, value) 的方式发送，在获取的地方用 c.Get(key) 的方式获取。 获取的方法有非常多，如下图： 在这里的获取要注意执行流的问题，如果第2个中间件执行 c.Set()，但是在第1个中间件就执行了 c.Get()，那会什么都拿不到。 eg： 1234567891011121314151617181920212223242526272829// 中间件1func m1(c *gin.Context) &#123; fmt.Println(&quot;m1 in...&quot;) c.Set(&quot;k&quot;, 123) // 设置数据 c.Next() fmt.Println(&quot;m1 out...&quot;)&#125;// 首页处理函数func indexHandler(c *gin.Context) &#123; fmt.Println(&quot;Index handler in...&quot;) fmt.Println(c.MustGet(&quot;k&quot;)) // 获取数据 c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;Here is index.&quot;, &#125;) fmt.Println(&quot;Index handler out...&quot;)&#125;func main() &#123; r := gin.Default() r.GET(&quot;/&quot;, m1, indexHandler) r.Run(&quot;:9090&quot;)&#125; 默认中间件gin.Default() 默认使用了 Logger 和 Recovery 中间件，其中： Logger中间件 将日志写入 gin.DefaultWriter，即使配置了 GIN_MODE=release。 Recovery中间件 会 recover 任何 panic。如果有panic的话，会写入500响应码。 如果不想使用上面两个默认的中间件，可以使用 gin.New() 新建一个没有任何默认中间件的路由。 并发注意事项gin中间件中使用goroutine 当在中间件或 handler 中启动新的 goroutine 时，不能使用原始的上下文（c *gin.Context），必须使用其只读副本（c.Copy()）。 123456789101112131415161718192021222324func m1(c *gin.Context) &#123; start := time.Now() end := time.Since(start) c.Set(&quot;timer&quot;, end) // go func(c) // 错误！！！ go func(c *gin.Context) &#123; // 只能使用上下文的拷贝，不能使用原本的上下文 fmt.Println(&quot;Other goroutine: &quot;, c.MustGet(&quot;timer&quot;)) &#125;(c.Copy())&#125;func indexHandler(c *gin.Context) &#123; timer := c.MustGet(&quot;timer&quot;) fmt.Println(&quot;indexHandler: &quot;, timer)&#125;func main() &#123; r := gin.Default() r.GET(&quot;/&quot;, indexHandler) r.Run(&quot;:9090&quot;)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Framework","slug":"Golang/Framework","permalink":"https://www.boii.xyz/categories/Golang/Framework/"}],"tags":[{"name":"gin","slug":"gin","permalink":"https://www.boii.xyz/tags/gin/"},{"name":"拦截器","slug":"拦截器","permalink":"https://www.boii.xyz/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"name":"中间件","slug":"中间件","permalink":"https://www.boii.xyz/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"监视器","slug":"监视器","permalink":"https://www.boii.xyz/tags/%E7%9B%91%E8%A7%86%E5%99%A8/"}]},{"title":"Gin [4-上传下载重定向]","slug":"Go/Framework/gin/Gin-4-上传下载重定向","date":"2021-07-19T10:11:34.000Z","updated":"2021-07-19T10:11:34.000Z","comments":true,"path":"posts/64ec0a72.html","link":"","permalink":"https://www.boii.xyz/posts/64ec0a72.html","excerpt":"上传、下载和重定向","text":"上传、下载和重定向 上传下载和重定向文件上传是后端开发中很常见的需求。 文件上传的原理无非是客户端 选择文件并点击上传，浏览器将文件内容读取然后传送到服务器； 服务端读取数据并新建文件，写入浏览器传输过来的内容。 单个文件上传前端部分1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;f1&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 前端需要用一个表单来进行上传，这里我们设置了表单提交的请求方式为 POST。 注意一定要指定编码类型 enctype=&quot;multipart/form-data&quot; 上传文件后点击上传按钮会向 http://localhost:9090/upload 这个路径发起POST请求。 后端部分1234567891011121314func main() &#123; r := gin.Default() r.POST(&quot;/upload&quot;, func(c *gin.Context) &#123; // 从请求中读取文件 f, _ := c.FormFile(&quot;f1&quot;) // 保存文件 c.SaveUploadedFile(f, &quot;./&quot; + f.Filename) // 给客户端返回上传成功的消息 c.JSON(200, gin.H&#123;&quot;code&quot;: 2003, &quot;msg&quot;: &quot;上传成功&quot;&#125;) &#125;) r.Run(&quot;:9090&quot;)&#125; 后端的处理主要分3步： 从请求中读取文件 保存文件 给客户端返回上传成功的消息 通过 gin.FormFile() 可以获取前端上传的文件，参数是 &lt;input /&gt; 标签的 name 属性，通过参数可以定位到上传的任何一个文件。 获取到文件后可以保存在数据库中，或者通过 gin.SaveUploadedFile() 将文件保存在某个位置，只需要将文件对象 f 和 路径作为参数传入即可。 最后给客户端返回一条上传成功的消息。 测试 使用 Postman使用 PostMan 时需要给 Header 添加一个属性 Content-Type: multipart/form-data 然后在 Body 中的 form-data 中上传数据 使用 curl 命令123curl -X POST http://localhost:9090/upload \\ -F &quot;file=@/xx/xx/xxx.zip&quot; \\ -H &quot;Content-Type: multipart/form-data&quot; 多个文件上传前端部分123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/upload_multi&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;files&quot; multiple&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 后端部分12345678910111213141516171819func main() &#123; r := gin.Default() r.POST(&quot;/upload&quot;, func(c *gin.Context) &#123; // 从请求中读取文件 form, _ := c.MultipartForm() files := form.File[&quot;files&quot;] // 逐个保存文件 for _, file := range files &#123; c.SaveUploadedFile(f, &quot;./&quot;+f.Filename) &#125; // 给客户端返回上传成功的消息 c.JSON(200, gin.H&#123;&quot;code&quot;: 2003, &quot;msg&quot;: &quot;上传成功&quot;&#125;) &#125;) r.Run(&quot;:9090&quot;)&#125; 单个文件上传和多个文件上传只有一点点区别 多个文件上传使用 gin.Context.MultipartForm() 来获取，该方法会返回一个 Form 结构体，结构体中map类型字段 File 存储了所有已上传的文件 通过遍历来逐个处理，然后给客户端返回上传成功的消息即可。 上传文件大小限制gin 默认上传的文件大小最大为 32Mb，如果要调小或调大，可以设置 gin.Engine.MaxMultipartMemory eg： 1234567func main() &#123; r := gin.Default() // 为 multipart forms 设置较高的内存限制 (默认是 32 MiB) r.MaxMultipartMemory = 2 &lt;&lt; 30; // 2*2^30 byte = 2Gb r.Run(&quot;:9090&quot;)&#125; 下载文件实现下载功能要先获取文件名，然后给响应头添加一个属性 Content-Disposition: attachment; filename=文件名 然后调用 gin.Context.File() 方法，传入文件路径即可。 12345678910111213func main() &#123; r := gin.Default() filename := &quot;a.txt&quot; r.GET(&quot;/download&quot;, func(c *gin.Context) &#123; // 获取文件名 filename := &quot;a.txt&quot; // 设置响应头 c.Header(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot;+filename) // 向客户端返回文件数据 c.File(&quot;./&quot;+filename) &#125; r.Run(&quot;:9090&quot;)&#125; 当然，还可以在响应头中添加更多信息 1234567891011121314151617func main() &#123; r := gin.Default() filename := &quot;a.txt&quot; r.GET(&quot;/download&quot;, func(c *gin.Context) &#123; // 获取文件名 filename := &quot;a.txt&quot; // 设置状态码 c.Writer.WriteHeader(http.StatusOK) // 添加内容位置声明 c.Header(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot;+filename) // 添加内容类型声明 c.Header(&quot;Content-Type&quot;, &quot;application/text/plain&quot;) // 向客户端返回数据 c.File(&quot;./&quot; + filename) &#125; r.Run(&quot;:9090&quot;)&#125; 注意！c.File(path) 中的参数 path 最好是绝对路径，可以使用 path.Join(路径, 文件名) 来得到绝对路径。处理不好 path 参数容易出错。 重定向 和 转发重定向和转发在实际开发过程中很有必要。 比如对 API 进行升级后，一些原本的请求路径不再使用，但是为了兼容，防止一些旧版本继续请求的时候请求失败，所以需要对原本的路由做重定向或转发处理。 区别： 重定向：用户请求一个旧的地址的时候，返回301，并告知新地址；然后用户再次请求新地址，得到正确返回。 重定向：重定向过后浏览器的URL会发生变化。 重定向：可以将请求转到别的地址，这个地址可以是外部链接，也可以是内部其他路由。 转发：用户请求一个旧地址的时候，服务端内部将请求路径修改为新地址，然后返回给用户 转发：转发过后浏览器的URL不会发生变化。 转发：只能转发到站内路由。 重定向1c.Redirect(http.StatusMovedPermanently, &quot;重定向的路径&quot;) eg： 12345678910111213141516171819func main() &#123; r := gin.Default() r.GET(&quot;/index&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: c.FullPath() &#125;) &#125;) // 重定向到站内其他路由 r.GET(&quot;/redirect&quot;, func(c *gin.Context) &#123; c.Redirect(http.StatusMovedPermanently, &quot;/index&quot;) &#125;) // 重定向到站外链接 r.GET(&quot;/redirect2&quot;, func(c *gin.Context) &#123; c.Redirect(http.StatusMovedPermanently, &quot;https://www.boii.xyz&quot;) &#125;) r.Run(&quot;:9090&quot;)&#125; 转发1c.Request.URL.Path = &quot;转发的目标路径&quot; eg： 123456789101112131415func main() &#123; r := gin.Default() r.GET(&quot;/index&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: c.FullPath() &#125;) &#125;) // 转发到站内其他路由 r.GET(&quot;/forward&quot;, func(c *gin.Context) &#123; // URL 不会改变 c.Request.URL.Path = &quot;/index&quot; // 修改请求的目标路径 r.HandleContext(c) &#125;) r.Run(&quot;:9090&quot;)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Framework","slug":"Golang/Framework","permalink":"https://www.boii.xyz/categories/Golang/Framework/"}],"tags":[{"name":"gin","slug":"gin","permalink":"https://www.boii.xyz/tags/gin/"},{"name":"上传","slug":"上传","permalink":"https://www.boii.xyz/tags/%E4%B8%8A%E4%BC%A0/"},{"name":"下载","slug":"下载","permalink":"https://www.boii.xyz/tags/%E4%B8%8B%E8%BD%BD/"},{"name":"重定向","slug":"重定向","permalink":"https://www.boii.xyz/tags/%E9%87%8D%E5%AE%9A%E5%90%91/"}]},{"title":"Gin [3-路由组]","slug":"Go/Framework/gin/Gin-3-路由组","date":"2021-07-19T10:11:18.000Z","updated":"2021-07-19T10:11:18.000Z","comments":true,"path":"posts/2c48000c.html","link":"","permalink":"https://www.boii.xyz/posts/2c48000c.html","excerpt":"路由和路由组的创建和实现","text":"路由和路由组的创建和实现 路由组开发中常常会遇到一种需求： 将系统划分成多个模块，例如用户管理模块、书籍管理模块等，这些模块下各自有子模块。 在设计路由路径的时候可能就需要设置成下面的样子： /user/register /user/login /user/:id/info /user/:id/setting /book/add /book/search/:id /book/remove/:id /book/modify/:id 这样的设计虽然没有什么问题，但是不方便管理，如果突然对 user 或者 book 这个大的模块进行修改还导致所有子模块全部都要改动。 所以合理的使用 路由组 可以很好的解决这些问题。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// main.gofunc main() &#123; r := gin.Default() // 创建 /user 路由组 userG := r.Group(&quot;/user&quot;) // &#123;&#125; 是书写规范 &#123; userG.POST(&quot;/register&quot;, Register) userG.POST(&quot;/login&quot;, Login) &#125; // 创建 /book 路由组 bookG := r.Group(&quot;/book&quot;) &#123; bookG.GET(&quot;/search/:id&quot;, SearchBook) bookG.DELETE(&quot;/remove/:id&quot;, RemoveBook) &#125; r.Run(&quot;:9090&quot;)&#125;// routes.gotype UserInfo struct &#123; User string `form:&quot;user&quot;` Pass string `form:&quot;pass&quot;`&#125;func Register(c *gin.Context) &#123; var u UserInfo c.ShouldBind(&amp;u) c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;Hello &quot; + u.User &#125;)&#125;func Login(c *gin.Context) &#123; var u UserInfo c.ShouldBind(&amp;u) c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;Hello &quot; + u.User &#125;)&#125;func SearchBook(c *gin.Context) &#123; bookID := c.Param(&quot;id&quot;) c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;ID &quot; + bookID &#125;)&#125;func RemoveBook(c *gin.Context) &#123; bookID := c.Param(&quot;id&quot;) c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;ID &quot; + bookID + &quot;was removed.&quot; &#125;)&#125; 首先通过 gin.Group() 传入组的共同前缀，例如上面的 /user、/book，获得一个路由组对象 然后就可以像之前一样的去绑定各个子路由了。之前的 GET()、POST() 等方法同样适用。 效果： 路由拆分和注册","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Framework","slug":"Golang/Framework","permalink":"https://www.boii.xyz/categories/Golang/Framework/"}],"tags":[{"name":"gin","slug":"gin","permalink":"https://www.boii.xyz/tags/gin/"},{"name":"路由","slug":"路由","permalink":"https://www.boii.xyz/tags/%E8%B7%AF%E7%94%B1/"}]},{"title":"Gin [2-接收请求]","slug":"Go/Framework/gin/Gin-2-接收请求","date":"2021-07-19T10:11:06.000Z","updated":"2021-07-19T10:11:06.000Z","comments":true,"path":"posts/d9677098.html","link":"","permalink":"https://www.boii.xyz/posts/d9677098.html","excerpt":"接收请求","text":"接收请求 接收请求作为一个服务器，最基本的任务就是接收请求，然后是返回结果。 客户端发来的请求可以有多种，如 GET、POST、PUT、DELETE。最基本的就是 GET、POST 两种，不过这里还是建议遵循 RESTful 规范。 基本处理：Handle()gin 接收请求有一种最基本的方法，使用 Handle() 方法。 其方法签名如下： 1func (group *RouterGroup) Handle(httpMethod, relativePath string, handlers ...HandlerFunc) IRoutes; 其接受的第一个参数为 HTTP 请求方式，第二个为路由路径，第三个为该请求对应的处理函数。 最基本的栗子，接收一个 GET 请求： 1234567891011func main() &#123; app := gin.Default() app.Handle(&quot;GET&quot;, &quot;/hello&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;Hello!&quot;, &#125;) &#125;) app.Run(&quot;:9090&quot;)&#125; 第4行调用了 Handle()，请求方式为 GET 方法，路由路径为 /hello，处理方法是返回一串JSON数据。 浏览器访问 http://localhost:9090/hello 可得到下面的结果 接收 POST、PUT 等方式的请求**： 通过 Handle() 第一个参数我们可以接收不同方式的请求，例如 POST 123456789101112131415161718192021222324func main() &#123; r := gin.Default() // http://127.0.0.1:9090/login r.Handle(&quot;POST&quot;, &quot;/login&quot;, func(c *gin.Context) &#123; // 处理 POST 请求 user := c.PostForm(&quot;user&quot;) // 获取表单参数 pass := c.PostForm(&quot;pass&quot;) // 获取表单参数 // 处理业务逻辑 if user == &quot;Boii&quot; &amp;&amp; pass == &quot;123&quot; &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;code&quot;: 2001, &quot;msg&quot;: &quot;登录成功&quot;, &#125;) return &#125; c.YAML(http.StatusOK, gin.H&#123; &quot;code&quot;: 4001, &quot;msg&quot;: &quot;登录失败&quot;, &#125;) &#125;) r.Run(&quot;:9090&quot;)&#125; 通过 Postman 可以设定表单参数然后发起请求，我们用gin写的代码就可以接收到一个 POST 请求，并进行处理。 可以看到， Postman 中设置了两个参数 user 和 pass，向 http://localhost:9090/login 发清请求。 关于获取参数后面会详解。 快捷方式：gin.GET()、gin.POST()…像 GET、POST、PUT、DELETE 等这些 HTTP方式的处理函数会很常用，所以 gin 提供了一系列方法供我们更方便的使用。 12345678910111213141516171819202122232425262728293031323334// POST is a shortcut for router.Handle(&quot;POST&quot;, path, handle).func (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes &#123; return group.handle(http.MethodPost, relativePath, handlers)&#125;// GET is a shortcut for router.Handle(&quot;GET&quot;, path, handle).func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes &#123; return group.handle(http.MethodGet, relativePath, handlers)&#125;// DELETE is a shortcut for router.Handle(&quot;DELETE&quot;, path, handle).func (group *RouterGroup) DELETE(relativePath string, handlers ...HandlerFunc) IRoutes &#123; return group.handle(http.MethodDelete, relativePath, handlers)&#125;// PATCH is a shortcut for router.Handle(&quot;PATCH&quot;, path, handle).func (group *RouterGroup) PATCH(relativePath string, handlers ...HandlerFunc) IRoutes &#123; return group.handle(http.MethodPatch, relativePath, handlers)&#125;// PUT is a shortcut for router.Handle(&quot;PUT&quot;, path, handle).func (group *RouterGroup) PUT(relativePath string, handlers ...HandlerFunc) IRoutes &#123; return group.handle(http.MethodPut, relativePath, handlers)&#125;// OPTIONS is a shortcut for router.Handle(&quot;OPTIONS&quot;, path, handle).func (group *RouterGroup) OPTIONS(relativePath string, handlers ...HandlerFunc) IRoutes &#123; return group.handle(http.MethodOptions, relativePath, handlers)&#125;// HEAD is a shortcut for router.Handle(&quot;HEAD&quot;, path, handle).func (group *RouterGroup) HEAD(relativePath string, handlers ...HandlerFunc) IRoutes &#123; return group.handle(http.MethodHead, relativePath, handlers)&#125; 通过源码可以看出，gin 很贴心的做了一层封装，提供了对应请求方式的 shortcut，使开发者更方便的调用。参数上只需要传递 路由路径 和 处理函数 即可，这些“快捷方式”会帮我们调用 handle()。 eg： 12345678func main() &#123; r := gin.Default() // http://127.0.0.1:9090/hello r.GET(&quot;/hello&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;Hello&quot;&#125;) &#125;) r.Run(&quot;:9090&quot;)&#125; 12345678func main() &#123; r := gin.Default() // http://127.0.0.1:9090/login r.POST(&quot;/login&quot;, func(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;msg&quot;: &quot;Hello&quot;&#125;) &#125;) r.Run(&quot;:9090&quot;)&#125; 404 页面123456789func main() &#123; r := gin.Default() r.NoRoute(func(c *gin.Context) &#123; c.HTML(http.StatusNotFound, &quot;views/404.html&quot;, nil) &#125;) r.Run(&quot;:9090&quot;)&#125; 不需要指定路径，只要用户访问不存在的路径，就会执行此路由。 处理请求参数获取 GET 请求的参数GET 请求的参数会显式的携带在URL中。 可以通过 gin.Context.Query() 或 gin.Context.DefaultQuery() 两种方法获取。 他们的区别是 DefaultQuery() 需要填入默认值。 12func (c *Context) Query(key string) string;func (c *Context) DefaultQuery(key, defaultValue string) string; eg： 1234567891011func main() &#123; r := gin.Default() r.GET(&quot;/hello&quot;, func(c *gin.Context) &#123; name := c.Query(&quot;name&quot;) age := c.DefaultQuery(&quot;age&quot;) c.JSON(200, gin.H&#123;&quot;msg&quot;: &quot;Hello &quot; + name + &quot;, you&#x27;re &quot; + age&#125;) &#125;) r.Run(&quot;:9090&quot;)&#125; 获取 POST 表单参数POST 请求的参数不会显式的携带在URL中，而是包裹在请求体 Body 中，是通过表单提交的。 可以通过 gin.Context.Postform() 或 gin.Context.DefaultPostform() 两种方法获取。 同样他们的区别仅在于一个需要填入默认值。 12func (c *Context) PostForm(key string) string;func (c *Context) DefaultPostForm(key, defaultValue string) string; eg： 123456789101112131415161718192021func main() &#123; r := gin.Default() // http://127.0.0.1:9090/login r.POST(&quot;/login&quot;, func(c *gin.Context) &#123; user := c.DefaultPostForm(&quot;user&quot;, &quot;admin&quot;) pass := c.PostForm(&quot;pass&quot;) if user == &quot;Boii&quot; &amp;&amp; pass == &quot;123&quot; &#123; c.JSON(http.StatusOK, gin.H&#123; &quot;code&quot;: 2001, &quot;msg&quot;: &quot;登录成功&quot;, &#125;) return &#125; c.YAML(http.StatusOK, gin.H&#123; &quot;code&quot;: 4001, &quot;msg&quot;: &quot;登录失败&quot;, &#125;) &#125;) r.Run(&quot;:9090&quot;)&#125; 处理其他格式的请求参数除了URL中的参数、表单提交的参数，在客户端发起 HTTP 请求时还可以使用 JSON、XML、YAML 等格式。 获取这些格式的参数，可以通过 gin.Context.Bind() 来获取， Bind() 有一系列的方法： 12345678func (c *Context) Bind(obj interface&#123;&#125;) error;func (c *Context) BindJSON(obj interface&#123;&#125;) error;func (c *Context) BindXML(obj interface&#123;&#125;) error;func (c *Context) BindQuery(obj interface&#123;&#125;) error;func (c *Context) BindYAML(obj interface&#123;&#125;) error;func (c *Context) BindHeader(obj interface&#123;&#125;) error;func (c *Context) BindUri(obj interface&#123;&#125;) error;func (c *Context) MustBindWith(obj interface&#123;&#125;, b binding.Binding) error; 显然，要解析请求中什么类型的数据就调用什么方法，参数 obj 需要我们传入一个结构体变量，用于装载解析后的数据。 结构体每个字段都需要有 tag，否则会解析失败。 1234567891011121314151617181920type UserInfo struct &#123; User string Pass string&#125;var u UserInfofunc main() &#123; r := gin.Default() r.POST(&quot;/login&quot;, func(c *gin.Context) &#123; c.BindJSON(&amp;u) c.JSON(200, gin.H&#123; &quot;user&quot;: u.User, &quot;pass&quot;: u.Pass, &#125;) &#125;) r.Run(&quot;:9090&quot;)&#125; 上面的例子可以解析 HTTP 请求中通过 JSON 携带的数据。 Bind()如果想根据请求中的 content-type 属性来选择，可以使用 Bind() 方法，该方法会 12345678910111213141516171819202122232425262728293031323334353637383940414243// gin 源码// context.go// Bind checks the Content-Type to select a binding engine automatically,// Depending the &quot;Content-Type&quot; header different bindings are used:// &quot;application/json&quot; --&gt; JSON binding// &quot;application/xml&quot; --&gt; XML binding// otherwise --&gt; returns an error.// It parses the request&#x27;s body as JSON if Content-Type == &quot;application/json&quot; using JSON or XML as a JSON input.// It decodes the json payload into the struct specified as a pointer.// It writes a 400 error and sets Content-Type header &quot;text/plain&quot; in the response if input is not valid.func (c *Context) Bind(obj interface&#123;&#125;) error &#123; b := binding.Default(c.Request.Method, c.ContentType()) return c.MustBindWith(obj, b)&#125;// gin 源码// binding.go// Default returns the appropriate Binding instance based on the HTTP method// and the content type.func Default(method, contentType string) Binding &#123; if method == http.MethodGet &#123; return Form &#125; switch contentType &#123; case MIMEJSON: return JSON case MIMEXML, MIMEXML2: return XML case MIMEPROTOBUF: return ProtoBuf case MIMEMSGPACK, MIMEMSGPACK2: return MsgPack case MIMEYAML: return YAML case MIMEMultipartPOSTForm: return FormMultipart default: // case MIMEPOSTForm: return Form &#125;&#125; 可以看到，context 中的 Bind() 方法调用了 binding.Default() 方法; 在 binding.Default() 方法中，如果请求方式是 GET 则返回 Form，否则的话，根据请求中的 content-type 属性返回对应的格式。 接着会调用 gin.Context.MustBindWith(obj, b) -&gt; gin.Context.ShouldBindWith(obj, b) -&gt; b.Bind()； 到 b.Bind() 这里的时候，会根据 b 的类型调用各自的 Bind() 方法。 例如 JSON 的话会调用 jsonBinding.Bind() 方法，然后在里面调用 decodeJSON() 方法。 一次解析多个参数上面登录的栗子中，我们简简单单的获取了两个参数，所以可以用两次 Postform() 方法。 但是当参数多起来的时候，这种方式并不是很好。好在 gin 还提供另外的方法方便我们一次解析多个参数。 要一次解析多个参数，我们需要一个 结构体 来装载这些参数的值，然后将结构体传给 gin.Context.Bind() 、 gin.Context.ShouldBind() 、 gin.Context.ShouldBindQuery() 等方法。 12func (c *Context) ShouldBind(obj interface&#123;&#125;) error;func (c *Context) ShouldBindQuery(obj interface&#123;&#125;) error; 要注意的是，我们定义的这个结构体每个字段都需要有 tag，否则会解析失败。 例如： 1234567891011121314151617181920func main() &#123; r := gin.Default() type UserInfo struct &#123; User string `form:&quot;user&quot;` Pass string `form:&quot;pass&quot;` &#125; // http://127.0.0.1:9090/login r.POST(&quot;/login&quot;, func(c *gin.Context) &#123; var u UserInfo c.ShouldBind(&amp;u) c.JSON(http.StatusOK, gin.H&#123; &quot;code&quot;: 2001, &quot;msg&quot;: &quot;登录成功&quot;, &quot;user&quot;: u.User, &quot;pass&quot;: u.Pass, &#125;) &#125;) r.Run(&quot;:9090&quot;)&#125; 效果是一样的。 解析路由路径中的参数gin.Context.Param()路由路径有时候并不固定，而是根据实际情况变化的。 例如下面的栗子，不同的用户有不同的ID，要获取这个ID，需要用到 gin.Context.Param() 方法，填入冒号通配符后面的变量 id 即可。 在使用 PUT、DELETE 等请求方法的时候是修改、删除某条记录的目的，这需要在路径中指定一个关键值（如 id），这里就可以用像下面这样去解析。 12345678910111213func main() &#123; r := gin.Default() // http://127.0.0.1:9090/user/10086 r.PUT(&quot;/user/:id&quot;, func(c *gin.Context) &#123; userId := c.Param(&quot;id&quot;) c.JSON(http.StatusOK, gin.H&#123; &quot;code&quot;: 2001, &quot;msg&quot;: &quot;ID is &quot; + userId, &#125;) &#125;) r.Run(&quot;:9090&quot;)&#125; gin.Context.Params除了Param()，还可以使用 Params.Get()、Params.ByName() 去获取想要的参数。 1234567891011121314151617181920func main() &#123; r := gin.Default() // http://127.0.0.1:9090/Boii/18/1234567 r.GET(&quot;/params/:name/:age/:tele&quot;, func(c *gin.Context) &#123; params := c.Params name, _ := params.Get(&quot;name&quot;) age := params.ByName(&quot;age&quot;) tele := c.Param(&quot;tele&quot;) c.JSON(http.StatusOK, gin.H&#123; &quot;name&quot;: name, &quot;age&quot;: age, &quot;tele&quot;: tele, &#125;) &#125;) r.Run(&quot;:9090&quot;)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Framework","slug":"Golang/Framework","permalink":"https://www.boii.xyz/categories/Golang/Framework/"}],"tags":[{"name":"gin","slug":"gin","permalink":"https://www.boii.xyz/tags/gin/"},{"name":"request","slug":"request","permalink":"https://www.boii.xyz/tags/request/"},{"name":"response","slug":"response","permalink":"https://www.boii.xyz/tags/response/"}]},{"title":"Gin [1-返回数据]","slug":"Go/Framework/gin/Gin-1-返回数据","date":"2021-07-19T10:10:07.000Z","updated":"2021-07-19T10:10:07.000Z","comments":true,"path":"posts/1937010b.html","link":"","permalink":"https://www.boii.xyz/posts/1937010b.html","excerpt":"Gin 返回数据格式","text":"Gin 返回数据格式 返回在接收到请求，经过一番处理之后，我们需要返回结果，也就是响应请求。 响应请求的格式有 &gt;= 5种格式： []byte string JSON XML YAML protobuf Template []byte 方式返回字节切片格式时，需要使用 gin.Context.Writer 的 Write 方法，将字节切片作为参数传入即可，无需填写状态码。 1234567891011func main() &#123; r := gin.Default() r.GET(&quot;/byte&quot;, func(c *gin.Context) &#123; fullpath := &quot;请求路径： &quot; + c.FullPath() c.Writer.Write([]byte(fullpath)) &#125;) r.Run()&#125; string 方式使用 string 方式则方便许多，直接使用 gin.Context 的 String 方法； 1func (c *Context) String(code int, format string, values ...interface&#123;&#125;); 参数含义为状态码、格式字符串、值。 1234567891011func main() &#123; r := gin.Default() r.GET(&quot;/byte&quot;, func(c *gin.Context) &#123; fullpath := &quot;请求路径： &quot; + c.FullPath() c.String(200, &quot;请求路径: %s&quot;, c.FullPath()) &#125;) r.Run()&#125; JSON 格式最常用的就是返回 JSON 格式，方法时使用 gin.Context 的 JSON 方法： 1func (c *Context) JSON(code int, obj interface&#123;&#125;); 参数含义为 状态码、数据 返回的数据可以用 map[string]interface&#123;&#125; 来装载，而 gin 贴心的为这个类型做了定义 gin.H。可以直接使用 gin.H，这样就不用写长长一串了。 1234567891011121314func main() &#123; r := gin.Default() r.GET(&quot;/json1&quot;, func(c *gin.Context) &#123; // 方法1 使用 map[string]interface&#123;&#125;，即 gin.H data := gin.H&#123; &quot;name&quot;: &quot;Boii&quot;, &quot;age&quot;: 17, &#125; c.JSON(http.StatusOK, data) &#125;) r.Run()&#125; 除了 gin.H，我们还可以使用结构体来装载我们的数据。 1234567891011121314func main() &#123; r := gin.Default() r.GET(&quot;/json2&quot;, func(c *gin.Context) &#123; // 方法2 使用结构体 data := struct &#123; Name string `json:&quot;name&quot;` Age int `json:&quot;age&quot;` &#125;&#123;&quot;Boii&quot;, 18&#125; c.JSON(http.StatusOK, data) &#125;) r.Run()&#125; YAML 格式yaml 也是一种很好用的格式，近年来也开始逐渐兴起 1func (c *Context) YAML(code int, obj interface&#123;&#125;); 参数含义为 状态码、数据，基本和JSON是一样的，数据可以使用 gin.H 也可以使用结构体。 1234567891011121314func main() &#123; r := gin.Default() r.GET(&quot;/json1&quot;, func(c *gin.Context) &#123; // 方法1 使用 map[string]interface&#123;&#125;，即 gin.H data := gin.H&#123; &quot;name&quot;: &quot;Boii&quot;, &quot;age&quot;: 17, &#125; c.YAML(http.StatusOK, data) &#125;) r.Run()&#125; 除了 gin.H，我们还可以使用结构体来装载我们的数据。 1234567891011121314func main() &#123; r := gin.Default() r.GET(&quot;/json2&quot;, func(c *gin.Context) &#123; // 方法2 使用结构体 data := struct &#123; Name string `json:&quot;name&quot;` Age int `json:&quot;age&quot;` &#125;&#123;&quot;Boii&quot;, 18&#125; c.YAML(http.StatusOK, data) &#125;) r.Run()&#125; XML 格式还有一种也是很常用的格式是 XML，但是这种只能使用 gin.H，不能使用结构体装载数据。 1func (c *Context) XML(code int, obj interface&#123;&#125;); 12345678910111213func main() &#123; r := gin.Default() r.GET(&quot;/xml&quot;, func(c *gin.Context) &#123; data := gin.H&#123; &quot;name&quot;: &quot;Boii&quot;, &quot;age&quot;: 18, &#125; c.XML(http.StatusOK, data) &#125;) r.Run()&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Framework","slug":"Golang/Framework","permalink":"https://www.boii.xyz/categories/Golang/Framework/"}],"tags":[{"name":"YAML","slug":"YAML","permalink":"https://www.boii.xyz/tags/YAML/"},{"name":"gin","slug":"gin","permalink":"https://www.boii.xyz/tags/gin/"},{"name":"Json","slug":"Json","permalink":"https://www.boii.xyz/tags/Json/"}]},{"title":"Golang [进阶] 19-reflect","slug":"Go/Adavanced/Golang-19-reflect","date":"2021-07-19T09:50:43.000Z","updated":"2021-07-19T09:50:43.000Z","comments":true,"path":"posts/c8c5007f.html","link":"","permalink":"https://www.boii.xyz/posts/c8c5007f.html","excerpt":"反射的操作","text":"反射的操作 2-reflect 官方Doc中Rob Pike定义：Reflection in computing is the ability of a program to examine its own structure, particularly through types; it’s a form of metaprogramming. It’s also a great source of confusion. 在计算机领域，反射是一种让程序——主要是通过类型——理解其自身结构的一种能力。它是元编程的组成之一，同时它也是一大引人困惑的难题。 维基百科定义：在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。 《Go 语言圣经》中这样定义：Go 语言提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法，但是在编译时并不知道这些变量的具体类型，这称为反射机制。 反射应用场景 由于没约定好，或者传入的类型很多、这些类型不能统一表示，导致不确定函数参数类型，就需要用反射来确定类型。 需要根据某些条件，如用户的输入，来决定调用哪个函数，则需要在运行期动态地执行函数。 不建议用反射的理由 反射代码难以阅读，降低代码可读性。 静态语言的优势之一在于编译期就能发现一些类型错误，而反射这种运行期的怪物会导致这一优势的失去。包含反射的代码很可能运行很久，才会出错，而且经常是直接 panic，造成严重后果。 反射对性能影响较大，相比正常代码慢出一两个数量级。 相关基础Golang 的类型Golang 的类型： 变量包括（type，value）两部分 type 包括 static type 和 concrete type。 static type 就是在编码时看得见的类型，如：int、string concrete type 是 runtime 系统看得见的类型。 类型能否断言成功，取决于变量的 concrete type。因此，一个 reader 变量如果它的 concrete type 实现了 write 方法，reader 也可以被断言为 writer。 静态类型和动态类型在反射的概念中，编译时就知道的变量类型叫静态类型，运行时才知道的变量类型叫动态类型。 静态类型：变量声明时赋予的类型。 1234567type Myint int // int 就是静态类型，type 是 static typetype A struct &#123; Name string // string 就是静态类型，type 是 static type&#125;var i *int // *int 就是静态类型，type 是 static type 动态类型：运行时给这个变量赋值时，这个值的类型。如果值为 nil 则没有动态类型。 一个变量的动态类型在运行时可能改变，则主要依赖于它的赋值，前提是这个变量是接口类型。 12345var A interface&#123;&#125; // 静态类型 interface&#123;&#125;A = 10 // 静态类型 interface&#123;&#125; 动态类型 intA = &quot;String&quot; // 静态类型 interface&#123;&#125; 动态类型 stringvar M *intA = M // 静态类型 interface&#123;&#125; 动态类型 *int Golang 的反射就是建立在类型之上的。Golang 变量的指定类型是静态的，在创建变量的时候类型就已经确定，如指定 int、string，所以称之为 static type。Golang 变量的指定类型是 interface 类型相关的，则类型在运行期才能确定，所以称之为 concrete type。只有 interface 类型才有反射一说。 interface 类型Golang 是通过接口实现的，任何 接口值 都是由一个 实际类型 和 实际类型的值 两个部分组成的。 每个 interface 变量都有一个对应的 pair，pair 中记录了 type 的类型和值： 1pair -&gt; (concrete type, value) concrete type 是实际变量的类型，concrete value 是实际变量的值。一个 interface 变量包含了 2 个指针，一个指向实际值的类型，一个指向实际值。 eg：打开文件会返回一个 *os.File 变量。 12f, err := os.OpenFile(&quot;/home/abc.txt&quot;, os.O_RDWR, 0777)var r io.Reader = f 接口变量 r 的 pair 信息记录如下：(f, *os.File)。 pair 在接口变量管道连续赋值过程中是不变的，将接口变量 r 赋值给另一个接口变量 w，他们的 pair 是相同的。 1var w io.Writer = r.(io.Writer) 接口变量 w 的 pair 信息记录如下：(f, *os.File)。即使 w 是空接口类型， pair 也是不变的。 interface及其pair的存在，是Golang中实现反射的前提，理解了pair，就更容易理解反射。反射就是用来检测存储在接口变量内部(类型concrete type, 值value) pair对的一种机制。 反射的使用 reflect包提供了几个重要类型和函数： reflect.Type接口表示接口值的”具体类型”；reflect.TypeOf()函数返回类型的名称，也就是 pair 中的 type reflect.Value结构表示接口值的”具体类型的值”；reflect.ValueOf()函数返回具体类型的值，也就是 pair 中的 value 先有一个接口类型的变量 把接口变量转化成 reflect 对象（reflect.Type 或 reflect.Value） 根据不同情况调用不同的函数 最简单的基本使用： 1234567891011121314package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)func main() &#123; var x float64 = 1.23 t := reflect.TypeOf(x) /* 实例到type */ v := reflect.ValueOf(x) /* 实例到value */ fmt.Println(t) // float64 fmt.Println(v) // 1.23&#125; reflect.Type123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105type Type interface &#123; // Kind返回该接口的具体分类 Kind() Kind // Name返回该类型在自身包内的类型名，如果是未命名类型会返回&quot;&quot; Name() string // PkgPath返回类型的包路径，即明确指定包的import路径，如&quot;encoding/base64&quot; // 如果类型为内建类型(string, error)或未命名类型(*T, struct&#123;&#125;, []int)，会返回&quot;&quot; PkgPath() string // 返回类型的字符串表示。该字符串可能会使用短包名（如用base64代替&quot;encoding/base64&quot;） // 也不保证每个类型的字符串表示不同。如果要比较两个类型是否相等，请直接用Type类型比较。 String() string // 返回要保存一个该类型的值需要多少字节；类似unsafe.Sizeof Size() uintptr // 返回当从内存中申请一个该类型值时，会对齐的字节数 Align() int // 返回当该类型作为结构体的字段时，会对齐的字节数 FieldAlign() int/* 判断相关 */ // 如果该类型实现了u代表的接口，会返回真 Implements(u Type) bool // 如果该类型的值可以直接赋值给u代表的类型，返回真 AssignableTo(u Type) bool // 如该类型的值可以转换为u代表的类型，返回真 ConvertibleTo(u Type) bool/* 类型相关 */ // 返回该类型的字位数。如果该类型的Kind不是Int、Uint、Float或Complex，会panic Bits() int // 返回array类型的长度，如非数组类型将panic Len() int // 返回该类型的元素类型，如果该类型的Kind不是Array、Chan、Map、Ptr或Slice，会panic Elem() Type // 返回map类型的键的类型。如非映射类型将panic Key() Type // 返回一个channel类型的方向，如非通道类型将会panic ChanDir() ChanDir/* 结构体相关 */ // 返回struct类型的字段数（匿名字段算作一个字段），如非结构体类型将panic NumField() int // 返回struct类型的第i个字段的类型，如非结构体或者i不在[0, NumField())内将会panic Field(i int) StructField // 返回索引序列指定的嵌套字段的类型， // 等价于用索引中每个值链式调用本方法，如非结构体将会panic FieldByIndex(index []int) StructField // 返回该类型名为name的字段（会查找匿名字段及其子字段）， // 布尔值说明是否找到，如非结构体将panic FieldByName(name string) (StructField, bool) // 返回该类型第一个字段名满足函数match的字段，布尔值说明是否找到，如非结构体将会panic FieldByNameFunc(match func(string) bool) (StructField, bool) &#123;&#125; // 返回该类型的方法public方法的数目 // 匿名字段的方法会被计算；主体类型的方法会屏蔽匿名字段的同名方法； // 匿名字段导致的歧义方法会滤除 NumMethod() int // 返回该类型方法集中的第i个方法，i不在[0, NumMethod())范围内时，将导致panic // 对非接口类型T或*T，返回值的Type字段和Func字段描述方法的未绑定函数状态 // 对接口类型，返回值的Type字段描述方法的签名，Func字段为nil Method(int) Method // 根据方法名返回该类型方法集中的方法，使用一个布尔值说明是否发现该方法 // 对非接口类型T或*T，返回值的Type字段和Func字段描述方法的未绑定函数状态 // 对接口类型，返回值的Type字段描述方法的签名，Func字段为nil MethodByName(string) (Method, bool)/* 函数相关 */ // 如果函数类型的最后一个输入参数是&quot;...&quot;形式的参数，IsVariadic返回真 // 如果这样，t.In(t.NumIn() - 1)返回参数的隐式的实际类型（声明类型的切片） // 如非函数类型将panic IsVariadic() bool // 返回func类型的参数个数，如果不是函数，将会panic NumIn() int // 返回func类型的返回值个数，如果不是函数，将会panic NumOut() int // 返回func类型的第i个参数的类型，如非函数或者i不在[0, NumIn())内将会panic In(i int) Type // 返回func类型的第i个返回值的类型，如非函数或者i不在[0, NumOut())内将会panic Out(i int) Type&#125; Kind 有 slice、map、ptr、struct、interface、string、Array、Funtcion、int 或其他基本类型组成。Kind 和 Type 之间要做好区分。 如：在 main() 中定义 type Person struct &#123;&#125;，那么 Kind 就是 struct，Type 就是 main.Person。 1234567891011121314type Person struct &#123; name string age int&#125;func main() &#123; pers := person&#123;&quot;Boii&quot;, 18&#125; t := reflect.TypeOf(pers) v := reflect.ValueOf(pers) fmt.Println(v) // &#123;Boii 18&#125; fmt.Println(t) // main.person fmt.Println(t.Name()) // person fmt.Println(t.Kind()) // struct&#125; reflect.Value12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 类型相关func (v Value) Addr() Valuefunc (v Value) Bool() boolfunc (v Value) Bytes() []bytefunc (v Value) Complex() complex128func (v Value) Int() int64func (v Value) Slice(i, j int) Valuefunc (v Value) Slice3(i, j, k int) Valuefunc (v Value) String() stringfunc (v Value) Uint() uint64func (v Value) Pointer() uintptrfunc (v Value) UnsafeAddr() uintptrfunc (v Value) Kind() Kindfunc (v Value) Type() Typefunc (v Value) InterfaceData() [2]uintptr// 函数相关func (v Value) Call(in []Value) []Valuefunc (v Value) CallSlice(in []Value) []Value// 判断相关func (v Value) CanAddr() boolfunc (v Value) CanInterface() boolfunc (v Value) CanSet() boolfunc (v Value) IsNil() boolfunc (v Value) IsValid() boolfunc (v Value) IsZero() boolfunc (v Value) OverflowComplex(x complex128) boolfunc (v Value) OverflowFloat(x float64) boolfunc (v Value) OverflowInt(x int64) boolfunc (v Value) OverflowUint(x uint64) bool// 转换相关func (v Value) Convert(t Type) Valuefunc (v Value) Interface() (i interface&#123;&#125;)func (v Value) Elem() Value// struct 相关func (v Value) NumField() intfunc (v Value) NumMethod() intfunc (v Value) Field(i int) Valuefunc (v Value) FieldByIndex(index []int) Valuefunc (v Value) FieldByName(name string) Valuefunc (v Value) FieldByNameFunc(match func(string) bool) Valuefunc (v Value) Method(i int) Valuefunc (v Value) MethodByName(name string) Value// Array、Slice 相关func (v Value) Index(i int) Value// Map 相关func (v Value) MapIndex(key Value) Valuefunc (v Value) MapKeys() []Valuefunc (v Value) MapRange() *MapIter// Array、Slice、Map 相关func (v Value) Cap() intfunc (v Value) Len() int// 通道相关func (v Value) Recv() (x Value, ok bool)func (v Value) Send(x Value)func (v Value) TryRecv() (x Value, ok bool)func (v Value) TrySend(x Value) boolfunc (v Value) Close()// 改值相关func (v Value) Set(x Value)func (v Value) SetBool(x bool)func (v Value) SetBytes(x []byte)func (v Value) SetCap(n int)func (v Value) SetComplex(x complex128)func (v Value) SetFloat(x float64)func (v Value) SetInt(x int64)func (v Value) SetLen(n int)func (v Value) SetMapIndex(key, elem Value)func (v Value) SetPointer(x unsafe.Pointer)func (v Value) SetString(x string)func (v Value) SetUint(x uint64) reflect中的结构体主要包括：Type，Value，ChanDir，Kind，MapIter，Method，SelectCase，SelectDir，SliceHeader，StringHeader，StructField，StructTag，ValueError 等。其中，Type 和 Value 之前已经介绍过了。 ChanDir：管道的方向，有三个值：RecvDir / SendDir / BothDir，分别为 接受，发送，双向； Kind：Type中的类型信息，包括：Invalid, Bool, Int, Int8, Int16, Int32, Int64, Uint, Uint8, Uint16, Uint32, Uint64, Uintptr, Float32, Float64, Complex64, Complex128, Array, Chan, Func, Interface, Map, Ptr, Slice, String, Struct, UnsafePointer， MapIter：Map的迭代器，包括三个方法：Key、Value、Next； Method：描述方法的信息，包括：方法名，包路径，类型，函数，所处的下标； SelectCase：描述select 操作的信息，case的方向SelectDir，使用的Channel，发送的值Send； SelectDir：描述SelectCase中的方向，有三个值：SelectSend / SelectRecv / SelectDefault SliceHeader：描述切片Slice的信息，包括指针，长度，容量； StringHeader：描述字符串string的信息，包括指针，长度； StructField：描述结构体中的域field中的信息，包括：域名，包路径，类型，标签Tag，在结构体中的偏移量offset，Type.FieldByIndex中的下标index，是否是匿名； StructTag：描述标签信息，有两个方法：Get、Lookup； ValueError：在调用一个Value不支持的方法时会报错，并记录到ValueError中。 反射API 上图很好的概括了 所有的API Type 表示 reflect 的 Type 类型： reflect.TypeValue 表示 reflect 的 Value 类型： reflect.Valueinterface&#123;&#125; 表示接口实例、任意类型Special Type 表示其他特殊类型 Type -&gt; Value：通过 reflect 包的静态方法 New()、NewAt()、Zero() Value -&gt; Type：通过 reflect对象的 Type() 方法 interface{} -&gt; Type：通过 reflect 包的静态方法 TypeOf() interface{} -&gt; Value：通过 reflect 包的静态方法 ValueOf() **Value -&gt; interface{}**：通过 reflect对象的 Interface() 方法，得到是一个静态类型 从 接口实例 获取 Typeinterface{} -&gt; Type：通过 reflect 包的静态方法 TypeOf()1func TypeOf(i interface&#123;&#125;) Type eg： 12345var x int = 10t := reflect.TypeOf(x)fmt.Printf(&quot;t的值：%v \\n&quot;, t) // intfmt.Printf(&quot;t的类型：%T \\n&quot;, t) // *reflect.rtype 从 接口实例 获取 Valueinterface{} -&gt; Value：通过 reflect 包的静态方法 ValueOf()1func ValueOf(i interface&#123;&#125;) Value eg： 12345var x int = 10v := reflect.ValueOf(x)fmt.Printf(&quot;t的值：%v \\n&quot;, v) // 10fmt.Printf(&quot;t的类型：%T \\n&quot;, v) // reflect.Value 从 Type 获取 ValueType -&gt; Value：通过 reflect 包的静态方法 New()、NewAt()、Zero()Type 里面只有类型信息，所以直接从一个 Type 接口变量里面是无法获得实例的 Value 的，但可以通过该 Type 构建一个新实例的 Value。12//New 返回的是一个 Value，该 Value 的 type 为 PtrTo(typ)，即 Value 的 Type 是指定 typ 的指针类型func New(typ Type) Value12//Zero 返回的是一个 typ 类型的零佳，注意返回的 Value 不能寻址，位不可改变func Zero(typ Type) Value如果知道一个类型值的底层存放地址，则还有一个函数是可以依据 type 和该地址值恢复出 Value 的：1func NewAt(typ Type, p unsafe.Pointer) Value 123456789101112var x int = 10t := reflect.TypeOf(x)newX := reflect.New(t) // Type -&gt; ValuezeroX := reflect.Zero(t) // Type -&gt; Valuefmt.Println(newX) // 0xc000012090fmt.Printf(&quot;%v \\n&quot;, newX) // 0xc000012090fmt.Printf(&quot;%T \\n&quot;, newX) // reflect.Valuefmt.Println(zeroX) // 0fmt.Printf(&quot;%v \\n&quot;, zeroX) // 0fmt.Printf(&quot;%T \\n&quot;, zeroX) // reflect.Value 从 Value 获取 TypeValue -&gt; Type：通过 reflect对象的 Type() 方法1func (v Value) Type() Type eg： 123456var x int = 10v := reflect.ValueOf(x)t := v.Type() // value -&gt; typefmt.Printf(&quot;t的值：%v \\n&quot;, t) // intfmt.Printf(&quot;t的类型：%T \\n&quot;, t) // *reflect.rtype 从 Value 获取 接口实例**Value -&gt; interface{}**：通过 reflect对象的 Interface() 方法，得到是一个静态类型123456789//该方法最通用，用来将 Value 转换为空接口，该空接口内部存放具体类型实例//可以使用接口类型查询去还原为具体的类型func (v Value) Interface() （i interface&#123;&#125;)//Value 自身也提供丰富的方法，直接将 Value 转换为简单类型实例，如果类型不匹配，则直接引起 panicfunc (v Value) Bool () boolfunc (v Value) Float() float64func (v Value) Int() int64func (v Value) Uint() uint64 eg1： 123456789101112131415var x int = 10v := reflect.ValueOf(x)iInt := v.Interface()vType := iInt.(int)vInt := v.Int()fmt.Println(iInt) // 10fmt.Printf(&quot;%T \\n&quot;, iInt) // intfmt.Println(vType) // 10fmt.Printf(&quot;%T \\n&quot;, vType) // intfmt.Println(vInt) // 10fmt.Printf(&quot;%T \\n&quot;, vInt) // int64 eg2： 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)func main() &#123; var x float64 = 1.23 t := reflect.TypeOf(x) // 获得 reflect.Type 对象 v := reflect.ValueOf(x) // 获得 reflect.Value 对象 fmt.Println(t) // float64 fmt.Println(v) // 1.23 fmt.Println(v.Kind()) // float64 fmt.Println(v.Type()) // float64 /* value 到 type */ fmt.Println(v.Float()) // 1.23 /* value 到 实例 */ /* value 到 实例 */ v = reflect.ValueOf(x) // 接口类型变量 -&gt; 反射类型对象 convertV := v.Interface().(float64) // 反射类型对象 -&gt; 接口类型变量, 可以理解为 强制转换 fmt.Println(convertV) // 1.23 p := reflect.ValueOf(&amp;x) convertP := p.Interface().(*float64) fmt.Println(convertP) // 0xc000012090&#125; 指针类型 与 值类型的转换 指针 -&gt; 值：t.Elem()，t 只可以是引用类型 指针 -&gt; 值：v.Elem()，v 只可以是指针 123// t 必须是 Array、Chan、Map、Ptr、Slice，否则会引起 panic// Elem 返回的是其内部元素的 Typefunc (t *rtype) Elem() Type eg： 1234567891011121314151617181920212223242526272829303132333435363738394041424344func main() &#123; var x int = 10 var s []int = []int&#123;10, 20, 30&#125;// TypeOf：只接受引用类型 t1 := reflect.TypeOf(s) te1 := t1.Elem() fmt.Println(te1) // int fmt.Printf(&quot;%T \\n&quot;, te1) // *reflect.rtype t2 := reflect.TypeOf(&amp;s) te2 := t2.Elem() fmt.Println(te2) // []int fmt.Printf(&quot;%T \\n&quot;, te2) // *reflect.rtype t3 := reflect.TypeOf(x) te3 := t3.Elem() // panic: reflect: Elem of invalid type int t4 := reflect.TypeOf(&amp;x) te4 := t4.Elem() fmt.Println(te4) // int fmt.Printf(&quot;%T \\n&quot;, te4) // *reflect.rtype// ValueOf：只接受prt类型 v1 := reflect.ValueOf(s) ve1 := v1.Elem() // panic: reflect: call of reflect.Value.Elem on slice Value v2 := reflect.ValueOf(&amp;s) ve2 := v2.Elem() fmt.Println(ve2) // [10 20 30] fmt.Printf(&quot;%T \\n&quot;, ve2) // reflect.Value v3 := reflect.ValueOf(x) ve3 := v3.Elem() // panic: reflect: call of reflect.Value.Elem on int Value v4 := reflect.ValueOf(&amp;x) ve4 := v4.Elem() fmt.Println(ve4) // 10 fmt.Printf(&quot;%T \\n&quot;, ve4) // reflect.Value&#125; 值 -&gt; 指针：PtrTo(t) 12// PtrTo 返回的是指向 t 的指针型 Typefunc PtrTo(t Type) Type eg： 12345678910111213func main() &#123; var x int = 10 var s []int = []int&#123;10, 20, 30&#125; xt := reflect.TypeOf(x) st := reflect.TypeOf(s) px := reflect.PtrTo(xt) ps := reflect.PtrTo(st) fmt.Println(px) // *int fmt.Println(ps) // *[]int&#125; Value 的可修改性123456789101112131415//通过 CanSet 判断是否能修改func (v Value) CanSet() bool &#123;&#125;//通过 Set 进行修改func (v Value) Set(x Value) &#123;&#125;func (v Value) SetBool(x bool) &#123;&#125;func (v Value) SetBytes(x []byte) &#123;&#125;func (v Value) SetCap(n int) &#123;&#125;func (v Value) SetComplex(x complex128) &#123;&#125;func (v Value) SetFloat(x float64) &#123;&#125;func (v Value) SetInt(x int64) &#123;&#125;func (v Value) SetLen(n int) &#123;&#125;func (v Value) SetMapIndex(key, elem Value) &#123;&#125;func (v Value) SetPointer(x unsafe.Pointer) &#123;&#125;func (v Value) SetString(x string) &#123;&#125;func (v Value) SetUint(x uint64) &#123;&#125; eg： 123456789101112131415161718func main() &#123; var x int = 10 var s []int = []int&#123;10, 20, 30&#125; vpx := reflect.ValueOf(&amp;x) vepx := vpx.Elem() if vepx.CanSet() == true &#123; // CanSet 判断 vepx.SetInt(20) // Set 设置 &#125; fmt.Println(x) // 20 vps := reflect.ValueOf(&amp;s) veps := vps.Elem() if veps.CanSet() == true &#123; // CanSet 判断 veps.Index(1).SetInt(345) // Index 获取元素，然后设置 &#125; fmt.Println(s) // [10 345 30]&#125; 反射结构体结构体相比基本类型稍微多一点步骤。 第一步，传入结构体指针，获取可修改的 reflect 对象第二步，使用 Elem() 获得字段列表第三步，使用 Field()系列方法 或 Method() 系列方法，获得指定字段或方法第四步，使用 Set()系列方法修改数值 或 使用 Call() 调用结构体方法 结构体的 Type 是 main.person结构体的 Kind 是 struct结构体的 Name 是 person NumField() 可以获得结构体字段的数量NumMethod() 可以获得结构体方法的数量，但只能获取 public 方法Field(idx) 可以通过下标获得指定的字段FieldByName(fieldName) 可以通过字段名字获得指定的字段Method(idx) 可以通过下标获得指定的方法MethodByName(methodName) 可以通过方法名获得指定的方法NumIn() 可以获得参数个数NumOut() 可以获得返回值个数 访问操作eg：访问结构体的字段和方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)type person struct &#123; name string Age int&#125;func (p person) Eat() &#123; fmt.Println(&quot;eat&quot;)&#125;func (p person) Run() &#123; fmt.Println(&quot;run&quot;)&#125;func (p person) gogogo() &#123; fmt.Println(&quot;go&quot;)&#125;func main() &#123; pers := person&#123;&quot;Boii&quot;, 18&#125; t := reflect.TypeOf(pers) v := reflect.ValueOf(pers) fmt.Println(v) // &#123;Boii 18&#125; fmt.Println(t) // main.person fmt.Println(t.Name()) // person fmt.Println(t.Kind()) // struct // 获取字段 // &#123; Name PkgPath Type Tag Offset Index Anonymous&#125; // &#123; name main string 0 [0] false&#125; // &#123; Age main int 16 [1] false&#125; for i := 0; i &lt; t.NumField(); i++ &#123; field := t.Field(i) value := v.Field(i) fmt.Printf(&quot;字段名称: %s\\t字段类型: %s\\t字段数值: %v\\n&quot;, field.Name, field.Type, value) &#125; // 字段名称: name 字段类型: string 字段数值: Boii // 字段名称: Age 字段类型: int 字段数值: 18 for i := 0; i &lt; v.NumField(); i++ &#123; fmt.Println(v.Field(i)) // Boii // 18 &#125; // 获取方法，t.NumMethod() 只能获取到 public 方法 // &#123;Name PkgPath Type Func Index&#125; // &#123;Eat func(main.person, string) &lt;func(main.person, string) Value&gt; 0&#125; // &#123;Run func(main.person) &lt;func(main.person) Value&gt; 1&#125; for i := 0; i &lt; t.NumMethod(); i++ &#123; method := t.Method(i) fmt.Printf(&quot;方法名称: %s\\t方法类型: %v\\n&quot;, method.Name, method.Type) &#125; // 方法名称: Eat 方法类型: func(main.person) // 方法名称: Run 方法类型: func(main.person) for i := 0; i &lt; v.NumMethod(); i++ &#123; fmt.Println(v.Method(i)) // 0x433600 // 0x433600 &#125;&#125; 修改操作如果想要对结构体的字段等进行修改，需要传入结构体指针来获得 reflect 对象。 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)type person struct &#123; name string Age int&#125;func (p person) Eat(food string) &#123; fmt.Println(&quot;eat&quot;, food)&#125;func (p person) Run() &#123; fmt.Println(&quot;run&quot;)&#125;func (p person) go() &#123; fmt.Println(&quot;go&quot;)&#125;func main() &#123; pers := person&#123;&quot;Boii&quot;, 18&#125; v := reflect.ValueOf(&amp;pers).Elem() // panic: reflect: reflect.Value.SetString using value obtained using unexported field v.FieldByName(&quot;name&quot;).SetString(&quot;Eva&quot;) // 传入结构体指针以后，Field 只能访问到 public 字段 v.Field(1).SetInt(20) fmt.Println(pers) // &#123;Boii 20&#125; // 调用有参方法 v.Method(0).Call([]reflect.Value&#123;reflect.ValueOf(&quot;apple&quot;)&#125;) // eat apple // 调用无参方法 v.Method(1).Call(nil) // run v.Method(1).Call(make([]reflect.Value, 0)) // run&#125; 通过结构体指针获得的 reflect 对象，要注意3点 需要 Elem() 方法获取到元素列表 只能访问到 public 的 字段和方法 通过 Call() 可以调用结构体的方法，如果无参，可以传入 nil 或者空切片如果有参，需传入Value切片 []reflect.Value 123456789//没有参数，直接写nil.Call(nil)// 或者args1 := make([]reflect.Value, 0).Call(args1)// 有参数args2 := []reflect.Value&#123; reflect.ValueOf(&quot;反射机制&quot;), reflect.ValueOf(100), ...&#125;.Call(args2) 反射调用函数反射调用函数和 调用方法其实差不多，可以通过函数名获得 reflect 对象，使用 Call() 调用 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)func main() &#123; //函数的反射 f1 := fun1 value := reflect.ValueOf(f1) fmt.Printf(&quot;Kind : %s , Type : %s\\n&quot;, value.Kind(), value.Type()) //Kind : func , Type : func() value2 := reflect.ValueOf(fun2) fmt.Printf(&quot;Kind : %s , Type : %s\\n&quot;, value2.Kind(), value2.Type()) //Kind : func , Type : func(int, string) //通过反射调用函数 value.Call(nil) args := []reflect.Value&#123;reflect.ValueOf(100), reflect.ValueOf(&quot;hello&quot;)&#125; value2.Call(args)&#125;func fun1()&#123; fmt.Println(&quot;我是函数fun1()，无参的。。&quot;)&#125;func fun2(i int, s string)&#123; fmt.Println(&quot;我是函数fun2()，有参数。。&quot;,i,s)&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Adavanced","slug":"Golang/Adavanced","permalink":"https://www.boii.xyz/categories/Golang/Adavanced/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [进阶] 18-并发安全","slug":"Go/Adavanced/Golang-18-并发安全","date":"2021-07-19T09:49:00.000Z","updated":"2021-07-19T09:49:00.000Z","comments":true,"path":"posts/65501a4c.html","link":"","permalink":"https://www.boii.xyz/posts/65501a4c.html","excerpt":"并发安全","text":"并发安全 1-并发安全 竞态竞态 是指多个 goroutine 按某些交错顺序执行时，争抢使用同一份临界资源，导致程序无法给出正确的结果。串行程序中（一个程序只有一个 goroutine），程序中各个步骤的执行顺序由程序逻辑决定，所以单个 goroutine 不会引发竞态问题。并发程序中（一个程序有多个 goroutine），每个 goroutine 的执行顺序是不一样的，因此可能会带来竞态问题。 例如： 1234567891011121314151617package mainimport &quot;fmt&quot;var x int64func add() &#123; for i := 0; i &lt; 5_000_000; i++ &#123; x = x + 1 &#125;&#125;func main() &#123; add() add() fmt.Println(x) // 10_000_000&#125; 这是一个串行程序，所以最终的结果是正确的。 下面开启新的 goroutine 执行 add() 12345678910111213141516171819202122232425262728package mainimport ( &quot;fmt&quot; &quot;sync&quot;)var ( x int64 wg sync.WaitGroup)func add() &#123; defer wg.Done() for i := 0; i &lt; 5_000_000; i++ &#123; x = x + 1 &#125;&#125;func main() &#123; wg.Add(2) go add() go add() fmt.Println(x) // 5_872_265 wg.Wait()&#125; 从打印结果可以看出结果并不正确，这是因为 3 个 goroutine 争抢着使用 x 这个临界资源，有可能最终的 x 的结果是正确的，但是main() 提前抢到资源就打印出来了，也有可能两个 子goroutine 争抢时导致 x 被写乱了（发生了竞态）。 避免竞态 第一种：不要修改变量。这种可以，但不现实，因为实际业务中必然涉及同时读写同一个变量的场景。只能说尽量避免。 第二种：上锁 上锁可以很好的解决竞态问题，但是会有些许性能上的损失。 发生竞态的主要原因是因为：多个 goroutine 争抢读写同一个临界资源。这个临界资源可以是打印机、全局变量等等。 举个栗子，一个人就是一个 goroutine，公共卫生间就是一种临界资源，同一时刻只能有一个人使用（一个临界资源，同一时刻只能有一个 goroutine 读写 ）。多个人同时争抢一个公共卫生间肯定出问题。 所以卫生间要加个锁，进去使用的人上锁，使用完了开锁。使用临界资源的 goroutine 给临界资源上锁，使用完了把锁释放。 Golang 中的 sync 包提供了 Mutex 和 RWMutex 两种锁。 sync.Mutex 互斥锁1234567type Mutex struct &#123; state int32 sema uint32&#125;func (m *Mutex) Lock() &#123;&#125;func (m *Mutex) Unlock() &#123;&#125; Mutex 非常简单，只有Lock() 和 Unlock() 两个方法。 加锁 Lock() 用于加锁 加锁规则： 如果互斥锁已经被上锁了，则加锁操作阻塞，直到互斥锁被解锁以后才能上锁。 如果互斥锁没有被上锁，那么上锁成功。 解锁 Unlock() 用于解锁 解锁规则：释放互斥锁 上锁下面我们对上面的例子中，争抢临界资源的部分上锁。 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;fmt&quot; &quot;sync&quot;)var ( x int64 wg sync.WaitGroup lock sync.Mutex)func add() &#123; defer wg.Done() for i := 0; i &lt; 5_000_000; i++ &#123; lock.Lock() // 加锁 x = x + 1 lock.Unlock() // 解锁 &#125;&#125;func main() &#123; wg.Add(2) go add() go add() fmt.Println(x) // 10_000_000 wg.Wait()&#125; 如此一来，不管哪个 子goroutine 得到运行的机会，别的 goroutine 都不能访问临界资源，得等到上了锁的 goroutine 释放，别的 goroutine 才能访问。 延迟解锁如果一个 goroutine 上了锁之后忘记释放锁，别的 goroutine 是永远拿不到锁的，还会导致死锁。在复杂的代码中，很难确定所有分支中的 Lock() 和 Unlock() 成对出现，所以，最好养成锁成对写、延迟解锁的习惯。 12345678910var x intvar lock sync.Mutexfunc add() &#123; lock.Lock() // 上锁 x = x + 1 defer lock.Unlock() // 延迟解锁，在函数运行结束之后会自动解锁 return x&#125; sync.RWMutex 读写互斥锁12345678910111213141516type RWMutex struct &#123; w Mutex // held if there are pending writers writerSem uint32 // semaphore for writers to wait for completing readers readerSem uint32 // semaphore for readers to wait for completing writers readerCount int32 // number of pending readers readerWait int32 // number of departing readers&#125;// 写锁func (rw *RWMutex) Lock() &#123;&#125;func (rw *RWMutex) Unlock() &#123;&#125;// 读锁func (rw *RWMutex) RLock() &#123;&#125;func (rw *RWMutex) RUnlock() &#123;&#125;func (rw *RWMutex) RLocker() Locker &#123;&#125; 读写互斥锁适用于读多写少的场景。因为在使用 Mutex 互斥锁的时候，不管是因为要去读上的锁还是要去写上的锁，只要一上了锁，别的 goroutine 就不能上锁，也不能读写。 于是在 读多写少 的场景下，导致少量写操作时，也不能读。所以这种场景要使用 读写互斥锁。 写锁 Lock() 函数用于上写锁 Unlock() 函数用于解写锁 加锁规则： 如果当前的读写锁被上锁了，则 加写锁 操作阻塞直到读写锁被释放 如果当前的读写锁没有被锁，则 加写锁 成功 释放规则：直接释放 读锁 RLock() 函数用于上读锁 RUnlock() 函数用于解读锁 加锁规则： 如果当前的读写锁 没有被锁，则 加读锁 操作成功 如果当前的读写锁 被上了读锁，则 加读锁 操作成功 如果当前的读写锁 被上了写锁，则 加读锁 操作阻塞，直到读写锁被释放 eg： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( &quot;fmt&quot; &quot;sync&quot; &quot;time&quot;)var ( x int64 wg sync.WaitGroup rwlock sync.RWMutex // 读写锁)func read() &#123; defer wg.Done() rwlock.RLock() // 加读锁 time.Sleep(time.Millisecond) fmt.Println(x) defer rwlock.RUnlock() // 解读锁&#125;func write() &#123; defer wg.Done() rwlock.Lock() // 加写锁 time.Sleep(time.Millisecond * 5) x = x + 1 defer rwlock.Unlock() // 解写锁&#125;func main() &#123; start := time.Now() for i := 0; i &lt; 10; i++ &#123; wg.Add(1) go write() &#125; for i := 0; i &lt; 1000; i++ &#123; wg.Add(1) go read() &#125; wg.Wait() fmt.Println(time.Now().Sub(start))&#125;// --------------------------------------// Output:...1111215.9568ms Mutex 和 RWMutex 的选择 仅在绝大部分goroutine都在获取读锁并且锁竞争比较激烈时（即，goroutine一般都需要等待后才能获到锁），RWMutex才有优势 否则，一般使用Mutex即可 sync.Once12345678910111213141516171819type Once struct &#123; done uint32 m Mutex&#125;func (o *Once) Do(f func()) &#123; if atomic.LoadUint32(&amp;o.done) == 0 &#123; o.doSlow(f) &#125;&#125;func (o *Once) doSlow(f func()) &#123; o.m.Lock() defer o.m.Unlock() if o.done == 0 &#123; defer atomic.StoreUint32(&amp;o.done, 1) f() &#125;&#125; Once 是一个结构体，里面有一把 Mutex 锁 m，还有一个 done 标志位用来标记 f 是否执行过了。（0未执行，1已执行） Once 只有一个 Do() 方法，其中检查了一下标志位，如果为 0 表示 f 未执行过，调用 doSlow()；非 0 表示执行过了，直接返回 doSlow() 中，先是上锁，然后检查 done 标志位，看看 f 是否执行过，如果没有执行，就执行，然后标志位置为 1。 用 sync.Once 写一个单例模式： 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot; &quot;sync&quot;)type person struct &#123; name string age int&#125;var ( p *person once sync.Once)// 构造方法使用 Once 的 Do 方法实现func NewSinglePerson(name string, age int) *person &#123; once.Do(func() &#123; p = &amp;person&#123;name, age&#125; &#125;) return p&#125;func main() &#123; p1 := NewSinglePerson(&quot;Boii&quot;, 18) p2 := NewSinglePerson(&quot;Eva&quot;, 20) fmt.Printf(&quot;%p\\n&quot;, p1) // 0xc0000044a0 fmt.Printf(&quot;%p\\n&quot;, p2) // 0xc0000044a0 fmt.Printf(&quot;%v\\n&quot;, p1) // &amp;&#123;Boii 18&#125; fmt.Printf(&quot;%v\\n&quot;, p2) // &amp;&#123;Boii 18&#125;&#125; sync.Map12345678910111213141516171819202122type Map struct &#123; mu Mutex read atomic.Value // readOnly dirty map[interface&#123;&#125;]*entry misses int&#125;// setfunc (m *Map) Store(key, value interface&#123;&#125;) &#123;&#125;// getfunc (m *Map) Load(key interface&#123;&#125;) (value interface&#123;&#125;, ok bool) &#123;&#125;// 删除func (m *Map) Delete(key interface&#123;&#125;) &#123;&#125;// 先加载看，有再删除func (m *Map) LoadAndDelete(key interface&#123;&#125;) (value interface&#123;&#125;, loaded bool) &#123;&#125;// 先加载看，没有再存，有就不存func (m *Map) LoadOrStore(key, value interface&#123;&#125;) (actual interface&#123;&#125;, loaded bool) &#123;&#125;// 遍历func (m *Map) Range(f func(key, value interface&#123;&#125;) bool) &#123;&#125;Golang 中内置的 map 不是并发安全的，在对 map 并发写的时候会出现问题。Golang 的 sync 包中提供了一个开箱即用的并发安全版map：sync.Map。开箱即用，即表示不需要 make() 函数初始化就能直接使用，同时内置了诸如 Store、Load、Delete、Range 等操作。 先看对内置 map 并发写会发生什么。 1234567891011121314151617181920212223242526272829303132var m = make(map[string]int)var wg sync.WaitGroupfunc get(key string) int &#123; return m[key]&#125;func set(key string, value int) &#123; m[key] = value&#125;func call (n int) &#123; defer wg.Done() key := strconv.Itoa(n) set(key, n) fmt.Printf(&quot;k=:%v,v:=%v\\n&quot;, key, get(key))&#125;func main() &#123; for i := 0; i &lt; 20; i++ &#123; wg.Add(1) go call(i) &#125; wg.Wait()&#125;// -------------------------------// Output:fatal error: k=:0,v:=0concurrent map writesk=:19,v:=19fatal error: concurrent map writes... 采用 并发安全版： 12345678910111213141516171819202122232425262728293031323334353637383940414243var wg sync.WaitGroupvar sm = sync.Map&#123;&#125; // 声明 sync.Map 变量func call(n int) &#123; defer wg.Done() key := strconv.Itoa(n) sm.Store(key, n) // 写 value, _ := sm.Load(key) // 读 fmt.Printf(&quot;k=:%v,v:=%v\\n&quot;, key, value)&#125;func main() &#123; for i := 0; i &lt; 20; i++ &#123; wg.Add(1) go call(i) &#125; wg.Wait()&#125;// -------------------------------// Output:k=:19,v:=19k=:10,v:=10k=:11,v:=11k=:2,v:=2 k=:15,v:=15k=:3,v:=3 k=:12,v:=12k=:0,v:=0 k=:13,v:=13k=:18,v:=18k=:14,v:=14k=:6,v:=6 k=:4,v:=4 k=:5,v:=5 k=:8,v:=8k=:7,v:=7k=:9,v:=9k=:1,v:=1k=:17,v:=17k=:16,v:=16 原子操作代码中的加锁操作因为涉及内核态的上下文切换会比较耗时、代价比较高。针对基本数据类型我们还可以使用原子操作来保证并发安全，因为原子操作是 Go 语言提供的方法它在用户态就可以完成，因此性能比加锁操作更好。Go语言中原子操作由内置的标准库 sync/atomic 提供。 atomic 包 读取操作 func LoadInt32(addr *int32) (val int32) func LoadInt64(addr *int64) (val int64) func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer) func LoadUint32(addr *uint32) (val uint32) func LoadUint64(addr *uint64) (val uint64) func LoadUintptr(addr *uintptr) (val uintptr) 写入操作 func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) 修改操作 func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr) 交换操作 func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) 比较并交换操作 func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package mainimport ( &quot;fmt&quot; &quot;sync&quot; &quot;sync/atomic&quot; &quot;time&quot;)var ( lock sync.Mutex x, y, z int64)// 非并发安全版func add() &#123; x++&#125;// 加锁版func mutexAdd() &#123; lock.Lock() defer lock.Unlock() y++&#125;// 原子版func atomicAdd() &#123; atomic.AddInt64(&amp;z, 1)&#125;func test(f func()) time.Duration &#123; var wg sync.WaitGroup start := time.Now() for i := 0; i &lt; 10000; i++ &#123; wg.Add(1) go func() &#123; defer wg.Done() f() &#125;() &#125; wg.Wait() return time.Now().Sub(start)&#125;func main() &#123; fmt.Println(&quot;非并发安全版:&quot;, x, test(add)) fmt.Println(&quot;加锁版 :&quot;, y, test(mutexAdd)) fmt.Println(&quot;原子操作版 :&quot;, z, test(atomicAdd))&#125;// -------------------------------// Output:非并发安全版: 9604 4.9936ms加锁版 : 10000 3.9898ms原子操作版 : 10000 2.9909ms 从结果可以看出，非并发安全版连结果都不对，加锁版安全，原子版安全且效率更高。 atomic 包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Adavanced","slug":"Golang/Adavanced","permalink":"https://www.boii.xyz/categories/Golang/Adavanced/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [进阶] 17-Channel","slug":"Go/Adavanced/Golang-17-Channel","date":"2021-07-19T09:28:33.000Z","updated":"2021-07-19T09:28:33.000Z","comments":true,"path":"posts/e3c7a27f.html","link":"","permalink":"https://www.boii.xyz/posts/e3c7a27f.html","excerpt":"不要通过共享内存来通信，而应该通过通信来共享内存","text":"不要通过共享内存来通信，而应该通过通信来共享内存 1-channel注意：通道 channel 是引用类型！！！ channel 的作用：单纯的并发执行函数的没有意义的。函数间需要交换数据才能体现并发执行的意义。就像 OS 的并发性和共享性，没有并发谈不上共享，没有共享并发没有意义。所以 channel 就是用在 goroutine 之间的通信上的。 Communicate through shared memory rather than through shared memory. —– Golang Golang 提倡通过通信共享内存而不是通过共享内存实现通信。 goroutine 是程序并发的执行体，channel 就是它们之间的通信管道。channel 有时候简写为：chan，遵循 FIFO 先进先出 的规则，保证了收发数据的顺序。每一个 chan 都是一个具体类型的管道，即声明 channel 时需要为其指定元素类型。 创建 channel1234var identifier chan Tidentifier = make(chan T[, size])identifier := make(chan T[, size]) // 短声明 chan 的创建需要 make() 分配内存才能使用。单纯的声明时，默认值为 nil。 分配内存时可以指定通道大小，也就是这条管子的容量。 123456789func main() &#123; var ch chan int // 声明通道变量 fmt.Println(ch) // nil ch = make(chan int) // 无缓冲区，分配内存 fmt.Println(ch) // 0xc0000d4000 ch2 := make(chan int, 2) // 有缓冲区 fmt.Println(ch2) // 0xc0000d5000&#125; 对于无缓冲的通道：一次发送、一次接收，都是阻塞的对于有缓冲的通道：发送-&gt;缓冲区满了，才会阻塞；接收-&gt;缓冲区空了，才会阻塞。 无缓冲通道就好像快递员送快递，只能当面送给你，你签收之前他就一直阻塞在那里。有缓冲通道就好像有了快递柜，放到快递柜里等你自己来拿。快递柜满了快递员也只能等着，阻塞在那里。 操作 channel通道有 发送（通道读入数据）、接收（通道写出数据）、关闭 三种操作 1ch := make(chan int) 发送和接收有点容易混淆，可以这么记：左发右收、左写右读。通道在左边：向通道发送；通道在右边：从通道接收 发送将一个值发送到通道中（通道写入一个值）。 1ch &lt;- 10 // 把 10 发送到 ch 中 接收从一个通道中接收值（通道读出一个值）。 12x := &lt;-ch // 从 ch 中接收值并赋值给变量 x&lt;- ch // 从 ch 中接收值，忽略结果 关闭调用内置函数 close() 来关闭通道。 1close(ch) 已关闭的通道仍然可以获取数据直到通道为空 已关闭的通道数据取完只会接收到零值 已关闭的通道再发送值会导致 panic 关闭已经关闭的通道会导致 panic，最好用 new(sync.Once).Do(func() &#123; close(ch) &#125;) 关闭 关于关闭通道需要注意的事情是： 只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。 通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。 判断通道是否被关闭x, ok := &lt;-ch从通道中接收值时，会返回两个值：一个是数据，一个是通道开启状态。通道被关闭后 ok 为 false。 1234567891011121314151617181920func main() &#123; ch := make(chan int, 3) ch &lt;- 10 ch &lt;- 20 ch &lt;- 30 close(ch) for &#123; x, ok := &lt;-ch if !ok &#123; break &#125; fmt.Println(x) &#125;&#125;// Output:102030 单向通道有时候我们会将通道作为参数在多个任务函数之间传递，通常我们在不同的任务函数中使用通道都会对其进行限制，如只能发送或接收。 上面介绍的都是双向通道，接下来我们使用单向通道可以处理这种情况（单向通道也常用于参数）。 &lt;-chan T 是一个只读单向通道，只能从通道中读取数据，通道可以执行接收操作但不能执行发送操作。 chan&lt;- T 是一个只写单项通道，只能向通道中写入数据，通道可以执行发送操作但不能执行读取操作。 在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来不可以。 123456789101112131415161718func producer(out chan&lt;- int) &#123; // 生产者，只能向通道写入数据 for i := 0; i &lt; 100; i++ &#123; out &lt;- i &#125; close(out)&#125;func consumer(in &lt;-chan int) &#123; // 消费者，只能从通道读取数据 for i := range in &#123; fmt.Println(i) &#125;&#125;func main() &#123; ch := make(chan int, 100) go producer(ch) go consumer(ch)&#125; 通道总结channel 常见异常总结： 关闭已经关闭的channel也会引发panic。 worker poolWorker Pool 是一种模型，其中固定数量的 m 个 worker，通过 worker 队列中的 n 个任务工作。worker 一直排在队列中，直到 worker 完成其当前任务并提出新任务为止。在 Golang 中 worker 使用 goroutine 实现，任务使用通道实现。 1234567891011121314151617181920212223242526272829303132333435package mainimport ( &quot;fmt&quot; &quot;time&quot;)func worker(id int, jobs &lt;-chan int, results chan&lt;- int) &#123; for j := range jobs &#123; fmt.Println(&quot;worker:&quot;, id, &quot;start job:&quot;, j) time.Sleep(time.Second) fmt.Println(&quot;worker:&quot;, id, &quot;end job:&quot;, j) results &lt;- j * 2 &#125;&#125;func main() &#123; jobs := make(chan int, 100) results := make(chan int, 100) // 开启3个goroutine for w := 1; w &lt;= 3; w++ &#123; go worker(w, jobs, results) &#125; // 5个任务 for j := 1; j &lt;= 5; j++ &#123; jobs &lt;- j &#125; close(jobs) // close(results) for a := 1; a &lt;= 5; a++ &#123; fmt.Println(&lt;-results) &#125;&#125; select 多路复用123456789select &#123; case communication clause: statements case communication clause: statements ... default: /* 可选 */ statements&#125; 唯一一个可用的通道会被选择。 如果多个通道可用，会随机公平地选择一个，其他不会执行。 如果没有通道可用，default 情况将被执行。 如果没有 default，select 将会阻塞，直到某个通道可以运行；Golang 不会重新对 channel 或 值进行求值。 123456789101112131415161718func main() &#123; ch := make(chan int) go func() &#123; ch &lt;- 10 fmt.Println(&quot;数据已写入&quot;) &#125;() select &#123; case x := &lt;-ch: fmt.Println(&quot;数据已读出:&quot;, x) default: fmt.Println(&quot;default..&quot;) &#125;&#125;// ---------------------------------------// Output:default.. 由于 goroutine 来不及启动完成，select 就执行了，此时 case 不满足，所以运行 default。如果 select 之前睡眠一下，给 goroutine 点时间，就可以运行到 case 了。 1234567891011121314151617181920func main() &#123; ch := make(chan int) go func() &#123; ch &lt;- 10 fmt.Println(&quot;数据已写入&quot;) &#125;() time.Sleep(500 * time.Millisecond) select &#123; case x := &lt;-ch: fmt.Println(&quot;数据已读出:&quot;, x) default: fmt.Println(&quot;default..&quot;) &#125;&#125;// ---------------------------------------// Output:数据已写入数据已读出: 10","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Adavanced","slug":"Golang/Adavanced","permalink":"https://www.boii.xyz/categories/Golang/Adavanced/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [进阶] 16-并发","slug":"Go/Adavanced/Golang-16-并发","date":"2021-07-19T08:52:30.000Z","updated":"2021-07-19T08:52:30.000Z","comments":true,"path":"posts/a6eafc24.html","link":"","permalink":"https://www.boii.xyz/posts/a6eafc24.html","excerpt":"并发","text":"并发 0-并发 goroutineGolang 并发通过 goroutine 实现，类似于线程，属于用户态的线程。goroutine 开销非常小，所以一个程序开辟数千个都没问题。 Golang 在语言层面已经内置了调度和上下文切换的机制，会智能地将 goroutine 种的任务合理地分配给每个CPU。 当需要让某个任务并发的执行时，只要把这个任务包装成一个函数，开启一个 goroutine 去执行这个函数即可。 主 goroutinemain() 函数自己本身就处于 主 goroutine。主 goroutine 结束的时候，其他执行完毕的、未执行完毕的 子 goroutine 也会一并被结束。 主 goroutine 的任务： 设定每个 goroutine 所能申请的栈空间的最大尺寸。在 32 位系统中最大尺寸为 250MB，64 位系统中最大尺寸为 1GB。如果某个 goroutine 的占空间尺寸大于这个限制，则运行时系统会引发一个栈溢出（Stack Overflow）的 panic，随后这个程序也会终止。 执行初始化工作： 创建一个特殊的 defer 语句，用于主 goroutine 退出时做必要的善后处理。因为 主 goroutine 也可能非正常结束。 启动专用于 GC(Garbage Clean) 的 goroutine，并设置 GC 可用的标识。 执行 main 包中的 init() 函数。 执行 main() 函数。 在 main() 函数结束后，检查 主 goroutine 是否引发了运行时 panic，并进行必要的处理。 最后，结束自己及当前进程的运行。 使用一个 goroutine 必对应一个函数，可以创建多个 goroutine 去执行相同的函数。只需要在函数调用处加上 go 关键字修饰，即可为一个函数创建一个 goroutine。 单个goroutine串行程序： 123456789101112func hello() &#123; fmt.Println(&quot;Hello World&quot;)&#125;func main() &#123; hello() fmt.Println(&quot;Main Function&quot;)&#125;// ---------------------------------// Output:Hello WorldMain Function goroutine 并发程序： 12345678910111213func hello() &#123; fmt.Println(&quot;Hello World&quot;)&#125;func main() &#123; go hello() // 为 hello() 开启一个 goroutine fmt.Println(&quot;Main Function&quot;) time.Sleep(time.Second) // 让主程序休眠一下&#125;// ---------------------------------// Output:Hello WorldMain Function 多个goroutine在单个 goroutine 的例子中，为了防止 主 goroutine 快于 子 goroutine 完成，导致 子 goroutine 来不及完成就退出程序，在 main() 中添加了一条 time.Sleep()。虽然暂时可以解决这个问题，但是不优雅，也不科学。 所以我们需要使用 sync.WaitGroup 来同步多个 goroutine。 使用步骤： 声明一个 sync.WaitGroup 对象 添加一个计数器 调用 Wait() 等待 在 goroutine 中 defer 修饰 sync.WaitGroup 的 Done() 方法 123456789101112131415161718192021222324252627282930313233343536package mainimport ( &quot;fmt&quot; &quot;sync&quot;)var wg sync.WaitGroup // 声明一个 WaitGroup 对象func main() &#123; wg.Add(10) // 添加一个计数器 for i := 0; i &lt; 10; i++ &#123; go hello(i) &#125; fmt.Println(&quot;Main Function&quot;) wg.Wait() // 等待计数器归零再往下走&#125;func hello(i int) &#123; defer wg.Done() // 计数器 -1 fmt.Println(&quot;Hello &quot;, i)&#125;// -------------------------------// Output:Hello 1Hello 2Hello 3Hello 4Main FunctionHello 9Hello 6Hello 7Hello 8Hello 0Hello 5","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Adavanced","slug":"Golang/Adavanced","permalink":"https://www.boii.xyz/categories/Golang/Adavanced/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"计算机网络 [1-物理层]","slug":"408/NET/计算机网络-1-物理层","date":"2021-07-17T07:13:26.000Z","updated":"2021-07-17T07:13:26.000Z","comments":true,"path":"posts/81730e0e.html","link":"","permalink":"https://www.boii.xyz/posts/81730e0e.html","excerpt":"梦开始的地方","text":"梦开始的地方 1-物理层 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 主要任务：确定与传输媒体接口相关的一些特性 -&gt; 定义标准 机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况。 电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等。 如：某网络在物理层规定，用+10v ～ +15v表示二进制 0, 用-10v ～ -15v表示二进制 1，电线长度 &lt; 15m 功能特性：指明某条线上出现的某一电平表示何种意义，接口部件的信号线的用途。 如：描述一个物理层接口引脚处于高电平时的含义。 规程特性：也叫过程特性，定义各条物理线路的工作规程和时序关系。 典型的数据通信模型 通信的目的是传送消息。 名词解释 数据：传送信息的实体，通常是有意义的符号序列。 信号：数据的电气/电磁的表现，是数据在传输过程中的存在形式。 数字信号：代表消息的参数取值是离散的。 模拟信号：代表消息的参数取值是连续的。 信源：产生和发送数据的源头。 信宿：接收数据的终点。 信道：信号的传输媒介。一般用来表示某一方向传送信息的介质，因此一条通信线路往往包含一条发信信道和一条接收信道。 按传输信号分：模拟信道、数字信道 按传输介质分：无线信道、有线信道 通信方式 单工通信：只有一个方向的通信而没有反方向的交互，仅需一条信道。 半双工通信：通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收，需要两条信道。 全双工通信：通信双方可以同时发送和接收信息，需要两条信道。 数据传输方式 串行传输：速度慢，费用低，适合远距离 并行传输：速度快，费用高，适合近距离 码元、速率、波特、带宽码元码元，指用一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形，是数字通信中数字信号的计量单位。时长内的信号称为 K 进制码元，而该时长称为码元宽度。当码元的离散状态有 M 个时（M 大于 2），此时码元为 M 进制码元。 速率、带宽速率，也叫数据率，指数据的**传输速率**（主机发送到信道上的速度），表示单位时间内传输的数据量。可以用**码元传输速率**和**信息传输速率**表示。 码元传输速率：表示单位时间内，数字通信系统所传输的 M 进制码元个数（也可称为信号变化次数、脉冲个数），又称码元速率、波形速率、调制速率、符号速率等，单位是波特（Baud）。 1 波特表示数字通信系统每秒传输 1 个码元（1 Baud = 1 码元/s），3 波特表示每秒传输 3 个码元。 这里的码元可以是多进制的，也可以是二进制的，即码元速率与码元进制无关。 信息传输速率：表示单位时间内，数字通信系统所传输的二进制码元个数（即比特数），又称信息速率、比特率等，单位是比特/秒（b/s）。 码元速率与信息速率的关系: 若一个码元携带 n bit 的信息量，则 M Baud 的码元传输速率所对应的信息传输速率为 $M \\times n$ bit/s。 如：3 波特二进制码元的信息速率。 二进制码元中每个码元携带 1 个比特信息，3 波特表示每秒传输 3 个码元，则对应的信息速率为 $3 \\times 1$ b/s。 四进制码元中每个码元携带 2 个比特信息，8 波特表示每秒传输 8 个码元，则对应的信息速率为 $8 \\times 2$ b/s。 带宽，表示在单位时间内从网络中某一点到另一点所能通过的“最高传输数据率”（主机传输到信道上），常用来表示网络通信线路所能传输数据的能力。单位是 b/s。 带宽与速率的关系：带宽是最高传输数据率，速率是实际传输数据率。 习题某一数字通信系统传输的四进制码元，4s 传输了 8000 个码元，求码元速率和信息速率。 某一数字通信系统传输的十六进制码元，6s 传输了 7200 个码元，求码元速率和信息速率。 那种更快？ 答： 四进制码元系统：码元速率 = $8000 \\div 4 = 2000$ Baud，信息速率 = $2000 \\times log_24=4000b/s$ 十六进制码元系统：码元速率 = $7200\\div6=1200$ Baud，信息速率 = $1200\\times log_2{16} = 4800b/s$ 系统传输的是比特流，通常比较的是信息速率，所以第二种更快。 奈氏准则、香农定理失真 影响失真程度的因素： 码元传输速率 信号传输距离 噪声干扰 传输媒体质量 码间串扰：接收端收到的信号波形失去了码元之间清晰界限的现象。 奈氏准则（奈奎斯特定理） 奈氏准则：在理想低通（无噪声、带宽受限）条件下，为了避免码间串扰，极限码元传输速率为 2W Baud。 W 是信道带宽，单位是 Hz。 理想：指无电磁干扰低通：指低于信道带宽（信道能通过的最高频率和最低频率之差）极限码元速率：$2W ;Baud$推广可得：极限信息速率：$2Wlog_2V ;b/s$，V为码元进制，$log_2V$为码元的离散电平数目 在任何信道中，码元速率是有上限的。超过上限就会出现严重的码间串扰问题，使接收端不可能完全正确识别码元。 信道的频带越宽（即能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输。 奈氏准则给出了码元速率的限制，当没有给出信息速率的限制。 由于码元速率受限与奈氏准则，所以要提高数据传输速率，就必须提高码元进制以使每个码元携带更多比特的信息量。 香农定理噪声存在于所有电子设备和通信信道中。由于噪声随机产生，它的瞬时值有时会很大，因此噪声会使接收端对码元的判决产生错误。但噪声的影响是相对的，所信号较强，那么噪声影响相对较小。即信号强度与噪声影响成反比。因此，信噪比就很重要。 信噪比 = 信号的平均功率 S /噪声的平均功率 N，记为 S/N，并用分贝（dB）作为度量单位，即：$$信噪比（dB） = 10 \\times log_{10}{(S/N)}$$ 香农定理：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值为$$信道的极限数据传输速率 = Wlog_2(1+S/N)（b/s）\\\\信道的极限数据传输速率 = 信道带宽 \\times log_2(1+信号平均功率/噪声平均功率)（比特/秒）$$ 信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。 只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输。 香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少。 从香农定理可以看出，若信道带宽 W 或信道比 S/N 没有上限(不可能),那么信道的极限信息传输速率也就没有上限。 习题电话系统的典型参数是信道带宽为 3kHz，信噪比为 30dB，则该系统最大数据传输速率是多少？ 答：$$30dB = 10log_{10}(S/N) \\\\3dB = log_{10}(S/N) \\\\dB = S/N = 1000$$信道的极限数据传输速率 = $Wlog_2(1+S/N) = 3k \\times log_2{(1+1000)} \\approx 30kb/s$ 奈氏准则 香农定理 宽带受限、无噪声下，为了避免码间串扰，码元传输速率上限为 2W Baud。 宽带受限、有噪声条件下的信息传输速率。 信道极限数据传输速率 $2Wlog_2V$（W 信道带宽，V 码元进制） $Wlog_2(1+S/N)$（W 信道带宽，S/N 信噪比） 提高速率 提高码元进制 提高带宽或信噪比 编码与调制信道上传播的信号分为 基带信号 和 宽带信号。 基带信号：来自信源的信号，将数字信号 1 和 0 直接用两种不同的电压表示，再送到数字信道上去传输（基带传输）。 像计算机输出的代表各种文字或图像的数据信号都属于基带信号，基带信号就是发出的直接表达了要传输的信息的信号，如我们说话的甚或就是基带信号。 宽带信号：将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输（宽带传输）。 把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段，以便在信道中传输（即仅在一段频率范围内能够通过信道）。 在传输距离近时，计网采用基带传输方式（因为近距离衰减小，从而信号内容不易发生变化） 在传输距离远时，计网采用宽带传输方式（因为远距离衰减大，即使信号变化大也能过滤还原出基带信号） 编码数字数据 ==&gt; 数字信号 非归零编码：高 1 低 0。编码容易实现，但没有检错功能，且无法判断一个码元的开始和结束，以至于首发双方难以保持同步。 归零编码：信号电平在一个码元内都要恢复到零。 反向不归零编码：0 则电平翻转，1 则电平不变。 曼彻斯特编码：前高后低表示 1，前低后高表示 0。将一个码元分成两个相等的间隔，每一个码元的中间出现跳变，位中间的跳变既作时钟信号（可用于同步），又作数据信号，但它所占的频带宽度是原始基带宽度的两倍。 差分曼彻斯特编码：同 1 异 0，前后两个码元之间发生跳变则前一个为 1，没发生跳变则前一个为 0。码元中间的一次电平跳变可以实现自动同步，差分曼彻斯特的抗干扰性强于曼彻斯特。 4B/5B编码：比特流中插入额外的比特以打破一连串的 0 或 1，就是用 5 个比特来编码 4 个比特的数据，之后再传给接收方，因此称为 4B/5B。编码效率为80%。 只采用 16 种对应 16 种不同的 4 位码，另外16中作为控制码（帧的开始、结束，线路状态等）或保留。 数字数据 ==&gt; 模拟信号数字数据调制技术： 调制：在发送端将数字信号转换为模拟信号 解调：在接收端将模拟信号转换为数字信号 调幅：载波的振幅随基带数字信号而变化。 调频：载波的频率随基带数字信号而变化。 调相：载波的初始相位随基带数字信号而变化。 QAM：调幅+调相，在调相的基础上对振幅进行调整，或在调幅的基础上对相位进行调整。 调制模拟信号 ==&gt; 数字信号 抽样：对模拟信号周期性扫描，把时间上连续的信号变成时间上离散的信号。 为了使所得的离散信号能无失真地代表被抽样的模拟数据，要使用采样定理进行采样：$采样频率;f \\ge 2f;信号最高频率$ 量化：把抽样取得的电平幅值按照一定的分级标度转化为对应的数字值，并取整数，这样就能把连续的电平幅值转换为离散的数字量。 编码：把量化的结果转化为与之对应的二进制编码。 模拟信号 ==&gt; 模拟信号为了实现传输的有效性，可能需要较高的频率。这种调剂方式还可以使用频分复用技术，充分利用带宽资源。在电话机和本地交换机所传输的信号是采用模拟信号传输模拟数据的方式；模拟的声音数据是加载到模拟的载波信号中传输的。 传输介质传输介质，也称传输媒体/传输媒介，是数据传输系统在发送设备和接收设备之间的物理通路。 传输介质不是物理层，而是在物理层下面，有体系结构第 0 层之称，而物理层是第 1 层。 在传输媒体中传输的是信号，传输媒体并不知道所传输的信号代表什么意思，当物理层规定了电气特性，因此能够识别所传送的比特流。 传输介质分 导向性传输介质 和 非导向性传输介质。 导向性传输介质：电磁波沿着固定媒介（铜线/光纤）传播。 非导向性传输介质：自由空间、空气、真空、海水等。 导向性传输介质双绞线由两个采用一定规则并排绞合的、相互绝缘的铜导线组成。绞合可以减少对相邻导线的电磁干扰。 为了进一步提高抗电磁干扰能力，可在双绞线外面加上一个金属丝编制成的屏蔽层。 有屏蔽层的就是屏蔽双绞线 STP，没有的就是非屏蔽层双绞线 UTP。 双绞线价格便宜，在局域网和传统电话网中普遍使用。模拟传输和数字传输都可以使用双绞线，其通信距离一般为几公里到数十公里。 距离太远时，对于模拟传输，要用放大器放大衰减的信号；对于数字传输，要用中继器将失真的信号整形。 同轴电缆 同轴电缆由导线铜质芯线、绝缘层、网状编织屏蔽层、塑料外层构成。 通常将同轴电缆分为两类： $50\\Omega$同轴电缆，主要用于传送基带数字信号，又称为基带同轴电缆，在局域网中得到广泛应用； $75\\Omega$同轴电缆，主要用于传送宽带信号，又称为宽带同轴电缆，主要用于有线电视系统。 由于外导体屏蔽层的作用，同轴电缆抗干扰特性比双绞线好，被广泛应用于传输较高速率的数据，其传输距离更远，但价格较双绞线贵。 光纤 光纤通信，是利用光导纤维（简称光纤）传递光脉冲来进行通信。有光脉冲表示 1，无光脉冲表示 0。而可见光大约是 $10^8MHz$，因此光纤通信系统的带宽远远大于目前其他各种传输媒体的带宽。 光纤在发送端有光源，可以采用发光二极管或半导体激光器，它们在电脉冲作用下能产生出光脉冲；在接收端用光电二极管做成光检测器，在检测到光脉冲时可还原出电脉冲。 光纤主要由纤芯（实心的！）和包层构成，光波通过纤芯进行传导，包层较纤芯有较低折射率。当光纤从高折射率的介质射向低折射率的介质时，其折射角将大于入射角。因此，如果入射角，就会出现全反射，即光线碰到包层就会折射会纤芯。这个过程不断重复，光就沿着光纤传输下去。 定义 光源 特点 单模光纤 一种在横向模式直接传输光信号的光纤 定向性很好的激光二极管 衰耗小，适合远距离传输 多模光纤 有多种传输光信号模式的光纤 发光二极管 易失真，适合近距离传输 光纤特点： 传输损耗小，中继距离长，对远距离传输特别经济。 抗雷电和电磁干扰性能好。 无串音干扰，保密性好，也不易被窃听或截取数据。 体积小，重量轻。 非导向性传输介质无线电波 微波 红外线、激光 物理层设备中继器诞生原因：由于传输存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，导致接收错误。 功能：对信号进行再生和还原，对衰减的信号进行放大，保持与原数据相同，以增加信号传输的距离，延长网络的长度。 中继器的两端： 两端的网络部分是网段，而不是子网，适用于完全相同的两类网络互连，且两个网段速率要相同。 中继器只将任何电缆段上的数据发送到另一段电缆上，它仅作用于信号的电气部分，并不管数据中是否有错误数据或不适于网段的数据。 两端可连相同媒体，也可连不同媒体。 中继器两端的网段一定要是同一个协议，因为中继器不会存储转发。 5-4-3规则：最多只能有5个网段，最多只能有4个中继器，最多只能有3台设备。 集线器（多口中继器）功能：对信号进行再生放大转发，对衰减信号进行放大，接着转发到其他所有（除输入端口外）处于工作状态的端口上，以增加信号传输的距离，延长网络长度。 集线器不具备定向传送能力，只能广播，无法分割冲突域，是一个共享式设备。 总结","categories":[{"name":"408","slug":"408","permalink":"https://www.boii.xyz/categories/408/"},{"name":"NET","slug":"408/NET","permalink":"https://www.boii.xyz/categories/408/NET/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.boii.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"物理层","slug":"物理层","permalink":"https://www.boii.xyz/tags/%E7%89%A9%E7%90%86%E5%B1%82/"}]},{"title":"Golang [基础] 15-单元测试","slug":"Go/Basic/Golang-15-单元测试","date":"2021-07-17T03:52:53.000Z","updated":"2021-07-17T03:52:53.000Z","comments":true,"path":"posts/d0d1ce.html","link":"","permalink":"https://www.boii.xyz/posts/d0d1ce.html","excerpt":"单元测试的创建与使用","text":"单元测试的创建与使用 单元测试Golang 的单元测试依赖 go test 命令，编写测试代码和编写普通代码一样，只需要遵循一定的规则即可。 go test 命令是一个按照一定约定和组织的测试代码的驱动程序。 所有以 _text.go 为后缀的源代码文件都是 go test 测试的一部分，不会被 go build 编译到可执行文件中； 测试文件 xxx_test.go 中有三种类型函数：单元测试函数、基准测试函数、示例函数. 类型 前缀 格式 作用 单元测试函数 Test TestTTT(t *testing.T) 测试程序的逻辑性为是否正确 基准测试函数 Benchmark BenchmarkBBB(b *testing.B) 测试程序的性能 示例函数 Example ExampleEEE() 为文档提供示例 在 go test 命令执行的过程中，会遍历所有 _text.go 文件中所有带有上述前缀的函数，生成一个临时 main 包用于调用相应的测试函数，然后编译、运行、报告测试结果、清理临时文件。 go test 命令基本命令是 go test，有很多参数可选， 1go test [build/flags] [packages] [build/test flags &amp; test binary flags] flags: -v: 打印测试过程 -cover: 打印测试覆盖率 -bench: 执行基准测试 … packages: packages 也就是要执行测试的文件，有两种模式：当前目录模式（local directory mode） 和 包列表模式（package list mode） 当前目录模式：没有填写具体的包名时就是这个模式。 比如执行命令 go test 或 go test -v 时，就是这种模式。 这种模式下会执行当前目录下的 *_test.go 文件的测试用例。 默认不开启缓存，也就是不会缓存上次测试的结果。 包列表模式：填写了具体的包名时就是这个模式。 比如执行命令 go test .、go test ./.../... 或 go test package_name 这种模式下会执行指定的包中的测试文件。 默认开启缓存，也就是会缓存上次测试的结果。可以通过 -count=1 关闭缓存。 单元测试基本格式 测试函数必须以 Test 开头 测试函数参数必须包含一个形参 *testing.T 测试函数没有返回值 1234567func TestFib(t *testing.T) &#123; // ...&#125;func TestSiztFmt(t *testing.T, n int) &#123; // ...&#125; 参数 t 用于报告测试成功、失败、日志等信息，其包含如下方法： 12345678910111213141516func (c *T) Error(args ...interface&#123;&#125;)func (c *T) Errorf(format string, args ...interface&#123;&#125;)func (c *T) Fail()func (c *T) FailNow()func (c *T) Failed() boolfunc (c *T) Fatal(args ...interface&#123;&#125;)func (c *T) Fatalf(format string, args ...interface&#123;&#125;)func (c *T) Log(args ...interface&#123;&#125;)func (c *T) Logf(format string, args ...interface&#123;&#125;)func (c *T) Name() stringfunc (t *T) Parallel()func (t *T) Run(name string, f func(t *T)) boolfunc (c *T) Skip(args ...interface&#123;&#125;)func (c *T) SkipNow()func (c *T) Skipf(format string, args ...interface&#123;&#125;)func (c *T) Skipped() bool 最简单的单元测试编写一个斐波那契数列，然后编写单元测试。 123456789// fib.gopackage fibfunc Fib(n int) int &#123; if n &lt; 2 &#123; return n &#125; return Fib(n-1) + Fib(n-2)&#125; 1234567891011121314151617// fib_test.gopackage fibimport &quot;testing&quot;// 单元测试函数，以 Test开头func TestFib(t *testing.T) &#123; var ( input = 7 // 输入数据 expected = 13 // 期望结果 ) actual := Fib(input) // 程序执行结果 // 如果与期望结果不一致，则输出错误提示。 if actual != expected &#123; t.Errorf(&quot;Fib(%d) = %d; expected %d&quot;, input, actual, expected) &#125;&#125; 123456789101112$ go testPASSok goTest 0.002s$ pwd~/---FILE---/---CODE/GoProject/playground/goTest$ tree -L 2 .goTest├── fib.go├── fib_test.go└── go.mod 这是测试通过的结果，如果我们的 Fib() 写错了，则会输出与期望值不同的结果，并报告错误。 现在将 Fib() 稍微修改一下，测试文件不动，再次执行 go test 12345678910// fib.gopackage fibfunc Fib(n int) int &#123; if n &lt; 2 &#123; return n &#125; // return Fib(n-1) + Fib(n-2) return Fib(n-1) + Fib(n-1) // 修改一下&#125; 123456$ go test--- FAIL: TestFib (0.00s) fib_test.go:12: Fib(7) = 64; expected 13FAILexit status 1FAIL goTest 0.002s 测试组单单测试一个例子不够，我们需要多测试几种情况，才能更好的保证我们程序的健壮性。 在单元测试函数里，我们可以按照测试用例定义一个结构体，然后创建一个结构体切片，将测试用例都放在里面。 遍历这个切片就可以测试这一整组测试用例。 12345678910111213141516171819202122232425// fib_test.gopackage fibimport &quot;testing&quot;func TestFib(t *testing.T) &#123; type test struct &#123; // 定义一个测试用例结构体 in int want int &#125; // 创建一个结构体切片存放所有测试用例 tests := []test&#123; &#123;in: 7, want: 13&#125;, &#123;in: 10, want: 55&#125;, &#123;in: 1, want: 1&#125;, &#123;in: 2, want: 1&#125;, &#123;in: -1, want: -1&#125;, &#125; // 遍历结构体切片，逐一测试每个测试用例 for _, tc := range tests &#123; if got := Fib(tc.in); got != tc.want &#123; t.Errorf(&quot;Fib(%d) = %d; expected %d&quot;, tc.in, got, tc.want) &#125; &#125;&#125; 定义测试用例结构体 创建测试用例结构体切片，放置所有测试用例 遍历切片逐一测试每个测试用例 1234# 测试成功$ go testPASSok goTest 0.002s 接着修改 Fib() 让其出错，再进行测试 123456789# 测试失败$ go test--- FAIL: TestFib (0.00s) fib_test.go:21: Fib(7) = 64; expected 13 fib_test.go:21: Fib(10) = 512; expected 55 fib_test.go:21: Fib(2) = 2; expected 1FAILexit status 1FAIL goTest 0.002s 子测试测试组在测试用例少的时候还比较好处理，但是用例多起来的时候就没法直接看出是哪些用例不通过了，所以我们可以使用官方提供的子测试。 还是一样定义一个测试用例结构体，但接着我们不是创建结构体切片，而是创建结构体 map 存放所有测试用例，遍历结构体 map，逐一调用 t.Run() 来测试每一个测试用例。 123456789101112131415161718192021222324252627// fib_test.gopackage fibimport &quot;testing&quot;func TestFib(t *testing.T) &#123; type test struct &#123; // 定义一个测试用例结构体 in int want int &#125; // 创建一个结构体切片存放所有测试用例 tests := map[string]test&#123; &quot;case7&quot;: &#123;in: 7, want: 13&#125;, &quot;case10&quot;: &#123;in: 10, want: 55&#125;, &quot;case1&quot;: &#123;in: 1, want: 1&#125;, &quot;case2&quot;: &#123;in: 2, want: 1&#125;, &quot;case_negative&quot;: &#123;in: -1, want: -1&#125;, &#125; for name, tc := range tests &#123; t.Run(name, func(t *testing.T) &#123; if got := Fib(tc.in); got != tc.want &#123; t.Errorf(&quot;Fib(%d) = %d; expected %d&quot;, tc.in, got, tc.want) &#125; &#125;) &#125;&#125; t.Run() 接受两个参数，一个是测试用例的名字，也就是 map 中的 key，另一个是一个 func(t *testing.T) 函数，在函数中写上具体的测试代码。 执行时带上 -v 参数，可以很直观看出哪些用例通过了 (PASS) 哪些没通过 (FAIL) 12345678910111213141516171819$ go test -v=== RUN TestFib=== RUN TestFib/case7 fib_test.go:22: Fib(7) = 64; expected 13=== RUN TestFib/case10 fib_test.go:22: Fib(10) = 512; expected 55=== RUN TestFib/case1=== RUN TestFib/case2 fib_test.go:22: Fib(2) = 2; expected 1=== RUN TestFib/case_negative--- FAIL: TestFib (0.00s) --- FAIL: TestFib/case7 (0.00s) --- FAIL: TestFib/case10 (0.00s) --- PASS: TestFib/case1 (0.00s) --- FAIL: TestFib/case2 (0.00s) --- PASS: TestFib/case_negative (0.00s)FAILexit status 1FAIL goTest 0.002s 执行时带上 -run 参数还可以指定运行哪一个测试用例 1234567891011121314151617$ go test . -v -run=TestFib/case7=== RUN TestFib=== RUN TestFib/case7 fib_test.go:22: Fib(7) = 64; expected 13--- FAIL: TestFib (0.00s) --- FAIL: TestFib/case7 (0.00s)FAILexit status 1FAIL goTest 0.002s$ go test . -v -run=Fib/case_negative=== RUN TestFib=== RUN TestFib/case_negative--- PASS: TestFib (0.00s) --- PASS: TestFib/case_negative (0.00s)PASSok goTest 0.002s -run=RegExp， -run 参数后带的是一个正则表达式，但是一般都像这样使用：-run=X/Y，其中： X 是 TestAAA 中的 AAA，或者直接写全: TestAAA ， Y 是测试用例结构体 map 的 key。如上面例子中 -run=Fib/case_negative 的 case_negative 就是 key。 覆盖率覆盖率就是你的代码被测试用例覆盖的百分比。通常这个覆盖指 语句覆盖。 输出覆盖率有两种方式：-cover、-coverprofile=outfile 使用 -cover 可以打印代码覆盖率。 使用 -coverprofile 可以将更详细的覆盖信息输出到指定文件中。 -cover 1234$ go test -coverPASScoverage: 100.0% of statementsok goTest 0.002s -coverprofile 123456789$ go test -coverprofile=fib.cover$ tree -L 2 .goTest├── fib.cover├── fib.go├── fib_test.go└── go.mod$ go tool cover -html=fib.cover 使用 go tool cover -html=制定文件 命令会打开默认浏览器显示具体的覆盖率信息。 如上图，绿色表示被覆盖的语句，红色表示未被覆盖的语句，灰色表示未追踪的语句。 基准测试基本格式 测试函数必须以 Benchmark 开头 测试函数参数只能包含一个形参 *testing.B 测试函数没有返回值 1234567func BenchmarkFib(b *testing.B) &#123; // ...&#125;func BenchmarkSiztFmt(b *testing.B) &#123; // ...&#125; 参数 t 用于报告测试成功、失败、日志等信息，其包含如下方法： 12345678910111213141516171819202122func (c *B) Error(args ...interface&#123;&#125;)func (c *B) Errorf(format string, args ...interface&#123;&#125;)func (c *B) Fail()func (c *B) FailNow()func (c *B) Failed() boolfunc (c *B) Fatal(args ...interface&#123;&#125;)func (c *B) Fatalf(format string, args ...interface&#123;&#125;)func (c *B) Log(args ...interface&#123;&#125;)func (c *B) Logf(format string, args ...interface&#123;&#125;)func (c *B) Name() stringfunc (b *B) ReportAllocs()func (b *B) ResetTimer()func (b *B) Run(name string, f func(b *B)) boolfunc (b *B) RunParallel(body func(*PB))func (b *B) SetBytes(n int64)func (b *B) SetParallelism(p int)func (c *B) Skip(args ...interface&#123;&#125;)func (c *B) SkipNow()func (c *B) Skipf(format string, args ...interface&#123;&#125;)func (c *B) Skipped() boolfunc (b *B) StartTimer()func (b *B) StopTimer() 最简单的基准测试编写一个容量格式化函数，然后编写对应的基准测试函数。 1234567891011121314151617181920212223242526272829// sizefmt.gopackage sizefmtimport &quot;strconv&quot;func sizeFmt(bit int64) string &#123; const ( // 定义几个数量级 _ = iota KB int64 = 1 &lt;&lt; (10*iota + 3) MB GB ) sizeFloat := float64(bit) unit := &quot;b&quot; switch &#123; // 根据 bit 参数的大小格式化不同的单位 case bit &lt; KB: return strconv.FormatInt(bit, 10) + unit case bit &gt;= KB &amp;&amp; bit &lt; MB: sizeFloat /= 1 &lt;&lt; 10 unit = &quot;K&quot; case bit &gt;= MB &amp;&amp; bit &lt; GB: sizeFloat /= 1 &lt;&lt; 20 unit = &quot;M&quot; case bit &gt;= GB: sizeFloat /= 1 &lt;&lt; 30 unit = &quot;G&quot; &#125; return strconv.FormatFloat(sizeFloat, &#x27;f&#x27;, 2, 64) + unit&#125; 然后编写基准测试函数。 12345678910// sizefmt_test.gopackage sizefmtimport &quot;testing&quot;// 基准测试函数以 Benchmark 开头func BenchmarkSizefmt(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; // b.N 不是一个固定的值，它会不断迭代 sizeFmt(1&lt;&lt;20 + 554) &#125;&#125; 在 for 循环中使用到了一个 b.N，这个变量 不是一个固定的值，它会从 1 不断的迭代，例如 1、2、5、10、20、50…，保证基准测试函数的执行时间至少超过 1 秒钟。这样得到的数据才比较有参考性。 从 1 开始是保证被测试函数 sizeFmt 至少没问题能跑得动。 使用 -bench=RegExp 来指定只执行基准测试。 12345678$ go test . -bench=Sizefmtgoos: linuxgoarch: amd64pkg: goTestcpu: Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHzBenchmarkSizefmt-4 3589545 330.4 ns/opPASSok goTest 1.528s goos: 当前操作系统 goarch: 当前芯片架构 pkg: 基准测试函数所在的包 cpu: 当前机器上 CPU 信息 BenchmarkSizefmt-4: 对 sizeFmt 函数进行基准测试，当前 GOMAXPROCS 的值，这个对于开发基准测试很重要。 3589545: 执行了3百多万次 330.4 ns/op: 在这3百多万次调用里平均每次调用 sizeFmt 函数耗时 330.4 纳秒。 PASS: 用于基准测试的用例执行通过 ok goTest 1.528s: 共耗时 1.528 秒 使用 -benchmem 参数可以获得内存分配的统计数据 12345678$ go test . -bench=Sizefmt -benchmemgoos: linuxgoarch: amd64pkg: goTestcpu: Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHzBenchmarkSizefmt-4 3589545 330.4 ns/op 40 B/op 3 allocs/opPASSok goTest 1.528s 40 B/op: 平均每次调用 sizeFmt 函数占用 40 个字节 3 allocs/op: 每次调用 sizeFmt 需要申请 3 次内存 性能比较函数上述例子我们得到的是给定例子的绝对耗时，但有些问题，例如斐波那契数列，数量不多的时候耗时还不会太长，但是当计算到 40 左右的时候就已经慢的不行了。 现在我们想要知道，当 Fib(n) 的 n 为 1、10、20、40、45 的时候他们的性能。 于是我们可以编写一个基准测试函数，不仅接受 b *testing.B，还接受另外一个参数 n，然后编写几个基准测试函数来测试。如下： 123456789// fib.gopackage fibfunc Fib(n int) int &#123; if n &lt; 2 &#123; return n &#125; return Fib(n-1) + Fib(n-2)&#125; 12345678910111213141516171819// fib_test.gopackage fibimport &quot;testing&quot;// 把原本的基准函数变成小写开头，这样 -bench=Fib 的时候也不会直接匹配到// 然后带上一个参数 nfunc benchmarkFib(b *testing.B, n int) &#123; for i := 0; i &lt; b.N; i++ &#123; fib(n) &#125;&#125;// 编写几个不同 n 的基准测试函数，每次去调用原本的基准测试函数func BenchmarkFib1(b *testing.B) &#123; benchmarkFib(b, 1) &#125;func BenchmarkFib10(b *testing.B) &#123; benchmarkFib(b, 10) &#125;func BenchmarkFib20(b *testing.B) &#123; benchmarkFib(b, 20) &#125;func BenchmarkFib40(b *testing.B) &#123; benchmarkFib(b, 40) &#125;func BenchmarkFib45(b *testing.B) &#123; benchmarkFib(b, 45) &#125; 然后执行命令： 123456789101112$ go test -bench=Fib -benchmemgoos: linuxgoarch: amd64pkg: goTestcpu: Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHzBenchmarkFibGreedy1-4 457008499 2.601 ns/op 0 B/op 0 allocs/opBenchmarkFibGreedy10-4 2589387 462.6 ns/op 0 B/op 0 allocs/opBenchmarkFibGreedy20-4 19940 57224 ns/op 0 B/op 0 allocs/opBenchmarkFibGreedy40-4 2 865527961 ns/op 0 B/op 0 allocs/opBenchmarkFibGreedy45-4 1 9598796528 ns/op 0 B/op 0 allocs/opPASSok goTest 17.082s 可以看出，n 比较少的时候，执行的次数比较多，每次耗费的时间也不多。当 n 超过 40 以后，机器有点受不了了， 45 仅仅只执行了一次，还耗时 9 秒多。 主要的原因是采用了递归求斐波那契数列，调用栈很快就爆满了。 得到性能数据信息以后，我们就得知这个 Fib 在 n 稍大时效果不理想，应做改进。 递归属于分治法中的一种，我们可以换成动态规划来解决这个问题。 123456789101112131415161718192021222324// fib.gopackage fib// 用递归求斐波那契数列func fibDAC(n int) int &#123; if n &lt; 2 &#123; return n &#125; return fibDAC(n-1) + fibDAC(n-2)&#125;// 用动态规划求func fibDP(n int) int &#123; if n &lt; 2 &#123; return n &#125; slice := make([]int, n) slice[0] = 1 slice[1] = 1 for i := 2; i &lt; n; i++ &#123; slice[i] = slice[i-1] + slice[i-2] &#125; return slice[n-1]&#125; 123456789101112131415161718192021222324252627// fib_test.gopackage fibimport &quot;testing&quot;func benchmarkFibDAC(b *testing.B, n int) &#123; for i := 0; i &lt; b.N; i++ &#123; fibDAC(n) &#125;&#125;func BenchmarkFibDAC1(b *testing.B) &#123; benchmarkFibDAC(b, 1) &#125;func BenchmarkFibDAC10(b *testing.B) &#123; benchmarkFibDAC(b, 10) &#125;func BenchmarkFibDAC20(b *testing.B) &#123; benchmarkFibDAC(b, 20) &#125;func BenchmarkFibDAC40(b *testing.B) &#123; benchmarkFibDAC(b, 40) &#125;func BenchmarkFibDAC45(b *testing.B) &#123; benchmarkFibDAC(b, 45) &#125;func benchmarkFibDP(b *testing.B, n int) &#123; for i := 0; i &lt; b.N; i++ &#123; fibDP(n) &#125;&#125;func BenchmarkFibDP1(b *testing.B) &#123; benchmarkFibDP(b, 1) &#125;func BenchmarkFibDP10(b *testing.B) &#123; benchmarkFibDP(b, 10) &#125;func BenchmarkFibDP100(b *testing.B) &#123; benchmarkFibDP(b, 100) &#125;func BenchmarkFibDP1000(b *testing.B) &#123; benchmarkFibDP(b, 1000) &#125; 执行测试： 123456789101112131415161718192021222324$ go test -bench=FibDP -benchmemgoos: linuxgoarch: amd64pkg: goTestcpu: Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHzBenchmarkFibDP1-4 1000000000 0.4029 ns/op 0 B/op 0 allocs/opBenchmarkFibDP10-4 20096688 51.87 ns/op 80 B/op 1 allocs/opBenchmarkFibDP100-4 3030915 380.3 ns/op 896 B/op 1 allocs/opBenchmarkFibDP1000-4 328071 3656 ns/op 8192 B/op 1 allocs/opPASSok goTest 5.356s$ go test -bench=FibDAC -benchmemgoos: linuxgoarch: amd64pkg: goTestcpu: Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHzBenchmarkFibGreedy1-4 457008499 2.601 ns/op 0 B/op 0 allocs/opBenchmarkFibGreedy10-4 2589387 462.6 ns/op 0 B/op 0 allocs/opBenchmarkFibGreedy20-4 19940 57224 ns/op 0 B/op 0 allocs/opBenchmarkFibGreedy40-4 2 865527961 ns/op 0 B/op 0 allocs/opBenchmarkFibGreedy45-4 1 9598796528 ns/op 0 B/op 0 allocs/opPASSok goTest 17.082s 上面 FibDP 是对动态规划实现的基准测试，下面 FibDAC 是对递归实现的基准测试。可以看到差距十分巨大。 注意不要拿 b.N 当参数 1234567891011// 错误示范1func BenchmarkFibWrong(b *testing.B) &#123; for n := 0; n &lt; b.N; n++ &#123; Fib(n) &#125;&#125;// 错误示范2func BenchmarkFibWrong2(b *testing.B) &#123; Fib(b.N)&#125; 重置时间b.ResetTime() 可以重置计时器，也就是这句语句前面的耗时不计入。所以可以执行一些不参与时间测试的工作，然后 b.ResetTimer(). 12345678func BenchmarkFib(b *testing.B) &#123; fmt.Println(&quot;Start Benchmark test of Fib()&quot;) time.Sleep(time.Second) for i:=0; i&lt;b.N; i++ &#123; Fib(10) &#125;&#125; 并行测试TestMain、Setup 和 TeardownTestMain 基本格式 函数名为 TestMain 函数参数必须包含一个形参 *testing.M 函数没有返回值 123func TestMain(m *testing.M) &#123; // ...&#125; 参数 m 用于启动测试，启动方法如下： 1func (m *M) Run() (code int) 有时候遇到测试之前需要做一些初始化工作或者测试之后需要做一些收尾工作，就可以用 TestMain() 。 如果测试文件中包含TestMain()，那么生成的测试将调用 TestMain(m)，而不是直接其他运行测试。 m.Run() 被调用后，将会运行测试文件中所有的测试函数。 TestMain 运行在主 goroutine 中 , 可以在调用 m.Run 前后做任何 Setup 和 Teardown 。 注意，在 TestMain 函数的最后，应该使用 m.Run 的返回值作为参数去调用 os.Exit。 另外，在调用 TestMain 时 , flag.Parse 并没有被调用。 所以，如果 TestMain 依赖于 command-line 标志（包括 testing 包的标志），则应该显式地调用 flag.Parse。注意，这里的依赖是指，若 TestMain 函数内需要用到 command-line 标志，则必须显式地调用 flag.Parse，否则不需要，因为 m.Run 中调用 flag.Parse。 示例123456789// fib.gopackage fibfunc Fib(n int) int &#123; if n &lt; 2 &#123; return n &#125; return Fib(n-1) + Fib(n-2)&#125; 12345678910111213141516171819202122232425262728293031// fib_test.gopackage fibimport &quot;testing&quot;// 单元测试函数，以 Test开头func TestFib(t *testing.T) &#123; var ( input = 7 // 输入数据 expected = 13 // 期望结果 ) actual := Fib(input) // 程序执行结果 if actual != expected &#123; // 如果与期望结果不一致，则输出错误提示。 t.Errorf(&quot;Fib(%d) = %d; expected %d&quot;, input, actual, expected) &#125;&#125;func setup() &#123; fmt.Println(&quot;设置一些东西&quot;)&#125;func teardown() &#123; fmt.Println(&quot;清理一些东西&quot;)&#125;func TestMain(m *testing.M) &#123; setup() code := m.Run() teardown() os.Exit(code)&#125; 12345$ go test设置一些东西PASS清理一些东西ok goTest 0.002s 子测试的 Setup 和 Teardown有时候不只是全局进行测试的时候需要 Setup 和 Teardown，有可能每个子测试在测试的时候也需要 Setup 和 Teardown。那可以对 Setup 和 Teardown 尝试以下这种优雅的写法： 123456func setup() func() &#123; fmt.Println(&quot;Setup&quot;) return func() &#123; fmt.Println(&quot;Teardown&quot;) &#125;&#125; 然后在子测试中这样使用： 12345678910111213141516171819202122func TestFibDP(t *testing.T) &#123; // 1 1 2 3 5 8 13 21 34 55 tests := map[string]test&#123; &quot;case1&quot;: &#123;1, 1&#125;, &quot;case2&quot;: &#123;2, 1&#125;, &quot;case3&quot;: &#123;3, 2&#125;, &quot;case4&quot;: &#123;7, 13&#125;, &quot;case9&quot;: &#123;9, 34&#125;, &#125; for name, tc := range tests &#123; t.Run(name, func(t *testing.T) &#123; teardown := setup() defer teardown() if got := fibDP(tc.in); got != tc.want &#123; t.Errorf(&quot;want: %v, got: %v&quot;, tc.want, got) &#125; else &#123; fmt.Println(&quot;yes!!!&quot;) &#125; &#125;) &#125;&#125; 效果如下： 123456789101112131415161718192021222324252627282930$ go test -run=FibDP -v ──(日,7月11)─┘=== RUN TestFibDP=== RUN TestFibDP/case1Setupyes!!!Teardown=== RUN TestFibDP/case2Setupyes!!!Teardown=== RUN TestFibDP/case3Setupyes!!!Teardown=== RUN TestFibDP/case4Setupyes!!!Teardown=== RUN TestFibDP/case9Setupyes!!!Teardown--- PASS: TestFibDP (0.00s) --- PASS: TestFibDP/case1 (0.00s) --- PASS: TestFibDP/case2 (0.00s) --- PASS: TestFibDP/case3 (0.00s) --- PASS: TestFibDP/case4 (0.00s) --- PASS: TestFibDP/case9 (0.00s)PASSok goTest 0.002s 参考： [李文周博客] : https://www.liwenzhou.com/posts/Go/16_test/#autoid-3-1-0","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [基础] 14-错误与异常","slug":"Go/Basic/Golang-14-错误与异常","date":"2021-07-17T03:47:17.000Z","updated":"2021-07-17T03:47:17.000Z","comments":true,"path":"posts/b2fbd54c.html","link":"","permalink":"https://www.boii.xyz/posts/b2fbd54c.html","excerpt":"错误与异常的处理","text":"错误与异常的处理 错误与异常 意料之中的叫错误意料之外的叫异常 错误：是指可能出现问题的地方出现了问题，比如打开一个文件时失败，这种情况是在意料之中的。异常：是指不应该出现问题的地方出现了问题，比如引用了空指针，这种情况在人们的意料之外。所以错误是业务过程的一部分，而异常不是。 错误 Go 中错误是一种类型。错误用内置的 error类型表示。和 int、float64 是等价的。 error 是一个接口，接口是一种类型，所以说 error 是一种类型。 123type error interface &#123;4Error() string&#125; error类型可以存储错误值，从函数中返回等等。 12345678910111213141516package mainimport ( &quot;fmt&quot; &quot;os&quot;)func main() &#123; f, err := os.Open(&quot;test.txt&quot;) if err != nil &#123; fmt.Println(err) return &#125; // 根据f进行文件读写 fmt.Println(f.Name(), &quot;opened successfully&quot;)&#125; 抛出错误在编写桩模块供人调用时，我们不知道调用者会传进来什么参数，所以我们需要对传进来的参数做判断。如果发生错误我们需要进行处理，或者抛出错误。 要抛出错误，那得先会创建错误。 创建错误有两种方式： 通过 errors 包的 New() 函数创建：func New(errMsg string) error 通过 fmt 包的 Errorf() 函数创建：func Errorf(format string, a ...interface&#123;&#125;) error 创建错误 12errors.New(string)fmt.Errorf(string, ...interface&#123;&#125;) 这两种方式区别在于：fmt.Errorf() 可以使用格式化字符来返回错误信息，而 errors.New() 不能。 eg： errors.New()： 123456func div(a, b float64) (float64, error) &#123; if b == 0 &#123; return 0, errors.New(&quot;除数小于0&quot;) &#125; return a / b, nil&#125; 调用的效果： 1fmt.Println(div(10, 0)) // 除数小于0 fmt.Errorf()： 123456func div(a, b float64) (float64, error) &#123; if b == 0 &#123; return 0, fmt.Errorf(&quot;错误码: [%d] \\t 除数小于0&quot;, 100) &#125; return a / b, nil&#125; 调用的效果： 1fmt.Println(div(10, 0)) // 0 错误码: [100] 除数小于0 捕获错误当我们写驱动模块的时候，在调用桩模块时有可能返回错误，我们可以通过判断 最后一个返回值 err （最后一个返回值返回错误类型，这是约定俗成的）来判断是否有返回错误。 12345678func main() &#123; quotient, err := div(10, 0) if err != nil &#123; // 捕获错误 fmt.Println(err) return &#125; fmt.Println(quotient)&#125; 自定义错误简简单单的 Error.New() 和 fmt.Errorf() 有时候并不能满足我们的需求，所以我们还得自定义错误。 自定义错误分为三步： 创建一个结构体 实现 error 接口 定义其他方法 其中第一步和第二步是必选的，第三步是可选的。 eg： 自定义错误 1234567891011121314// 创建一个结构体type dataError struct &#123; Err string height int weight int age int&#125;// 实现 error 接口，使 dataError 成为 error 类型func (d *dataError) Error() string &#123; return d.Err &#125;// 定义其他方法func (d *dataError) heightNegativeError() bool &#123; return d.height &lt; 0 &#125;func (d *dataError) weightNegativeError() bool &#123; return d.weight &lt; 0 &#125;func (d *dataError) ageNegativeError() bool &#123; return d.age &lt;= 0 &#125; 抛出错误 12345678910111213141516171819type status = boolconst ( SUCCESS = true // SUCCESS 验证通过 FAIL = false // FAIL 验证未通过)type Person struct &#123; height int weight int age int&#125;// 验证不通过时，抛出错误func variety(p Person) (status, error) &#123; if p.height &lt; 0 || p.weight &lt; 0 || p.age &lt; 0 &#123; return FAIL, &amp;dataError&#123;&quot;数据有误&quot;, p.height, p.weight, p.age&#125; // 抛出错误 &#125; return SUCCESS, nil&#125; 捕获错误 12345678910func main() &#123; p := Person&#123;178, 120, -18&#125; s, err := variety(p) if err != nil &#123; // 捕获错误 fmt.Println(&quot;Error:&quot;, err) return &#125; fmt.Println(s, p)&#125; 输出结果： 12$ go run main.goError: 数据有误 如果捕获到了错误，而我们又想进一步判断是什么错误，需要用到 类型断言。 1234567891011121314151617func main() &#123; p := Person&#123;178, 120, -18&#125; s, err := variety(p) if err != nil &#123; // 捕获错误 if ins, ok := err.(*dataError); ok &#123; // 类型断言，判断是哪种错误 switch &#123; // 捕获后的处理，可以打印错误信息，也可以取个绝对值等其他操作。 case ins.heightNegativeError(): ins.Err = &quot;身高为负&quot; case ins.weightNegativeError(): ins.Err = &quot;体重为负&quot; case ins.ageNegativeError(): ins.Err = &quot;年龄为负&quot; &#125; fmt.Println(&quot;Error:&quot;, ins) &#125; return &#125; fmt.Println(s, p)&#125; 输出结果： 12$ go run main.goError: 年龄为负 异常当一个程序遇到意料之外的错误时，应该抛出异常，停止程序的运行。Go 中引入两个内置函数 panic() 和 recover() 来出发和终止异常处理流程，同时引入关键字 defer 来延迟执行延迟函数。 复习一下 defer1234567891011121314func fn() &#123; fmt.Println(&quot;start&quot;) defer fmt.Println(1) defer fmt.Println(2) defer fmt.Println(3) fmt.Println(&quot;end&quot;)&#125;// ---------------------// Output:startend321 先 defer 的后执行，后 defer 的先执行 panic 内置函数 发生 panic 的情况有两种： 手动抛出，即编写 panic 语句 程序发生错误由系统抛出。 如果函数中出现了 panic 语句，则不会继续执行 panic 下面的代码，而是会逆序执行 defer 修饰的函数，然后返回调用处 如果一路都没有遇到 recover()，则一路传递回所在协程的起点，然后该协程结束，终止其他所有协程（包括主协程）。 最终整个 goroutine 退出，报告错误。 panic 的签名如下： 1func panic(v interface&#123;&#125;) panic 中接受一个任何类型的参数，可以传递一个错误消息的字符串，也可以传递一个错误码。 eg： 1234567891011121314151617181920212223242526272829func fn() &#123; fmt.Println(&quot;start&quot;) defer fmt.Println(1) defer fmt.Println(2) panic(100) defer fmt.Println(3) fmt.Println(&quot;end&quot;)&#125;func main() &#123; defer fmt.Println(&quot;main defer...&quot;) fn() fmt.Println(&quot;After fn()...&quot;)&#125;// ---------------------// Output:start21main defer...panic: 100goroutine 1 [running]:main.fn() e:/---CODE/GO/root/src/boii.xyz/study/Helloworld/main.go:19 +0x166main.main() e:/---CODE/GO/root/src/boii.xyz/study/Helloworld/main.go:26 +0x27exit status 2 可以看出发生 panic 之后，在 panic 之前 defer 的代码依然会逆序执行，然后回到调用处。上面的例子执行完 fn() 中 defer 函数后，便返回了 main() 函数，接着执行 早在调用 fn() 之前就 defer 的 打印语句，然后就终止程序了。 结论：defer函数的执行 优先于 panic recover 内置函数 用来终止一个协程中的 panicking 行为，捕获 panic，从而影响应用的行为。 recover 需要用 defer 修饰。 一般的调用建议： 在 defer 函数中，通过 recover 来终止一个 协程的 panicking 过程，从而恢复正常代码的执行 可以获取通过 panic 传递的 error 简而言之，go中可以抛出一个 panic的异常，然后在 defer 中通过 recover 捕获这个异常，然后正常处理。 Q：为什么 recover 需要 defer 修饰？A：因为发生 panic 后，只会执行 defer 修饰的函数，然后返回函数调用处。 而 recover 是专门用来恢复 panic 的，所以必须用 defer 修饰 recover， 且 recover 需放置在出现或可能出现 panic 的地方之前，否则一旦发生 panic，程序控制流就开始往回走，panic 下 方的任何代码包括 defer 修饰的地方也不会执行，这样就捕获不到 panic 了。 eg：发生数组下标越界，没有 recover时 12345678910111213141516171819202122232425262728293031func traverse(a [5]int) &#123; for i := 0; i &lt;= 5; i++ &#123; fmt.Println(a[i]) &#125; fmt.Println(&quot;under for&quot;)&#125;func main() &#123; defer fmt.Println(&quot;main defer...&quot;) a := [5]int&#123;1, 2, 3, 4, 5&#125; traverse(a) fmt.Println(&quot;After div()...&quot;)&#125;// ---------------------// Output:12345main defer...panic: runtime error: index out of range [5] with length 5goroutine 1 [running]:main.traverse(0x1, 0x2, 0x3, 0x4, 0x5) e:/---CODE/GO/root/src/boii.xyz/study/Helloworld/main.go:17 +0xbemain.main() e:/---CODE/GO/root/src/boii.xyz/study/Helloworld/main.go:25 +0x105exit status 2 最后的 exit status 2说明程序是非正常退出的。 下面是使用了 recover 的效果 123456789101112131415161718192021222324252627282930func traverse(a [5]int) &#123; defer func() &#123; if msg := recover(); msg != nil &#123; fmt.Println(msg) &#125; &#125;() for i := 0; i &lt;= 5; i++ &#123; // 这里会发生数组下标越界，引发panic fmt.Println(a[i]) &#125; fmt.Println(&quot;under for&quot;)&#125;func main() &#123; defer fmt.Println(&quot;main defer...&quot;) a := [5]int&#123;1, 2, 3, 4, 5&#125; traverse(a) fmt.Println(&quot;After div()...&quot;)&#125;// ---------------------// Output:12345runtime error: index out of range [5] with length 5After div()...main defer... 可以看到，发生数组下标越界时，程序会引发 panic，然后开始执行 defer 函数；在 defer 函数里遇到了 recover，使得程序恢复正常运行，打印了错误信息后，回到主函数继续执行但是我们会发现虽然被 recover 恢复了，但是 for 循环下面的 语句依然不会执行。 结论：recover 必须用 defer 修饰recover 必须放在可能引发 panic 的地方之前即使 recover 了，在函数里，引发 panic 的地方下面那些代码依然没有机会运行。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [基础] 13-面向对象","slug":"Go/Basic/Golang-13-面向对象","date":"2021-07-17T03:42:18.000Z","updated":"2021-07-17T03:42:18.000Z","comments":true,"path":"posts/88c693c7.html","link":"","permalink":"https://www.boii.xyz/posts/88c693c7.html","excerpt":"Golang 模拟面向对象的实现","text":"Golang 模拟面向对象的实现 13-面向对象面向对象三大特性：封装、继承、多态 Golang 没有类的概念，也没有面向对象的概念。准确的说，面向对象、封装、继承、多态、抽象等等，这些都是编程思想，不同的语言实现这些特性的方式不同。例如 Java，用的是类 class，访问修饰符 public、protected、default、private 等来实现；在 Golang 中，用的是结构体 struct、标识符首字母大小写 等来实现。 面向过程、面向对象、一切皆对象、一切皆文件 等诸如此类的概念，在学习之初可能会成为初学者的一道坎，也可能是帮助新手更快入门的好帮手；等到学到一定程度以后，这些思想能帮助我们快速解决一些问题，也可能开始禁锢我们的思想；善于变通者会慢慢看透本质，脱离这些思想的枷锁，对编程形成自己的认知。变通者和不变通者的区别在于：是否愿意深入底层（汇编、组原等等），是否愿意摒弃语言执念。 封装 封装也叫信息隐藏、数据访问保护。通过暴露有限的访问接口，外部仅能通过类提供的方式来访问内部信息或数据。 需要编程语言提供权限访问控制语法来支持。如： Java 中的 public、protected、private Python 中标识符的双下划线前缀 __xxx或__slots__ 白名单 Golang 中标识符首字母大小写。 封装存在的意义， 一方面是保护数据不被随意修改，提高代码可维护性； 一方面是仅暴露有限的必要接口，提高易用性。 抽象 封装讲的是如何隐藏信息、保护数据，抽象讲的就是如何隐藏的具体实现。 抽象可以通过接口类或者抽象类来实现，但不需要特殊的语法机制来支持。 抽象存在的意义， 一方是是提高代码的可扩展性、维护性，修改实现不需要修改定义，减少代码改动范围； 另一方面，抽象也是处理复杂系统的有效手段，能有效过滤掉不必关注的信息。 继承 继承是用来表示类之间的 is-a 和 has-a 的关系，分为两种模式：单继承和多继承。 单继承表示一个子类只能继承一个父类，多继承表示一个子类可以继承多个父类。 需要编程语言提供特殊语法机制来支持。如： Java 中的 extends 关键字 Python 中类名后的括号 Go 中的结构体嵌套 继承存在的意义，是用来解决代码复用的问题。 多态 多态是指子类可以替代父类。在实际代码运行过程中，调用子类的方法实现。 需要编程语言提供特殊语法机制来支持。如：继承、接口、duck-typing。 多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现的基础。 封装在 Java 等面向对象中，会将一类事物抽象出属性和行为，并通过语言层面限定 访问性。 属性 使用基本数据类型或复合类型描述；行为 通过函数描述，并称之为方法；属性+方法组成一个类class；访问性各个语言实现不同。 在 Go 中没有类的概念，而是将事物的 属性 使用基本数据类型或复合数据类型 封装在结构体中，而 行为 是通过 给函数限定调用者的方式 实现。访问性 是通过首字母大写为 public，首字母小写为 private。 这种限定了调用者的函数，我们称之为方法。而拥有方法的结构体，我将其称之为类。 Golang 中，类 = 结构体 + 限定调用者的函数 + 访问性 123456789// class Atype A struct &#123; fieldA&#125;func (a A) aMethod() &#123; ...&#125; 构造函数Go 不支持像 Java 那样的构造函数，但是可以通过 标识符首字母大小写 + 工厂函数 实现构造函数。 一般分为4步： 将结构体、字段的首字母小写 结构体所在的包提供一个工厂模式的函数，首字母大写，模拟一个构造函数。按照规范，构造函数的名字以 new 或 New 开头。注意返回值必须是结构体指针，因为结构体是值类型。 提供首字母大写的 Get 方法，用于获取属性的值，建议命名规则：属性名首字母大写，如属性 sex 的 Get 方法为 Sex()、属性 name 的 Get 方法为 Name()。 提供首字母大写的 Set 方法，用于设置属性的值，建议命名规则：Set+属性名首字母大写，如属性 sex 的 Set 方法为 SetSex()、属性 name 的 Set 方法为 SetName()。 eg： 123456789101112131415161718192021222324252627282930313233343536373839type person struct &#123; name string age int&#125;// 写一个工厂函数，首字母大写，其他方就可以访问，相当于构造函数func NewPerson (name string, age int) *person &#123; if age &lt;= 0 || name == &quot;&quot; &#123; return nil &#125; return &amp;person&#123;name, age&#125;&#125;// Get 方法func (p person) Name() string&#123; return p.name&#125;func (p person) Age() int &#123; return p.age&#125;// Set 方法func (p person) SetName(name string) &#123; if name == &quot;&quot; &#123; return &#125; p.name = name&#125;func (p person) SetAge(age int) &#123; if age &lt;= 0 &#123; return &#125; p.age = age&#125;func main() &#123; // 然后这样创建对象： p := NewPerson(&quot;Boii&quot;, 18) fmt.Println(p) // &amp;&#123;Boii 18&#125; p.Name() // Boii p.SetAge(20) // p.age == 20&#125; toString在面向对象中，每个类默认继承自 Object，打印一个对象的时候，会调用这个对象的 toString() 方法，如果这个对象没有重写 toString()，会找其父类，一层层往上，找到了执行 toString()，找不到就执行 Object 的 toString()。 想要打印对象信息，在 Java 中是 .toString()，在 Python 中是 .__str__() 在 Go 中是 .String() 在 Go 中，可以通过 %v 打印结构体信息。fmt.Printf(&quot;%v \\n&quot;, t) 这句话等价于 fmt.Printf(&quot;%v \\n&quot;, t.String())，也等价于 fmt.Println(t)。那么想要打印结构体信息时按照自己想法来，就可以为结构体写一个 String() 方法。 123456789101112131415type car struct &#123; band string model string&#125;func (c car) String() string &#123; return c.band + &quot;-&quot; + &quot;c.model&quot;&#125;func main() &#123; c1 := &amp;car&#123;&quot;Benz&quot;, &quot;S600&quot;&#125; fmt.Printf(&quot;%v \\n&quot;, c1) // Benz-S600 fmt.Printf(&quot;%v \\n&quot;, c1.String()) // Benz-S600 fmt.Println(c1) // Benz-S600&#125; 继承面向对象中的继承性：如果两个类 class 存在继承关系，其中一个是子类，另一个作为父类，那么： 子类可以直接访问父类的属性和方法 子类可以新增自己的属性和方法 子类可以重写父类的方法（override，就是将父类已有的方法，重新实现） Golang 语法上不支持继承，但是通过结构体嵌套却可以实现继承，而且可以多继承，且通过 匿名字段 和 非匿名字段 还可以进一步区分 is-a 继承关系 和 has-a 聚合关系 Golang 的结构体嵌套： 模拟继承性：is - a12345678910111213141516171819202122232425262728293031323334type Base struct &#123; fieldB&#125;type Son struct &#123; fieldS Base // 匿名字段，模拟的是 继承关系&#125;func (b Base) baseMethod() &#123; // A的方法 fmt.Println(&quot;base method&quot;)&#125;func (s Son) sonMethod() &#123; // B的方法 fmt.Println(&quot;son method&quot;)&#125;func main() &#123; base := Base&#123;&#125; son := Son&#123;&#125; base.fieldB // 正确使用 son.fieldS // 正确使用 son.fieldB // 正确使用 son.Base.fieldB // 正确使用 base.fieldS // !报错 base.Son.fieldS // !报错 base.baseMethod() // 正确使用 son.sonMethod() // 正确使用 son.baseMethod() // 正确使用 son.Base.baseMethod() // 正确使用 base.sonMethod() // !报错 base.Son.sonMethod() // !报错&#125; 模拟聚合关系：has - a123456789101112131415161718type C struct &#123; fieldC&#125;type D struct &#123; fieldD c C // 非匿名字段，模拟的是 聚合关系&#125;func (c C) cMethod() &#123; fmt.Println(&quot;C method&quot;)&#125;d := D&#123;...&#125;d.fieldC // !报错d.C.fieldC // !报错d.c.fieldC // 正确使用d.c.cMethod() // 正确使用 小结在结构体中嵌套了其他结构体，会出现两种情况，一种是 is - a 的关系，一种的 has - a 的关系。 is - a 是一种继承关系，子类可以直接使用父类（被嵌套类）的变量，如上面例子中的 b.fieldAhas - a 是一种聚合关系，当前类使用聚合类（被嵌套类）的变量必须通过聚合类的名字，如上面例子中的 d.c.fieldC，其他两种方式会报错。 多态Golang 中的多态是通过 接口 和 Duck-typing 实现的。 Duck-typing 也是一种编程思想：只要一个东西看起来像鸭子，走路像鸭子，吃起来像鸭子…，那它就是鸭子。反映在编程语言中就是，只要一个结构体或者一个类，具有某个方法的具体实现，那它就可以被我这个函数/方法接受。 Golang 中的接口是非侵入式的，不像Java 那样需要显式的在类声明中加上 implement xxer，Golang 不需要结构体显示的声明实现某个接口，只要你这个结构体有我这个接口所有方法的具体实现，那这个结构体就实现是我这个接口，就是我的实现类，就是我这种类型。 123456789101112131415161718192021222324252627282930313233type Aer interface &#123; show() string&#125;type X struct &#123;&#125;type Y struct &#123;&#125;type Z struct &#123;&#125;func (x X) show() string &#123; return &quot;I&#x27;m X&quot;&#125;func (x X) add(a, b int) int &#123; return a + b&#125;func (x Y) show() string &#123; return &quot;I&#x27;m Y&quot;&#125;func PrintStruct(a Aer)&#123; fmt.Println(a.show())&#125;func main() &#123; x := X&#123;&#125; y := Y&#123;&#125; z := Z&#123;&#125; PrintStruct(x) // I&#x27;m X PrintStruct(y) // I&#x27;m Y PrintStruct(z) // !报错, 因为 Z 没有实现 Aer 的方法 show()，不是 Aer 类型&#125; 重写重写，说大白话就是：爹有的，儿子不满意，儿子自己来。 Golang 中通过嵌套结构体模拟继承，如果子结构体有和父结构体 同名同参的方法，则称作重写。 Golang 中不支持同名不同参。 123456789101112131415161718192021222324252627282930type base struct &#123; // 父类 name string&#125;type son struct &#123; // 子类 base // 继承了父类 age int&#125;func (b base) say() &#123; // 父类方法 fmt.Println(&quot;Base said.&quot;)&#125;func (b base) run() &#123; // 父类方法 fmt.Println(&quot;Base ran.&quot;)&#125;func (s son) say() &#123; // 子类方法，重写了父类方法 fmt.Println(&quot;Son said.&quot;)&#125;func main() &#123; b := base&#123;&quot;Eva&quot;&#125; // 实例化父类 s := son&#123;base&#123;&quot;Boii&quot;&#125;, 64&#125; // 实例化子类 b.say() // Base said. s.say() // Son said. b.run() // Base ran. s.run() // Base ran.&#125; 举个栗子Java实现现在我们用 Java 来定义一个类 123456789101112131415161718192021222324252627282930313233public class Dog&#123; // 属性 private String name; private int age; // 构造函数 public Dog(String name, int age)&#123; this.name = name; this.age = age; &#125; // getter public String getName() &#123; return this.name; &#125; public int getAge() &#123; return this.age; &#125; // setter public void setName(String newName) &#123; this.name = newName; &#125; public void setAge(int newAge)&#123; this.age = newAge; &#125; // toString @Override public String toString() &#123; return this.name + &quot;-&quot; + this.age; &#125;&#125; 以上就是用 Java 定义的一个最简单的类了。类中有属性、构造函数、getter 和 setter 和 toString()。 使用的时候是这样子的： 1234567Dog doge = new Dog(&quot;Doge&quot;, 2);System.out.println(doge.getName()); // DogeSystem.out.println(doge.getAge()); // 2doge.setAge(3);System.out.println(doge.getAge()); // 3System.out.println(doge) // Doge-3 Go 实现下面我们来看看用 Go 怎么做： 12345678910111213141516171819202122232425262728293031323334353637383940//$GOPATH/src/dog/myDog.gopackage dogimport ( &quot;fmt&quot; &quot;strconv&quot;)// 定义 Dog 结构体，包含了属性type dog struct &#123; name string age int8&#125;// 构造函数func NewDog(name string, age int8) *dog &#123; return &amp;dog&#123;name, age&#125;&#125;// getterfunc (d *dog) Name() string &#123; return d.name&#125;func (d *dog) Age() int8 &#123; return d.age&#125;// setterfunc (d *dog) SetName(newName string) &#123; d.name = newName&#125;func (d *dog) SetAge(newAge int8) &#123; d.age = newAge&#125;// toStringfunc (d *dog) String() string &#123; return d.name + &quot;-&quot; + strconv.Itoa(int(d.age))&#125; 同样实现了属性、构造函数、getter 和 setter。 使用的时候是这样子的： 12345678910111213141516171819//$GOPATH/src/Hello/main.gopackage mainimport ( &quot;dog&quot; &quot;fmt&quot;)func main() &#123; doge := NewDog(&quot;Doge&quot;, 2) fmt.Println(doge.Name()) // Doge fmt.Println(doge.GetAge()) // 2 doge.SetAge(3) fmt.Println(doge.Age()) // 3 fmt.Printf(&quot;%v \\n&quot;, doge) // Doge-3 fmt.Println(doge) // Doge-3&#125; 抽象类抽象类其实和接口的性质是一样的，但是又多了一些具体的实现。 当一个接口中的某些方法，所有子类的实现都一样时，可以换成抽象类来实现，将这些共同的实现写在抽象类中，剩下不同的实现续集保持抽象。 以 Java 为栗eg： 1234567891011121314151617181920212223242526// 定义一个抽象类public abstract class Animal &#123; // 实现共同方法 public void run() &#123; System.out.println(this.name() + &quot; is running!&quot;); &#125; // 定义抽象方法 public abstract String kind();&#125;// 继承抽象类public class cat extends Animal &#123; // 实现抽象方法 public String kind() &#123; return &quot;cat&quot;; &#125;&#125;// 继承抽象类public class dog extends Animal() &#123; // 实现抽象方法 public String kind() &#123; return &quot;dog&quot;; &#125;&#125; 上面抽象了一个动物类 Animal，我们实现了共同的方法 run()，并定义了需要子类自己实现的抽象方法 kind()。 接着定义了两个具体类 cat 和 dog 继承 Animal，并各自具体实现抽象方法 kind()。 Go 实现抽象类Go 并没有抽象类的概念，但是通过 struct 和 interface 可以实现出抽象类。 思考一下：Java 中抽象类和接口的区别在哪？ 其实就是抽象类中需要具体实现一些 公共方法，剩下的那些抽象方法，用 Java 中的接口实现也是一样的。 只不过 Java 有抽象类的概念，可以优雅的实现。 那么我们也可以在 Golang 中，定义一个接口IAer，接口中定义一些抽象方法； 然后定义一个 Aer 作为公共的结构体（类），由它来实现公共的部分 然后其他结构体嵌套这个公共结构体，并实现接口 IAer 的方法，这样就能达到与抽象类相同的效果。 123456789101112131415161718192021// 抽象类 -- starttype IAnimal interface &#123; kind() string&#125;type Animal struct &#123;&#125;func (a *Animal) run(this IAnimal) &#123; // !注意这里接受的是接口变量 fmt.Println(this.kind + &quot;is running.&quot;)&#125;// 抽象类 -- end// 继承抽象类type cat struct &#123; Animal &#125;// 实现抽象方法func (c *cat) kind() string &#123; return &quot;cat&quot; &#125;// 继承抽象类type dog struct &#123; Animal &#125;// 实现抽象方法func (d *dog) kind() string &#123; return &quot;dog&quot; &#125; 接口定义抽象方法，公共结构体实现公共方法，其他要继承象类的子类只要匿名嵌套公共结构体即可 另外在公共结构体实现公共方法时，其至少接收一个接口类型的参数，这个参数相当于this。 调用： 12345678func main() &#123; c := &amp;cat&#123;&#125; c.run(c) d := &amp;dog&#123;&#125; d.run(d) fmt.Println(&quot;kind(): &quot;, d.kind())&#125; 输出： 123cat is runningdog is runningkind(): dog 小结Golang 中实现抽象类： 抽象的方法放在接口中 公共的方法定义一个公共结构体去实现，需要用到 this 的地方使用接口变量 继承抽象类的子类要做两件事： 匿名嵌套公共结构体 实现接口中的所有方法 在调用公共方法时，需要将子类自己传进去。 泛型据说在 Go 1.17 出 单例模式 饿汉式： 1234567type singleton struct&#123;&#125;var single *singleton = new(singleton)func GetPersonInstance() *singleton &#123; return single&#125; 测试一下 123456func main() &#123; s3 := GetPersonInstance() s4 := GetPersonInstance() fmt.Printf(&quot;%p\\n&quot;, s3) // 0x104d5b8 fmt.Printf(&quot;%p\\n&quot;, s4) // 0x104d5b8&#125; 懒汉式： 12345678910type singleton struct&#123;&#125;var single *singletonfunc GetPersonInstance() *singleton &#123; if single == nil &#123; single = new(singleton) &#125; return single&#125; 测试一下 123456func main() &#123; s3 := GetPersonInstance() s4 := GetPersonInstance() fmt.Printf(&quot;%p\\n&quot;, s3) // 0x104d5b8 fmt.Printf(&quot;%p\\n&quot;, s4) // 0x104d5b8&#125; 使用 sync.Once 实现的懒汉式： 12345678910111213type singleton struct&#123;&#125;var ( single *singleton once sync.Once)func GetPersonInstance() *singleton &#123; once.Do(func() &#123; single = new(singleton) &#125;) return single&#125; 测试一下： 123456func main() &#123; s1 := GetPersonInstance() s2 := GetPersonInstance() fmt.Printf(&quot;%p\\n&quot;, s1) // 0xdbd5b8 fmt.Printf(&quot;%p\\n&quot;, s2) // 0xdbd5b8&#125;","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [基础] 12-接口","slug":"Go/Basic/Golang-12-接口","date":"2021-07-17T03:39:55.000Z","updated":"2021-07-17T03:39:55.000Z","comments":true,"path":"posts/19a13983.html","link":"","permalink":"https://www.boii.xyz/posts/19a13983.html","excerpt":"接口的创建与使用","text":"接口的创建与使用 12-接口Go 中的接口 interface 是一种类型，一种抽象的类型。 interface 是一组方法的集合，是 dack-type programming 的一种体现。接口做的事情就像是定义一个协议（规则），只要一台机器具有洗衣服和甩干的功能，我就称其为洗衣机。接口不关心属性（数据），只关心行为（方法）。 只要一个结构体 X 实现了接口 A 中所有的方法，就称这个结构体 X 为接口 A 的实现类，称结构体 X 实现了接口 A。还可称结构体 X 是 A 类型。 为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型。 定义接口基本语法如下： 123456type identifier interface &#123; methodName1([param])[(return)] methodName2([param])[(return)] methodName3([param])[(return)] ...&#125; identifier：接口名，命名时按照规范应该加上 er，如 有字符串功能的 Stringer、有读取功能的 Reader。methodName：方法名 eg： 1234type USBer interface &#123; start() end()&#125; 实现接口实现接口： 123456789101112131415161718// 定义一个接口type USBer interface &#123; start() end()&#125;// 定义一个结构体type Mouse struct &#123; name string&#125;// 实现两个接口中的方法，接收者为结构体 Mouse，这样 Mouse 就是一个实现类func (m Mouse) start() &#123; fmt.Println(m.name, &quot;starts working.&quot;)&#125;func (m Mouse) end() &#123; fmt.Println(m.name, &quot;end working.&quot;)&#125; 结构体 Mouse 实现了 USBer 的所有方法 start() 和 end()，所以 Mouse 就是 USBer 的一个实现类。 使用接口实现了接口的结构体（实现类）和没实现接口的结构体，区别在于当一个函数需要传递一个接口类型的参数时，可以传递一个接口变量进去，也可以传一个实现类对象进去。 123456789101112func test(usb USBer) &#123; // 需要传递一个接口类型的参数 usb.start() usb.end()&#125;func main() &#123; m1 := Mouse&#123;&quot;罗技&quot;&#125; test(m1) // 传递一个实现类对象 var u1 USBer = m1 test(u1) // 传递一个接口变量&#125; 注意，接口变量使用之前，需要先赋一个实现类对象。接口变量可以调用接口中的方法，但不可以调用实现类的属性和方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport &quot;fmt&quot;// 定义一个接口type iUSBer interface &#123; start() end()&#125;// 定义一个结构体type Mouse struct &#123; name string&#125;// 实现两个接口中的方法，接收者为结构体 Mouse，这样 Mouse 就是一个实现类func (m Mouse) start() &#123; fmt.Println(m.name, &quot;starts working.&quot;)&#125;func (m Mouse) end() &#123; fmt.Println(m.name, &quot;end working.&quot;)&#125;// 定义结构体 Mouse 自己的方法func (m Mouse) selfMethod() &#123; fmt.Println(m.name, &quot;selfMethod&quot;)&#125;// 定义一个测试方法，需要接收一个 USB 接口变量。可以传递 USB 变量，也可以传递 USB 实现类的对象func test(usb iUSBer) &#123; // 需要传递一个接口类型的参数 usb.start() usb.end()&#125;func main() &#123; m1 := Mouse&#123;&quot;罗技&quot;&#125; // Mouse是一个实现类，可以传递实现类对象给 test() test(m1) // 接口变量使用之前要先赋一个实现类对象 var u1 iUSBer = m1 // 传递一个接口变量给 test() test(u1) m1.start() // 罗技 starts working. m1.end() // 罗技 end working. m1.selfMethod() // 罗技 selfMethod u1.start() // 罗技 starts working. u1.end() // 罗技 end working. // u1.selfMethod() // 错误，接口变量不可以调用实现类的方法 // u1.name // 错误，接口变量不可以调用实现类的属性&#125; 空接口不包含任何方法的接口，称为空接口。我们可以认为 任意类型都实现了空接口 123interface &#123;&#125;type T interface &#123;&#125; eg： 123456789101112131415type T interface&#123;&#125;type person struct &#123; name string&#125;var t1 T = person&#123;&quot;Boii&quot;&#125;var t2 T = &quot;str&quot;var t3 T = 100var t4 T = []int&#123;1, 2, 3&#125;fmt.Println(t1) // &#123;Boii&#125;fmt.Println(t2) // strfmt.Println(t3) // 100fmt.Println(t4) // [1 2 3] 空接口的作用在于 任意类型。当我们想要接受一个任意类型的参数，或者定义一个接收任意类型的容器，都可以使用空接口来代替。1234567func test (a interface&#123;&#125;) &#123; ...&#125;test(&quot;string&quot;)test(123)test([]int&#123;1, 2, 3, 4&#125;)123456a := []interface&#123;&#125;&#123;1, 3, &quot;str&quot;, true&#125;fmt.Println(a) // &#123;1 3 str true&#125;type T interface&#123;&#125;b := []T&#123;1, 3, &quot;str&quot;, true&#125;fmt.Println(b) // &#123;1 3 str true&#125; 接口嵌套接口中不仅可以定义方法签名，还可以定义其他的接口。这种方式我们称为接口嵌套。 123456789101112131415161718192021222324252627282930313233// 接口Atype A interface &#123; method1()&#125;// 接口Btype B interface &#123; method2()&#125;// 接口C，嵌套了接口 A 和 Btype C interface &#123; A B method3()&#125;// 结构体type person struct &#123; name string&#125;func (p person) method1() &#123; // 使 person 成为 接口A 的实现类 ...&#125;func (p person) method2() &#123; // 使 person 成为 接口B 的实现类 ...&#125;func (p person) method3() &#123; // 使 person 成为 接口C 的实现类，前提是实现了前面两个 ...&#125; 嵌套了接口，不仅要实现接口本身的方法，还要实现接口中的嵌套接口的方法，才能认为实现了最外侧的接口。 如上面例子，person 要成为 C 的实现类，不仅要实现 C 的 method3() 方法，还得实现 A 的 method1() 和 B 的method2()。 12345678910111213141516171819202122232425262728func main() &#123; p := person&#123;&quot;Boii&quot;&#125; p.method1() p.method2() p.method3() var a1 A = p a1.method1() // a1.method2() // !报错 // a1.method3() // !报错 var b1 B = p b1.method2() // b1.method1() // !报错 // b1.method3() // !报错 var c1 C = p c1.method1() // 正确 c1.method2() // 正确 c1.method3() // 正确 var a2 A = c1 // 接口C变量看成是接口A类型，这是可以的 a2.method1() // 但是只能调用接口A的 method1() // a2.method2() // !报错 // a2.method3() // !报错 var c2 C = a1 // !报错，接口A变量看成是接口C类型，这是错误的&#125; 接口断言设 定义了一个接口A，还有两个结构体 X、Y，两个结构体都实现了接口A，当一个函数或方法想要接收 X 或 Y 两种类型时，可以将形参设置为 接口A 类型，这样传递的时候不管是 X 的对象还是 Y 的对象都可以传递进来。 【Q】：那如果在方法或函数里，我需要确定到底是 X 还是 Y 怎么办？ 123456789101112131415161718192021222324252627type A interface &#123; aMethod()&#125;type X struct &#123; name string age int&#125;type Y struct &#123; name string sex string&#125;// 实现接口Afunc (x X) aMethod() &#123; fmt.Println(&quot;I am &quot;, x)&#125;func (y Y) aMethod() &#123; fmt.Println(&quot;I am&quot;, y)&#125;// 定义一个接收 X 和 Y 对象的函数func test(a A) &#123; a.aMethod()&#125; 【A】：这时候我们需要用到接口类型断言来确定传进来的到底是 x 还是 y。 方式1： instance := 接口对象.(实际类型)，这种不安全，会引发 panic() instance, ok := 接口对象.(实际类型)，这种就安全。接口对象是实际类型时，ok 为 true 方式2：switch 12345switch instance := 接口对象.(type) &#123;case 实际类型1: ...case 实际类型2: ......&#125; 于是在 test() 函数中我们可以这样写： 1234567func test (a A) &#123; if ins, ok := a.(X); ok &#123; fmt.Println(ins.age) &#125; else if ins, ok := a.(Y); ok &#123; fmt.Println(ins.sex) &#125;&#125; 或者这样写： 123456789// 定义一个接收 X 和 Y 对象的函数func test(a A) &#123; switch ins := a.(type) &#123; case X: fmt.Println(ins.age) case Y: fmt.Println(ins.sex) &#125;&#125; 值类型实现 VS 指针类型实现我们先定义一个接口，和两个结构体 然后分别使用 值类型 和 指针类型 实现接口 1234567891011type Aer interface &#123; method()&#125;type X struct &#123;&#125;type Y struct &#123;&#125;// 值类型实现func (x X) method() &#123;&#125;// 指针类型实现func (y *Y) method() &#123;&#125; 此时实现接口的是 X 类型 和 *Y 类型。 接着我们来使用一下： 12345678910func main() &#123; x := X&#123;&#125; y := Y&#123;&#125; var a1 Aer = x // a1 可以接收 x 类型 var a2 Aer = &amp;x // a2 可以接收 *X 类型 var a3 Aer = y // !报错，a3 不可以接收 y 类型 var a4 Aer = &amp;y // a4 可以接收 *y 类型&#125; 在使用值类型实现接口之后，不管是 X 结构体类型 还是 *X 结构体指针类型，都可以赋值给该接口变量。因为在 Go 语言中有对指针类型变量求值的语法糖，X 指针 &amp;x 内部会自动求值。var a2 Aer = &amp;x 会变成 var a2 Aer = *(&amp;x)。 而 Y 是用指针类型实现的，所以只能传递指针 &amp;y 给 Aer 接口变量。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [基础] 11-包","slug":"Go/Basic/Golang-11-包","date":"2021-07-17T03:38:35.000Z","updated":"2021-07-17T03:38:35.000Z","comments":true,"path":"posts/6239436b.html","link":"","permalink":"https://www.boii.xyz/posts/6239436b.html","excerpt":"包的使用","text":"包的使用 11-包在工程化的Go语言开发项目中，Go语言的源码复用是建立在包（package）基础之上的。本文介绍了Go语言中如何定义包、如何导出包的内容及如何导入其他包。 包（package）是多个 Go 源码的集合，是一种高级的代码复用方案，例如 Go 就提供了很多内置包，如fmt、os、io等。 定义包一个包可以简单理解为一个存放 .go 文件的目录。该目录下面所有的go文件都要再代码第一行添加 package 包名，声明该文件归属的包。 注意： 一个目录下面直接包含的文件只能归属一个 package 同一个 package 的文件不能放在多个目录下 包名可以不和目录名一样，但不能包含 - 符号 main 包 为程序的入口包，这种包编译后会得到一个可执行文件 编译不含 main 包 的源代码不会得到可执行文件 123456789demo├── utils│ ├── calc.go // package utils│ └── data.go // package utils├── log│ ├── debug.go // package log│ └── info.go // package log├── main.go // package main└── test.go // package main 可见性在一个包中引用另外一个包里的标识符（变量、函数、类型等），该标识符必须是对外可见的，即首字母大写的。 1234567891011121314151617181920212223242526package modelimport &quot;fmt&quot;var a = 100 // 首字母小写，外部包不可见，只能在当前包内使用const PI = 3.14 // 首字母大写，外部包可见，可在其他包中使用type person struct &#123; // 首字母小写，外部包不可见，只能在当前包内使用 Name string // 首字母大写，外部包可见，可在其他包中使用 age int8 // 仅限包内访问的字段&#125;type Payer interface &#123; // 首字母大写，外部包可见，可在其他包中使用 init() // 仅限包内访问的方法 Pay() // 可在保外访问的方法&#125;func Add(x, y int) int &#123; // 首字母大写，外部包可见，可在其他包中使用 return x + y&#125;func age() &#123; // 首字母小写，外部包不可见，只能在当前包内使用 var Age = 18 // 函数局部变量，外部包不可见，只能在当前函数内使用 fmt.Println(age)&#125; 导入包1import &quot;包的路径&quot; 注意： import 语句通常放在文件开头、包声明语句下面。 包的路径需要双引号括起来 包名是从 $GOPATH/src/ 后面开始计算的，使用 / 分割路径，这是绝对路径；也可以使用相对路径 禁止互相导包 单行导入12import &quot;包1&quot;import &quot;包2&quot; 多行导入1234import ( &quot;包1&quot; &quot;包2&quot;) GO MODULE 模式下导入自己的包使用 Go Module 模式管理包时，如果想导入自己写的包，路径应为 module名/路径... eg： 1234├── go.mod // module Stack├── main.go // package main└── seqStack └── SeqStack.go // package seqStack 从项目根目录下开始，有一个 main.go 文件，还有一个子包 seqStack。现在我想在 main.go 中使用 SeqStack.go 中的函数，需要在 main.go 中导入 seqStack 这个包。 分为以下三步： 在 go.mod 中写下： 12345module Stack // 声明 module 名go 1.16... 在 SeqStack.go 中声明： 123package seqStack // 声明子包名... 在 main.go 中导入： 12345package main // 声明 main 包import &quot;Stack/seqStack&quot; // 正确导入... 别名导包的时候，可以给包设置别名。常用于处理包名太长或包名冲突的情况。 1import 别名 &quot;包的路径&quot; 单行123456import &quot;fmt&quot;import t &quot;tcp404.com/study/go/test&quot;func main() &#123; fmt.Println(t.Add(10, 20))&#125; 多行12345678import ( . &quot;fmt&quot; // 使用 . 作为别名，则使用时可以省略包名 t &quot;tcp404.com/study/go/test&quot;)func main() &#123; Println(t.Add(10, 20))&#125; 省略包名在给包起别名的时候，别名为 . ，在后面使用时可以直接使用包中的变量和方法等，不需要加包名。 12345import . &quot;fmt&quot;func main() &#123; Println(&quot;Hello!&quot;)&#125; init() 初始化函数 Go 在执行导包之前，会自动触发包内的 init() 函数的调用。 init() 没有参数也没有返回值，自动被调用，不能主动调用，main() 也是。 一个包内的init() 可以有多个，main() 只能有一个。 一个包可以被多个包导入，但是 init() 只会执行一次。 包内多个 init() 的执行顺序不固定，目前（Go 1.16.5）是按照文件名升序，a最先执行，z最后执行。 每个 .go 文件都可以有自己的 init() ， 1234567891011121314151617package mainimport &quot;fmt&quot;// 全局变量var age int8 = 18const E = 2.78// init函数func init() &#123; fmt.Println(E)&#125;// main函数func main() &#123; fmt.Println(&quot;Hello World&quot;)&#125; 一个包中的执行顺序为：1. 全局声明(const -&gt; var) -&gt; 2. init() -&gt; 3. main() 多个包有导入关系时，init() 执行顺序：从main 包开始，按照 main 包的 import 的顺序 广度优先 一层层往下找 匿名导包有时候只想导入一个包执行一下它的 init() 函数，并不使用包里的东西，可以使用匿名导包。 1import _ &quot;包的路径&quot; 匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [基础] 10-结构体","slug":"Go/Basic/Golang-10-结构体","date":"2021-07-17T03:30:00.000Z","updated":"2021-07-17T03:30:00.000Z","comments":true,"path":"posts/ff53e8a4.html","link":"","permalink":"https://www.boii.xyz/posts/ff53e8a4.html","excerpt":"结构体的创建与使用","text":"结构体的创建与使用 10-结构体Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。 当我们想表示一些事物时，我们可以用基本数据类型表示其各项基本属性，通过结构体将其组合起来。在 Go 中可以通过 struct 实现面向对象。 定义注意：结构体是值类型！！！ 使用 type 和 struct 来定义结构体。 基本语法如下： 12345type structT struct &#123; field1 T field2 T ...&#125; structT：标识只定义结构体名称，同一包内不能重复。field：结构的基本属性的名字，结构体中的字段名不能重复T：字段的具体类型 eg： 12345type person struct &#123; name string age int8 city string&#125; 同类型字段可以写在一行 1234type person struct &#123; name, city string age int8&#125; 通过以上代码，我们就可以得到一个 person 的自定义类型，它有 name、age、city 三个字段，表示人的姓名、年龄、城市三个属性。这样就可以通过 person 这个结构体很方便的在程序中表示和存储人的信息了。 在定义结构体时，建议各个字段按字段类型从小到大排序，有助于内存对齐。类型大小参考《数据类型》一章 Go 内置的基本数据类型用来描述一个值，而结构体用来描述一组值，本质上是一种聚合型数据类型。一个结构体就像 Java 中的一个类，不过 Java 中的类还有构造函数、方法等，这些 Go 的结构体一样可以实现，方式有些不同 实例化只有当结构体实例化时，才会真正地分配内存。即必须实例化后才能使用结构体的字段。结构体本身也是一种数据类型，我们可以像声明基本数据类型一样声明结构体 12345// 方式1var identifier structTidentifier.field1 = value1identifier.field2 = value2... identifier：结构体实例名称structT：结构体类型field：结构体字段 方式1：基本实例化123456789101112131415type person struct &#123; name string city string age int8&#125;func main() &#123; // 方式1 var p1 person p1.city = &quot;SWA&quot; p1.name = &quot;Boii&quot; fmt.Printf(&quot;p1 = %v \\n&quot;, p1) // p1 = &#123;Boii 0 SWA&#125; fmt.Printf(&quot;p1 = %#v \\n&quot;, p1) // p1 = main.person&#123;name:&quot;Boii&quot;, age:0, city:&quot;SWA&quot;&#125;&#125; 仔细观察： 方式1声明以后逐一给每个字段赋值，可以结构体中定义字段时的顺序，没有赋值的字段默认为零值 方式2 和 方式3在赋值的时候需要所有字段都赋值，且需要按顺序。 通过.可以访问结构体中的字段，例如p1.city. 方式2：new(T) 结构体指针通过 new() 可以对结构体实例化，得到的是结构体指针，其各个字段都为零值。 1234567891011121314type person struct &#123; name string city string age int8&#125;func main() &#123; var p1 = new(person) fmt.Printf(&quot;%T \\n&quot;, p1) // *main.person fmt.Printf(&quot;p1 = %#v \\n&quot;, p1) // p1 = &amp;main.person&#123;name:&quot;&quot;, age:0, city:&quot;&quot;&#125; p1.name = &quot;Boii&quot; fmt.Printf(&quot;p1 = %#v \\n&quot;, p1) // p1 = &amp;main.person&#123;name:&quot;Boii&quot;, age:0, city:&quot;&quot;&#125;&#125; 注意：Go 中的结构体指针可以直接使用.来访问结构体成员。p1.name = &quot;Boii&quot; 相当于 (*p1).name = &quot;Boii&quot;，这是 Go 的语法糖。 方式3：&amp;T{} 取结构体地址使用 &amp; 对结构体取地址操作相当于对该结构体类型进行了一次 new实例化操作。 123456789101112131415161718type person struct &#123; name string city string age int8&#125;func main() &#123; var p2 = &amp;person&#123;&quot;Boii&quot;, 10, &quot;SWA&quot;&#125; fmt.Printf(&quot;%T \\n&quot;, p2) // *main.person fmt.Printf(&quot;p2 = %#v \\n&quot;, p2) // p = &amp;main.person&#123;name:&quot;Boii&quot;, age:10, city:&quot;SWA&quot;&#125; p3 := &amp;person&#123;&#125; p3.name = &quot;Candy&quot; p3.age = 10 p3.city = &quot;SWA&quot; fmt.Printf(&quot;%T \\n&quot;, p3) // *main.person fmt.Printf(&quot;p3 = %#v \\n&quot;, p3) // p = &amp;main.person&#123;name:&quot;Candy&quot;, age:10, city:&quot;SWA&quot;&#125;&#125; 所以：new(Type) 和 &amp;Type&#123;&#125; 是等价的。 匿名结构体在定义一些临时数据结构等场景下还可以使用匿名结构体。 1234567891011121314151617181920func main() &#123; // 定义匿名结构体 // 字段之间用 分号 隔开 var user struct&#123;name string; age int8&#125; // 通过结构体实例使用匿名结构体 user.name = &quot;Boii&quot; user.age = 18 fmt.Printf(&quot;%v \\n&quot;, user) // &#123;Boii 18&#125; fmt.Printf(&quot;%#v \\n&quot;, user) // struct &#123; name string; age int8 &#125;&#123;name:&quot;Boii&quot;, age:18&#125; // 相同类型可以简写 var stu struct&#123;name string; ID, age int&#125; // 规范写法 var stud struct &#123; name string ID, age int &#125;&#125; 初始化结构体没有初始化的时候，成员变量都是对应类型的零值，这点在上面的例子中已经有所体现。 12345678910type stu struct &#123; name string age int8 ID int8&#125;func main() &#123; var s1 stu fmt.Printf(&quot;s1 = %#v \\n&quot;, s1) // s1 = main.stu&#123;name:&quot;&quot;, age:0, ID:0&#125;&#125; 使用键值对的方式初始化123456789101112identifier := structT&#123; field1: value1, field2: value2, ...&#125;var identifier = structT&#123; field1: value1, field2: value2, ...&#125; 1234567891011s2 := stu&#123; name: &quot;Boii&quot;, age: 18,&#125;fmt.Printf(&quot;s2 = %#v \\n&quot;, s2) // s2 = main.stu&#123;name:&quot;Boii&quot;, age:18, ID:0&#125;var s3 = stu&#123; name: &quot;Eva&quot;, age: 18,&#125;fmt.Printf(&quot;s3 = %#v \\n&quot;, s3) // s3 = main.stu&#123;name:&quot;Eva&quot;, age:18, ID:0&#125; 使用键值对的方式可以不按结构体定义时字段的顺序，可以不初始化每一个字段，没被初始化的字段就默认为零值。注意最后一个字段也要加上逗号,。 12345s3 := &amp;stu&#123; age: 18, ID: 101,&#125;fmt.Printf(&quot;s3 = %#v \\n&quot;, s3) // s3 = &amp;main.stu&#123;name:&quot;&quot;, age:18, ID:101&#125; 也可以对结构体指针进行键值对初始化 使用值列表的方式初始化初始化结构体的时候可以简写，不写键，只写值。 1234567891011identifier := structT&#123; value1, value2, ...&#125;var identifier = structT&#123; value1, value2, ...&#125; eg： 123456s4 := stu&#123; &quot;Boii&quot;, 18, 102,&#125;fmt.Printf(&quot;s4 = %#v \\n&quot;, s4) // s4 = main.stu&#123;name:&quot;Boii&quot;, age:18, ID:102&#125; 使用这种要注意： 必须初始化结构体里所有字段 初始值填充顺序必须和字段在结构体中声明的顺序一致 不能和键值对的初始化方式混用 一点细节初始化时，如果值写成多行，则最后一个也要带上逗号 , ;如果写成一行，则最后一个可以不带逗号 , ; 也可以带上逗号。 1234567891011121314151617181920212223type Person struct &#123; name string age int sex string&#125;func main() &#123; p1 := Person&#123; &quot;Boii&quot;, 18, &quot;male&quot;, &#125; p2 := Person&#123; name: &quot;Boii&quot;, sex: &quot;male&quot;, age: 18, &#125; p3 := Person&#123; &quot;Boii&quot;, 18, &quot;male&quot; &#125; p4 := Person&#123; name: &quot;Boii&quot;, sex: &quot;male&quot;, age: 18, &#125;&#125; 方法和接收者例如下面的通式，方法名前面的接收者变量和接收者类型，就是一种限定。 123456789// 方法func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) &#123; 方法体&#125;// 对比：函数func 函数名(参数列表) (返回参数) &#123; 函数体&#125; 接收者指的就是被允许调用的调用者。注意理解：下面将以接收者代替调用者的说法。 接收者变量：命名时，官方建议使用接收者类型首个字母小写。eg：p Person、c Connector 接收者类型：接收者类型和参数相似，可以是指针类型或非指针类型 方法名、参数列表、返回参数：具体格式与函数定义相同 12345678910111213141516171819202122232425262728// Dog 结构体type Dog struct &#123; name string age int8&#125;// NewDog 构造函数func NewDog(name string, age int8) *Dog &#123; return &amp;Dog&#123;name, age&#125;&#125;// Run Dog奔跑的方法// 限定了 Dog 结构体类型才可以调用此方法func (d Dog) Run(distance int) &#123; fmt.Printf(&quot;%d 岁的狗狗 %s 跑了 %d 米\\n&quot;, d.age, d.name, distance)&#125;func main() &#123; boby := NewDog(&quot;Boby&quot;, 2) boby.Run(100) doge := Dog&#123;&quot;Doge&quot;, 3&#125; doge.Run(12)&#125;// -------------------------------------------------// Output:2 岁的狗狗 Boby 跑了 100 米3 岁的狗狗 Doge 跑了 12 米 指针类型的接收者 如果指定指针类型的接收者，在方法内修改接收者的成员变量，则结束方法后修改依然有效。 例如我们为 Dog 添加一个 setAge 方法： 12345678910func (d *Dog) SetAge(newAge int8) &#123; d.age = newAge&#125;func main() &#123; boby := NewDog(&quot;Boby&quot;, 2) fmt.Println(boby.age) // 2 boby.SetAge(10) fmt.Println(boby.age) // 10&#125; 值类型的接收者 当方法作用于值类型接收者时，Go 会在运行时将接收者的值复制一份。不过在方法内对接收者的修改只是对副本的修改，不会影响接收者。 12345678910func (d Dog) SetAge(newAge int8) &#123; d.age = newAge&#125;func main() &#123; boby := NewDog(&quot;Boby&quot;, 2) fmt.Println(boby.age) // 2 boby.SetAge(10) fmt.Println(boby.age) // 2&#125; 任意类型添加方法在 Go 中，接收者类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 12345678910type Status int // 自定义类型func (s Status) say() &#123; fmt.Println(&quot;OK&quot;)&#125;func main() &#123; var s Status s.say()&#125; 注意： 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。 内存布局在 Go 中，结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套了结构体也一样。 12345678910111213141516type person struct &#123; name string age int8&#125;type stu1 struct &#123; ID int8 info person depart string&#125;type stu2 struct &#123; ID int8 info *person depart string&#125; 匿名字段Go 中的结构体允许声明时只有类型而没有名字，这样的字段叫做匿名字段 12345678910111213type stu struct &#123; string int8&#125;func main() &#123; s1 := stu&#123; &quot;Boii&quot;, 18, &#125; fmt.Printf(&quot;%#v\\n&quot;, s1) // main.stu&#123;string:&quot;Boii&quot;, int8:18&#125; fmt.Println(s1.string, s1.int8) // Boii 18&#125; 匿名字段默认采用类型作为字段名，同一个结构体中一种类型只能有一个匿名字段。 所以上面的结构体等价于： 1234type stu struct &#123; string string int8 int8&#125; 嵌套结构体嵌套结构体，简单说就是套娃 1234567891011121314151617181920212223type person struct &#123; name string age int8&#125;// 娃娃2type stu struct &#123; ID int8 info person // 套娃娃1 depart string&#125;func main() &#123; stuA := stu&#123; ID: 101, info: person&#123; &quot;Alice&quot;, 18, &#125;, depart: &quot;CA&quot;, &#125; fmt.Printf(&quot;%#v\\n&quot;, stuA) // main.stu&#123;ID:1, info:main.person&#123;name:&quot;Boii&quot;, age:18&#125;, depart:&quot;CA&quot;&#125;&#125; 如果结构体太大，担心开销的话，可以用结构体指针 123456789101112131415161718192021222324// 娃娃1type person struct &#123; name string age int8&#125;// 娃娃2type stu2 struct &#123; ID int8 info *person // 套娃娃1的指针 depart string&#125;func main() &#123; stuB := stu2&#123; ID: 102, info: &amp;person&#123; &quot;Boii&quot;, 20, &#125;, depart: &quot;SE&quot;, &#125; fmt.Printf(&quot;%#v\\n&quot;, stuB) // main.stu2&#123;ID:1, info:(*main.person)(0xc0000044a0), depart:&quot;CA&quot;&#125;&#125; 用结构体和结构体指针的差别如下图： 显然当结构体较大的时候，使用结构体指针的操作开销会很小。 嵌套结构体的匿名字段1234567891011121314151617181920type addr struct &#123; province string city string&#125;type user struct &#123; name string age int8 addr // 匿名字段&#125;func main() &#123; var userA user userA.name = &quot;Boii&quot; userA.age = 18 userA.addr.province = &quot;GD&quot; // 匿名字段默认使用类型名作为字段名 userA.city = &quot;SWA&quot; // 匿名字段可以省略 fmt.Printf(&quot;%#v \\n&quot;, userA) // main.user&#123;name:&quot;Boii&quot;, age:18, addr:main.addr&#123;province:&quot;GD&quot;, city:&quot;SWA&quot;&#125;&#125;&#125; 嵌套结构体命名冲突当嵌套结构体出现命名冲突的时候，只要不省略，把关系链写清楚就没事了。 1234567891011121314151617181920212223242526type addr struct &#123; province string city string createTime string // 命名冲突&#125;type user struct &#123; name string age int8 addr // 匿名字段 createTime string // 命名冲突&#125;func main() &#123; var userA user userA.name = &quot;Boii&quot; userA.age = 18 userA.addr.province = &quot;GD&quot; userA.city = &quot;SWA&quot; // 命名冲突字段 userA.createTime = &quot;2020&quot; // 关系链写清楚 userA.addr.createTime = &quot;2021&quot; // 关系链写清楚 fmt.Printf(&quot;%#v \\n&quot;, userA) // main.user&#123;name:&quot;Boii&quot;, age:18, addr:main.addr&#123;province:&quot;GD&quot;, city:&quot;SWA&quot;, createTime:&quot;2021&quot;&#125;, createTime:&quot;2020&quot;&#125;&#125; 结构体的继承在面向对象中，继承指的是子类可以拥有父类所有非私有属性和方法。 Go 中使用结构体嵌套也可以实现其他编程语言中面向对象的继承。方法是通过在 “子结构体” 中嵌套 “父结构体” ，这样 “子结构体” 就拥有 “父结构体” 的属性了 结合上面 “嵌套结构体的匿名字段” 中的例子，无命名冲突时，可以通过 子结构体实例.父结构体属性调用的特性，可以很容易的编写出适合 “子结构体” 的方法。 12345678910111213141516171819202122232425// animal 动物type animal struct &#123; name string&#125;// dog 狗type dog struct &#123; variety string *animal // 子结构体嵌套父结构体实现继承，必须使用匿名字段&#125;func (d *dog) bark() &#123; // dog 没有 name 属性，但是内嵌的 animal 有 fmt.Printf(&quot;%s 正在汪汪汪~&quot;, d.name)&#125;func main() &#123; doge := &amp;dog&#123; variety: &quot;Doge&quot;, animal: &amp;animal&#123; // 注意嵌套的是结构体指针 name: &quot;Boby&quot;, &#125;, &#125; doge.bark() // Boby 正在汪汪汪~&#125; 结构体标签 TagTag 是结构体的元信息，可以在运行的时候通过反射机制读取。所以只有首字母大写的可被导出的变量能被反射读取，转成JSON。Tag 在结构体字段的后方定义，由一对反引号包起来。 eg： 123type person struct &#123; Name string `json:&quot;name&quot;`&#125; 一个 Tag 由一个或多个键值对组成。 键值对之间使用空格分隔 键与值之间使用冒号分隔，不能有空格 值使用双引号括起来。 值为 - 时该字段不会被序列化 编写 Tag 时必须严格遵守键值对的规则。结构体标签的解析容错能力很差，写错了编译期和运行期都不会提示任何错误，反射也无法正确取值。 结构体序列化序列化（struct -&gt; JSON）：结构体对象 转成 JSON格式字符串反序列化（JSON -&gt; struct）：JSON格式字符串 转成 结构体对象 使用 encoding/json 完成。 1import &quot;encoding/json&quot; 1234// 序列化函数，struct -&gt; JSONfunc Marshal(v interface&#123;&#125;) ([]byte, error) &#123;&#125;// 反序列化函数，JSON -&gt; structfunc Unmarshal(data []byte, v interface&#123;&#125;) error &#123;&#125; eg： 1234567891011121314151617181920212223242526272829303132333435package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot;)// 1. 序列化 encode：把结构体变量 -&gt; json格式的字符串// 2. 反序列化 decode：json格式的字符串 -&gt; 结构体变量type person struct &#123; Name string `json:&quot;name&quot; db:&quot;name&quot; ini:&quot;name&quot;` Age int `json:&quot;age&quot;` Sex string Addr string `json:&quot;-&quot;` // value 为 &quot;-&quot; 时不序列化&#125;func main() &#123; p1 := person&#123;&quot;Boii&quot;, 18, &quot;male&quot;&#125; /* 序列化 */ b, err := json.Marshal(p1) if err != nil &#123; fmt.Println(err) &#125; fmt.Println(string(b)) // &#123;&quot;name&quot;:&quot;Boii&quot;,&quot;age&quot;:18,&quot;Sex&quot;:&quot;male&quot;&#125; fmt.Printf(&quot;%T \\n&quot;, b) // []uint8 /* 反序列化 */ str := `&#123;&quot;name&quot;:&quot;Eva&quot;,&quot;age&quot;:18&#125;` var p2 person json.Unmarshal([]byte(str), &amp;p2) fmt.Printf(&quot;%#v \\n&quot;, p2) // main.person&#123;Name:&quot;Eva&quot;, Age:18, Sex:&quot;&quot;&#125; fmt.Printf(&quot;%T \\n&quot;, p2) // main.person&#125; 序列化时，key 会优先选择字段的 Tag 中指定的 key 结构体中非 public 的字段不会被序列化 结构体的深浅拷贝深拷贝：即为新的对象分配了内存，对新对象的修改不会影响旧对象浅拷贝：即复制了旧对象的地址，对新对象的修改会影响旧对象值类型都是深拷贝引用类型都是浅拷贝 看懂以上两句话，结构体的深浅拷贝就很容易实现了 123456789101112131415161718192021222324252627package mainimport &quot;fmt&quot;type Person struct &#123; name string age int&#125;func main() &#123; // 结构体的深拷贝 person1 := Person&#123;&quot;Boii&quot;, 18&#125; person2 := person1 // 深拷贝 fmt.Println(person1) // &#123;Boii 18&#125; fmt.Println(person2) // &#123;Boii 18&#125; person2.age = 20 fmt.Println(person1) // &#123;Boii 18&#125; fmt.Println(person2) // &#123;Boii 20&#125; // 结构体的浅拷贝 person3 := &amp;person1 // 浅拷贝 person3.age = 20 fmt.Println(person1) // &#123;Boii 20&#125; fmt.Println(person3) // &amp;&#123;Boii 20&#125;&#125; 结构体是值类型，直接赋值的时候是深拷贝，赋值一个指针则是浅拷贝","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [基础] 9-指针","slug":"Go/Basic/Golang-9-指针","date":"2021-07-17T03:28:14.000Z","updated":"2021-07-17T03:28:14.000Z","comments":true,"path":"posts/237b56c2.html","link":"","permalink":"https://www.boii.xyz/posts/237b56c2.html","excerpt":"指针的创建与使用","text":"指针的创建与使用 9-指针区别于C/C++中的指针，Go中的指针不能进行偏移和运算，是安全指针， 任何程序数据载入内存后，在内存都有他们的地址，这就是指针。为了保存一个数据在内存中的地址，我们就需要指针。 Go 中的指针操作非常简单：&amp;取地址符、*根据地址取值。 定义指针、指针取地址注意：指针是值类型！！！ 123var identifier *Tvar identifier *T = &amp;variableidentifier := &amp;variable identifier：指针名、T指针基类型、*T某类型指针、variable：变量、&amp;variable：取变量地址 Go 中的值类型（int、float、bool、string、数组、struct结构体）都有对应类型指针，如 *int、*float、*string、*bool、*[5]int。 12345678910func main() &#123; i := 1 var p *int = &amp;i fmt.Printf(&quot;i: %d \\n&quot;, i) // i: 1 fmt.Printf(&quot;iaddr: %p \\n&quot;, &amp;i) // addr: 0xc000012090 fmt.Printf(&quot;p: %p \\n&quot;, p) // p: 0xc000012090 fmt.Printf(&quot;paddr: %p \\n&quot;, &amp;p) // addr: 0xc000006028 fmt.Printf(&quot;pint Type: %T \\n&quot;, p) // pint Type: *int&#125; 指针取值定义指针之后，就可以对指针进行操作了。指针的操作有两种：&amp;取地址、*根据地址取值 1234567891011121314151617func main() &#123; // 指针取值 a := 10 b := &amp;a fmt.Println(b) // b 中保存着 a 的地址 fmt.Println(&amp;a) // 取 a 的地址 fmt.Println(a) // a 的值 fmt.Println(*b) // 取 b&#125;// ------------------------------------// Output:0xc0000120900xc0000120901010 取地址操作符&amp;和取值操作符*是一对互补操作符，&amp;取出地址，*根据地址取出地址指向的值。 变量、指针地址、指针变量、取地址、取值的相互关系和特性如下： 对变量进行取地址（&amp;）操作，可以获得这个变量的指针变量。 指针变量的值是指针地址。 对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。 结构体指针结构体指针访问结构体字段 同 结构体变量访问结构体字段一样，使用 . 点操作符，Go 没有 -&gt; 操作符。 eg: 12345678910111213type User struct &#123; // 定义结构体 name string age int&#125;Boii := User &#123; // 定义结构体变量 name: &quot;Boii&quot;, age: 18&#125;p := &amp;Boii // 定义结构体指针fmt.Println(p.name) // 用 . 点操作符访问成员 Boii 指针做形参1234567891011121314151617func fn1(x int) &#123; x = 100&#125;func fn2(x *int) &#123; *x = 100&#125;func main() &#123; var a int = 10 fn1(a) fmt.Println(a) // 10 var b *int = &amp;a fn2(b) fmt.Println(a) // 100&#125; 指针做返回值Go 允许使用“栈逃逸”机制将局部变量的空间分配在堆上。使用这种机制，需要返回指针 eg： 12345678910func add(a, b int) *int &#123; sum := a + b return &amp;sum&#125;func main() &#123; psum := add(10, 20) fmt.Println(psum) // 0xc000012090 fmt.Println(*psum) // 30&#125; new 和 makenewnew 是一个内置函数，它的函数签名如下： 1func new(Type) *Type Type 表示类型，new函数只接收一个参数，这个参数只能是类型*Type 表示类型指针，new 函数返回一个指向该类型内存地址的指针 new函数可以接受所有类型，使用new函数可以得到类型的指针，并且这个指针指向的内存地址中存着该类型的零值。 123456789101112131415func main() &#123; a := new(int) b := new([5]int) c := new([]string) d := new(map[int]string) fmt.Printf(&quot;a type: %T \\n&quot;, a) // a type: *int fmt.Printf(&quot;b type: %T \\n&quot;, b) // b type: *[5]int fmt.Printf(&quot;c type: %T \\n&quot;, c) // c type: *[]string fmt.Printf(&quot;d type: %T \\n&quot;, d) // d type: *map[int]string fmt.Println(*a) // 0 fmt.Println(*b) // [0 0 0 0 0] fmt.Println(*c) // [] fmt.Println(*d) // map[]&#125; new 函数会开辟一块空间，然后把这块空间的地址返回出去，这样外面的指针变量（a、b、c、d）就可以操作了。如果仅仅只是声明一个指针变量，而没有开辟内存空间，这个指针变量是无法使用的。 以下为错误示例： 12345678910111213141516func main() &#123; var i *int fmt.Println(i) *i = 10 // 这里会引发 panic&#125;// ------------------------------------// Output:&lt;nil&gt;panic: runtime error: invalid memory address or nil pointer dereference[signal 0xc0000005 code=0x1 addr=0x0 pc=0x97581b]goroutine 1 [running]:main.main() e:/---CODE/GO/src/Hello/main.go:23 +0x7bexit status 2 从上面例子可以看到，声明了一个指针，默认值为 nil。在没有分配内存的情况下去使用指针，会导致 panic。 以下为正确示例： 12345678func main() &#123; var i *int // 声明一个指针变量 fmt.Println(i) // &lt;nil&gt; | 默认值为 nil i = new(int) // 给这个指针分配内存 *i = 10 // 存个值进去 fmt.Println(i) // 0xc000012098 | 已经有内存空间了 fmt.Println(*i) // 10 | 正常~~&#125; makemake 也是用于分配内存，但是只能用于slice切片、map字典、chan通道的内存创建，而且它返回的类型 就是这三个类型本身，因为这三种类型就是引用类型，所以没必要返回他们的指针了。 make 的函数签名如下： 1func make(t Type, size ...IntegerType) Type 在使用 slice、map、chan的时候，都需要使用 make 进行初始化，然后才可以对它们进行操作 1234567891011func main() &#123; c := new([]string) s := make([]string, 10) d := new(map[int]string) e := make(map[int]string) fmt.Printf(&quot;c type: %T \\n&quot;, c) // c type: *[]string | string切片类型的指针 fmt.Printf(&quot;s type: %T \\n&quot;, s) // s type: []string | string切片 fmt.Printf(&quot;d type: %T \\n&quot;, d) // d type: *map[int]string | map类型的指针 fmt.Printf(&quot;e type: %T \\n&quot;, e) // e type: map[int]string | map&#125; new 和 make 的区别 new 返回的是指针，make返回的是类型本身 new 可以给所有类型的指针开辟空间，make 只能用于 slice、map、chan的初始化","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [基础] 8-函数","slug":"Go/Basic/Golang-8-函数","date":"2021-07-17T03:23:40.000Z","updated":"2021-07-17T03:23:40.000Z","comments":true,"path":"posts/ce0db2d0.html","link":"","permalink":"https://www.boii.xyz/posts/ce0db2d0.html","excerpt":"函数的创建与使用","text":"函数的创建与使用 8-函数如果一个动作需要重复执行，那就应该把这个动作封装到函数中。 在 Go 中，函数是一等公民 定义注意：函数是引用类型！！！ Go 语言中函数的基本形式： 123func 函数名(参数列表)(返回值)&#123; 函数体&#125; 函数名：由字母、数字、下划线组成，但不能数字开头；同一个包内，函数名不能重名 参数：由参数变量和变量类型组成，多个参数使用, 分隔 返回值：由返回变量和变量类型，也可只写变量类型，多个返回值必须用()包裹，并用,分隔 函数体：实现指定功能的代码 eg：求两数之和 123func sum(a int, b int) int &#123; return a + b&#125; eg：无参数无返回值的函数 123func sayHello() &#123; fmt.Println(&quot;Hello&quot;)&#125; 调用通过函数名(参数)的方式调用，如果定义的函数没有要求参数，则调用时不需要给参数 eg： 1234func main() &#123; res := sum(1, 3) fmt.Println(res)&#125; 调用有返回值的函数时可以不接受其返回值。 参数类型简写如果相邻变量类型相同，可以只写一个 eg： 123func fn(x, y int, p, q string) &#123; fmt.Println(x, y, p, q)&#125; x 和 y 均为 int 型，x 后面就可省略；p 和 q 都是 string 型，p 后面就可以省略 可变参数如果参数数量不固定，可以在类型前面加上...，但是只能接收这种类型的参数，且此时要注意类型简写的方法注意：和固定参数搭配时，可变参数要放在固定参数后面 123456789func fn(x int, y ...int) &#123; fmt.Println(x) // 1 fmt.Println(y) // [2 3 5] fmt.Printf(&quot;%T \\n&quot;, y) // []int&#125;fn(1, 2, 3, 5)// 错误，只能传递int型：fn(1, 2, &quot;B&quot;, &quot;C&quot;)// 错误，全都要int型： fn(1, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;) 可变参数实际上是通过切片实现的 关于类型简写： 1234567// 错误func fn(x, y ...int) &#123;&#125;// 正确func fn(x ...int) &#123;&#125;func fn(x int, y ...int) &#123;&#125;func fn(x, z int, y ...int) &#123;&#125; 关于可变参数位置 123456// 错误func fn(y ...int, x int) &#123;&#125;func fn(x int, y ...int, s string) &#123;&#125;// 正确func fn(x int, y ...int) &#123;&#125; 返回值多返回值Go 中支持多返回值，如果有多个返回值时，必须用()包裹起来 eg： 123func calc(x, y int) (int, int) &#123; return x + y, x - y&#125; 调用之后可以接收返回值，也可以不接收，如果指向接收一个，另一个可以用匿名变量 _ 去接 123456789// 两个都接收sum, sub := calc(10, 5)// 两个都不接收calc(10, 5)// 只接收一个_, sub := calc(10, 5)sum, _ := calc(10, 5) 返回值命名函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过return 返回 12345func calc(x, y int) (sum, sub int)&#123; sum = x + y sub = x - y return&#125; 如果给返回值命名了，但是又 return 了别的变量，以别的变量为准 123456789func calc(x, y int) (sum int, diff int) &#123; sum = x + y diff = x - y mul := x * y div := x / y return mul, div&#125;fmt.Println(calc(10, 5)) // 50 2 函数进阶变量作用域函数类型函数可以有类型，使用关键字type可以定义一个函数类型 eg： 1type calculation func(int, int) int 上面的例子定义了一个 calculation 类型，它是一种函数类型，一种接收两个int参数返回一个int值的函数类型。方式满足上面特点的函数都是 calculation 类型。 eg： 1234567func add(x int, y int) int &#123; return x + y&#125;func sub(x, y int) int &#123; return x - y&#125; add() 和 sub() 都是 calculation 类型，都可以赋值给 calculation 类型变量 12345678var c calculationc = addres := c(10, 5)fmt.Println(res) // 15s := subfmt.Println(s(20, 55)) // -35 函数变量在 Go 中，函数被看作是第一类值，这意味着函数像变量一样，有类型、有值，普通变量能做的事函数也能做。 例如函数类型的例子，即使不定义函数类型，也可以直接将函数赋值给变量 12345678func add(x, y int) int &#123; return x + y&#125;func main() &#123; a := add fmt.Println(a(10, 20)) // 30&#125; 调用 nil 的函数变量会导致 panic 函数变量的零值 nil，所以函数变量可以跟 nil 比较，但函数变量之间不能比较。 12345678910111213141516171819202122232425262728293031323334package mainimport &quot;fmt&quot;type processFunc func(int) bool // 声明一个函数类型func isOdd(i int) bool &#123; // 定义这种类型的函数 return i%2 != 0&#125;func isEven(i int) bool &#123; // 定义这种类型的函数 return i%2 == 0&#125;func filter(slice []int, f processFunc) []int &#123; // 接收这种类型的函数 var res []int for _, v := range slice &#123; if f(v) &#123; res = append(res, v) &#125; &#125; return res&#125;func main() &#123; s := []int&#123;1, 2, 3, 4, 5, 7&#125; fmt.Println(&quot;s = &quot;, s) // s = [1 2 3 4 5 7] odd := filter(s, isOdd) // 调用这种类型的函数 even := filter(s, isEven) // 调用这种类型的函数 fmt.Println(&quot;Odd slice&quot;, odd) // Odd slice [1 3 5 7] fmt.Println(&quot;Even slice&quot;, even) // Even slice [2 4]&#125; 匿名函数没有名字的函数就叫匿名函数基本语法： 123func (函数) (返回值) &#123; 函数体&#125; 匿名函数没有函数名，所以需要变量来保存，或者作为立即执行函数 1234567func main() &#123; // 将匿名函数保存到变量 add := func (x, y int) int &#123; return x + y &#125; add(10, 20) // 通过变量调用匿名函数&#125; 123456func main() &#123; // 自执行函数：匿名函数定义完加()直接执行 func (x, y int) &#123; fmt.Println(x + y) &#125;(10, 20)&#125; 高阶函数高阶函数分为 函数作参数 和 函数作返回值 函数作为参数1234567891011121314151617181920212223// 定义一个函数，使用函数作为参数// @param x int 操作数1// @param y int 操作数2// @param operate func(int, int) int 操作函数// @return int 经过操作函数操作的结果func calc (x int, y int, operate func(int, int) int) int &#123; return operate(x, y)&#125;// 定义一个操作函数// @param x 操作数1// @param y 操作数2// @return 两个操作数相加的结果func add(x, y int) int &#123; return x + y&#125;func main() &#123; // 调用 calc 函数，把 add 函数传进去 res := calc(10, 20, add) fmt.Println(res) // 30&#125; 函数作为返回值12345678910111213141516171819202122232425262728func add(x, y int) int &#123; return x + y&#125;func sub(x, y int) int &#123; return x - y&#125;// 定义一个函数，根据传入的操作符返回相应的操作函数// @param s string 操作符// @return func(int, int) int, error 操作函数func do(s string) (func(int, int) int, error) &#123; switch s &#123; case &quot;+&quot;: return add, nil case &quot;-&quot;: return sub, nil default: return nil, errors.New(&quot;非法操作符&quot;) &#125;&#125;func main() &#123; fn, err := do(&quot;+&quot;) if err == nil &#123; fmt.Println(fn(10, 20)) // 20 &#125;&#125; 闭包 a closure is a record storing a function together with an environment.闭包是由函数和与其相关的引用环境组合而成的实体 。 闭包能将局部变量带出其作用域 1234567891011121314func adder() func() int &#123; var x int return func() int &#123; x++ return x &#125;&#125;func main() &#123; i := adder() fmt.Println(i()) // 1 fmt.Println(i()) // 2 fmt.Println(i()) // 3&#125; 相当于： 123456789101112131415func adder() func() int &#123; var x int f := func() int &#123; x++ return x &#125; return f&#125;func main() &#123; i := adder() i() // 1 i() // 2 i() // 3&#125; 等于说，在 adder() 中声明的变量x，本该在adder()调用完就被销毁，却被闭包带出了x的作用域（adder函数内），使得局部变量x没有被销毁。即局部变量x逃逸了，它的生命周期没有随着它的作用域结束而结束。 defer 语句defer 就是延迟的意思，被 defer 关键字修饰的函数或方法会延迟执行。 1234567891011func main() &#123; fmt.Println(&quot;start&quot;) defer fmt.Println(1) fmt.Println(&quot;end&quot;)&#125;// ---------------------// Output:startend1 程序先执行第一句打印了 start，往下遇到 defer，于是把第二句先压入栈，然后继续执行第三句打印了 end。再继续往下已经没有，函数准备结束；但是在结束之前需先出栈，也就执行了第二句，打印了 1。最后结束。 这就是 defer 语句。 由于 defer 语句延迟调用的特性，所以 defer 语句能非常方便的处理资源释放的问题。比如：关闭文件、关闭数据库连接、资源清理、释放锁、记录时间等等。eg ：123456789func fn() &#123; f, err := os.Open(&quot;./main.go&quot;) // 打开文件 defer f.Close() // 函数退出之前关闭文件 if err != nil &#123; fmr.Println(err) return &#125;&#125; 多个 defer 的执行顺序当有多个 defer时，按照栈的方式执行。即先defer的后执行。eg： 1234567891011121314func fn() &#123; fmt.Println(&quot;start&quot;) defer fmt.Println(1) defer fmt.Println(2) defer fmt.Println(3) fmt.Println(&quot;end&quot;)&#125;// ---------------------// Output:startend321 defer 执行时机Go 中的 return语句并不是原子操作，它分为 给返回值赋值 和 RET指令两步。而 defer 语句执行的时机在返回值赋值之后，RET指令执行之前。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [基础] 7-map","slug":"Go/Basic/Golang-7-map","date":"2021-07-17T03:19:18.000Z","updated":"2021-07-17T03:19:18.000Z","comments":true,"path":"posts/d554428f.html","link":"","permalink":"https://www.boii.xyz/posts/d554428f.html","excerpt":"键值对的创建与使用","text":"键值对的创建与使用 7-map map 是 Go 提供的一种映射关系容器，其内部使用散列表(hash)实现map 是一种无序的基于 key-value 的数据结构Go 中的 map 是引用类型，必须初始化才能使用。 key 可以是任意可用 == 或 != 比较的类型，如：string、int、float 数组、切片不能作为 key 指针和接口类型可以作为 key 包含数组切片的结构体不能作为 key，只包含原生类型的结构体可以作为 key 如果结构体要作为 key 可以提供 Key() 和 Hash() 方法 value 可以是任意类型 通过 key 在map 中查找是很快的，但是还是比数组和切片慢100倍。如果性能很重要的话还是用切片来解决问题。 map可以用函数作为值，这样就可以用来做分支结构：用key来选择要执行的函数。 声明注意：map 是引用类型！！！ 定义语法如下 12345var map1 map[keyT]valueT// 示例var map1 map[string]intvar map2 map[int]rune 声明时不需要直到map长度，map是可以动态增长的未初始化的map的值是 nil，需要使用 make() 函数来分配内存 1make(map[keyT]valueT, cap) cap 是可选的，但是我们应该再初始化map的时候就为其指定一个合适的容量。 eg： 123456789func main() &#123; var m1 map[int]string m2 := make(map[int]string) fmt.Println(m1) // map[] fmt.Println(m2) // map[] fmt.Printf(&quot;%T \\n&quot;, m1) // map[int]string fmt.Printf(&quot;%T \\n&quot;, m2) // map[int]string&#125; 声明并初始化12345678910func main() &#123; m1 := map[int]string&#123; 1: &quot;Alice&quot;, 2: &quot;Boii&quot;, 3: &quot;Candy&quot;, 4: &quot;Danish&quot;, &#125; fmt.Println(m1) // map[1:Alice 2:Boii 3:Candy 4:Danish] fmt.Printf(&quot;%T \\n&quot;, m1) // map[int]string&#125; 注意：这种方式，每一对 k-v后面都要有,，最后一对也要有 单独赋值123456789func main() &#123; m1 := make(map[int]string) m1[1] = &quot;Alice&quot; m1[2] = &quot;Boii&quot; m1[5] = &quot;Eva&quot; fmt.Println(m1) // map[1:Alice 2:Boii 5:Eva]&#125; 判断键是否存在Go 中有个判断 map 中键是否存在的特殊写法，基本格式为： 1val, ok := map[key] eg： 123456789101112131415161718func main() &#123; m1 := map[byte]string&#123; &#x27;a&#x27;: &quot;Alice&quot;, &#x27;b&#x27;: &quot;Boii&quot;, &#x27;c&#x27;: &quot;Candy&quot;, &#x27;d&#x27;: &quot;Danish&quot;, &#125; val, ok := m1[&#x27;a&#x27;] fmt.Println(val) // Alice fmt.Println(ok) // true if val, ok := m1[&#x27;b&#x27;]; ok &#123; fmt.Println(&quot;I got&quot;, val) &#125; else &#123; fmt.Println(&quot;None.&quot;) &#125;&#125; 遍历可以使用 for...range 遍历 123456789101112func main() &#123; m1 := map[byte]string&#123; &#x27;a&#x27;: &quot;Alice&quot;, &#x27;b&#x27;: &quot;Boii&quot;, &#x27;c&#x27;: &quot;Candy&quot;, &#x27;d&#x27;: &quot;Danish&quot;, &#125; for k, v := range m1 &#123; fmt.Println(k, v) &#125;&#125; 只想遍历 key 的时候可以 123for k := range m1 &#123; fmt.Println(k)&#125; 只想遍历 value 的时候可以 123for _, v := range m1 &#123; fmt.Println(v)&#125; 注意： 遍历 map 时元素顺序与添加键值对顺序无关。 delete()Go 的内建函数 delete() 可以从 map 中删除一对键值对，格式如下： 1delete(map, key) eg： 12345678910func main() &#123; m1 := map[int]byte&#123; 1: &#x27;A&#x27;, 2: &#x27;B&#x27;, 3: &#x27;C&#x27;, &#125; fmt.Println(m1) // map[1:65 2:66 3:67] delete(m1, 2) fmt.Println(m1) // map[1:65 3:67]&#125; 值为切片的mapmap 中 value 可以是任何类型，所以也可以是切片类型 12345var sm map[keyT][]Tsm := make(map[keyT][]T, cap)sm := map[keyT][]T&#123;initial value&#125; []T：某种类型的切片 eg： 1234567891011121314151617181920212223242526272829303132333435363738394041func main() &#123; // 创建一个map, key 为 string, value 为 []int，容量为5 sliceMap1 := make(map[string][]int, 5) // var sliceMap1 map[string][]int 用这种声明方式也行 // 为 map 中每一对 k-v 初始化 sliceMap1[&quot;A&quot;] = make([]int, 3, 3) sliceMap1[&quot;B&quot;] = make([]int, 3, 3) sliceMap1[&quot;C&quot;] = make([]int, 3, 3) sliceMap1[&quot;D&quot;] = make([]int, 3, 3) sliceMap1[&quot;E&quot;] = make([]int, 3, 3) fmt.Println(&quot;1: &quot;,sliceMap1) // 1: map[A:[0 0 0] B:[0 0 0] C:[0 0 0] D:[0 0 0] E:[0 0 0]] for k, v := range sliceMap1 &#123; fmt.Println(k, v) &#125; // A [0 0 0] // B [0 0 0] // C [0 0 0] // D [0 0 0] // E [0 0 0] // 用这种方式初始化效果一样 sliceMap2 := map[string][]int&#123; &quot;A&quot;: &#123;1, 2, 3&#125;, &quot;B&quot;: make([]int, 3), &quot;C&quot;: &#123;2, 4, 0, 9&#125;, &quot;D&quot;: make([]int, 3), &quot;E&quot;: make([]int, 3), &#125; fmt.Println(&quot;2: &quot;,sliceMap2) // 2: map[A:[1 2 3] B:[0 0 0] C:[2 4 0 9] D:[0 0 0] E:[0 0 0]] for k, v := range sliceMap2 &#123; fmt.Println(k, v) &#125; // A [1 2 3] // B [0 0 0] // C [2 4 0 9] // D [0 0 0] // E [0 0 0]&#125; 值为map的切片看起来好像有点绕，但是捋清楚就好办了map[keyT]valT是map类型，[]T是切片类型，那么[]map[keyT]valT就是map类型切片了 1234567891011121314151617181920212223242526// 类型定义[]map[keyT]valT// 声明var identifier []map[keyT]valT// 声明并初始化var identifier = []map[keyT]valT&#123; &#123;map1key1: val, map1key2: val, map1key3: val&#125;, &#123;map2key1: val, map2key2: val, map2key3: val&#125;, &#123;map3key1: val, map3key2: val, map3key3: val&#125;,&#125;// 声明并初始化identifier := []map[keyT]valT&#123; &#123;map1key1: val, map1key2: val, map1key3: val&#125;, &#123;map2key1: val, map2key2: val, map2key3: val&#125;, &#123;map3key1: val, map3key2: val, map3key3: val&#125;,&#125;// 使用makeidentifier := make([]map[keyT]valT, cap)identifier[skey] = make(map[keyT]valT)identifier[skey][mkey] = validentifier[skey] = map[keyT]valT&#123;mkey1: val, mkey2: val&#125; eg： 1var ms []map[int]string 12345678910111213141516func main() &#123; // 声明一个切片，map[int]string 类型的，并初始化 ms := []map[int]string&#123; &#123;1: &quot;A&quot;, 2: &quot;B&quot;, 3: &quot;C&quot;&#125;, &#123;4: &quot;I&quot;, 6: &quot;N&quot;, 9: &quot;G&quot;&#125;, &#123;3: &quot;R&quot;, 7: &quot;Y&quot;, 5: &quot;Q&quot;&#125;, make(map[int]string), &#125; for _, v := range ms &#123; fmt.Println(v) &#125; // map[1:A 2:B 3:C] // map[4:I 6:N 9:G] // map[3:R 5:Q 7:Y] // map[]&#125; 12345678910111213141516171819func main() &#123; // make 一个切片，类型为 map[int]string, 长度和容量都为 3 mapSlice := make([]map[int]string, 3) // 为切片第一个元素创建一个 map，然后为其逐个添加 k-v mapSlice[0] = make(map[int]string) mapSlice[0][1] = &quot;A&quot; mapSlice[0][2] = &quot;B&quot; mapSlice[0][3] = &quot;C&quot; // 为切片第二个元素 创建并初始化一个 map mapSlice[1] = map[int]string&#123;4: &quot;I&quot;, 6: &quot;N&quot;, 9: &quot;G&quot;&#125; for _, v := range mapSlice &#123; fmt.Println(v) &#125; // map[1:A 2:B 3:C] // map[4:I 6:N 9:G] // map[]&#125; 注意Go 内置的 map 不是并发安全的，并发安全的 map 可以使用标准包 sync 中的 map不要直接修改 map value 中某个成员的值。如果想修改 map value 中的某个成员的值，必须整体赋值。eg：123456789101112131415type User struct &#123; name string age int&#125;func main() &#123; ma := make(map[rune]User) boii := User&#123;&quot;Boii&quot;, 18&#125; ma[&#x27;a&#x27;] = boii // ma[&#x27;a&#x27;].age = 19 // ERROR，不能通过 map 引用直接修改 boii.age = 19 ma[&#x27;a&#x27;] = boii // 必须整体替换&#125; 练习 写一个程序，统计一个字符串中每个单词出现的次数。比如：”how do you do” 中 how=1 do=2 you=1。 思路：先用 strings.Split 把单词切割出来然后利用 map ，把单词作为 key，出现频次作为 value，遍历一下就能得到答案 1234567891011121314151617181920package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() &#123; str := &quot;how do you do I do not know how to tell you&quot; strSplit := strings.Split(str, &quot; &quot;) strMap := make(map[string]int) for _, word := range strSplit &#123; strMap[word] += 1 &#125; fmt.Println(strMap)&#125;// -----------------------------------------// Output:map[I:1 do:3 how:2 know:1 not:1 tell:1 to:1 you:2]","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [基础] 6-slice","slug":"Go/Basic/Golang-6-slice","date":"2021-07-17T03:16:55.000Z","updated":"2021-07-17T03:16:55.000Z","comments":true,"path":"posts/6642a673.html","link":"","permalink":"https://www.boii.xyz/posts/6642a673.html","excerpt":"面试高频考点：切片","text":"面试高频考点：切片 6-切片 切片是一个拥有相同数据类型元素的可变长度的序列。 数组是固定长度，切片是可变长度数组是值类型，切片是引用类型 数组有很多局限性，切片非常灵活，支持自动扩容 切片内部结构包含 地址、长度、容量，一般用于快速操作一块数据集合。 创建切片注意：切片是引用类型！！！ 12345678// 切片var identifier []typevar identifier = []type&#123;initial value&#125;identifier := []type&#123;initial value&#125;// 数组var identifier [len]typevar identifier = [...]type&#123;initial value&#125; identifier：切片名、type：切片数据类型 ::: alert-info区别于数组，切片在定义时不用填写 len。它和初始化数组时省略 len 不同，数组省略 len 时要写 ...，切片啥也不用写。::: 12345678func main() &#123; var a []string // 声明一个字符串切片 var b = []int&#123;1, 2, 3, 4, 5&#125; // 声明一个整型切片,并初始化 c := []bool&#123;false, true&#125; // 声明一个布尔型切片,并初始化 fmt.Println(a) // [] fmt.Println(b) // [1 2 3 4 5] fmt.Println(c) // [false, true]&#125; Slice 的创建方式有三种： 通过下标的方式获得数组或切片的一部分 使用字面量初始化新的切片 使用关键字 make 创建切片 12345arr := [8]int&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;s1 := arr[2:6] // 1. 通过下标基于数组或切片创建s2 := []int&#123;11, 22, 33&#125; // 2. 通过字面量创建s3 := make([]int, 10, 20) // 3. 通过关键字 make 创建 基于数组创建切片底层是数组，当底层数组不够的时候，切片就会扩容。 上面的定义是创建一个匿名数组，让切片指向这个匿名数组，下面是基于数组定义切片 1identifier := array[start_with:end:max] 123456789101112func main() &#123; // 基于数组定义切片 arr := [8]int&#123;55, 56, 57, 58, 59, 60, 61, 62&#125; b := arr[1:5] // 其范围用数学表示为：[1,5) 从arr[1]取到arr[4]不包含arr[5] fmt.Println(b) // [55 56 57 58 59] fmt.Printf(&quot;%T \\n&quot;, b) // []int // 切片再次切片 c := b[0:len(b)] // len(b)为5，所以取了b[0]、b[1]、b[2]、b[3]、b[4]，相当于复制一整个切片 fmt.Println(c) // [55 56 57 58 59] fmt.Printf(&quot;%T \\n&quot;, c) // []int&#125; 直接定义切片和指定数组定义切片的区别在于： 直接定义切片会引用一个匿名数组，指定数组定义切片会引用指定数组 直接定义切片长度=容量，指定数组定义切片长度和容量视具体情况 直接定义切片 ↓ 指定数组定义切片 ↓ 容量指的是从接片第一个元素到底层数组的最后一个元素例如上面第三张图中：12345arr := [8]int&#123;55, 56, 57, 58, 59, 60, 61, 62&#125;c := arr[3:6]len(c) // 3cap(c) // 5 使用make()创建如果需要动态的创建一个切片，可以使用内置的make()函数基本语法为： 1234make([]type, len, cap)var identifier []type = make([]type, len, cap)identifier := make([]type, len, cap) type：切片数据类型、len：长度、cap：容量cap 可以不填，默认和 len 相同 12345678910func main() &#123; // make函数构造切片 // make([]type, len, cap) d := make([]int, 4, 10) // 构造一个整型切片，填充5个元素，最大容量10 fmt.Println(d) // [0 0 0 0] fmt.Printf(&quot;%T \\n&quot;, d) // []int fmt.Println(len(d)) // 4 fmt.Println(cap(d)) // 10&#125; 动态就动态在于它能使用变量哈哈哈 123func fn(a int, b int) []int &#123; return make([]int, a, b)&#125; 切片是引用类型判空检查切片是否为空，不能用 s == nil，而是应该使用 len(s) == 0 切片是一种引用类型，当它被声明的时候，没有指向任何数组，包括匿名数组也没有，此时切片中指针为 nil 1var s []int // s == nil 当切片被初始化的时候，它就指向了一个数组，这时切片中的指针不为 nil。 1var s = []int&#123;&#125; // s != nil 切片不能直接比较切片是一种引用类型，我们不能用 == 操作符来判断两个切片是否含有全部相等元素。切片唯一合法的比较操作是和 nil 比较。 一个nil值的切片并没有底层数组，一个nil值的切片的长度和容量都是0。 但是我们不能说一个长度和容量都是0的切片一定是nil 123var s1 []int //len(s1)=0; cap(s1)=0; s1==nils2 := []int&#123;&#125; //len(s2)=0; cap(s2)=0; s2!=nils3 := make([]int, 0) //len(s3)=0; cap(s3)=0; s3!=nil 所以要判断一个切片是否是空的，要是用len(s) == 0来判断，不应该使用s == nil来判断。 切片的拷贝赋值下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。 1234567func main() &#123; s1 := make([]int, 3) //[0 0 0] s2 := s1 //将s1直接赋值给s2，s1和s2共用一个底层数组 s2[0] = 100 fmt.Println(s1) //[100 0 0] fmt.Println(s2) //[100 0 0]&#125; 切片遍历切片的遍历方式和数组是一致的，支持索引遍历和for range遍历。 1234567891011func main() &#123; s := []int&#123;1, 3, 5&#125; for i := 0; i &lt; len(s); i++ &#123; fmt.Println(i, s[i]) &#125; for index, value := range s &#123; fmt.Println(index, value) &#125;&#125; append()Go 中的内建函数 append() 可以为切片动态添加元素，可以一次添加一个或多个元素。 1append(slice, elem_arr_or_slice) eg： 12345func main() &#123; s := []int&#123;1, 2, 3, 4, 5&#125; // [1 2 3 4 5] s = append(s, 11) // [1 2 3 4 5 11] s = append(s, 12, 13, 14) // [1 2 3 4 5 11 12 13 14]&#125; append() 第二个参数也可以是另一个切片，不过记得加上 ... 1234func main() &#123; s2 := []int&#123;55, 56, 57&#125; s = append(s, s2...)&#125; 注意： 通过var声明的零值切片可以在 append() 函数直接使用，无需初始化。 12345678910// 正确var s []ints = append(s, 1, 2, 3)// X 没必要var s = []int&#123;&#125;s = append(s, 1, 2, 3)// X 没必要var s = make([]int)s = append(s, 1, 2, 3) copy()切片是引用类型，如果直接 s1 = s2 ，其实是将 s2 中的数组地址赋值给 s1 的指针，s1 修改的时候 s2 也会受影响。要实现真正的复制，需要使用内建函数 copy() 进行复制。 1copy(destSlice, srcSlice) destSlice：目标切片、srcSlice：数据来源切片 12345678910111213141516171819202122232425262728func main() &#123; s1 := []int&#123;1, 2, 3, 4&#125; s2 := []int&#123;12, 13, 14&#125; copy(s1, s2) fmt.Println(s1) // [12 13 14 4] fmt.Println(s2) // [12 13 14] s3 := []int&#123;1, 2, 3, 4&#125; s4 := []int&#123;12, 13, 14&#125; copy(s4, s3) fmt.Println(s3) // [1 2 3 4] fmt.Println(s4) // [1 2 3] s5 := []int&#123;1, 2, 3, 4&#125; s6 := make([]int, 4) copy(s5, s6) fmt.Println(s5) // [0 0 0 0] fmt.Println(s6) // [0 0 0 0] s7 := []int&#123;1, 2, 3, 4&#125; s8 := make([]int, 4) copy(s8, s7) fmt.Println(s7) // [1 2 3 4] fmt.Println(s8) // [1 2 3 4] s8[0] = 100 fmt.Println(s7) // [1 2 3 4] fmt.Println(s8) // [100 2 3 4]&#125; [:] 语法这里需要说明一下，无论任何语言的 [:] 语法都是左闭右开的，用数学表达就是 $[start, end)$。 在 Python 中，[:]的语法规则是 [low:high:step]； 而在 Golang 中则是 [low:high:max]，其规则是： 0 &lt;= low &lt;= len(arr) &lt;= high &lt;= max &lt;= cap(arr)。 low 的取值在 0 至 底层结构长度，取底层结构长度时为空切片 high的取值在low 至 max，取 low 时为空切片 max的取值在high 至 底层结构容量，取 high 时新切片 len==cap 举个栗子： 123456789101112func main() &#123; a := [10]int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125; s := a[2:6:10] // [low:high:max] fmt.Printf(&quot;a: %v\\n&quot;, a) // a: [0 1 2 3 4 5 6 7 8 9] fmt.Printf(&quot;a len: %d\\n&quot;, len(a)) // a len: 10 fmt.Printf(&quot;a cap: %d\\n&quot;, cap(a)) // a cap: 10 fmt.Printf(&quot;s: %v\\n&quot;, s) // s: [2 3 4 5] fmt.Printf(&quot;s len: %d\\n&quot;, len(s)) // s len: 4 fmt.Printf(&quot;s cap: %d\\n&quot;, cap(s)) // s cap: 8&#125; 总结一下就是 新切片的容量 cap(s) = max - low 新切片的长度 len(s) = high - low low 取值在 [0, len(arr)] high 取值在 [low, max] max 取值在 [hign, cap(arr)] 删除Go 并没有提供删除切片元素的方法，我们可以利用其本身的特性来删除元素切片可以取自切片，那我们就将被删除元素之前的元素切下来，再把被删除元素之后的元素切下来，然后用append()拼接 123456func main() &#123; a := []int&#123;30, 31, 32, 33, 34, 35, 36, 37&#125; // 删除下标为2的元素 a = append(a[:2], a[3:]...) fmt.Println(a) // [30, 31, 33, 34, 35, 36, 37]&#125; 简单说就是 a = append(a[:index], a[index+1:]...) 其他操作12345678910111213141516171819202122232425262728293031323334353637// append sliceslice = append(slice, slice2...) // copydest := make([]int, len(src))copy(dest, src)// 删除多个连续的元素a = append(a[:i], a[j:]...)// 删除一个元素 ia = append(a[:i], a[i+1:]...)// 扩展 j 个元素a = append(a, make([]T, j)...)// 插入元素 x 到 i 的位置上a = append(a[:i], append([]T&#123;x&#125;, a[i:]...)...)// push，追加到尾部a = append(a, x)// pop，尾部弹出x, a = a[len(a)-1], a[:len(a)-1]// dequeue，队头出队x, a = a[0], a[1:]// enqueue，队尾入队a = append(a, x)// shift，头部取出x, a = a[0], a[1:]// unshift，头部加入a = append([]T&#123;x&#125;, a...) 总结切片和数组之间有那么点像数据库中的 基本表和视图。基本表是存储数据定义和数据的，视图只存储数据定义。所以基本表改变时视图也改变。数组是存储定义和数据的，切片只存储定义。所以数组元素改变时切片也改变。 这个例子可能不是很贴切，但联系一下这句话：数组是值类型，切片是引用类型。也就是说，数组是实实在在存数据的地方，切片只是对某个数组的引用，自己并没有数据。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [基础] 5-数组","slug":"Go/Basic/Golang-5-数组","date":"2021-07-17T02:31:48.000Z","updated":"2021-07-17T02:31:48.000Z","comments":true,"path":"posts/8961d743.html","link":"","permalink":"https://www.boii.xyz/posts/8961d743.html","excerpt":"数组的定义与操作","text":"数组的定义与操作 5-数组数组是同一种数据类型元素的集合。在 Go 中 数组从声明时就确定，使用时可以修改数组成员，但不能修改数组大小。 数组定义注意：数组是值类型！！！ 1var identifier [len]type identifier：数组名、len：数组长度、type：数组类型 数组长度必须是常量，且一旦定义就不能更改。[5]int和[10]int是不同的类型。 123var arr1 [5]intvar arr2 [8]intarr1 = arr2 // 禁止这样做，因为此时 arr1 和 arr2 是不同的类型 arr2 不可以赋值给 arr2，因为它俩类型不同，如果换成 var arr1 [5]int 和 var arr2 [5]int 这样就可以。 123456789101112131415func main() &#123; var arr1 = [3]int&#123;12, 3&#125; var arr2 [3]int arr2 = arr1 for _, e := range arr2 &#123; fmt.Println(e) &#125;&#125;// ----------------------------------------// Output:1230 数组初始化初始化方式有很多种 方法1使用初始化列表设置数组元素的值 12var identifier [len]typevar identifier = [len]type&#123;initial list&#125; eg: 1234567var a [3]intvar b = [3]int&#123;1, 2&#125;var c = [3]string&#123;&quot;Alice&quot;, &quot;Boii&quot;&#125;fmt.Println(a) // [0 0 0]fmt.Println(b) // [1 2 0]fmt.Println(c) // [Alice Boii] 方法2让编译器根据初始值个数自行推断数组长度 1var identifier = [...]type&#123;initial list&#125; eg: 123var b = [...]int&#123;1, 2, 3, 4&#125;fmt.Println(b) // [1 2 3 4]fmt.Printf(&quot;Type of b: %T \\n&quot;, b) // Type of b: [4]int 方法3通过指定索引值来初始化数组，数组长度为 最大的下标+1通过这种方式的可以不指定数组长度，如果指定了数组长度且没有更大的下标，则以指定长度为最大长度 1var identifier = [...]int&#123;idx: elem, idx: elem&#125; eg: 12345678910111213func main() &#123; a := [...]int&#123;1: 3, 5: 2&#125; b := [7]int&#123;0: 2, 4: 5&#125; fmt.Println(a) // [0 3 0 0 0 2] fmt.Println(b) // [2 0 0 0 5 0 0] fmt.Printf(&quot;Type of a: %T \\n&quot;, a) // Type of a: [6]int fmt.Printf(&quot;Type of b: %T \\n&quot;, b) // Type of b: [7]int // b := [3]int&#123;0: 2, 4: 5&#125; // 上面这句会报错，指定长度3，却又指定了索引4&#125; 数组遍历数组遍历可以通过 for 循环，也可以通过 for...range，比较推荐 for...range 1234567891011func main() &#123; str := [...]string&#123;&quot;广州&quot;, &quot;深圳&quot;, &quot;东莞&quot;&#125; for i := 0; i &lt; len(str); i++ &#123; fmt.Println(str[i]) &#125; for idx, value := range str &#123; fmt.Println(idx, value) &#125;&#125; 多维数组Go 中支持多维数组，这里以二维数组为例。 定义123456789func main() &#123; a := [3][2]string&#123; &#123;&quot;广东&quot;, &quot;广州&quot;&#125;, &#123;&quot;浙江&quot;, &quot;杭州&quot;&#125;, &#123;&quot;四川&quot;, &quot;成都&quot;&#125;, &#125; fmt.Println(a) // [[广东 广州] [浙江 杭州] [四川 成都]] fmt.Println(a[1][1]) // 支持索引取值： 杭州&#125; 遍历1234567891011121314151617181920func main() &#123; a := [3][2]string&#123; &#123;&quot;广东&quot;, &quot;广州&quot;&#125;, &#123;&quot;浙江&quot;, &quot;杭州&quot;&#125;, &#123;&quot;四川&quot;, &quot;成都&quot;&#125;, &#125; for _, v1 := range a &#123; for _, v2 := range v1 &#123; fmt.Printf(&quot;%s \\t&quot;, v2) &#125; fmt.Println() &#125;&#125;// ----------------------------------------// Output:广东 广州浙江 杭州四川 成都 注意：多维数组只有第一层可以省略长度。eg： 12345678910111213// 合法写法a := [...][2]string&#123; &#123;&quot;广东&quot;, &quot;广州&quot;&#125;, &#123;&quot;浙江&quot;, &quot;杭州&quot;&#125;, &#123;&quot;四川&quot;, &quot;成都&quot;&#125;,&#125;// 非法写法a := [...][...]string&#123; &#123;&quot;广东&quot;, &quot;广州&quot;&#125;, &#123;&quot;浙江&quot;, &quot;杭州&quot;&#125;, &#123;&quot;四川&quot;, &quot;成都&quot;&#125;,&#125; 数组是值类型数组是值类型，赋值和传参会赋值整个数组。因此改变副本的值，不会改变本身的值。 12345678910111213141516171819func modifyArray(x [3]int) &#123; x[0] = 100&#125;func modifyArray2(x [3][2]int) &#123; x[2][0] = 100&#125;func main() &#123; a := [3]int&#123;10, 20, 30&#125; modifyArray(a) //在modify中修改的是a的副本x fmt.Println(a) //[10 20 30] b := [3][2]int&#123; &#123;1, 1&#125;, &#123;1, 1&#125;, &#123;1, 1&#125;, &#125; modifyArray2(b) //在modify中修改的是b的副本x fmt.Println(b) //[[1 1] [1 1] [1 1]]&#125; 注意： 数组支持 ==、!= 操作符，因为内存总是被初始化过的。 [len]*type 表示指针数组，本质是数组，存放指针的数组 *[len]type 表示数组指针，本质是指针，指向数组的指针","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [基础] 4-流程控制","slug":"Go/Basic/Golang-4-流程控制","date":"2021-07-17T02:27:41.000Z","updated":"2021-07-17T02:27:41.000Z","comments":true,"path":"posts/7ebc0a4.html","link":"","permalink":"https://www.boii.xyz/posts/7ebc0a4.html","excerpt":"基本流程控制","text":"基本流程控制 4-流程控制分支结构if 基本写法1234567if 表达式1 &#123; 分支1&#125; else if 表达式2 &#123; 分支2&#125; else&#123; 分支3&#125; eg： 1234567891011func main() &#123; score := 65 if score &gt;= 90 &#123; fmt.Println(&quot;A&quot;) &#125; else if score &gt; 75 &#123; fmt.Println(&quot;B&quot;) &#125; else &#123; fmt.Println(&quot;C&quot;) &#125;&#125; if 特殊写法在 if 表达式之前添加一个执行语句，再根据变量值进行判断 12345678910func main() &#123; if score := 65; score &gt;= 90 &#123; fmt.Println(&quot;A&quot;) &#125; else if score &gt; 75 &#123; fmt.Println(&quot;B&quot;) &#125; else &#123; fmt.Println(&quot;C&quot;) &#125;&#125; 注意上述代码中的 score 是在 if 语句中创建并初始化的，其作用域仅限于 if 语句块（包括同属的 else if 语句、else 语句） 但是如果声明是在 if 语句外，则其作用域不限于 if 语句中 1234567891011121314func main() &#123; var score int if score := 65; score &gt;= 90 &#123; fmt.Println(&quot;A&quot;) &#125; else if score &gt; 75 &#123; fmt.Println(&quot;B&quot;) &#125; else &#123; fmt.Println(&quot;C&quot;) &#125; // score 在if外部声明，所以出了 if 依然有效 fmt.Println(score)&#125; switch case123456789101112switch [判断变量] &#123; case 常量1 或 表达式1: 执行语句1 case 常量2 或 表达式2: 执行语句2 case 常量3 或 表达式3: 执行语句3 case 常量4 或 表达式4: 执行语句4 default: 执行语句N&#125; 一个switch 可有多个分支，但只能有一个default 分支，且 defalut 分支不是必须的。 eg： 123456789101112131415161718func main() &#123; num := 2 switch num &#123; case 1: fmt.Println(&quot;It is 1.&quot;) case 2: fmt.Println(&quot;It is 2.&quot;) case 3: fmt.Println(&quot;It is 3.&quot;) default: fmt.Println(&quot;It is more than 3.&quot;) &#125;&#125;// ----------------------------------------// Output:It is 2. 一个分支可以有多个值，每个值之间用逗号分开 eg： 123456789func main() &#123; switch n := 7; n &#123; case 1, 3, 5, 7, 9: fmt.Println(&quot;Odd&quot;) case 2, 4, 6, 8, 10: fmt.Println(&quot;Even&quot;) default &#125;&#125; 分支也可以用表达式，这时 switch 后面不需要跟判断变量 eg： 12345678910111213func main() &#123; age := 25 switch &#123; // switch 后不带判断变量，则case 只能判断 true 或 false case age &lt; 25: fmt.Println(&quot;好好学习！&quot;) case age &gt; 25 &amp;&amp; age &lt; 35: fmt.Println(&quot;好好工作！&quot;) case age &gt; 60: fmt.Println(&quot;好好享受！&quot;) default: fmt.Println(&quot;好好活着！&quot;) &#125;&#125; 或者 12345678910111213func main() &#123; switch age := 25; &#123; case age &lt; 25: fmt.Println(&quot;好好学习！&quot;) case age &gt; 25 &amp;&amp; age &lt; 35: fmt.Println(&quot;好好工作！&quot;) case age &gt; 60: fmt.Println(&quot;好好享受！&quot;) default: fmt.Println(&quot;好好活着！&quot;) &#125;&#125; switch 中的 case 默认不会穿透，执行完这个 case 之后就跳出switch，但是可以使用 fallthrough 击穿 case。fallthrough 语句可以执行满足条件的 case 的下一个 case，这是为了兼容 C 语言中的 case 设计的。 123456789101112131415161718func switchDemo5() &#123; s := &quot;a&quot; switch &#123; case s == &quot;a&quot;: fmt.Println(&quot;a&quot;) fallthrough case s == &quot;b&quot;: fmt.Println(&quot;b&quot;) case s == &quot;c&quot;: fmt.Println(&quot;c&quot;) default: fmt.Println(&quot;...&quot;) &#125;&#125;// ----------------------------------------// Output:ab 循环结构for 循环123for 初始化语句; 条件语句; 迭代语句 &#123; ...&#125; 或 12345初始化语句for 条件语句 &#123; ... 迭代语句&#125; eg： 123for i := 0; i &lt; 5; i++ &#123; fmt.Println(i)&#125; 或 12345i := 0for i &lt; 5 &#123; fmt.Println(i) i++&#125; 无限循环123for &#123; 循环体&#125; for 循环可以通过 break、continue、return、panic语句强制退出循环。 for range 键值循环使用 for range 可以遍历数组、切片、字符串、map 和通道channel。 通过 for range 遍历的返回值有以下规律： 数组、切片、字符串 返回索引和值 map 返回键和值 通道 channel 只返回通道内的值 基本语法为： 123for idx, val := range iter &#123; ...&#125; eg： 12345678910111213141516func main() &#123; numbers := [6]int&#123;1, 2, 3, 5&#125; for i, x := range numbers &#123; fmt.Printf(&quot;第 %d 位 x 的值为 %d \\n&quot;,i ,x) &#125;&#125;// ----------------------------------------// Output:第 0 位 x 的值为 1第 1 位 x 的值为 2第 2 位 x 的值为 3第 3 位 x 的值为 5第 4 位 x 的值为 0第 5 位 x 的值为 0 注意： val 始终为iter中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值。如果 val 为指针，则会产生指针的拷贝，依旧可以修改集合中的原值。 eg： 123456789101112131415161718192021func main() &#123; a, b, c := 1, 2, 3 d, e, f := 4, 5, 6 pointer := [3]*int&#123;&amp;a, &amp;b, &amp;c&#125; valuer := [3]int&#123;d, e, f&#125; fmt.Println(a, b, c) // 1 2 3 fmt.Println(d, e, f) // 4 5 6 for _, p := range pointer &#123; *p = *p + 10 &#125; for _, v := range valuer &#123; v = v + 1 &#125; fmt.Println(a, b, c) // 11 12 13 fmt.Println(d, e, f) // 4 5 6&#125; goto 跳转goto语句 通过标签进行代码间的无条件跳转。标签即某一行第一个一冒号（:）结尾的单词,为了提升可读性，一般建议标签名称使用全大写。 goto语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go 语言中使用 goto 语句能简化一些代码的实现过程。 123456789101112131415161718192021func main() &#123; for i := 0; i &lt; 10; i++ &#123; if i == 6 &#123; goto GOTOTAG &#125; fmt.Println(i) &#125;GOTOTAG: fmt.Println(&quot;I&#x27;m break.&quot;)&#125;// ----------------------------------------// Output:012345I&#x27;m break. 使用 goto 语句也可以实现循环，但是不建议这么做，因为滥用 goto 语句会写出意大利面条代码 123456789func main() &#123; a := 1L: if a &lt; 10 &#123; fmt.Println(a) a++ goto L &#125;&#125; 如果您必须使用 goto，应当只使用正序的标签（标签位于 goto 语句之后），但注意标签和 goto 语句之间不能出现定义新变量的语句，否则会导致编译失败。 break、continuebreak：跳出整个循环continue：跳出本次循环 break 和 continue 语句后面都可以添加标签。不过标签必须位于 for、switch、select代码块之上。eg： 1234567891011121314151617func main() &#123;breakTag: for i := 0; i &lt; 10; i++ &#123; if i == 5 &#123; break breakTag &#125; fmt.Println(i) &#125;&#125;// ----------------------------------------// Output:01234","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [基础] 3-运算符","slug":"Go/Basic/Golang-3-运算符","date":"2021-07-17T02:25:53.000Z","updated":"2021-07-17T02:25:53.000Z","comments":true,"path":"posts/5d7d558a.html","link":"","permalink":"https://www.boii.xyz/posts/5d7d558a.html","excerpt":"内置操作符","text":"内置操作符 运算符官方定义的所有运算符123456+ &amp; += &amp;= &amp;&amp; == != ( )- | -= |= || &lt; &lt;= [ ]* ^ *= ^= &lt;- &gt; &gt;= &#123; &#125;/ &lt;&lt; /= &lt;&lt;= ++ = := , ;% &gt;&gt; %= &gt;&gt;= -- ! ... . : &amp;^ &amp;^= 算术运算符 运算符 描述 + 加 - 减 * 乘 / 除 % 求余 Go 中 ++ 和 -- 是单独的语句，不是运算符。即 a++ 后面不能有其他东西了，且只有后置，没有前置 123456func main() &#123; a := 10 a++ // 正确，a的值为11 a++ + 10 // 错误 ++a // 错误，只有后置自增和后置自减&#125; 关系运算符 运算符 描述 == 等于 != 不等于 &gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 逻辑运算符 运算符 描述 &amp;&amp; 逻辑与 || 逻辑或 ! 逻辑非 位运算符 运算符 含义 &amp; 按位与 两位均为1才为1 | 按位或 两位有一个为1就为1 ^ 按位异或 两位不同则为1 &lt;&lt; 左移 左移n位 == 乘以2的n次方，高位丢弃，低位补0 &gt;&gt; 右移 右移n位 == 除以2的n次方，高位补0，低位丢弃 赋值运算符 运算符 描述 = 将右边赋值给左边 += 相加后赋值 -= 相减后赋值 *= 相乘后赋值 /= 相除后赋值 %= 求余后赋值 &amp;= 按位与后赋值 |= 按位或后赋值 ^= 按位异或后赋值 &lt;&lt;= 左移后赋值 &gt;&gt;= 右移后赋值 优先级从高到低 分类 描述 关联性 后缀 () [] . ++ -- 左到右 一元 + - ! ~ ++ -- (type) * &amp; sizeof 右到左 乘除 * / % 左到右 加减 + - 左到右 移位 &lt;&lt; &gt;&gt; 左到右 关系 &lt; &lt;= &gt; &gt;= 左到右 相等 == != 左到右 按位AND &amp; 左到右 按位XOR ^ 左到右 按位OR ` ` 逻辑AND &amp;&amp; 左到右 逻辑OR ` 赋值 = += -= *= /= %= &gt;&gt;= &lt;&lt;= &amp;= ^= 右到左 逗号 , 左到右","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [基础] 2-数据类型","slug":"Go/Basic/Golang-2-数据类型","date":"2021-07-17T02:24:06.000Z","updated":"2021-07-17T02:24:06.000Z","comments":true,"path":"posts/c6fec8a1.html","link":"","permalink":"https://www.boii.xyz/posts/c6fec8a1.html","excerpt":"基础数据类型","text":"基础数据类型 2-数据类型整型整型分为两大类：有符号和无符号 按长度分为：int8、int16、int32、int64；uint8、uint16、uint32、uint64 类型 范围 描述 对应C int8 -128~127 有符号8位整型 byte int16 -32768~32767 有符号16位整型 short int32 -2147483648~2147483647 有符号32位整型 int int64 -9223372036854775808~9223372036854775807 有符号64位整型 long uint8 0~255 无符号8位整型 unsigned byte uint16 0·65535 无符号16位整型 unsigned short uint32 0~4294967295 无符号32位整型 unsigned int uint64 0~18446744073709551615 无符号64位整型 unsigned long 特殊整型 类型 描述 uint 32位OS上就是uint32，64位OS上就是uint64 int 32位OS上就是int32，64位OS上就是int64 uintptr 无符号整型，用于存放一个指针 注意： 在使用int和uint类型时，不能假定它是32位或64位的整型，而要考虑int和uint可能在不同平台上的差异。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用int和uint。 数字字面量语法字面量语法使得开发者可以用 二进制、八进制、十六进制的格式定义数字 v := 0b101110，0b前缀；代表二进制的 101110，相当于八进制的56，十进制的46，十六进制的 2E v := 0o56，0o前缀；代表八进制的 56 v := 46，无前缀；代表十进制的 46 v := 0x2e，0x前缀；代表十六进制的 2E v := 0x1p-2，代表十六进制的 1 除以 $2^2$，也就是 0.25 还可以用 _ 来分隔数字。比如 v := 1_000_000 表示 v 的值等于 一百万 1000000。 借助 Printf() 可以将一个整数以不同进制形式展示 1234567891011121314func main() &#123; num := 0b101110 fmt.Printf(&quot;%b \\t %#b \\n&quot;, num, num) fmt.Printf(&quot;%o \\t\\t %#o \\n&quot;, num, num) fmt.Printf(&quot;%d \\t\\t %#d \\n&quot;, num, num) fmt.Printf(&quot;%x \\t\\t %#x \\t %#X \\n&quot;, num, num, num)&#125;// ----------------------------------------// Output:101110 0b10111056 05646 462e 0x2e 0X2E 整型支持算术运算和位操作，算术表达式和位操作表达式的结果还是整型 1var a int = 1000 &gt;&gt; 2 浮点型Go 语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循 IEEE754标准： float32的浮点数最大范围约为3.4e38，可以使用常量定义 math.MaxFloat32 float64的浮点数最大范围约为1.8e308，可以使用常量定义 math.MaxFloat64 打印浮点数时，可以使用占位符 %f: 12345678910111213package mainimport &quot;math&quot;import &quot;fmt&quot;func main() &#123; fmt.Printf(&quot;%f \\n&quot;, math.Pi) fmt.Printf(&quot;%.2f \\n&quot;, math.Pi)&#125;// ----------------------------------------// Output:3.1415933.14 浮点型字面量被自动类型推断为 float64 类型 12b := 10.00fmt.Printf(&quot;%T&quot;, b) // float64 计算机很难进行浮点数的精确表示和存储，因此两个浮点数之间不应该使用 == 或 != 来比较，高精度科学计算应该使用 math 标准库 复数complex64 和 complex128 12345678910var c1 complex64 = 1 + 2ivar c2 complex128 = 2 + 3ifmt.Println(c1)fmt.Println(c2)// ----------------------------------------// Output:(1+2i)(2+3i) 复数有实部和虚部complex64的实部和虚部为32位complex128的实部和虚部为64位。 Go 有三个内置函数处理复数 123var v = complex(2.1, 3) // 构造一个复数 (2.1+3i)a := real(v) // 返回复数实部 2.1b := imag(v) // 返回复数虚部 3 布尔值Go 语言中以 bool 类型进行声明布尔型，布尔型数据只有 true 和 false 两个值。 布尔类型变量默认值为 false Go 语言中不允许将整型强制转换为布尔型（integer !-&gt; bool） 布尔型无法参与数值运算，无法与其他类型进行转换 字符串Go 语言中的字符串是原生数据类型，使用字符串就像使用其他原生数据类型（int、bool、float32等）一样Go 语言中字符串内部实现使用 UTF-8 编码，这使得 go 不需要专门使用 UTF-8 字符集的文本进行编码和解码，可以在Go语言中直接添加非ASCII码字符 字符串是一种值类型，且值不可变；即创建某个文本后你无法再次修改这个文本的内容，即使你改变了，你会发现那已经不是原来的那串字符串了。更深入的讲，字符串是字节的定长数组。 Go 支持以下2种形式的字面值 解释字符串 该类字符串使用双括号 &quot;&quot; 引起来，其中转义字符（\\n、\\r、 \\t、 \\\\）会被替换。 eg： 12str1 := &quot;Hello&quot;str2 := &quot;Boii&quot; 非解释字符串 该类字符串使用反引号括起来 **``**，支持换行 eg： 123// 下面的 \\n 会被原样输出str := `This is araw string \\n` **Go 中的字符串是根据长度限定，而非特殊字符 \\0**。 string 类型的零值：长度为 0 的字符串，即空字符串 &quot;&quot; 可以通过 len() 函数来获取字符串字符个数 字符串中的内容（纯字节）可以通过标准索引法来获取 123456789func main() &#123; str := &quot;hello Boii&quot; c1 := str[0] c4 := str[4] cEnd := str[len(str)-1] fmt.Println(c1) // 104 fmt.Println(c4) // 111 fmt.Println(cEnd) // 105&#125; 输出的是字符的 Ascii 码 字符串类型底层实现是一个二元的数据结构，一个是指向字节数组的起点，另一个是长度。 eg： 12345// runtime/string.gotype stringStruct struct &#123; str unsafe.Pointer // 指向底层字节数组的指针 len int // 字节数组长度&#125; 基于字符串创建的切片 和 原字符串 指向相同的 底层字符数组，一样不能修改，对字符串的切片操作返回的仍然是 string，而非 slice。 12345a := &quot;Hello World&quot;b := a[0:4]c := a[1:]fmt.Printf(&quot;b -&gt; %s, b -&gt; type: %T\\n&quot;, b, b) // b -&gt; Hell, b -&gt; type: stringfmt.Printf(&quot;c -&gt; %s, c -&gt; type: %T\\n&quot;, c, c) // c -&gt; ello World, c -&gt; type: string 字符串常用操作 方法 描述 返回值 len(str) 求字符串长度 int + 或 fmt.Sprintf(“%s %s”, str1, str2) 拼接字符串 string strings.Split(str, 分隔符) 分割字符串 []string strings.Contains(str, 目标内容) 判断str是否包含目标子串 bool strings.HasPrefix(str, 目标内容) 判断str是否以目标内容开头 bool strings.HasSuffix(str, 目标内容) 判断str是否以目标内容结尾 bool strings.Index(str, 目标内容) 返回str第一次出现目标内容的首个字符的下标 int strings.LastIndex(str, 目标内容) 返回str最后一次出现目标内容的首个字符的下标 int strings.Join(strArr, 拼接符号) 返回用拼接符号拼接strArr的字符串 string 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() &#123; // 求字符串长度 str1 := `hello Boii` fmt.Println(len(str1)) // 10 str2 := &quot;Hello 中国&quot; fmt.Println(len(str2)) // 12 fmt.Println() // 拼接字符串 fmt.Println(str1 + str2) // hello BoiiHello 中国 str3 := fmt.Sprintf(&quot;%s | %s&quot;, str1, str2) fmt.Println(str3) // hello Boii | Hello 中国 fmt.Println() // 字符串分割 str4 := `How do you do` fmt.Println(strings.Split(str4, &quot; &quot;)) // [How do you do] fmt.Printf(&quot;%T \\n&quot;, strings.Split(str4, &quot; &quot;)) // []string fmt.Println() // 判断是否包含 fmt.Println(strings.Contains(str4, &quot;do&quot;)) // true // 判断前缀 fmt.Println(strings.HasPrefix(str4, &quot;How&quot;)) // true // 判断后缀 fmt.Println(strings.HasSuffix(str4, &quot;How&quot;)) // false fmt.Println() // 判断子串位置 fmt.Println(strings.Index(str4, &quot;do&quot;)) // 4 // 最后子串出现的位置 fmt.Println(strings.LastIndex(str4, &quot;do&quot;)) // 11 fmt.Println() // join str5 := []string&#123;&quot;how&quot;, &quot;do&quot;, &quot;you&quot;, &quot;do&quot;&#125; fmt.Println(str5) // [how do you do] fmt.Println(strings.Join(str5, &quot;-&quot;)) // how-do-you-do&#125; 字符Go 的字符有以下两种： uint8类型，别名 byte，代表一个 ASCII 码字符 int32类型，别名 rune，代表一个 UTF-8 字符 注意：字符用单引号( ‘ ‘ )括起来 1234567891011func main() &#123; var c1 byte = &#x27;a&#x27; var c2 rune = &#x27;a&#x27; fmt.Println(c1, c2) fmt.Printf(&quot;c1 type: %T, c2 tpye: %T \\n&quot;, c1, c2)&#125;// ----------------------------------------// Output:97 97c1 type: uint8, c2 tpye: int32 在编写代码的时候，使用别名 byte、rune 可以使得代码更加清晰，不过这两个别名在经过编译后还是会还原成 unit8 和 int32。 当需要处理中文、日文或者中英混杂的字符时，则需要用到 rune 类型，因为 byte 型只有8位，只能显示 ASCII 码，而 rune 型有32位。 1234567891011121314151617181920func main() &#123; s := `Hello 中国` for i := 0; i &lt; len(s); i++ &#123; fmt.Printf(&quot;%v[%c]\\t&quot;, s[i], s[i]) &#125; fmt.Println() for _, char := range s &#123; fmt.Printf(&quot;%v[%c]\\t&quot;, char, char) &#125; fmt.Println()&#125;// ----------------------------------------// Output:72[H] 101[e] 108[l] 108[l] 111[o] 32[ ] 228[ä] 184[¸] 173[­] 229[å] 155[] 189[½] 72[H] 101[e] 108[l] 108[l] 111[o] 32[ ] 20013[中] 22269[国] 遍历一个中英混杂的字符串后我们会发现，中文一个字占好几个字节。因为 go 中字符串是按照 UTF-8 编码的，而 UTF-8 编码下一个中文汉字由 3~4 个字节组成。len(str) 返回的是字符串的字节数，而不是字符串的个数，所以第一个循环中会出现乱码的情况。 第二种方式 for...range 则可以正确的返回字符串中每个字符，因为它是按 rune 类型计算的，所以打印的时候没有乱码。 字符串的底层是一个 byte 数组，所以字符串可以和 []byte 型互相转换。 字符串是不能修改的 字符串是由 byte 字节组成的 字符串的长度是 byte 字节的长度 rune 类型用来表示 utf8 字符 一个字符由一个或多个 byte 组成 修改字符串 将字符串转换成 []byte 或 []rune 类型；例如[]byte(str) 或 []rune(str) 修改字符串 转回 string 无论哪种转换，都会重新分配内存，并复制字节数组。 1234567891011121314151617181920func main() &#123; str1 := &quot;big&quot; byteS = []byte(str1) // 转成[]byte切片 byteS[0] = &#x27;p&#x27; // 修改 str1 = string(byteS) // 转回 string fmt.Println(str1) str2 = &quot;青菜&quot; runeS = []rune(str2) // 转成[]rune切片 runeS[0] = &#x27;白&#x27; // 修改 str2 = string(runeS) // 转回 string fme.Println(str2)&#125;// ----------------------------------------// Output:pig白菜 类型转换Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用 基本语法如下： 1Type(expression) Type 表示要转的类型，expression 表示变量、复杂算式、函数返回值等 12var i int = 10var f float32 = float32(i) 详见类型转换 类型大小 类型 bit数 指针 32位 -&gt; 4bit，64位C -&gt; 8bit uintptr 32位 -&gt; 4bit，64位C -&gt; 8bit bool 8 byte 8 int8 8 uint8 8 int16 16 uint16 16 int32 32 rune 32 uint32 32 float32 32 int64 64 uint64 64 float64 64 complex64 64 complex128 128 int 与CPU位数相同 uint 与CPU位数相同 string ASCII范围8bit，中文24bit 使用 unsafe.Sizeof(v) 可以得到 v 占用内存大小。 类型别名、自定义类型类型别名为类型起个别名，方便代码编写过程中使用， 1type alias = T type：关键字、alias：类型别名、T：类型 例如数据类型中提到的Unicode字符型 rune 和ASCII字符型 byte就是类型别名 12type rune = int32type byte = uint8 自定义类型在 Go 中有一些基本的数据类型，如string、int、bool等数据类型，也可以通过关键字 type 来定义自定义类型 自定义类型是定义了一个全新的类型，我们可以基于内置基本类型定义，也可以通过 struct 定义。eg： 1type Status bool 通过 type 关键字的定义，Status就是一种新的类型，它具有 bool 的特性 区别从定义上看，类型别名有 = ，自定义类型没有。 12345678910func main() &#123; type abc = string type Status bool var OK Status var ss abc fmt.Printf(&quot;Type of OK: %T\\n&quot;, OK) // Type of OK: main.Status fmt.Printf(&quot;Type of ss: %T\\n&quot;, ss) // Type of ss: string&#125; OK 的类型是 main.Status，表示在 main 包下定义的Status类型ss 的类型是 string。abc类型只会在代码中存在，编译前编译器会将其替换回来。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [基础] 1-基础","slug":"Go/Basic/Golang-1-基础","date":"2021-07-17T02:20:39.000Z","updated":"2021-07-17T02:20:39.000Z","comments":true,"path":"posts/7b9344b7.html","link":"","permalink":"https://www.boii.xyz/posts/7b9344b7.html","excerpt":"基础语法","text":"基础语法 1-基础标识符 [ _ | A-Z | a-z | 0-9 ] 不能数字开头 不能与关键字和保留字冲突 关键字Go 中有25个关键字 12345break default func interface selectcase defer go map structchan else goto package switchconst fallthrough if range typecontinue for import return var 37个保留字 12345678910Constants: true false iota nil Types: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string errorFunctions: make len cap new append copy close delete complex real imag panic recover 变量声明1var 变量名 变量类型 变量声明以关键字 var 开头，类型放在后面，无需分号 123var name stringvar age intvar isEmpty bool 批量声明每个变量写一个 var 太麻烦，go 支持批量声明 1234567var ( name string age int isEmpty bool)var num1, num2, num3 int 初始化 go 声明变量时，会自动对变量对应的内存区域进行初始化，每个变量都会被初始化成默认值。 eg：整型和浮点型变量默认值是 0，字符串变量默认值是 空字符串，布尔类型变量默认值是false，切片、函数、指针变量默认是 nil。 同时，我们可以在声明变量时为其指定初始值，格式如下： 1var 变量名 类型 = 表达式 eg： 12var name string = &quot;Boii&quot;var age int = 18 或者一次初始化多个变量。eg： 1var name, age = &quot;Boii&quot;, 18 Go 语言具有的这种特性，使得交换两个变量非常方便，可以简单地使用 a, b = b, a 完成交换两个变量的值。 类型推导类型推导指的是没有显示的写明类型，编译器会通过等号右边的值来推导出类型，然后完成初始化工作。 123var name = &quot;Boii&quot;var age = 18height := 180 交换变量123a, b := 10, 15a, b = b, afmt.Println(a, b) // 15 10 短变量声明在函数内部，可以用更简略的方式 := 声明并初始化变量，但这种方式只能声明局部变量 123456789101112131415package mainimport &quot;fmt&quot;var m = 100 // 声明全局变量 mfunc main() &#123; n := 10 // 声明局部变量 n m := 200 // 声明局部变量 m fmt.Println(m ,n)&#125;// ----------------------------------------// Output:200 10 匿名变量使用多重赋值时，想要忽略某个值，可以使用 匿名变量，也就是一个下划线 _ 表示。eg： 1234567891011func foo() (int, string) &#123; return 18, &quot;Boii&quot;&#125;func main() &#123; x, _ := foo() fmt.Println(&quot;x =&quot;, x)&#125;// ----------------------------------------// Output:18 匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明，且匿名变量无法拿来使用，只能用来承接不想要的值。 总结 函数外的每个语句都必须以关键字开始（var、const、func等） := 不能在函数外使用 _ 多用于占位，表示忽略值 常量常量是程序运行期间不会改变的那些值。变量声明是用 var，常量声明是用 const常量在定义的时候必须赋值 12const PI = 3.14156const E = 2.7182 批量声明 1234const ( PI = 3.14156 E = 2.7182) 批量声明时，如果省略了赋值则表示与上面一行的值相同。eg： 1234567const ( a = 100 b c = 3.33 d e) 例子中，常量 a 和 b 的值都是 100，c、d、e 的值都是 3.33 iotaiota 是go语言中的常量计数器，只能在常量的表达式中使用。 iota 在const 关键字出现时将被重置为 0。const 中每新增一行常量声明，将使 iota +1iota 可理解为const 块中的行索引使用iota能简化定义，在枚举时很方便 1234567891011121314const ( n1 = iota // 0 n2 // 1 n3 // 2 n4 // 3)func main() &#123; fmt.Println(n1, n2, n3, n4)&#125;// ----------------------------------------// Output:0 1 2 3 还有几个比较经典的例子: 匿名变量插队 123456const ( n1 = iota // 0 n2 // 1 _ n4 // 3) 声明中间插队 12345678const ( n1 = iota // 0 n2 = 100 // 100 n3 = iota // 2 n4 // 3 n5 // 4)const n6 = iota // 0 定义数量级 12345678const ( _ = iota KB = 1 &lt;&lt; (10 * iota) // 10*1 == 10 MB = 1 &lt;&lt; (10 * iota) // 10*2 == 20 GB = 1 &lt;&lt; (10 * iota) // 10*3 == 30 TB = 1 &lt;&lt; (10 * iota) // 10*4 == 40 PB = 1 &lt;&lt; (10 * iota) // 10*5 == 50) 多个 iota 定义在一行 12345678910111213const ( a, b = iota + 1, iota + 2 //1,2 c, d //2,3 e, f //3,4)func main() &#123; fmt.Println(a, b, c, d, e, f)&#125;// ----------------------------------------// Output:1 2 2 3 3 4 iota 只有在新起一行才会自增 iota 只有遇到新的 const 才会重置 iota 是从 0 开始的。 值类型和引用类型值类型：int float bool string 指针，使用这些类型的变量直接指向存在内存中的值，存储在栈中。j = i 引用类型：slices、maps、channel，被引用的变量会存储在堆中，以便垃圾回收。r1 = r2","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"Golang [基础] 0-总叙","slug":"Go/Basic/Golang-0-总叙","date":"2021-07-17T02:11:51.000Z","updated":"2021-07-17T02:11:51.000Z","comments":true,"path":"posts/913ad9ee.html","link":"","permalink":"https://www.boii.xyz/posts/913ad9ee.html","excerpt":"Go 是一门好语言吗？","text":"Go 是一门好语言吗？ 0-总叙特性 简化问题，易于学习 内存管理，简洁语法，易于使用 快速编译，高效开发 高效执行 并发支持，轻松驾驭 静态类型 标准类库，规范统一 易于部署 文档全面 免费开源 环境变量 GOROOT：Go的安装位置，默认$HOME/go GOPATH：工作目录，在这下面写代码 GOBIN：编译器和链接器的安装位置，默认 $GOROOT/bin GOOS：运行Go的操作系统； 取值：[darwin | freebsd | linux | windows] GOARCH：运行Go的处理器架构； 取值：[386 | amd64 | arm] GOARM：专门针对基于 arm 架构的处理器，默认为 6； 取值：[5 | 6] Hello World123456789// src/Hello/main.gopackage main // 声明 mian 包，表明当前是一个可执行程序import &quot;fmt&quot; // 导入内置 fmt 包func main() &#123; // main 函数，程序执行入口 fmt.Println(&quot;Hello World!&quot;) // 在终端打印 Hello World！&#125; package main 定义了包名。必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。 package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 import &quot;fmt&quot; 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。 func main() 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行 init() 函数）。 fmt.Println(...) 可以将字符串输出到控制台，并在最后自动增加换行字符 \\n。使用 fmt.Print(“hello, world\\n”) 可以得到相同的结果。 在 Go 中，左大括号不能单独一行，这会编译不了 对缩进没有要求，可以用 go fmt 文件名.go 命令将文件格式化 每个语句独占一行，不需要加分号 大部分语句只能写在 {} 内， {} 外只能做一些声明变量、函数、结构体的工作。 变量声明了不使用也是不允许的 运行在文件目录下，可以运行 go build 命令，编译之后会在目录下生成一个可执行文件 Hello.exe，输入文件名即可以运行。 1234$ go build$ ./HelloHello World! 如果不在文件目录下，也可以使用 go build 项目名称 命令，编译之后会在所在目录下生成一个可执行文件 Hello.exe。 12345$ cd ..$ go build Hello$ ./HelloHello World! 也可以使用 -o 参数来指定可执行文件的名字 1234$ go build -o haha.exe$ ./hahaHello World! 还可以使用 go run 文件名.go 命令来执行，但不会生成可执行文件。 1234$ cd src/Hello$ go run main.goHello World! init 函数每个源文件都只能包含一个 init 函数。它不能被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。可以将数据检验或修复的工作放在 init函数中，这样程序开始执行之前就会先修复或检验数据，保证程序状态正确性。 1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;math&quot;)var Pi float64func init() &#123; Pi = 4 * math.Atan(1) fmt.Println(&quot;init()&quot;)&#125;func main() &#123; fmt.Println(&quot;main()&quot;)&#125; 输出： 12345$ go run main.goinit()main()$","categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"}]},{"title":"计算机网络 [0-概述]","slug":"408/NET/计算机网络-0-概述","date":"2021-07-16T07:51:46.000Z","updated":"2021-07-16T10:13:26.000Z","comments":true,"path":"posts/f56d3ab8.html","link":"","permalink":"https://www.boii.xyz/posts/f56d3ab8.html","excerpt":"计算机网络一览~","text":"计算机网络一览~ 概述计算机网络定义计算机网络是互联的、自治的计算机集合。 互联：互联互通、 自治：无主从关系，相互独立。有通信，但不能控制对方 计算机网络的功能 数据通信：数据可以在信道上传输，使得硬件设备可以通信 资源共享：硬件、软件、数据的共享 分布式处理：多台计算机各自承担同一工作任务的不同部分 提高可靠性：一台主机挂了，另外一台可以顶上。 负载均衡 组成组成部分硬件、软件、协议 工作方式分为边缘部分和核心部分 边缘部分：各种主机、终端机、服务器等；用于直接使用，分C/S方式和P2P方式 核心部分：各种路由器、集线器等；为边缘部分服务 功能组成 通信子网：实现数据通信 资源子网：实现资源共享/数据处理 分类 按分布范围分： 广域网 WAN - 使用交换技术 城域网 MAN 局域网 LAN - 广播技术 个人区域网 PAN 按使用者分 公用网 - 中国电信、移动、联通 专用网 - 军队、政府、银行等使用的专用网络，需要一定权限 按交换技术分 电路交换 报文交换 分组交换 按拓扑结构分 总线型 星型 环形 网状型 - 常用于广域网 按传输技术分 广播式网络 - 共享公共通信信道 点对点网络 - 使用分组存储转发和路由选择机制 标准化工作分类 法定标准：由权威机构制定的正式的、合法的标准，如OSI 事实标准：某些公司的产品在竞争中占据主流，时间长了，这些产品中的协议和技术就成了标准，如 TCP/IP RFCRFC (Request For Comments) —— 互联网标准的形式 RFC要上升为互联网正式标准的四个阶段： 互联网草案 (Internet Draft) : 这个阶段还不是RFC文档 建议标准 (Proposed Standard) : 被收录后就进入这个阶段，成为RFC文档，然后进一步完善成为草案标准 草案标准 (Draft Standard) : 完善以后就形成一个草案标准，交由IETF、IAB 审核 互联网标准 (Internet Standard) : 通过审核以后就正式成为互联网标准。 2013年后取消了草案标准这一阶段，被收录为RFC文档完善审核通过后直接成为互联网标准。 相关组织 主要贡献 ISO 国际标准化组织 OSI 参考模型、HDLC协议 ITU 国际电信联盟 指定通信规则 IEEE 国际电气电子工程师协会 学术论文、IEEE802系列标准、5G IETF Internet工程任务组 负责互联网标准制定 性能指标速率又称 数据率 或 数据传输率 或 比特率（比特，即 1/0 ，又称“位”）指连接在计算机网络上的主机在数字信道上传送数据位数的速度。 单位是 b/s、kb/s、Mb/s、Gb/s、TB/s 速率 存储容量（1Byte=8bit） 千 $1kb/s = 10^3b/s$ $1KB=2^{10}B=1024B=1024\\times8b$ 兆 $1Mb/s = 10^3kb/s = 10^6b/s$ $1MB=2^{10}KB=1024KB$ 吉 $1Gb/s = 10^3Mb/s = 10^6kb/s=10^9b/s$ $1GB=2^{10}MB=1024MB$ 太 $1Tb/s=10^3Gb/s=10^6Mb/s=10^9kb/s=10^{12}b/s$ $1TB=2^{10}GB=1024GB$ 带宽（车道数） 计算机网络中，带宽表示网络通信线路传送数据的能力，通常指单位时间内从网络中某一点到另一点所能通过的“最高数据率”，即网络设备所支持的最高速度 带宽用来表示网络的通信线路传送数据的能力，通常指单位时间内从网络中的一端到另一端所能通过的“最高数据率”。单位是 b/s、kb/s、Mb/s、Gb/s、Tb/s换言之，就是一秒内我这个设备能传输到信道上的最多的比特数。 吞吐量（车流量） 单位时间内通过某个网络（或信道、接口）的数据量。即实际接收到的数据量。 单位是 b/s、kb/s、Mb/s、Gb/s、TB/s 带宽是理想，吞吐量是现实。 带宽指的是最大的发送或接收能力，吞吐量是实际的发送或接收的量。 时延 指数据从网络的一段传送到另一端所需的时间。也叫延迟、迟延。单位是 s。 时延包括 4 大类： 发送时延（传输时延）：一堆数据从开始推送到信道上那一刻起，到全部推完，这个动作持续的时间。 $发送时延 = \\frac {数据长度} {信道带宽(发送速率)}$ 传播时延：一堆数据在数据链路上跑到目的地的用时。取决于电磁波传播速度($2\\times10^8m/s$)和链路长度 $传播时延 = \\frac {链路长度} {电磁波传播速度}$ 排队时延：数据在经过路由器、交换机等设备时不一定能马上处理，需要等待；排队时延指等待输入/输出链路可用这段时间。 排队时延包括等待输入链路时的排队和等待输出链路时的排队。 处理时延：指排队排到了以后，路由器/交换机等设备对数据进行检错、分析的这段时间。 时延 = 发送时延 + 传播时延 + 排队时延 + 处理时延 举个例子：从 A 城拉一车水果到 B 城。 发送时延 = 把水果装到车上的时间 传播时延 = 把车从 A 城开到 B 城花费的时间 排队时延 = 车在路上经过安检，在排队等待安检的这段时间 处理时延 = 被安检这个过程花费的时间 时延带宽积 时延带宽积 bit = 传播时延 s $\\times$ 带宽 bit/s 时延带宽积又称 以比特为单位的链路长度，即某段链路中现在有多少比特。 带宽是最大发送速率，也就是货物装车最快能装多快。 往返时间RTT RTT 指从发送法发送数据开始，到发送方收到接收方的确认（接收方收到数据后立即发送确认）总共经历的时延。 RTT 越大，在收到确认之前，可以发送的数据越多。 RTT 包括 往返传播时延 = 传播时延$\\times$2 + 末端处理时间 RTT 只管信道上的时延，不管主机上的发送时延。 利用率利用率包括信道利用率 和 网络利用率。 $信道利用率 = \\frac {有数据通过时间} {(有+无)数据通过时间}$ 网络利用率 = 信道利用率加权平均值 分层 实体：第 n 层还中的活动元素称为 n 层实体。同一层的实体叫对等实体。 协议：为进行网络中的对等实体数据交换而建立的规则、标准或约定，称为网络协议。[水平] 语法：规定传输数据的格式 语义：规定所要完成的功能 同步：规定各种操作的顺序 接口(访问服务点，SAP)：上层使用下层服务的入口。 服务：下层为相邻上层提供的功能调用。[垂直] PDU = PCI + SDU 数据包 = 上层数据 + 本层协议头 SDU, Service Data Unit，服务数据单元：为完成用户所要求的功能而应传送的数据。 PCI, Protocols Control Infomation，协议控制信息：控制协议操作的信息。 PDU, Protocols Data Unit，协议数据单元：对等层次之间传送的数据单位。 分层的基本原则 各层之间相互独立，每层只实现一种相对独立的功能。 每层之间界面自然清晰，易于理解，相互交流尽可能少。 结构上可分隔开，每层都采用最合适的技术来实现。 保持下层对上层的独立性，上层单向使用下层提供的服务。 整个分层结构应该能促进标准化工作。 网络体系结构是从功能上描述计算机网络结构。 计算机网络体系结构，简称网络体系结构，是分层结构。 每层遵循某个/某些网络协议以完成本层功能。 计算机网络体系结构是计算机网络的各层及其协议的集合。 第 n 层在向 n+1 层提供服务时，此服务不仅包含第 n 层本身的功能，还包含由下层服务提供的功能。 仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。 体系结构是抽象的，而实现是指能运行的一些软件和硬件。 OSI 网络模型 法定标准：7 层 OSI 参考模型 事实标准：4 层 TCP/IP 参考模型 上面 4 层是端到端的通信，下面 3 层是点到点的通信。 应用层：所有能和用户交互产生网络流量的程序。典型应用层服务： 文件传输 FTP 电子邮件 SMTP 万维网 HTTP 表示层：用于处理在两个通信系统中交换信息的表示方式（语法和语义） 功能一：数据格式交换 功能二：数据加密解密 功能三：数据压缩和恢复 会话层：向表示层实体/用户进程提供建立连接并在连接上有序地传输数据。这是会话，也是建立同步（SYN） 功能一：建立、管理、终止会话 功能二：使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步。适用于传输大文件。 主要协议：ADSP、ASP 传输层：负责主机中两个进程的通信，即端到端的通信。传输单位是报文段或用户数据报。 功能一：可靠传输 TCP、不可靠传输 UDP 功能二：差错控制 功能三：流量控制（协调发送端和接收端的速度问题） 功能四：复用分用 复用：多个应用层进程可同时使用下面运输层的服务。 分用：运输层把收到的信息分别交付给上面应用层中相应的进程。 主要协议：TCP、UDP 网络层：主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。传输单位是数据报。 数据报和分组的关系是：数据报过长的时候就可以切成很多个分组。 功能一：路由选择（选择最佳路径） 功能二：差错控制 功能三：流量控制（协调发送端和接收端的速度问题） 功能四：拥塞控制。若所有结点都来不及接收分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要进行拥塞控制。 主要协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF。 数据链路层：主要任务是把网络层传下来的数据报组装成帧。传输单位是帧。 功能一：成帧（定义帧的开始和结束） 功能二：差错控制，包括帧错和位错 功能三：流量控制 功能四：访问（接入）控制，控制对信道的访问 主要协议：SDLC、HDLC、PPP、STP 物理层：主要任务是在物理媒体上实现比特流的透明传输。 透明传输：指不管所传数据是什么样的比特组合，都应当能够在链路上传送。 功能一：定义接口特性，如接头有多少引脚、使用多少跟线、电压所少… 功能二：定义传输模式 单工：只能发送或只能接收 半双工：可以发送或接收，但同一时刻只可以一方在发送或接收 全双工：可以在发送的同时也在接收 功能三：定义传输速率 功能四：比特同步 功能五：比特编码 主要协议：Rj45、IEEE 802.3 主要任务 传输单位 主要协议 应用层 处理用户交互产生的数据 APDU HTTP、FTP、DNS 表示层 处理在两个通信系统中交换信息的表示方式 PPDU JPEG、ASCII 会话层 建立连接，并在连接上有序地传输数据 SPDU ADSP、ASP 传输层 负责主机中两个进程的通信 报文段/用户数据报 TCP、UDP 网络层 源主机到目的主机的数据分组路由与转发 数据报 IP、IPX、ICMP、IGMP、ARP、RARP、OSPF 数据链路层 把网络层传下来的数据报组装成帧 帧 SDLC、HDLC、PPP、STP 物理层 比特传输 比特 Rj45、IEEE 802.3 TCP/IP 网络模型 OSI 模型 TCP/IP 模型 网络层 无连接+面向连接 无连接 传输层 面向链接 无连接+面向连接 面向连接：喂你吃东西之前问你要不要吃，然后给你吃。 无连接：直接塞你嘴里。 面向连接分三个阶段： 建立连接：再此阶段发出一个建立连接的请求； 数据传输：只有在连接成功建立之后，才能开始数据传输； 释放连接：数据传输完成后，释放连接。 无连接：直接进行数据传输。 5层参考模型 数据封装与解封装","categories":[{"name":"408","slug":"408","permalink":"https://www.boii.xyz/categories/408/"},{"name":"NET","slug":"408/NET","permalink":"https://www.boii.xyz/categories/408/NET/"}],"tags":[{"name":"七层模型","slug":"七层模型","permalink":"https://www.boii.xyz/tags/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/"},{"name":"OSI 模型","slug":"OSI-模型","permalink":"https://www.boii.xyz/tags/OSI-%E6%A8%A1%E5%9E%8B/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.boii.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"OneTiny 开发日记-2021-6-29","slug":"Other/OneTiny-开发日记-2021-6-29","date":"2021-06-29T07:58:28.000Z","updated":"2021-06-29T07:58:28.000Z","comments":true,"path":"posts/41947.html","link":"","permalink":"https://www.boii.xyz/posts/41947.html","excerpt":"新增访问层级限制","text":"新增访问层级限制 更新功能没写成，还是没想好怎么处理整个流程。 摆在面前有两个问题： 下载下来的新版本（可执行文件）放在哪 如何关闭自己然后启动新版本 所以暂时搁置，转头去实现访问层级限制功能。 使用中间件这次把中间件用上了，还把之前对浏览器的默认行为：请求 favicon.ico 进行拦截的部分放在单独的中间件里，并且应用到全局。 1234567891011121314151617181920// Start 函数负责启动 gin 实例，开始提供 HTTP 服务func Start() &#123; gin.SetMode(gin.ReleaseMode) r := gin.New() r.Use(gin.LoggerWithWriter(config.Output),gin.Recovery()) // 中间件 r.Use(middleware.InterceptICO) r.Use(middleware.CheckLevel) r.NoRoute(controller.NotFound) r.GET(&quot;/*filename&quot;, controller.Handler) r.POST(&quot;/upload&quot;, controller.Upload) printInfo() err := r.Run(&quot;:&quot; + config.Port) if _, ok := err.(*net.OpError); ok &#123; log.Fatal(color.RedString(&quot;指定的 %s 端口已被占用，请换一个端口号。&quot;, config.Port)) &#125;&#125; 拦截浏览器默认请求行为的中间件： 12345678910111213141516package middlewareimport ( &quot;net/http&quot; &quot;strings&quot; &quot;github.com/gin-gonic/gin&quot;)// InterceptICO 拦截浏览器默认请求 favicon.ico 的行为func InterceptICO(c *gin.Context) &#123; if strings.HasSuffix(c.Param(&quot;filename&quot;), &quot;.ico&quot;) &#123; c.Status(http.StatusOK) c.Abort() &#125;&#125; gin 的封装真的让 web 开发变得很方便，中间件也让代码更加清晰，耦合度降低。Nice！ 新增参数 -x这次新增一个访问层级限制的功能，使用参数 -x 或者 --max 可以指定。 例如： 用户指定共享目录为：/a/b , 最大层级为 2，则访问者最深可以访问到 /a/b/c/d 、/a/b/c/d/file 。 /a/b /a/b/file /a/b/c /a/b/c/file /a/b/c/d /a/b/c/d/file /a/b/c/d/e /a/b/c/d/e/file 其实这个功能有点鸡肋，真实场景下限制访问层级可能不常用，只有一个场景会很常见。 即：共享者只是想开放共享目录那一层给人访问，你可以看到这一层有什么子目录和文件，你可以下载这一层的所有文件，但不能深入访问子目录。 所以我把参数的默认值设置为 0。即只能访问共享目录那一层，如果要开放子目录给人访问，就自己设置 -x 参数。 最核心的就是这个函数： 12345678910111213// 检查当前访问的路径是否超过限定层级func isOverLevel(relPath string, isFile bool) bool &#123; rel, _ := filepath.Rel(config.RootPath, filepath.Join(config.RootPath, relPath)) i := strings.Split(rel, config.SEPARATORS) level := len(i) if i[0] == &quot;.&quot; &#123; level = 0 &#125; if isFile &#123; level-- &#125; return level &gt; int(config.MaxLevel)&#125; 通过 filepath.Rel 把当前访问路径切出来，按照路径分隔符 config.SEPARATORS 切割，判断切割出来的个数是否超过设定的最大访问层级。 如果访问的是共享目录，filepath.Rel 会返回一个单元素切片 [&quot;.&quot;]，应该把 level 修正为 0 。如果访问的是文件，会超出 1 级，应该把 level 自减 1 。 例如 filepath.Rel(&quot;/a/b&quot;, &quot;/a/b/c/file&quot;) 会得到 /c/file，切割得到切片为 [&quot;c&quot; &quot;file&quot;]，level 为 2 。但这个 file 实际上是 c 目录下的一个文件，应该是与 c 同一层级 1，所以做一次自减来修正。 最后今晚想了想，这好像是个 FTP 工具，却用 HTTP 来实现，总感觉怪怪的。有时间研究研究 FTP 协议，看看能不能用 FTP 协议实现吧。","categories":[{"name":"Other","slug":"Other","permalink":"https://www.boii.xyz/categories/Other/"}],"tags":[{"name":"OneTiny","slug":"OneTiny","permalink":"https://www.boii.xyz/tags/OneTiny/"},{"name":"FTP","slug":"FTP","permalink":"https://www.boii.xyz/tags/FTP/"},{"name":"局域网","slug":"局域网","permalink":"https://www.boii.xyz/tags/%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"name":"gin","slug":"gin","permalink":"https://www.boii.xyz/tags/gin/"},{"name":"独立开发","slug":"独立开发","permalink":"https://www.boii.xyz/tags/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91/"}]},{"title":"OneTiny 开发日记-2021-6-25","slug":"Other/OneTiny-开发日记-2021-6-25","date":"2021-06-25T04:57:42.000Z","updated":"2021-06-25T04:57:42.000Z","comments":true,"path":"posts/42715.html","link":"","permalink":"https://www.boii.xyz/posts/42715.html","excerpt":"第一次修改别人的东西哈哈","text":"第一次修改别人的东西哈哈 今天开始给 OneTiny 增加更新的功能，本来想做一个跟 oh-my-zsh 一样的效果，就是会突然跳出来问你是不是要更新，是的话就给你下载最新版然后重启一下终端。 但是写着写着渐渐面临一个问题，下载后放哪？如果是类 Unix 系统怎么把文件放到 /usr/bin 目录下？放完怎么让他自己启动？ 慢慢的又修改思路，换成不自动检查更新或隔一段时间检查，通过 onetiny update 命令可以主动更新。 在写的时候新引入了两个库，一个时负责下载时显示进度的 progressbar，一个是解析命令参数的 flaggy。 修改 progressbar 库 修改内容：修复了多了很多空行的情况 在使用 progressbar 时，跑了官方给出的示例但是没得到官方的效果。 官网给出的例子： 1234567func main() &#123; bar := progressbar.Default(100) for i := 0; i &lt; 100; i++ &#123; bar.Add(1) time.Sleep(40 * time.Millisecond) &#125;&#125; 官方演示的效果：实际跑出来的效果： 12345678910$ go run main.go100% |█████████████████████████████████████| (100/100, 25bit/s) 有很多的空行。应用到 OneTiny 里也是一样，官方并没有给出太多答案。不过进度条的核心就在于 \\r 字符串，于是顺着代码一步步找下去，最后在库的源文件 progressbar.go 中找到了一个函数 clearProgressBar(): 点击查看 `clearProgressBar()` 12345678910111213func clearProgressBar(c config, s state) error &#123; if c.useANSICodes &#123; // write the &quot;clear current line&quot; ANSI escape sequence return writeString(c, &quot;\\033[2K\\r&quot;) &#125; // fill the empty content // to overwrite the progress bar and jump // back to the beginning of the line str := fmt.Sprintf(&quot;\\r%s\\r&quot;, strings.Repeat(&quot; &quot;, s.maxLineWidth)) return writeString(c, str) // the following does not show correctly if the previous line is longer than subsequent line // return writeString(c, &quot;\\r&quot;)&#125; 看到最下面的注释，虽然我不知道上面 return 了下，但是最后一句注释让我觉得有戏。于是我把上面的 return 注释掉，取消了最后一行 return 的注释。 点击查看修改后的 `clearProgressBar()` 12345678910111213func clearProgressBar(c config, s state) error &#123; if c.useANSICodes &#123; // write the &quot;clear current line&quot; ANSI escape sequence return writeString(c, &quot;\\033[2K\\r&quot;) &#125; // fill the empty content // to overwrite the progress bar and jump // back to the beginning of the line- str := fmt.Sprintf(&quot;\\r%s\\r&quot;, strings.Repeat(&quot; &quot;, s.maxLineWidth))- return writeString(c, str) // the following does not show correctly if the previous line is longer than subsequent line+ return writeString(c, &quot;\\r&quot;)&#125; 结果居然正常了…正常了…常了…了… 好吧没时间管那么多，提交了个 issue 给官方就走了。 修改 flaggy 库 修改点：增加了修改 --help 和 --version 的描述信息的接口，增加了打印版本信息的简写 -v 之前使用的是 flag 包解析命令行参数，但这包对子命令不友好。 增加修改 SetHelpFlagDescription 和 SetVersionFlagDescription我准备把原本的命令改成： 12345678 tiny ├── -a --allow 指定是否允许访问者上传。 ├── -r --road 指定对外开放的目录的绝对路径。 (default: /home/boii/...) ├── -p --port 指定开放的端口 (default: 9090) ├── -h --help 打印帮助信息。+ ├── -v --version 打印版本信息。当前版本: v0.2.1+ └── update 更新到最新版本+ └── -l --list 列出当前最新版本和更新内容 增加了打印版本信息、update 子命令； update 子命令不带参数时执行更新。 用 flag 包太麻烦了，找了一会儿 github 之后终于找到一个比较适合的库 flaggy。使用方式和 flag 大体相似，支持子命令等更丰富的功能。 但是在打印 help 信息时，它把 --help 和 --version 的描述写死了，还不提供接口给人修改。 1234567891011121314tiny - 一个用于局域网内共享文件的FTP程序。 Usage: tiny [update] Subcommands: update (u) update 可以帮你进行版本升级 Flags: --version Displays the program version string. -h --help Displays help with available flag, subcommand, and positional value parameters. -r --road 指定对外开放的目录的绝对路径。 (default: /home/boii/...) -p --port 指定开放的端口 (default: 9090) -a --allow 指定是否允许访问者上传。 中英混杂，看着就别扭。 文档中给出的示例也只有一点点，让我猜了好久最后找到了。 点击查看修改步骤 步骤1步骤2步骤3最后使用在 main.go 中增加两个函数，开发者可以通过这两个函数修改默认的描述信息：123456789101112131415161718 // SetName sets the name of the default package command parser func SetName(name string) &#123; DefaultParser.Name = name &#125;+ // SetHelpFlagDescription sets the help flag description of the default package command parser+ func SetHelpFlagDescription(description string) &#123;+ DefaultParser.HelpFlagDescription = description+ &#125;++ // SetVersionFlagDescription sets the version flag description of + the default package command parser+ func SetVersionFlagDescription(description string) &#123;+ DefaultParser.VersionFlagDescription = description+ &#125; // ShowHelpAndExit shows parser help and exits with status code 2 func ShowHelpAndExit(message string) &#123; ...当然，原本的默认描述还是要保留的123456789 // defaultVersion is applied to parsers when they are created const defaultVersion = &quot;0.0.0&quot;+ var defaultHelpFlagDescription = &quot;Displays help with available flag, subcommand, and positional value parameters.&quot;+ var defaultVersionFlagDescription = &quot;Displays the program version string.&quot; // DebugMode indicates that debug output should be enabled var DebugMode bool在 helpValues.go 中修改两处地方：12345678910111213141516171819202122232425 // if the built-in version flag is enabled, then add it as a help flag if p.ShowVersionWithVersionFlag &#123; defaultVersionFlag := HelpFlag&#123; ShortName: &quot;&quot;, LongName: versionFlagLongName,- Description: &quot;Displays the program version string.&quot;,+ Description: DefaultParser.VersionFlagDescription, DefaultValue: &quot;&quot;, Spacer: makeSpacer(versionFlagLongName, maxLength), &#125; h.Flags = append(h.Flags, defaultVersionFlag) &#125; // if the built-in help flag exists, then add it as a help flag if p.ShowHelpWithHFlag &#123; defaultHelpFlag := HelpFlag&#123; ShortName: helpFlagShortName, LongName: helpFlagLongName,- Description: &quot;Displays help with available flag, subcommand, and positional value parameters.&quot;,+ Description: DefaultParser.HelpFlagDescription, DefaultValue: &quot;&quot;, Spacer: makeSpacer(helpFlagLongName, maxLength), &#125; h.Flags = append(h.Flags, defaultHelpFlag) &#125;修改 subCommand.go 中的结构体12345678910111213141516type Subcommand struct &#123; Name string ShortName string Description string+ HelpFlagDescription string // the help flag description+ VersionFlagDescription string // the version flag description Position int // the position of this subcommand, not including flags Subcommands []*Subcommand Flags []*Flag PositionalFlags []*PositionalValue ParsedValues []parsedValue // a list of values and positionals parsed AdditionalHelpPrepend string // additional prepended message when Help is displayed AdditionalHelpAppend string // additional appended message when Help is displayed Used bool // indicates this subcommand was found and parsed Hidden bool // indicates this subcommand should be hidden from help&#125;我也想不明白为啥 DefaultParser 声明是个 *Parser，但是在 VSCODE 中点击跳转会跳到 SubCommand。最后，修改一下 parser.go 中的结构体。123456789101112131415161718192021222324252627282930type Parser struct &#123; Subcommand Version string // the optional version of the parser.+ HelpFlagDescription string // the help flag description+ VersionFlagDescription string // the version flag description ShowHelpWithHFlag bool // display help when -h or --help passed ShowVersionWithVersionFlag bool // display the version when --version passed ShowHelpOnUnexpected bool // display help when an unexpected flag or subcommand is passed TrailingArguments []string // everything after a -- is placed here HelpTemplate *template.Template // template for Help output trailingArgumentsExtracted bool // indicates that trailing args have been parsed and should not be appended again parsed bool // indicates this parser has parsed subcommandContext *Subcommand // points to the most specific subcommand being used&#125;// NewParser creates a new ArgumentParser ready to parse inputsfunc NewParser(name string) *Parser &#123; // this can not be done inline because of struct embedding p := &amp;Parser&#123;&#125; p.Name = name p.Version = defaultVersion+ p.HelpFlagDescription = defaultHelpFlagDescription+ p.VersionFlagDescription = defaultVersionFlagDescription p.ShowHelpOnUnexpected = true p.ShowHelpWithHFlag = true p.ShowVersionWithVersionFlag = true p.SetHelpTemplate(DefaultHelpTemplate) p.subcommandContext = &amp;Subcommand&#123;&#125; return p&#125;12345678910 flaggy.SetName(&quot;tiny&quot;) flaggy.SetVersion(VERSION) flaggy.SetDescription(&quot;一个用于局域网内共享文件的FTP程序。&quot;)+ flaggy.SetHelpFlagDescription(&quot;打印帮助信息。&quot;)+ flaggy.SetVersionFlagDescription(&quot;打印版本信息。当前版本: &quot; + VERSION) flaggy.String(&amp;RootPath, &quot;r&quot;, &quot;road&quot;, &quot;指定对外开放的目录的绝对路径。&quot;) flaggy.String(&amp;Port, &quot;p&quot;, &quot;port&quot;, &quot;指定开放的端口&quot;) flaggy.Bool(&amp;IsAllowUpload, &quot;a&quot;, &quot;allow&quot;, &quot;指定是否允许访问者上传。&quot;) ... flaggy.Parse() 增加打印版本信息的 -v原本的打印信息有两种方式： 1234567# 第一种$ cmd --version0.0.1# 第二种$ cmd version0.0.1 可能是为了把 -v 留给使用者定义成 --verbose 之类的，所以源码中只有几个默认的值： 1234// strings used for builtin help and version flags both short and longconst versionFlagLongName = &quot;version&quot;const helpFlagLongName = &quot;help&quot;const helpFlagShortName = &quot;h&quot; 不过我暂时用不到，我希望能有第三种方式： 123# 第三种$ cmd -v0.0.1 所以进行了以下修改： 步骤1步骤2步骤3main.go 添加 versionFlagShortName 12345 // strings used for builtin help and version flags both short and long const versionFlagLongName = &quot;version&quot;+ const versionFlagShortName = &quot;v&quot; const helpFlagLongName = &quot;help&quot; const helpFlagShortName = &quot;h&quot;helpValues.go 修改一下，这样打印帮助信息的时候才会显示出来 -v 123456789101112 // if the built-in version flag is enabled, then add it as a help flag if p.ShowVersionWithVersionFlag &#123; defaultVersionFlag := HelpFlag&#123;- ShortName: &quot;&quot;,+ ShortName: versionFlagShortName, LongName: versionFlagLongName, Description: DefaultParser.VersionFlagDescription, DefaultValue: &quot;&quot;, Spacer: makeSpacer(versionFlagLongName, maxLength), &#125; h.Flags = append(h.Flags, defaultVersionFlag) &#125;subCommand.go 修改一下，这里主要是让 -v 生效 12345678 // if the flag being passed is version or v and the option to display // version with version flags, then display version if p.ShowVersionWithVersionFlag &#123;- if flagName == versionFlagLongName &#123;+ if flagName == versionFlagLongName || flagName == versionFlagShortName &#123; p.ShowVersionAndExit() &#125; &#125; 同样在 subCommand.go 修改一下，这里主要是检查使用者是不是定义了 -v 或者 –version 1234567891011121314// ensureNoConflictWithBuiltinVersion ensures that the flags on this subcommand do// not conflict with the builtin version flag (-v/--version). Exits the program// if a conflict is found.func (sc *Subcommand) ensureNoConflictWithBuiltinVersion() &#123; for _, f := range sc.Flags &#123; if f.LongName == versionFlagLongName &#123; sc.exitBecauseOfVersionFlagConflict(f.LongName) &#125;- if f.ShortName == versionFlagLongName &#123;+ if f.ShortName == versionFlagShortName &#123; sc.exitBecauseOfVersionFlagConflict(f.ShortName) &#125; &#125;&#125;","categories":[{"name":"Other","slug":"Other","permalink":"https://www.boii.xyz/categories/Other/"}],"tags":[{"name":"OneTiny","slug":"OneTiny","permalink":"https://www.boii.xyz/tags/OneTiny/"},{"name":"FTP","slug":"FTP","permalink":"https://www.boii.xyz/tags/FTP/"},{"name":"局域网","slug":"局域网","permalink":"https://www.boii.xyz/tags/%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"name":"gin","slug":"gin","permalink":"https://www.boii.xyz/tags/gin/"},{"name":"独立开发","slug":"独立开发","permalink":"https://www.boii.xyz/tags/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91/"}]},{"title":"OneTiny 开发日记-2021-6-22","slug":"Other/OneTiny-开发日记-2021-6-22","date":"2021-06-22T00:30:47.000Z","updated":"2021-06-22T00:30:47.000Z","comments":true,"path":"posts/25754.html","link":"","permalink":"https://www.boii.xyz/posts/25754.html","excerpt":"开发 OneTiny 时的一点思路","text":"开发 OneTiny 时的一点思路 需求自从买了台二手 Surface 二合一电脑以后，的确效率上去了，可以手写真香，手终于能跟上脑子了。一开始拿来当出门用的备用机，轻便，但是使用久了以后，渐渐开始有和主力机之间传输文件的需求。最简单的就是拿个 U 盘拷过来拷过去，一次两次还好，多了就烦了。 于是经过搜索我发现了 Python 可以通过在命令行输入 python -m http.server 8000 来暂时开启一个共享目录，同一局域网内的主机就可以访问到这个目录的内容。但是这条命令在 Linux 中可以，在 Windows 下不能执行。 想想这玩意本质就是开启一个 HTTP 服务，指定当前目录为 HTTP 服务的根目录。刚好学了 Gin 框架，而 Golang 又可以编译独立的可执行文件，还可以交叉编译，于是说干就干开始干活。 思路开启一个 HTTP 服务以后，当有人访问时，需要返回目录下的内容。返回的页面采用最简单的效果，基本没有 CSS 。 v0.1 版非常简单，程序启动的时候通过 -r 指定目录，没有的话默认当前目录；通过 -p 可以指定程序运行的端口。 当有人访问时，也就是程序接收到请求，读取目录下所有文件包括目录，交给 HTML 生成器 generateHTML 生成 HTML 内容，然后返回给访问者。 如果用户点击的是目录，则遍历该目录、生成 HTML，返回；如果用户点击的是文件，则触发下载行为，将文件传输给访问者。 v0.1.1 版时重构了 获取IP 函数，解决了 Windows 下给出的无效 IP 的问题，并修复了下载文件异常的问题。 到这里 OneTiny 作为一个局域网 FTP 工具已经可以提供稳定的服务了。 但是只能单向下载文件还不够，如果能上传就好了，有来有回。 于是 v0.2 版新增了上传功能，并且在 HTML 部分增加了显示文件大小、返回上一级目录的链接。 这一版在新增功能的时候做了一部分重构。由于 0.1 版直接获取请求路径中的参数导致代码耦合度非常高，所以创建了一个 FileStruction 的模型，用于存储文件的绝对路径、相对路径、文件大小等信息。 v0.2.1 版的时候觉得，有时候开放一个目录供人下载文件，但不希望对方上传文件上来，所以需要一个开关来设置是否允许上传。于是增加了 -a 的参数，默认不可以上传，除非加上 -a 参数才会在客户端展示的时候展示出上传框。 v0.2.2 版对整个程序做了较大幅度的重构，将一些全局的变量移动到 config 包，然后把启动 Gin 实例的部分移动到 start 包，并做了对 -p 、-r 参数的校验，避免用户指定系统预留的端口，或者输入一个不存在的目录作为访问根目录。还另外增加了 color 包用于控制台彩色打印（windows 除外）。 后记这是我的第一个规范使用 Git 维护的独立项目，源自自身实际需求。虽然市面上有许多现成的好看的功能更强大的 FTP 工具，但是我觉得那些太复杂，且需要安装等等。我更愿意使用一个简简单单的只负责在局域网内的设备间传输文件的工具，除了必要的功能不添加太多复杂的功能，所以连界面也采用最简单的 “裸 HTML” 。（我也不喜欢把时间花在写出华丽的界面上，而更愿意把时间拿来完善和增强本身的功能） 简单、专注、无需安装，这些是 OneTiny 的特点，也是 OneTiny 的局限。我希望除了图形界面版本，OneTiny 能一直保持这种大道至简的风格，专注与局域网 FTP 这个职责即可。 Давай! Todo 上传功能 自动检查更新功能 密码验证功能（防止局域网内监听） 增加图形界面（使用 fyne） 限定访问层级 限定允许上传位置 大文件多线程下载 断点续传 版本历史 2021-06-16 0.2.1 -&gt; 0.2.2 Refactor: 对gin实例启动部分进行重构，移动至 start 包内；新增 config 包Style：控制台增加彩色打印（windows除外）Fix: 增加 flag 参数的验证 2021-06-16 v0.2 -&gt; v0.2.1 Feat: 新增 允许上传 flag -a 2021-06-11 v0.1.1 -&gt; v0.2 Feat: 新增上传功能Style: 文件列表增加 文件大小，增加返回上一级目录链接 2021-06-11 v0.1 -&gt; v0.1.1 Fix: 修复了下载文件异常Refactor: 重构了获取IP函数 2021-06-11 nil -&gt; v0.1 首个版本，具有局域网内单向共享文件的功能，未具有上传功能。可通过 -p 指定端口，通过 -r 指定目录","categories":[{"name":"Other","slug":"Other","permalink":"https://www.boii.xyz/categories/Other/"}],"tags":[{"name":"OneTiny","slug":"OneTiny","permalink":"https://www.boii.xyz/tags/OneTiny/"},{"name":"FTP","slug":"FTP","permalink":"https://www.boii.xyz/tags/FTP/"},{"name":"局域网","slug":"局域网","permalink":"https://www.boii.xyz/tags/%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"name":"gin","slug":"gin","permalink":"https://www.boii.xyz/tags/gin/"},{"name":"独立开发","slug":"独立开发","permalink":"https://www.boii.xyz/tags/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91/"}]},{"title":"DataStruction 0x09 图-3","slug":"408/DataStruction/DataStruction [9-图3]","date":"2021-02-23T08:00:44.000Z","updated":"2021-07-19T08:56:49.546Z","comments":true,"path":"posts/1aa7bff2.html","link":"","permalink":"https://www.boii.xyz/posts/1aa7bff2.html","excerpt":"图的应用: 最小生成树、最短路径、拓扑排序、关键路径","text":"图的应用: 最小生成树、最短路径、拓扑排序、关键路径 9-图3图在现实中有着许多的应用，帮助人们解决了许多问题，同时图的应用也是比较晦涩难懂的地方。 本文图的应用共有： 最小生成树 最短路径法 拓扑排序 关键路径 从图结构的角度看，图的应用有两种：一种的解决无向图的，一种是解决有向图的。更详细的看： 最小生成树使用的是贪心算法，得到的是局部最优解，有可能得到的不是全局最优解 最短路径法使用的是动态规划，得到的是全局最优解 拓扑排序关注的是点 关键路径关注的是边 接下来每讲一个应用之前我会先举一个场景，这样学习的时候才不至于不知道用来干嘛的。 最小生成树 Minimum Spanning Tree应用场景假设现在有 北、上、广、深、杭、厦 几个城市，他们之间要建立通信联络网。一共有 6 个城市，他们之间最少只需要 6 - 1 = 5 条通信线路即可连通。但是各个城市之间的距离是不同的，距离越远，建立费用越高（即距离和费用成正比）。所以，问题就是：怎么样让这 6 个城市建立起通信联络网，并且建立费用最低？ 答案是使用最小生成树。 理解要理解最小生成树，可以从最小和树去理解。 先理解「树」：首先，生成树是一颗树，那么一堆顶点要生成一棵树，就不能有环其次，每个顶点都不能落下，所以这些顶点得组成一个连通图 接着理解「最小」：一张网，也就是路径上带权值的图，可以有很多生成树，而最小生成树则是：所有生成树里路径权值总和最小的一颗生成树。 普里姆算法 (Prim)从任一顶点出发，将其加入已选顶点数组、其邻接的边加入备选边数组；选取该顶点权值最小的一条边，所连接的顶点也加入已选顶点数组，并将该边 克鲁斯卡尔算法 (Kruskal)克鲁斯卡尔算法适合求 稀疏网 的最小生成树。 克鲁斯卡尔算法的做法是将每一条边和权值存储到数组中，然后 进行一次从小到大的排序。 从最小的边开始，将边放置到顶点上。放置前判断是否产生环： 是：跳过这条边 否：放置这条边 重复步骤 1 总共放置顶点总数 - 1 次即可。 12345678910111213141516171819202122typedef struct &#123; Vertex a, b; int Weight;&#125; Edge;Edge net[];void Kruskal() &#123; sort(net); int n = 0; for (size_t i = 0; i &lt; len(net); i++) &#123; if (n &gt; VertexCount-1) break; if (isCycle(net[i].a)) &#123; continue &#125; else &#123; addEdge(net[i]); n++; &#125; &#125;&#125; 先将每条边和其权值存储到数组里，做一个从小到大的排序遍历数组，判断是否产生环 是：删除该边 否：将边放入图中，进入下一轮 循环次数：顶点总数 - 1 最短路径最短路径和最小生成树都是求几个顶点之间的最短的路径，区别在于： 最小生成树的思想是使用贪心算法，而贪心算法能获得的是局部最优解，不一定是全局最优解 最短路径的思想则是使用动态规划，而动态规划能获得的是全局最优解 迪杰斯特拉算法 (Dijkstra)弗洛伊德算法 (Floyd)拓扑排序AOV-网 (Activity On Vertex Network)关键路径AOE-网 (Activity On Edge Network)","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"DataStruction 0x08 图-2","slug":"408/DataStruction/DataStruction [8-图2]","date":"2021-02-23T08:00:43.000Z","updated":"2021-07-19T08:56:49.384Z","comments":true,"path":"posts/55493.html","link":"","permalink":"https://www.boii.xyz/posts/55493.html","excerpt":"图的存储","text":"图的存储 8-图2图的ADT12345678910111213141516171819202122ADT 图 GraphData 顶点的有穷非空集合和边的集合Operation CreateGraph(*G, V, E): 按照顶点集V和边集E的定义构造图G DestoryGraph(G*): 图G存在则销毁 LocateVex(G*, v): 若图G中存在顶点v，则返回v在图中的顶点数组的下标 GetVex(G*, v): 返回图中顶点v的值 PutVex(G*, v, value): 将图G中顶点v赋值value FirstNeighbor(G*, v): 返回顶点v的第一个邻接点，若无则返回空 NextNeighbor(G*, v1, v2): 返回顶点v1相对于顶点v2的下一个邻接点，若v2是v1的最后一个邻接点则返回空 InsertVex(G*, v): 在图G中增加顶点v DeleteVex(G*, v): 删除图G中顶点v及其相关的边/弧 InsertArc(G*, v1, v2): 在图G中增加弧&lt;v1, v2&gt;，若G是无向图，还需添加对称弧&lt;v2, v1&gt; DeleteArc(G*, v1, v2): 在图G中删除弧&lt;v1, v2&gt;，若G是无向图，还需删除对称弧&lt;v2, v1&gt; DFSTraverse(G*): 对图G中进行深度优先遍历 BFSTraverse(G*): 对图G中进行广度优先遍历 Adjacent(G*, v1, v2): 判断图G中是否存在边/弧&lt;v1, v2&gt; Neighbors(G*, v): 列出图G中与顶点v邻接的边 GetEdgeValue(G*, v1, v2): 获取图G中边/弧&lt;v1, v2&gt;对应的权值 SetEdgeValue(G*, v1, v2, value): 设置图G中边/弧&lt;v1, v2&gt;对应的权值为valueendADT 图的存储结构图的顶点之间没有次序关系，且顶点的邻接情况多变，无法用统一的格式来存储。 图的存储结构总共有以下 5 种方式： 邻接矩阵 邻接表 十字链表 邻接多重表 边集数组 邻接矩阵 Adjacent Matrix图的邻接矩阵的存储方式是用两个数组来表示图。一个一维数组用来存储图中的顶点集，一个二维数组（称为邻接矩阵）用来存储图中的边集。图的邻接矩阵表示法 = 一维数组 $\\times$ 1 + 二维数组 $\\times$ 1 设 图G 有 n 个顶点，则邻接矩阵是一个 $n \\times n$ 的方阵，定义为： $$Arc[i][j] =\\begin{cases}1, &amp; {(v_i, v_j) \\in E 或 \\langle v_i, v_j \\rangle \\in E} \\\\0, &amp; {反之}\\end{cases}$$ 无向图理论描述顶点集很容易表示，使用顶点结构类型的一维数组来存储顶点信息。边集可以用 矩阵(Metrix) 来表示，而矩阵在计算机中可以使用二维数组来实现。 eg: 这个图的边集可以变成下面的矩阵： $$\\begin{bmatrix}0 &amp; 1 &amp; 1 &amp; 0 \\\\1 &amp; 0 &amp; 1 &amp; 0 \\\\1 &amp; 1 &amp; 0 &amp; 1 \\\\0 &amp; 0 &amp; 1 &amp; 0\\end{bmatrix}$$ 所以对于图 G =（V, {E}），可以使用一个一维数组来存储顶点集 V，再用一个二维数组来存储边集 E。于是一张图可以变成下图所示： 上图中，有一个结构体 struct Graph，结构体中包含一个一维数组 Vertex[] 和一个二维数组 Edge[][]，一个 v_count 存储顶点数，一个 e_count 存储边数。 Vertex[] 用来存储顶点信息，Edge[][] 用来存储边的信息。 例如 (v1, v2) 就将 Edge[0][1] 置为1；而 (v1, v2) 也可以表示为 (v2, v1) ，所以 Edge[1][0] 也应置为1。而简单图不会有自己邻接自己的边，所以 Edge[0][0]、Edge[1][1]、Edge[2][2]、Edge[3][3] 均为0。 稍微观察可以发现，无向图的邻接矩阵一定是一个对称矩阵[^1]，于是我们可以很容易知道图中的信息： 某个顶点的度，起始就是这个顶点 vi 在邻接矩阵中第 i 行（或第 i 列）的元素之和。eg：顶点 v3 的度就是 1+1+0+1 = 3 求顶点 vi 的所有邻接点就是在邻接矩阵中第 i 行所有元素为 1 的点。eg：顶点 v2 的所有邻接点就遍历 Edge[1][…]，其中为 Eege[1][0]、Edge[1][2] 为1，表示 v1 和 v3 为邻接点。 代码实现1234567891011121314151617181920212223242526// GraphModel.h#ifndef GRAPH_MODEL_H_INCLUDED#define GRAPH_MODEL_H_INCLUDED#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define MAX 4typedef enum &#123; ERROR, OK,&#125; Status;typedef enum &#123; DG, // 有向图 UDG, // 无向图 DN, // 有向网 UDN, // 无向网&#125; GraphKind;typedef char* Vertex; // 顶点数组类型typedef int Edge; // 邻接矩阵类型#endif // GRAPH_MODEL_H_INCLUDED 123456789101112131415161718192021222324252627282930// MatrixGraph.h#ifndef MATRIX_GRAPH_H_INCLUDED#define MATRIX_GRAPH_H_INCLUDED#include &quot;GraphModel.h&quot;typedef struct &#123; Vertex vers[MAX]; // 顶点数组 Edge edges[MAX][MAX]; // 邻接矩阵（边数组） size_t v_count; // 顶点总数 size_t e_count; // 边总数 GraphKind kind; // 图类型&#125; MatrixGraph;/** * @description: 创建无向图 * @param G 要操作初始化的图 * @return 成功返回OK，失败返回ERROR */Status CreatUDG(MatrixGraph* G);/** * @description: 返回某个顶点在顶点集合中的下标 * @param G 要查找的图结构 * @param v 顶点 * @return 返回下标，不存在返回-1 */int LocateVex(MatrixGraph* G, Vertex v);#endif // MATRIX_GRAPH_H_INCLUDED 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// MatrixGraph.c#include &quot;MatrixGraph.h&quot;Status CreatUDG(MatrixGraph* G)&#123; G-&gt;kind = UDG; printf(&quot;Please type the count of Vertex : &quot;); scanf(&quot;%d&quot;, &amp;G-&gt;v_count); printf(&quot;Please type the count of Edge : &quot;); scanf(&quot;%d&quot;, &amp;G-&gt;e_count); // 录入顶点数组 printf(&quot;Please type Vertex in turn.\\n&quot;); for (int i = 0; i &lt; G-&gt;v_count; i++) &#123; G-&gt;vers[i] = calloc(10, sizeof(Vertex)); printf(&quot;Vertex %d :&quot;, i); scanf(&quot;%s&quot;, G-&gt;vers[i]); &#125; // 初始化邻接矩阵，所有边的权值设置为0 for (int i = 0; i &lt; G-&gt;v_count; i++) &#123; for (int j = 0; j &lt; G-&gt;v_count; j++) &#123; G-&gt;edges[i][j] = 0; &#125; &#125; // 录入邻接矩阵 printf(&quot;Please type Vertex and Adjacent. \\n&quot;); for (int i = 0; i &lt; G-&gt;e_count; i++) &#123; Vertex v1 = calloc(10, sizeof(Vertex)); Vertex v2 = calloc(10, sizeof(Vertex)); printf(&quot;Vertex %d : &quot;, i + 1); scanf(&quot;%s&quot;, v1); printf(&quot;Adjacent %d : &quot;, i + 1); scanf(&quot;%s&quot;, v2); /** 核心代码 begin */ // 获取顶点的下标 int x = LocateVex(G, v1); int y = LocateVex(G, v2); if (x == -1 || y == -1) return ERROR; // 对应位置置为1 G-&gt;edges[x][y] = 1; G-&gt;edges[y][x] = 1; /** 核心代码 end */ free(v1); free(v2); &#125; return OK;&#125;int LocateVex(MatrixGraph* G, Vertex v)&#123; int index = 0; while (index &lt; G-&gt;v_count) &#123; if (strcmp(v, G-&gt;vers[index]) == 0) &#123; break; &#125; index++; &#125; return index == G-&gt;v_count ? -1 : index;&#125;void Test()&#123; MatrixGraph G; Status status = CreatUDG(&amp;G); if (status = ERROR) &#123; printf(&quot;Create Graph Failed~&quot;); return; &#125; printf(&quot;The Adjacent Matrix: \\n&quot;); printf(&quot;\\t&quot;); for (int i = 0; i &lt; G.v_count; i++) &#123; printf(&quot;\\t%s&quot;, G.vers[i]); &#125; printf(&quot;\\n&quot;); for (int i = 0; i &lt; G.e_count; i++) &#123; printf(&quot;\\t%s&quot;, G.vers[i]); for (int j = 0; j &lt; G.e_count; j++) &#123; printf(&quot;\\t%d&quot;, G.edges[i][j]); &#125; printf(&quot;\\n&quot;); &#125;&#125; 1234567#include &quot;MatrixGraph.c&quot;int main(int argc, char const* argv[])&#123; Test(); return 0;&#125; 有向图理论描述有向图和无向图的区别在于邻接矩阵。 在有向图邻接矩阵中，第 i 行含义：以结点 vi 为尾的弧（即出度边）第 i 列含义：以结点 vi 为头的弧（即入度边） 其特点为： 无向图的邻接矩阵一定是对称的，当有向图的邻接矩阵不一定是对称的。 顶点 vi 的出度 = 第 i 行元素之和 顶点 vi 的入度 = 第 i 列元素之和 顶点 vi 的度 = 第 i 行元素之和 + 第 i 列元素之和 口诀：Arc[行][列]Arc[出][入]列头入，行尾出：即 列为弧头、入度；行为弧尾、出度。 代码实现在代码实现上，有向图与无向图唯一的区别在于：录入弧的数据之后，只需要执行赋值一次就可以。 12G-&gt;edges[x][y] = 1;// G-&gt;edges[y][x] = 1; 这里我将有向图和无向图的创建合并在一起，在调用函数时多传入一个 GraphKind 类型参数来区分。 123456789101112131415161718192021222324252627282930313233343536Status CreatGraph(MatrixGraph* G, GraphKind kind)&#123; G-&gt;kind = kind; // 录入顶点数和边数 ... // 录入顶点数组 ... // 初始化邻接矩阵，所有边的权值设置为0 ... // 录入邻接矩阵 printf(&quot;Please type %s and %s. \\n&quot;, kind == UDG ? &quot;Vertex&quot; : &quot;InDegree&quot;, kind == UDG ? &quot;Adjacent&quot; : &quot;OutDegree&quot;); for (int i = 0; i &lt; G-&gt;e_count; i++) &#123; Vertex v1 = calloc(10, sizeof(Vertex)); Vertex v2 = calloc(10, sizeof(Vertex)); printf(&quot;%s %d : &quot;, kind == UDG ? &quot;Vertex&quot; : &quot;OutDegree&quot;, i + 1); scanf(&quot;%s&quot;, v1); printf(&quot;%s %d : &quot;, kind == UDG ? &quot;Adjacent&quot; : &quot;InDegree&quot;, i + 1); scanf(&quot;%s&quot;, v2); int x = LocateVex(G, v1); int y = LocateVex(G, v2); if (x == -1 || y == -1) return ERROR; G-&gt;edges[x][y] = 1; G-&gt;edges[y][x] = kind == UDG ? 1 : 0; // 无向图置为1，有向图保持默认 free(v1); free(v2); &#125; return OK;&#125;// Status status = CreatGraph(&amp;G);Status status = CreatGraph(&amp;G, DG); 同时，有向图的顶点的度 = 出度 + 入度，可以实现一个函数根据图的类型来返回顶点的度。 12345678910111213141516171819/** * @description: 获取某个顶点的度 * @param G 要查找的图 * @param v 要查询度的顶点 * @return 该顶点的度 */size_t GetDegree(MatrixGraph* G, Vertex v)&#123; // 获取无向图的度：累加第i行或第i列的元素之和 // 获取有向图的度：累加第i行和第i列的元素之和并相加 int index = LocateVex(G, v); int inDegree = 0; int outDegree = 0; for (int i = 0; i &lt; G-&gt;e_count; i++) &#123; inDegree += G-&gt;edges[i][index]; outDegree += G-&gt;edges[index][i]; &#125; return G-&gt;kind == UDG ? inDegree : inDegree + outDegree;&#125; 无向图的度只需要返回行的和或列的和就行，有向图的度则需要相加再返回。 网边或弧带权的图即为网。 理论描述设 图G 有 n 个顶点，则邻接矩阵是一个 $n \\times n$ 的方阵，定义为： $$Arc[i][j] =\\begin{cases}W_{ij}, &amp; {(v_i, v_j) \\in E 或 \\langle v_i, v_j \\rangle \\in E} \\\\0, &amp; {i=j} \\\\∞, &amp; {反之}\\end{cases}$$ 这里 $W_{ij}$ 表示 $\\langle v_i, v_j \\rangle$ 或 $(v_i, v_j)$ 上的权值。$\\infty$ 表示一个计算机允许的、大于所有边上权值的值，即一个不可能的极限值，在C语言中可以使用 INT_MAX 来表示无穷。 代码实现网的大部分代码与有向图和无向图的相同的，只有几处需要修改。 123456// 初始化邻接矩阵，所有边的权值设置为无穷for (int i = 0; i &lt; G-&gt;v_count; i++) &#123; for (int j = 0; j &lt; G-&gt;v_count; j++) &#123; G-&gt;edges[i][j] = INT_MAX; &#125;&#125; 在初始化时，不能初始化为0，而要初始化为 INT_MAX。 12345678910111213141516171819202122232425// 录入邻接矩阵 printf(&quot;Please type %s and %s. \\n&quot;, kind == UDN ? &quot;Vertex&quot; : &quot;InDegree&quot;, kind == UDN ? &quot;Adjacent&quot; : &quot;OutDegree&quot;); for (int i = 0; i &lt; G-&gt;e_count; i++) &#123; Vertex v1 = calloc(10, sizeof(Vertex)); Vertex v2 = calloc(10, sizeof(Vertex)); int weight = 0; // 权值 printf(&quot;%s %d : &quot;, kind == UDN ? &quot;Vertex&quot; : &quot;OutDegree&quot;, i + 1); scanf(&quot;%s&quot;, v1); printf(&quot;%s %d : &quot;, kind == UDN ? &quot;Adjacent&quot; : &quot;InDegree&quot;, i + 1); scanf(&quot;%s&quot;, v2); printf(&quot;Value %d: &quot;, i + 1); scanf(&quot;%s&quot;, &amp;weight); int x = LocateVex(G, v1); int y = LocateVex(G, v2); if (x == -1 || y == -1) return ERROR; G-&gt;edges[x][y] = weight; G-&gt;edges[y][x] = kind == UDN ? weight : INT_MAX; free(v1); free(v2); &#125; 录入邻接矩阵时也需要多录入一个权值。 12345678// 邻接矩阵for (int i = 0; i &lt; G.e_count; i++) &#123; printf(&quot;\\t%s&quot;, G.vers[i]); for (int j = 0; j &lt; G.e_count; j++) &#123; printf(&quot;\\t%s&quot;, G.edges[i][j] == INT_MAX ? &quot;∞&quot; : (char*)G.edges[i][j]); &#125; printf(&quot;\\n&quot;);&#125; 打印时也稍作处理。 邻接表 Adjacent List邻接矩阵适合处理稠密图，对于稀疏图，邻接矩阵会造成巨大的浪费。在数据结构中，解决浪费问题需要往链式结构的方向去想。 图的邻接表的存储方式是用一维数组和单链表来表示图。一个一维数组用来存储图中的顶点集，多个单链表用来存储图中的边集。图的邻接矩阵表示法 = 一维数组 $\\times$ 1 + 单链表 $\\times$ n 无向图的邻接表邻接表的处理方法如下： 图的顶点集用一维数组存储，数组元素为 数据域(data) + 首邻接点域(firstEdge)； 图的边/弧集用单链表存储，链表结点由 邻接点域(adjvex) + 指针域(next) 构成； 首邻接点域 指的是顶点的第一个边链表结点的地址，链表中的 邻接点域 存储的是邻接点的在顶点数组中的下标。 从上图可以看出，一个无向图可以用一个顶点类型的一维数组来存储顶点，每个顶点都各自有一条边链表，存储着该顶点的所有邻接点； 顶点数组中的某个顶点 Vertex[i] 和 对应边链表中的任一个结点构成了一条边。 eg： $v_1$ 的邻接点是 $v_2$ 和 $v_3$，在顶点数组中 $v_1$ 的下标是 0；在 Vertex[0] 数据域(data) 中存着 $v_1$，首邻接点域(firstEdge) 存储着边链的第一个结点的地址；在边链的第一个结点中，邻接点域(adjvex) 存储着 $v_2$ 的下标 1，然后指针域(next) 指向下一个结点；下一个结点的邻接点域存储着 $v_3$ 的下标 2，后面不再有了，所以指针域为空。 仔细观察可以发现以下特点： 无向图的邻接表重复存储着数据（邻接矩阵里也是），但总比邻接矩阵节省空间。 边链中的结点，除了与顶点数组中的元素，相互之间没有关系。 顶点的度 = 它的边链的结点数 求顶点的所有邻接点 = 遍历顶点的边链并取邻接点域 如果有 n 条边，则边链表会有 2n 个结点 有向图的邻接表有向图的邻接表是类似的，但有向图区分方向。 我们以顶点为弧尾来存储边链表，并称这样的边链表为出边表，或正邻接表我们以顶点为弧头来存储边链表，并称这样的边链表为入边表，或逆邻接表 右上出边表 和 右下入边表 右上为出边表，右下为入边表 出边表中，顶点 v1 作为弧尾，邻接弧头 v2，所以首邻接点与指向出边表的第一个结点，结点中的数据域存储着弧头 v2 的下标 1。所以 v1 和 Vertex[1] 共同组成一条弧。 而顶点 v2 有 2 个出度，所以 v2 的出边表中有 2 个结点。 入边表中，顶点 v3 作为弧头，邻接弧尾 v2 和 v4，所以首邻接点指向入边表的第一个结点，结点中存着 v2 的下标 1，第二个结点存着 v4 下标 3。 观察两个表，可以发现以下特点： 使用入边表表示图时，顶点的入度 = 对应入边表的结点数量，要计算出度只能遍历所有边链表 使用出边表表示图时，顶点的出度 = 对应出边表的结点数量，要计算入度只能遍历所有边链表 边链表中的结点，除了与顶点元素，相互之间没有关系 弧的总数 = 所有边链表的结点的总数之和 有向网的邻接表有向网和无向网的邻接表仅仅只是在边链表中的结点增加一个变量 weight 来存储权值。同样有有向无向、出边入边之分。 代码实现12345678910111213141516171819202122// 边链表结点类型typedef struct node&#123; int adjvex; // 邻接点域、邻接点下标 struct node* next; // 指针域&#125; EdgeNode, ArcNode;// 顶点类型typedef char* Vertex;// 顶点结点类型typedef struct &#123; Vertex data; // 数据域 EdgeNode firstEdge; // 首邻接点域&#125; VertexNode;// 图类型typedef struct &#123; VertexNode vexs[MAX]; // 顶点结点数组 int v_count; // 顶点数量 int e_count; // 边/弧数量 GraphKind kind; // 图类型&#125; AdjListGraph; 十字链表 Orthogonal List十字链表主要针对有向图，适用于需要频繁获取顶点的入度和出度，频繁地判断一个点是不是另一个点的邻接点等的情况。其核心思想是将出边表和入边表整合起来。 有向图的邻接表只有表示出度的出边表，或者表示入度的入边表，鱼和熊掌不可兼得。 对于这种情况，小孩子才做选择，大人全都要！ 于是我们可以改造一下顶点数组，让一个顶点数组的元素包含 顶点、出边表的首邻接点域、入边表的首邻接点域 data 表示顶点，iFirst 表示入边表的首邻接点域，oFirst 表示出边表的首邻接点域。 于是我们可以得到一个这样的双邻接表： ←图结构，↑出边表，↓入边表，→双邻接表 最左边是图结构，中间上面是出边表，中间下面是入边表，将它们结合，就成了最右边的双邻接表 下一步我们改造一下边链表的结点，让它由 弧尾下标 + 弧尾边链的指针域 + 弧头下标 + 弧头边链的指针域 构成。 oVex 表示弧中出边的结点，即弧尾结点，的下标；oNext 替代了原出边表结点里的指针域；iVex 表示弧中入边的结点，即弧头结点，的下标；iNext 替代了原入边表结点里的指针域； 现在对双邻接表进行改造： 然后我们会发现有很多重复的结点，我们保留一个，删除一个： 接着把被删除的地方的链指向保留下来的那个结点： 例如 v1 的出边表第一个结点（v1 红色线条指向的那个 0 和 1 的结点） 和 v2 的入边表的第一个节点（v2 蓝色线条指向的那个 0 和 1 的结点）， 这两个结点相同， 于是我删掉其中 v2 的那个，然后让 v2 的蓝色线指向 v1 的第一个结点，其他结点也是同样操作。 最后整理一下就是下图的样子： 对比一下该图的顶点 v2 的出边表和十字链表： 可以看到没有损失任何信息。 代码实现1234567891011121314151617181920212223242526/** 顶点类型 */typedef char* Vertex;/** 十字链表结点 */typedef struct node&#123; Vertex oVex; // 弧头下标 Vertex iVex; // 弧尾下标 struct node* oNext; // 出边表指针域 struct node* iNext; // 入边表指针域 int weight; // 权值&#125; OrthoNode;/** 顶点数组元素类型 */typedef struct &#123; Vertex data; // 顶点 OrthoNode iFirst; // 入边表的首个结点 OrthoNode oFirst; // 出边表的首个节点&#125; VertexNode;/** 图结构 */typedef struct &#123; VertexNode vexArray[MAX]; // 顶点数组 int v_count; // 顶点数量 int a_count; // 弧的数量 GraphKind kind; // 图的类型（有向图/有向网）&#125; OrthoGraph; 总结十字链表5步走：生成有向图的出边表和入边表组合成双邻接表改造链表结点删除重复结点连接 邻接多重表 Adjacent Multilist List邻接多重表主要是针对无向图。 从图中可以发现边链结点很多都是重复的。当删除一条边时，需要到两条边链中删除。例如删除 边(v1, v3)，需要找到 v1 的边链，删除第二个结点，然后还要找到 v3 的边链，然后删除第一个结点。显然这是比较繁琐的。 所以邻接多重表就在邻接表的基础上对边链的结点进行改造。 邻接表的结点由 邻接点的下标 + 下一结点指针 构成邻接多重表的结点由 顶点下标 + 顶点的下一结点的指针 + 邻接点下标 + 邻接点的下一结点的指针 构成 其思想是将所有顶点的边链整合起来，即节省空间，也提高了操作效率。 下面介绍一下如何将邻接表改为邻接多重表： 首先将 边链的结点进行改造：边链结点中不仅要填入邻接点的下标，还要填入顶点自己的下标。 例如 顶点 v1 有两个邻接点 v2 和 v3，所以要在两个结点中的 ivex 处填入 v1 的下标 0。其他结点同理。看不懂可以对比两个图的边链。 例如 v1 的第一个边链结点中有 0 和 1，代表 v1 的地址和 v2 的地址；v2 的第一个边链结点也有 1 和 0，所以随便保留哪一个都可以。 图中将 v2 的第一个边链结点删除，然后让 v1 的第一个边链结点也成为 v2 的边链结点。 这一步怎么删，删完指向谁可能有点乱，请看下面的图。 这里左侧两个图结构是同一个，第二个图结构多做了4条辅助线用来对照，实际真正的图是第一个的图结构，不要混淆。对照第二个的图结构，和右侧的邻接多重表： 顶点 v1 有两条边，邻接 v2 和 v3，在邻接多重表中用红色线连接起来了。单独观察 VertexNode[0] 和 红色线连接的两个结点，是不是跟邻接表相似？ 同样道理可以继续观察 v2、v3、v4。 我们会发现邻接多重表的结点数少了，而且结点总数刚好就是边数。 现在再来体会那句：将所有边链整合起来，再体会体会为什么要增加 inext 和 jnext 两个元素在结点中，其实就是为了保留原本的信息。 邻接多重表中边链的结点不分是谁的，只记录边两头两个顶点的下标。 扩展一下，如果无向网使用邻接多重表表示，是不是只要将边链结点多加一个 权值 的成员即可？如果还要再来个是否被搜索过的标记，是不是再加个 布尔值 的成员即可？ 边集数组 Edgeset Array边集数组是由两个一维数组构成，一个是存储顶点的信息，另一个是存储边的信息。这个边数组的每个元素由一条边的起点下标 (begin) 、终点下标 (end) 和权 (weight) 组成。边集数组关注的是边的集合。在边集数组中要查找一个顶点的度需要扫描整个边数组，效率不高，因此更适合对边依次进行处理的操作，而不适合对顶点相关的操作。 适用情况总结 邻接矩阵适合处理稠密图 邻接表适合处理稀疏图 十字链表适合于需要频繁获取顶点的入度和出度，频繁地判断一个点是不是另一个点的邻接点等的情况 邻接多重表主要是针对无向图 边集数组适合对边依次进行处理的操作，而不适合对顶点相关的操作 图的遍历深度优先搜索 DFS深度优先遍历 (Depth-First-Search) 是仿树的前序遍历，该算法是利用栈来实现，也就是递归，所以在 DFS 中会有递归和回溯的说法。 DFS 需要借助一个数组来记录访问状态，这里将其称作状态数组（Status Array）；该数组长度为顶点总数，次序与顶点数组相同。 从某一个顶点 vi 出发，则当前顶点为 vi； 先将该顶点标记为已访问，然后遍历其所有邻接点，找到 第一个未访问的邻接点 vj 并置为当前顶点； 接着从该顶点 vj 出发，先标记为已访问，然后遍历找到 第一个未访问的邻接点 vk 并置为当前顶点… 以此类推 例如上图左边是一个图，我们可以转换一下思维，像右图一样把那两条边当作没有，就可以看成一棵二叉树 运用树的前序遍历法可以得到：v0 -&gt; v1 -&gt; v5 -&gt; v2 -&gt; v4 -&gt; v3，而这正好就是 DFS 的结果。 回过头来重新看着左边的图，假设从 v0 出发（其实图是无序的，从任何一点出发都可以）； v0 有两个邻接点 v1 和 v3，我们先选择 v1，然后从 v1 出发； v1 有两个邻接点 v5 和 v0，v0 已经访问过了，只能选择 v5，然后从 v5 出发； v5 有三个邻接点 v1、v2、v3，v1 已经访问过了，我们先选择 v2 ，然后从 v2 出发； v2 有两个邻接点 v5 和 v4，v5 已经访问过了，只能选择 v4，然后从 v4 出发； v4 有两个邻接点 v2 和 v3，v2 已经访问过了，只能选择 v3，然后从 v3 出发； v3 有三个邻接点 v4、v5、v0，全都访问过了，到此遍历也就结束了。 如果仔细阅读上面6个步骤会发现，当我们遍历时，我们需要知道这个顶点是不是被访问过了，所以我们需要一个状态数组来记录； 而当有多个邻接点可以访问时，我们选择的依据，其实是顶点在顶点数组中存储的顺序所决定的。 例如在 v5 的时候，选择了 v2 而不是 v3，其实是我们默认顶点数组是按照 v0、v1、v2、v3、v4、v5 的顺序存储，假设是按照 v0、v1、v3、v2、v4、v5 存储，v3 在 v2 前，则会先访问 v3。 邻接矩阵的 DFS 先将图的边用矩阵表示，在计算机中使用二维数组存储。然后设置一个状态数组，长度和顶点数组相同。 接下来就可以执行 DFS 了。 第一步：先初始化状态数组为未访问状态，即最开始所有顶点都未访问。第二步：遍历顶点数组，让数组里每个顶点都放入遍历执行函数中，不过在调用遍历执行函数之前要先判断顶点是否已被访问。 12345678910111213141516171819int visited[MAX];/** DFS begin *//** * @description: 深度优先遍历算法 * @param G 需要被遍历的图 * @return 无 */void DFSTraverse_AMG(MatrixGraph* G)&#123; // 初始化状态数组 for (int i = 0; i &lt; G-&gt;v_count; i++) visited[i] = UNVISITED; // DFS 遍历 for (int i = 0; i &lt; G-&gt;v_count; i++) if (!visited[i]) // 如果某个顶点未访问 DFS_AMG(G, i); // 调用遍历执行函数&#125; 遍历执行函数就是 DFS 的核心算法了。该函数接收顶点的下标，并做3件事： 访问当前顶点 更改顶点的访问状态 获取第一个未访问的邻接点下标，然后递归进去，找不到则回溯 12345678910111213141516/** * @description: 深度优先搜索的核心算法 * @param G 要搜索的图 * @param index 要搜索的顶点的下标 * @return 无 */void DFS_AMG(MatrixGraph* G, int index)&#123; printf(&quot;-&gt; %s &quot;, G-&gt;vexes[index]); // 访问当前顶点 visited[index] = VISITED; // 更改当前顶点的访问状态 for (int j = 0; j &lt; G-&gt;v_count; j++) if (G-&gt;matrix[index][j] &amp;&amp; !visited[j]) // 获取第一个未访问的邻接点下标然后递归进去 DFS_AMG(G, j);&#125;/** DFS end */ 在邻接矩阵中，获取某个顶点的所有邻接点就是遍历其所在的行，找到第一个未访问的邻接点。 从邻接矩阵中看如上图 最开始从第 0 行进行（箭头1），找到第一个邻接点的下标，其列标为 1，于是跳到第 1 行（箭头2） 第 1 行第一个邻接点是 v0 ，已经访问过，所以跳过（箭头3），一直找到 v5 这个邻接点，其列标为 5，于是跳到第 5 行（箭头4） 第 5 行第一个邻接点的 v1，已经访问过，所以跳过（箭头5），接下去找到第二个邻接点 v2，其列标为 2，于是跳到第 2 行（箭头6） 接下去的步骤都是这个思路，画出来太乱就没画了。 邻接表的 DFS邻接表的具体代码实现跟邻接矩阵稍稍不同而已，只不过把数组处理换成了链表处理 最开始从 v1 开始（箭头1），访问 v1 的边链上第一个结点（箭头2），得到了 v2 的下标，于是跳到 v2（箭头3） 接着从 v2 开始，先访问 v2，然后遍历 v2 的边链上的结点（箭头4），第一个结点 0 是 v1 的下标，已经访问过了，于是继续下一个结点，得到了 v3 的下标，于是跳到 v3（箭头5） 接着从 v3 开始，先访问 v3，然后遍历 v3 的边链上的结点（箭头6），第一和第二个结点是 v1 和 v2 的下标，已经访问过，所以接着下一个结点，得到 v4 的下标，于是跳到 v4（箭头7） 接着从 v4 开始，先访问 v4，然后遍历 v4 的边链上的结点，发现得到的是 v3 的下标，已经访问过了，再下去没有了，于是结束。 123456789101112131415161718192021222324void DFSTraverse_ALG(AdjListGraph* G)&#123; // 初始化状态数组 for (int i = 0; i &lt; G-&gt;v_count; i++) visited[i] = UNVISITED; // DFS遍历 for (int i = 0; i &lt; G-&gt;v_count; i++) if (!visited[i]) // 如果顶点没有被访问，就递归调用 DFS_ALG(G, i);&#125;void DFS_ALG(AdjListGraph* G, int index)&#123; printf(&quot; -&gt; %s&quot;, G-&gt;vexes[index].data); // 访问顶点 visited[index] = VISITED; // 更改状态 // 寻找邻接点 EdgeNode* eNode = G-&gt;vexes[index].firstEdge; while (eNode) &#123; if (!visited[eNode-&gt;adjvex]) // 如果邻接点未访问就递归访问 DFS_ALG(G, eNode-&gt;adjvex); eNode = eNode-&gt;nextEdge; &#125;&#125; DFSTraverse_ALG() 和 DFSTraverse_AMG() 是一样的，初始化状态数组，然后遍历顶点数组，调用 DFS 算法 DFS_AMG() 中是遍历某一行，DFS_ALG() 中是遍历某一条链表，执行的逻辑都是如果邻接点为访问就递归。 时间复杂度在遍历图时，对图中每个顶点至多调用一次 DFS 函数，因为一旦某个顶点被标志成已访问后，就不再从它出发进行搜索。因此，深度遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费时间取决于所采用的存储结构。 当用邻接矩阵时，使用的是二位数组，查找每个顶点的邻接点所需时间为 $O(n^2)$，n 为图中顶点数。 当用邻接表时，使用的是链表，查找每个顶点的邻接点所需时间为 $O(e)$，e 为无向图中边的数量，或有向图中弧的数量。 由此，邻接矩阵的 DFS 时间复杂度为 $O(n^2 + n) = O(n^2)$邻接表的 DFS 时间复杂度为 $O(n+e)$ 广度优先 BFS广度优先遍历 (Breadth-First-Search) 是仿树的层次遍历。该算法是利用队列实现的。 BFS 的思想是，把顶点都放到队列中，当访问一个顶点，即为出队一个元素；当出队一个元素时，需将其所有未访问的邻接点入队。 先从 v0 开始遍历，打印 v0，然后 v0 入队 队列不为空，v0 出队，同时 v0 的未入队且未访问的邻接点 v1、v3 入队，然后访问 v1、v3 队列不为空，v1 出队，同时 v1 的未入队且未访问的邻接点 v5、v6 入队，然后访问 v5、v6 队列不为空，v3 出队，同时 v3 的未入队且未访问的邻接点 v4 入队，然后访问 v4 队列不为空，v5 出队，同时 v5 的未入队且未访问的邻接点 v2 入队，然后访问 v2 队列不为空，v6 出队，同时 v6 已经没有未入队且为访问的邻接点了，不做入队操作 队列不为空，v4 出队 队列不为空，v2 出队队列为空，结束到此 BFS 执行完毕 所以该图的 BFS 顺序为 v0 -&gt; v1 -&gt; v3 -&gt; v5 -&gt; v6 -&gt; v4 -&gt; v2。 队列BFS 需要借助队列实现，下面是队列的代码： 1234567891011121314151617181920212223242526// LinkQueue.h#ifndef LINK_QUEUE_H_INCLUDED#define LINK_QUEUE_H_INCLUDED#include &quot;GraphModel.h&quot;typedef Vertex Element;// 结点typedef struct QueueNode &#123; Element data; struct QueueNode* next;&#125; QueueNode;// 队列typedef struct &#123; QueueNode* front; QueueNode* rear;&#125; LinkedQueue;Status InitLinkedQueue(LinkedQueue* q);Status EnQueue(LinkedQueue* q, Element e);Status DeQueue(LinkedQueue* q, Element* e);bool isEmptyQueue(LinkedQueue* q);void PrintLinkedQueue(LinkedQueue* q);#endif // LINK_QUEUE_H_INCLUDED 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// LinkQueue.c#include &quot;LinkQueue.h&quot;Status InitLinkedQueue(LinkedQueue* q)&#123; q-&gt;front = NULL; q-&gt;rear = NULL; return OK;&#125;Status EnQueue(LinkedQueue* q, Element e)&#123; QueueNode* new = malloc(sizeof(QueueNode)); new-&gt;data = e; new-&gt;next = NULL; if (isEmptyQueue(q)) &#123; // 处理空队情况 q-&gt;front = q-&gt;rear = new; return OK; &#125; else &#123; // 处理非空队情况 q-&gt;rear-&gt;next = new; // 原队尾结点的next指向新结点 q-&gt;rear = new; // 更新队尾指针 return OK; &#125; return ERROR;&#125;Status DeQueue(LinkedQueue* q, Element* e)&#123; if (isEmptyQueue(q)) &#123; // 空队直接返回 e = NULL; return OK; &#125; if (q-&gt;front == q-&gt;rear) &#123; // 处理队中只有一个结点的情况 *e = q-&gt;front-&gt;data; free(q-&gt;front); q-&gt;front = q-&gt;rear = NULL; return OK; &#125; // 处理队中不止一个结点的情况 QueueNode* del = q-&gt;front; // 标记队头结点 q-&gt;front = del-&gt;next; // 队头指针指向下一个结点 *e = del-&gt;data; // 取数据 free(del); // 删除原队头结点 del = NULL; return OK;&#125;bool isEmptyQueue(LinkedQueue* q)&#123; return q-&gt;front == NULL || q-&gt;rear == NULL;&#125;void PrintLinkedQueue(LinkedQueue* q)&#123; if (isEmptyQueue(q)) &#123; printf(&quot;Queue Empty&quot;); &#125; QueueNode* p = q-&gt;front; while (p) &#123; printf(&quot;\\t%s &quot;, p-&gt;data); p = p-&gt;next; &#125;&#125; 邻接矩阵的 BFS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** BFS begin */void BFSTraverse_AMG(MatrixGraph* G)&#123; for (int i = 0; i &lt; G-&gt;v_count; i++) visited[i] = UNVISITED; // 循环遍历每个顶点 for (int i = 0; i &lt; G-&gt;v_count; i++) if (!visited[i]) // 如果没有访问过就遍历访问 BFS_AMG(G, i);&#125;void BFS_AMG(MatrixGraph* G, int index)&#123; printf(&quot;-&gt; %s &quot;, G-&gt;vexes[index]); // 访问顶点 visited[index] = VISITED; // 更改访问状态 LinkQueue queue; InitLinkedQueue(&amp;queue); // 初始化队列 EnQueue(&amp;queue, G-&gt;vexes[index]); // 当前顶点入队，对应上图中第一步的 v0 入队 while (!isEmptyQueue(&amp;queue)) &#123; // 取出队头元素，遍历队头顶点的所有邻接点 Vertex vex; DeQueue(&amp;queue, &amp;vex); // 取出的队头顶点 // 获取该顶点的所有邻接点 for (int i = FirstAdjVex_AMG(G, vex); i; i = SecondAdjVex_AMG(G, vex, G-&gt;vexes[i])) &#123; if (!visited[i]) &#123; printf(&quot;-&gt; %s &quot;, G-&gt;vexes[i]); // 遇到顶点的邻接点先访问 visited[i] = VISITED; EnQueue(&amp;queue, G-&gt;vexes[i]); // 再入队 &#125; &#125; &#125;&#125;int FirstAdjVex_AMG(MatrixGraph* G, Vertex v)&#123; int defaultWeight = G-&gt;kind &lt;= 1 ? 0 : INT_MAX; // 图/网 的默认权重 int vex_index = LocateVex(G, v); // 获取顶点下标 if (vex_index == -1) return ERROR; // 搜索图的邻接矩阵中域顶点v的第一个邻接点下标 for (int j = 0; j &lt; G-&gt;v_count; j++) if (G-&gt;matrix[vex_index][j] != defaultWeight) return j; return 0;&#125;int SecondAdjVex_AMG(MatrixGraph* G, Vertex v1, Vertex v2)&#123; int defaultWeight = G-&gt;kind &lt;= 1 ? 0 : INT_MAX; // 图/网 的默认权重 int index1 = LocateVex(G, v1); int index2 = LocateVex(G, v2); if (index1 == -1 || index2 == -1) return 0; for (int i = index2 + 1; i &lt; G-&gt;v_count; i++) if (G-&gt;matrix[index1][i] != defaultWeight) return i; return 0;&#125;/** BFS end */ 邻接表的 BFS按理来说邻接矩阵的 BFS 和邻接表的 BFS 应该是一样的，至少在无向图中是一样的。但是如果邻接表是用的头插法，那可能结果是不一样的 12345678910111213141516171819202122232425262728293031323334void BFSTraverse_ALG(AdjListGraph* G)&#123; for (int i = 0; i &lt; G-&gt;v_count; i++) // 初始化状态数组 visited[i] = UNVISITED; for (int i = 0; i &lt; G-&gt;v_count; i++) // 遍历顶点数组，逐一对每一个未访问的顶点执行 BFS if (!visited[i]) BFS_ALG(G, i);&#125;void BFS_ALG(AdjListGraph* G, int index)&#123; printf(&quot;-&gt; %s &quot;, G-&gt;vexes[index].data); // 访问顶点 visited[index] = VISITED; // 更改顶点状态 LinkQueue queue; InitLinkedQueue(&amp;queue); EnQueue(&amp;queue, G-&gt;vexes[index].data); // 当前顶点入队 while (!isEmptyQueue(&amp;queue)) &#123; // 取出队头元素，遍历队头顶点的所有邻接点 Vertex vex; DeQueue(&amp;queue, &amp;vex); // 取出队头元素 // 遍历所有邻接点 EdgeNode* node = G-&gt;vexes[LocateVex_ADJ(G, vex)].firstEdge; while (node) &#123; if (!visited[node-&gt;adjvex]) &#123; printf(&quot;-&gt; %s &quot;, G-&gt;vexes[node-&gt;adjvex].data); // 邻接点先访问 visited[node-&gt;adjvex] = VISITED; EnQueue(&amp;queue, G-&gt;vexes[node-&gt;adjvex].data); // 再入队 &#125; node = node-&gt;nextEdge; &#125; &#125;&#125; 时间复杂度在遍历图时，每个顶点最多进一次队列，遍历图的过程实质上是通过边或弧找邻接点的过程。因此，广度优先搜索、深度优先搜索，在遍历图时的时间复杂度是相同的。 总结 存储结构： 邻接矩阵：一维数组存储顶点集+二维数组存储边/弧 邻接表：一维数组存储顶点集+单链表存储边/弧 出边表：链表的结点存储的是弧头的下标 入边表：链表的结点存储的是弧尾的下标 十字链表：将出边表和入边表整合起来，主要针对有向图 邻接多重表：将所有边链的结点整合起来，去除重复的结点，主要针对无向图 边集数组：一维数组存储顶点集+一维数组存储边集，关注的是边 图的遍历： 深度优先搜索 DFS 和 广度优先搜索 BFS 是图的最基本的遍历方式。 DFS 是仿树的前序遍历，利用栈做辅助，具体实现是不断将当前顶点的第一个未访问邻接点拿去递归。 BFS 是仿树的层序遍历，利用队列做辅助，具体实现是每当出队一个元素时，就访问其所有未访问且未入队的邻接点，并将这些邻接点入队。 使用邻接矩阵存储和使用邻接表存储的图在做 DFS 或 BFS 时没什么区别，只不过邻接矩阵是操作二维数组，邻接表是操作链表。 [^1]: 对称矩阵：n 阶矩阵的元满足 $a_{ij} = a_{ji}, (0 \\leq i, j \\leq n)$，即从矩阵左上角到右下角的主对角线为轴，右上角的元与左下角相对应的元完全相等。","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"DataStruction 0x07 图-1","slug":"408/DataStruction/DataStruction [7-图1]","date":"2021-02-23T08:00:42.000Z","updated":"2021-07-19T08:56:49.299Z","comments":true,"path":"posts/55674.html","link":"","permalink":"https://www.boii.xyz/posts/55674.html","excerpt":"什么是图？","text":"什么是图？ 7-图图 是有顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（ V, E ）其中 G 表示一个图，V 是顶点集合，E 是边的集合。 线性表的数据元素 -&gt; 元素 Element树中的数据元素 -&gt; 结点 Node图中的数据元素 -&gt; 顶点 Vertex[^0] 线性表没有数据元素 -&gt; 空表树中没有数据元素 -&gt; 空树图中没有数据元素 -&gt; 不行！ 线性表中，相邻的元素之间具有线性关系树中，相邻的两层之间具有层次关系图中，任意两个顶点之间都可能有关系。顶点之间的逻辑关系用边来表示。边集可以为空。 定义无向边若顶点 vi 到 vj 之间的边没有方向，则称这条边为无向边（Edge）[^1]，用无序偶对（vi, vj） 来表示。如果图中任意两个顶点之间的边都是无向边，则称该图为无向图（Undirected graphs）[^2]。 上图就是一个无向图，K 到 T 之间的边可以表示成无序对（K, T）或者（T, K）。而整个图可以描述成为: G1 = (V1，{E1})，其中顶点集合 V1=&#123;G, Z, K, T, C&#125;；边集合 E1 = &#123; (G, Z), (G, K), (Z, K), (Z, T), (K, T), (K, C), (T, C) &#125;； 有向边若顶点 vi 到 vj 之间的边有方向，则称这条边为弧（Arc）[^3]。用无序偶对 &lt;vi, vj&gt; 来表示： $v_i \\to v_j$， vi 称为弧尾（Tail），即指出去的那个；vj 称为弧头（Head），即被指的那个。 如果图中任意两个顶点之间的边都是有向边，则称该图为有向图（Directed graphs）[^4]。 上图就是一个有向图，连接 G 到 K 的边就是弧，K 是弧头，被指向的那个，G 是弧尾，指出去的那个。&lt;G, k&gt; 表示弧，不能写为 &lt;K, G&gt;。而整个图可以描述成为 G2 = (V2，{E2})，其中顶点集合 V2 = &#123;G, Z, K, T, C&#125;；弧集合 E2 = &#123; &lt;G, K&gt;, &lt;Z, G&gt;, &lt;Z, K&gt;, &lt;K, T&gt;, &lt;T, Z&gt;, &lt;T, C&gt;, &lt;C, K&gt; &#125;； 注意：无向边用 () 表示， 有向边用 &lt; &gt; 表示。 简单图在图中若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图[^5]。在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图（Undirected Completed graph）[^6]在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图（Directed graph）。[^7] 含有 n 个顶点的无向完全图有 $\\frac {n(n-1)} 2$ 条边，如上图的无向完全图有4个顶点，边数为 $4 \\times 3 \\div 2 = 6$ 含有 n 个顶点的有向完全图有 $n \\times (n-1)$ 条边，如上图的有向完全图有4个顶点，边数为 $4 \\times 3 = 12$ 推广一下：在非完全的图中，设图具有 n 个顶点和 e 条边，若该图为无向图则 $0 \\leq e \\leq \\frac {n(n-1)} 2$若该图为有向图则 $0 \\leq e \\leq n(n-1)$ 有很少条边或弧称为稀疏图（Sparse greph），反之称为稠密图（Dense greph）。稀疏和稠密的相对的概念，没有严格定义。 权、网图的边或弧有相关的数值，这个数叫做权（Weight）[^8]，可以表示一个顶点到另一个顶点的距离或耗费等等。这种带全的图通常称为网（Network）[^9]。 子图假设两个图 $G = (V, {E})$ 和 $G’ = (V’, {E’})$，如果 $V’ \\subseteq V$ 且 $E’ \\subseteq E$，则称 G’ 为 G 的子图（Subgraph）[^10]。 图的顶点和边间的关系度无向图的度对于无向图 G = (V, {E}) 如果边 $(v, v’) \\in E$，则称顶点 v 和 v’ 互为 邻接点（Adjacent），即 v 和 v’ 相邻接。 边 (v, v’) 依附（Incident） 于顶点 v 和 v’，即边（v, v’）与顶点 v 和 v’ 相关联。 顶点 v 的度（Degree）[^11] 是和 v 相关的边的数量，记为 TD（v）。 eg: 例如这个图，顶点 G 和 K 互为邻接点，边 （G, K）依附于 G 和 K 上，K顶点的度为 3。 图的边数为 5，各个顶点的度的和 = 3+3+2+2 = 10，其中重复两次计数，所以边数应为个顶点度数之和的一半。 记作 $$e= \\frac 1 2 \\sum_{i=1}^n TD(v_i)$$ 有向图的度对于有向图 G = (V, {E}) 如果弧 $\\langle v, v’ \\rangle \\in E$，则称：顶点 v 邻接到 v’，顶点 v’ 邻接自 v。顶点 v 和 v’ 互为邻接点（Adjacent）。 弧 &lt;v, v’&gt; 依附（incident） 于顶点 v 和 v’，即弧 &lt;v, v’&gt; 与 顶点 v 和 v’ 相关联。 以顶点 v 为头的弧的数量称为 v 的入度（InDegree）[^12]，记为 ID（v）; 以顶点 v 为尾的弧的数量称为 v 的出度（OutDegree）[^13]，记为 OD（v）; 顶点 v 的度（Degree） 为 TD（v） = ID（v） + OD（v）。 eg: 例如这个图，顶点 G 和 K 互为邻接点，顶点 G 邻接到 K，K 邻接自 G。 边 （G, K）依附于 G 和 K 上，顶点 K 的入度为 2，$ID(K) = 2$，出度为 1，$OD(K) = 1$，度为 $TD(K) = ID(K) + OD(K) = 3$ 图的弧数为 5，各个顶点的入度和 = 1+2+2+0 = 5，出度和 = 1+1+0+3 = 5； 由此可得有向图的弧数: $$e= \\sum_{i=1}^n ID(V_i) = \\sum_{i=1}^n OD(v_i)$$ 路径无向图**G = (V, {E})**中从顶点 v 到顶点 v’ 的路径（Path）[^14]是一个顶点序列 $(v = v_{i,0}, v_{i,1}, …, v_{i,m} = v’)$，其中 $(v_{i,j-1}, v_{i,j}) \\in E, 1\\leq j \\leq m$。 G 到 T 有四种路径。 如果 G 是有向图，则路径也是有向的，顶点序列应满足 $\\langle v_{i,j-1}, v_{i,j}\\rangle \\in E, 1 \\leq j \\leq m$。 上图种 G 到 T 只有一种路径，其他路径都不行。因为 G 到 Z 不存在路径。 路径的长度[^15]是路径上的边或弧的数量。例如上图的有向图，G到T的路径长度为2。 第一个顶点到最后一个顶点相同的路径称为回路（circuit）或环（Cycle）[^16]。 序列种顶点不重复出现的路径为简单路径[^17]。 除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路（Simple circuit）或简单环（Simple Cycle）。 左边图路径为 {B, C, D, A, B}，第一个顶点和最后一个顶点都是 B，且 C、D、A没有重复出现，所以是一个简单环右边图路径为 {B, C, D, A, C, B}，由于 C 重复，所以不是简单环。 连通图无向连通图 无向图中：任意两个顶点之间都有直接或间接的路径，即都能到达，则称这个图为连通图（Connected Graph）[^18]。例如 图1 就是非连通图，应为顶点 5 和 6 没有路径到顶点 1、2、3、4，而图2、3、4 就是连通图。 无向图中的极大连通子图（Great Connected Subgraph）称为连通分量（Connected Component）[^19]，它强调： 必须是子图（子图） 子图是连通的（连通） 连通子图含有极大顶点数（有极大顶点数） 具有极大顶点数的连通子图包含依附于这些顶点的所有边。（含有边） 例如 图1就是一个无向非连通图，但是它有两个连通分量 图2 和 图3，而 图4 虽然是 图1 的子图，但是不满足连通子图的极大顶点数（图2 满足），所以不是连通分量。 有向连通图 有向图中：任意两个顶点都有直接路径或间接路径，则称这个图为强连通图（Strong Connected Graph）[^20]。有向图中的极大强连通子图（Great Strong Connected Subgraph）称作有向图的强连通分量（Strong Connected Component）[^21]。 例如 图1 就不是一个强连通图，因为 1 到 4 有路径，而 4 到 1 没路径。而 图2 就是 图1 的极大强连通子图，即它的强连通分量。 生成树、生成森林生成树 对连通图进行遍历，过程中所经过的边和顶点的组合可看做是一棵普通树，通常称为生成树（Spanning Tree）[^22]。 左边是一张连通图，右边则是其对应的两种生成树。连通图中，任意两顶点之间可能还有多条路径，遍历连通图的方式有多种，往往一张连通图可能有多种不同的生成树与之对应。 连通图中的生成树必须满足以下2个条件：包含连通图中所有的顶点；任意两顶点之间有且仅有一条通路；因此，连通图的生成树具有这样的特征：生成树中 边的数量 = 顶点数 - 1。$$\\begin{cases}非连通图, &amp; 顶点个数 = n;边数 \\lt n-1 \\\\生成树, &amp; 顶点个数 = n;边数 = n-1 \\\\一定有环, &amp; 顶点个数 = n;边数 \\gt n-1 \\\\\\end{cases}$$ 生成森林生成树的对于连通图来说的，而生成森林则是对应非连通图来说的。非连通图可以分解为多个连通分量，而每个连通分量又各自对应多棵生成树，因此与整个非连通图相对应的，是由多棵生成树组成的生成森林（Spanning Forest）[^23]。 上图左边是一张非连通图，可以分解为右边三个连通分量，其中各个连通分量对应的生成树如下所示： 上图只是列出各个连通分量的其中一种生成树。 总结 图由顶点和边组成，无向图由 顶点 和 边 构成；有向图由 顶点 和 弧 构成，弧分 弧头弧尾。 任两个顶点之间都存在边叫完全图，分有向完全图和无向完全图。同一条边不重复出现的图叫简单图。 顶点之间有邻接点、依附的概念，无向图的顶点的边数叫 度，有向图的顶点分 出度 和 入度 ，度 = 出+入。 从图的顶点集和边集中取一小部分组成新的图，称为原图的子图。 带数值的边叫权，顶点和权构成网 图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中顶点没有重复过称为简单路径。若任意两顶点都是连通的，则图是连通图，有向则是强连通图。图中有子图，若子图极大连通则称连通分量，有向则称强连通分量。 无向图中连通且边数 = 顶点数 - 1 的树叫生成树，无向非连通图的连通分量生成的生成树一起构成生成森林。 有向图中一个顶点入度为 0，其他顶点的入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林。 [^0]: 顶点 -&gt; 图的数据元素 [^1]: 无向边 -&gt; 边没有方向 [^2]: 无向图 -&gt; 边没有方向的图，n个顶点的无向图最多有 $\\frac {n(n-1)} 2$ 条边 [^3]: 弧 -&gt; 边有方向；弧有弧头弧尾之分 [^4]: 有向图 -&gt; 边有方向的图，n个顶点的有向图最多有 $n(n-1)$ 条边 [^5]: 简单图 -&gt; 同一条边不重复出现的图 [^6]: 无向完全图 -&gt; 任意两个顶点之间都有边，共有 $\\frac {n(n-1)} 2$ 条边 [^7]: 有向完全图 -&gt; 任意两个顶点之间都有弧，共有 $n(n-1)$ 条弧 [^8]: 权 -&gt; 有数值的边 [^9]: 网 -&gt; 顶点+权 [^10]: 子图 -&gt; 从原图中拆出来的图 [^11]: 度 -&gt;顶点的边数 [^12]: 入度 -&gt; 邻接到顶点的边的数量 [^13]: 出度 -&gt; 顶点邻接出去的边的数量 [^14]: 路径 -&gt; 两个顶点之间的直接线路或间接线路的边集序列，注意是序列，所以可能不止一条 [^15]: 路径长度 -&gt; 两个顶点之间的线路的边数 [^16]: 回路或环 -&gt; 从起始点离开最后到达起始点的路径 [^17]: 简单路径 -&gt; 回路上没有重复的点的路径 [^18]: 连通图 -&gt; 任意两顶点都是连通的无向图 [^19]: 连通分量 -&gt; 无向图的极大连通的子图 [^20]: 强连通图 -&gt; 任意两顶点都是连通的有向图 [^21]: 强连通分量 -&gt; 有向图的极大连通的子图 [^22]: 生成树 -&gt; 无向连通图生成的 边的数量 = 顶点数 -1 的树 [^23]: 生成森林 -&gt; 无向非连通图的连通分量生成的生成树一起构成生成森林","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"DataStruction 0x06 树","slug":"408/DataStruction/DataStruction [6-树]","date":"2021-02-23T08:00:41.000Z","updated":"2021-07-12T14:01:10.000Z","comments":true,"path":"posts/48872.html","link":"","permalink":"https://www.boii.xyz/posts/48872.html","excerpt":"什么是树？","text":"什么是树？ 6-树前面的线性表、广义表、栈、队、串，都是一对一的数据结构。现在开始我们要讨论一种一对多的数据结构: 树。 定义 树是 n 个结点的有限集。 n=0 时称为 空树。n&gt;1 时，有且仅有一个特定的根节点 root，其余结点可分为 m（m&gt;0）个互不相交的有限集 $T_1、T_2、…、T_m$，其中每个集合本身又是一棵树，称为 子树。 名词解释 名词 解释 示例 结点 树中的一个独立单元。包含一个数据元素及若干指向其他子树的分支。 eg：图中每一个圆圈都是结点。 结点的度 结点拥有的子树的数量。 eg：A的度为3，B的度为2，C的度为1。 树的度 树内各结点的度的最大值。 eg：上面的树的度为3。 树的高度（深度） 树中的最大层数。 eg：图中树的深度（高度）为 4。 叶子结点 度为0的结点，也称终端结点。 eg：K、L、F、G、M、I、J 都是叶子结点。 分支结点 度不为0的结点，也称非终端结点。 eg： A、B、C、D、E、H 都是非终端结点。 双亲结点 一个结点的直接前驱结点称为其双亲结点。 eg：E的双亲为B，G的双亲为C。 孩子结点 一个结点的所有直接后继结点称为其孩子结点。 eg：B的子结点为E、F，H的子结点为M。 兄弟结点 同一个双亲的子结点之间互称兄弟结点。 eg：H的兄弟结点为I、J。 祖先 从一个结点到根节点所经分支上的所有结点。 eg：K的祖先为E、B、A。 子孙 一个结点所有直接和间接后继结点。 eg：D的子孙为H、I、J、M。 堂兄弟 双亲在同一层的结点互为堂兄弟。 eg：G与E、F、H、I、J 互为堂兄弟。 层 根为第一层，根的孩子为第二层，以此类推 eg：A为1层，B、C、D为2层，K、L、M为3层。 有序树、无序树：树中的结点从左至右依次有序不能互换，称为有序，否则称为无序。有序树中最左边的子树称为根节点的第一个孩子，最右边称为根节点的最后一个孩子。 森林：m棵不相交的树的集合。 ADT12345678910111213141516171819ADT TreeData 树是由一个根结点和若干子树构成。树中结点具有相同数据类型及层次关系。Operation InitTree(T*): 构造空树T DestoryTree(T*): 销毁树T CreateTree(T*, definition): 按definition中给出的树的定义来构造树 ClearTree(T*): 若树T存在，则将树T清空为空树 TreeEmpty(T): 若T为控诉，返回true，否则返回false TreeDepth(T): 返回树T的深度 Root(T): 返回T的根节点 Value(T, cur_e): cur_e 是树T中一个结点，返回此结点的值 Assign(T, cur_e, value): 给树T的结点cur_e赋值为 value Parent(T, cur_e): 若 cur_e 是树T的非根结点，则返回它的双亲，否则返回空 LeftChild(T, cur_e): 若 cur_e 是树T的非叶结点，则返回它的最左孩子，否则返回空 RightSibling(T, cur_e): 若 cur_e 有右兄弟，则返回它的右兄弟，否则返回空 InsertChild(T*, p*, i, c): 其中p指向树T的某个结点，i为所指结点p的度+1，非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树 DeleteChild(T*, p*, i): 其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树endADT 存储结构顺序结构双亲表示法除了根节点，其他结点一定有双亲结点 双亲表示法有两种： 只能简单的记录结点关系的一维数组 带数据域和指示域的多维数组 我们利用一维数组，下标表示树中的结点，数组元素的内容表示该结点的双亲结点。 用结构数组，每个结点附设一个指示器指示其双亲结点在表中的位置。上图的树用多维数组表示为： 下标 数据 双亲 0 A -1 1 B 0 2 C 0 3 D 1 4 E 1 5 F 2 6 G 2 7 H 3 用代码实现如下： 1234567891011121314151617181920#define MAX_TREE_SIZE 100typedef char Element; // 数据元素类型，暂定为字符型typedef struct &#123; Element data; // 数据域 int parent; // 双亲位置&#125; PTNode;typedef struct &#123; PTNode nodes[MAX_TREE_SIZE]; // 结点数组 int root, node_count; // 根的位置和结点数&#125; PTree;Status insert(PTree* pt, Element e, int p) &#123; pt-&gt;nodes[pt-&gt;node_count].data = e; pt-&gt;nodes[pt-&gt;node_count].parent = p; if (p == -1) pt-&gt;root = pt-&gt;node_count; pt-&gt;node_count++;&#125; 这种结构的话很容易找到一个结点的双亲结点，如果parent为-1即表示此结点为根节点。但是如果要找结点的孩子，只能遍历整个数组。 链式结构二叉树 Binary Tree定义二叉树 是 n（n >= 0）个结点的有限集合，该集合或者为空集，或者有一个根结点和两棵不相交的分别称为根结点的左子树和右子树的二叉树组成。 一棵树的度为 n 时，又称 n 叉树。所以二叉树的度为2，即每个结点最多有2个子结点。 特点 每个结点最多有两棵子树，所以二叉树中不存在度 &gt; 2 的结点。 左子树和右子树是有顺序的，次序不能任意颠倒。就像左手是左手，右手是右手，不能互换。 即使树中某结点只有一棵子树，也要区分是左子树还是右子树。就像摔伤了左手还是右手，对你生活的影响程度是不一样的。 二叉树有5种基本形态： 空二叉树 只有根节点 根节点+左子树 根节点+右子树 根节点+左子树+右子树 斜树所有结点都只有左子树的二叉树叫左斜树所有结点都只有右子树的二叉树叫右斜树 斜树有很明显的特点，每一层都只有一个结点，结点的个数与二叉树的深度相同。 满二叉树 在一棵二叉树中，所有分支节点都有左子树和右子树，且所有叶结点都在同一层，则称为 满二叉树。 注意单是每个结点都存在左右子树还不够，那样只算完全二叉树，还需要叶子节点都在同一层。满二叉树的特点有： 叶结点只能出现在最下层，其他层出现就不可能达成平衡 分支结点的度必须 = 2，否则就是缺胳膊少腿了。 在同样深度的二叉树中，满二叉树的结点树最多，叶子最多。 完全二叉树对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1 &lt;= i &lt;= n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。 一棵满二叉树一定是完全二叉树，一棵完全二叉树不一定是满二叉树。 注意完全二叉树是按层序编号 第 2 棵树虽然有些结点没有连续，但是因为每个结点都是按层序编号，和满二叉树能对应，所以是完全二叉树 第 3 棵树由于叶结点出现在最后一层（编号 8、9、10）和倒数第三层（编号 3），叶子结点层数差超过 1，所以不是完全二叉树 第 4 棵树应为 12 的结点编号为 11，所以不是完全二叉树。 完全二叉树的特点： 叶子结点只能出现在最下面两层。 最下层的叶子一定集中在左部连续位置。 倒数两层，若有叶子结点，一定都在右部连续位置 如果结点度为 1，则该结点只有左孩子，不能只有右孩子。 同样结点数的二叉树，完全二叉树的深度最小。 上图这两颗就是正确的完全二叉树。左边为满二叉树，右边为完全二叉树。 看右边那棵，叶结点只在最下两层（7、8、9、10、11、12），度为1时只有左孩子（6 -&gt; 12） 性质 性质1：在二叉树的第 i 层上最多有 $2^{i-1}$ 个结点。 第一层是根结点，只有1个结点，$2^{1-1} = 2^0 = 1$第二层最多有2个结点，$2^{2-1} = 2^1 = 2$第三层最多有4个结点，$2^{3-1} = 2^2 = 4$第四层最多有8个结点，$2^{4-1} = 2^3 = 8$通过归纳法，可以得出：二叉树的第i层最多有 $2^{i-1}$ 个结点。推广一下：一棵树的度为 n 时，又称n 叉树。如果一棵三叉树、四叉树，在第i层上最多有 $3^{i-1}$、$4^{i-1}$ 个结点。由此可得：一棵 n 叉树在第i层上最多有 $n^{i-1}$个结点。 性质2：深度为 k 的二叉树总结点数最多有 $2^k - 1$个（k &gt;= 1）。 如果有一层，最多共1个结点。$2^1 - 1 = 1$如果有两层，最多共3个结点。$2^2 - 1 = 3$如果有三层，最多共7个结点。$2^3 - 1 = 7$如果有四层，最多共15个结点。$2^4 - 1 = 15$通过归纳法，可以得出：深度为 k 的二叉树总结点数最多有 $2^k - 1$ 个。 性质3：对任何一棵二叉树 T，如果其叶子结点总数为 $n_0$，度为 2 的结点总数为 $n_2$，则 $n_0 = n_2 + 1$。 例如上图右边的完全二叉树，叶子结点为7、8、9、10、11、12共6个，所以 $n_0 = 6$；而度为2的结点1、2、3、4、5共5个，$n_2 = 5$。所以 $n_0 = n_2 + 1 = 5 + 1 = 6$。 性质4：总结点数为 n 的完全二叉树的深度为 $⌊log_2 n⌋ + 1$。 ⌊x⌋ 表示对 x 向下取整。 例如上图左边的满二叉树，总结点数为 15，深度为 $⌊log_2 15⌋ + 1 = 4$。 性质5：若对一颗总结点数为 n 的完全二叉树（其深度为 $⌊log_2 n⌋ + 1$）的结点按层序编号，对任一结点 i （1 &lt;= i &lt;= n）有： 如果 i = 1，则结点 i 是二叉树的根，无双亲；如果 i &gt; 1，则其双亲结点是第 $⌊i/2⌋$ 个；如果 2i &gt; n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点 2i；如果 2i+1 &gt; n，则结点 i 无右孩子；否则其右孩子是结点 2i+1。 例如这样一棵完全二叉树。总结点数 10；高度 4。 如果 i = 1，根节点。 如果 i = 7，双亲就是 $⌊7/2⌋ = ⌊3.5⌋ = 3$； 如果 i = 6，(2i = 2*6 = 12) &gt; (10 = n)，所以6无左孩子； 如果 i = 4，(2i + 1 = 9) &gt; 10，所以4的右孩子是9。 总结一下就是： i = 1，为根结点 i 的双亲是 ⌊i/2⌋ i 的左孩子是 2i i 的右孩子是 2i + 1 存储结构顺序结构适用性不强，还是用链表结构比较好。 每个结点包含一个数据域和两个左右孩子指针域，当然也可以包含一个双亲域。 12345678910111213141516typedef struct &#123; int id; char* name;&#125; Elem;typedef struct BTNode&#123; Elem data; // 数据域 struct BTNode* lchild; // 左孩子 struct BTNode* rchild; // 右孩子&#125; BTNode;typedef struct &#123; BTNode* root; // 根结点 int depth; // 树的度 int count; // 总结点数&#125; BTree; 遍历 前序遍历法 DLR即先打印根结点，再打印左孩子，最后打印右孩子，以此类推 上面的打印顺序为：ABDHKECFIGJ 123456void PreOrderTraverse(BTNode T) &#123; if (T == NULL) return; printf(&quot;%c&quot;, T-&gt;data); PreOrderTraverse(T-&gt;lchild); PreOrderTraverse(T-&gt;rchild);&#125; 中序遍历法 LDR即先打印左孩子，再打印根结点，最后打印右孩子，以此类推 上面的打印顺序为：HKDBEAIFCGJ 123456void InOrderTraverse(BTNode T) &#123; if (T == NULL) return; InOrderTraverse(T-&gt;lchild); printf(&quot;%c&quot;, T-&gt;data); InOrderTraverse(T-&gt;rchild);&#125; 后序遍历法 LRD即先打印左孩子，再打印右孩子，最后打印根结点，以此类推 上面的打印顺序为：KHDEBIFJGCA 123456void PostOrderTraverse(BTNode T) &#123; if (T == NULL) return; PostOrderTraverse(T-&gt;lchild); PostOrderTraverse(T-&gt;rchild); printf(&quot;%c&quot;, T-&gt;data);&#125; 层序遍历法即按层从左到右依次打印上面打印顺序为：ABCDEFGHIJK 层序遍历时需要借助一个队列来完成。从根结点开始，当一个结点出队时，将其所有孩子结点入队。 123456789void SequenceTraverse(BTree T) &#123; EnQueue(T-&gt;root); BTNode* root = DeQueue() for (int i = 0; i &lt; T-&gt;count; i++) &#123; if (root) printf(&quot;%c&quot;, root-&gt;data); if (root-&gt;lchild) EnQueue(root-&gt;lchild); if (root-&gt;rchild) EnQueue(root-&gt;rchild); &#125;&#125; 总结前序就是根结点在前面中序就是根结点在中间后序就是根结点在后面 像这棵比较小的树，前序 DLR：ABDEC中序 LDR：DBEAC后序 LRD：DEBCA层次遍历：ABCDE 例题如果一棵二叉树的前序遍历序列为 ABCDEF，中序遍历序列为 CBAEDF，请问后序遍历序列为？解题思路： 前序的第一位或后序的最后一位，一定是根节点，所以这题的根结点就是 A。 接着看 A 在中序序列的位置，可以看出 CB 是 A 的左孩子，EDF是 A 的右孩子；然后在前序中就可以确定 BC 为一组，DEF 为一组。 二叉树的子树也是二叉树。根据这个道理，从前序中可以知道 B是左子树的根结点，同理D是右子树的根结点。 拿着 B 和 D 到中序序列中分析，分出左右子树，以此类推。 核心就是：从前序的第一个 或 后序的最后一个确定根结点，然后到中序里区分左右子树。 所以这道题应该是这样一棵树： 后序应该为： CBEFDA 线索二叉树 Threading Tree线索二叉树 = （前 | 中 | 后）遍历 + 二叉树。 虽然采用链式结构存储，每个结点存储本身数据和左右孩子的指针，但还是会带来一个问题：叶子结点没有子树，它们的孩子指针必然为 NULL，叶子越多，NULL 越多，这就导致不管什么树，都必然会浪费一定的空间。 例下图： 现在思考如何将那些 ^ 利用起来。如果一个结点没有孩子，则让孩子指针指向双亲？这样有的指有的不指，很奇怪，且实现起来很不方便。如果结合遍历顺序怎么样？可以。 因为在没有遍历的情况下，我们不知道一个结点的前驱是谁，后继是谁，不如在创建树时，如果没有子树，就换成记录前驱元素或后继元素。 这样创建出来的树，就叫 线索二叉树。 线索二叉树的核心思想为： 如果有左子树，则左指针域指向左子树；如果没有左子树，则左指针指向**遍历前驱元素** 如果有右子树，则右指针域指向右子树；如果没有右子树，则右指针指向**遍历后继元素** 这里的前驱和后继指的是 某个结点在遍历后得到的序列中的前驱和后继。 例如： 后序遍历得到序列：CBEFDA。其中 E 是 F 的前驱，D 是 F 的后继。 即：线索二叉树 = （前 | 中 | 后）遍历 + 二叉树。 我们在将左右指针指向子树还是前驱后继这个行为叫做线索化。 实现细节定义了二叉树，我们需要讨论：如何知道一个结点的孩子指针是指向子树还是指向前驱后继？为了解决这个问题，还需要在每个结点中增加两个变量 ltag 、rtag。当 ltag 或 rtag 为 true 时表示有孩子，指针域指向子树；当 ltag 或 rtag 为 false 时表示没有孩子，指针域指向前驱或后继。 1234567typedef struct BTNode&#123; Elem data; // 数据域 struct BTNode* lchild; // 左孩子 struct BTNode* rchild; // 右孩子 bool ltag; bool rtag;&#125; BTNode; 这样在创建一棵树时，如果某个结点有左子树，ltag 为 true，lchild 指向左子树；如果没有左子树，ltag 为 false，lchild 指向前驱。eg：这样一棵二叉树，经过中序线索化以后，变成下面这样： 1234567891011121314151617181920TTNode* pre; // 全局变量，指向刚刚访问过的结点void InThreading(TTNode* T) &#123; if(T) &#123; InThreading(T-&gt;lchild); // 递归左子树线索化 /** 线索化 begin */ if(!T-&gt;lchild) &#123; // 没有左孩子 T-&gt;ltag = false; // 线索标志 T-&gt;lchild = pre; // 指向前驱元素 &#125; if(!pre-&gt;rchild) &#123; // 前驱结点没有右孩子 pre-&gt;rtag = false; // 线索标志 pre-&gt;rchild = T; // 前驱右指针指向当前指针 &#125; pre = T; // 保持 pre 指向 T 的前驱 /** 线索化 end */ InThreading(T-&gt;rchild); // 递归右子树线索化 &#125;&#125; 转换树转二叉树一棵不规则的树，在一定程度上可以转换为一棵二叉树。 转换方法： 连接：兄弟之间连线 断开：双亲结点只保留最左孩子，其余都断开 旋转：调整好位置 保留的做左子树，连接的做右子树 将这样一棵树转成二叉树。 第一步：兄弟结点之间连接起来。例如 BCD 之间都连接起来了。第二步：除了双亲跟左孩子，其他联系都断开。例如A只保留与 B，断开与 CD 的关系。第三步：旋转调整。保留下来的作为左子树，连接得来的作为右子树。例如 B 是保留下来的，作为左子树，CD 是连接出来的，作为右子树。 口诀：一连接、二断开、三旋转、保留左子树、连接右子树。 二叉树转树二叉树转树 是 树转二叉树的逆过程 一旋转、二断开、三连接即可。 第一步：旋转，将右子树都旋转都同一层第二步：连接右子树结点与双亲结点第三步：断开兄弟间的连线 二叉树转森林判断一棵树是普通树还是二叉树，看它根结点有没有右子树。有就是二叉树，没有就是普通树。 二叉树转森林只需要把每个有孩子的右子树拆开作为单独一棵树即可。 哈夫曼树 哈夫曼树是一类带权路径长度最短的树，又称赫夫曼树、最优树、最优二叉树。 哈夫曼树的应用非常广泛，特别是在大文本编码方面，压缩比非常可观。 首先解释一下带权路径： 路径：两个结点之间那根线就叫路径 权：路径上的数字。 带权路径：两个结点之间那根线带数字 权值可以用来表示某些含义，而在哈夫曼编码中，权值只有 0 和 1 两种。 路径长度：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称作路径长度 树的路径长度：从树根到每一个结点的路径长度之和。 树的带权路径长度：树中所有叶子结点的带权路径长度之和，通常记作 $WPL=\\sum^n_{k=1}{w_kl_k}$。（$l$ 为结点 $k$ 的层数，从 0 开始计算） 上图中的 3 棵二叉树，都有 4 个叶子结点 A、B、C、D，分别带权 11、7、6、9。他们的带权路径长度分别为： $WPL = 11 \\times 2 + 7 \\times 2 + 6 \\times 2 + 9 \\times 2 = 66$ $WPL = 11 \\times 2 + 7 \\times 1 + 6 \\times 3 + 9 \\times 3 = 74$ $WPL = 11 \\times 1 + 7 \\times 2 + 6 \\times 3 + 9 \\times 3 = 70$ 假设有一棵二叉树，其有 n 个叶子结点，并有 n 个权值 ${w_1, w_2, …, w_n}$，每个叶子结点带权为 $w_i$，则其中带权路径长度 WPL 最小的二叉树称作最优二叉树或哈夫曼树。 哈夫曼编码 哈夫曼编码是一种变长的编码方式，在大文本压缩方面有着出色的表现。 相对比变长，另一种编码方式为定长。 假设现在有一串文本 aaabbaacdeefdeaeff，共 18 个字符。现在要进行远距离传输，我们需要先进行编码，也就是编成二进制形式。 可以看到总共是 abcdef 这几个字符，那么我们可以用 001 表示 a，010 表示 b，011 表示 c… 以此类推。 a b c d e f 001 010 011 100 101 110 这就是定长编码，每一个字符编码后都是同样的位数 3 位。 aaabbaacdeefdeaeff 编码后为 001001001010010001001011100101101110100101001101110110。18 个字符共编成 54 个二进制位。 这种方式有个缺点：现在只有 6 种字符，所以每个字符编码后的位数占了 3 位，如果有 17 种字符，那么每个字符编码后需要占用 5 位，非常浪费空间。 所以哈夫曼教授提出了现在的哈夫曼编码，核心就是一句话：让出现次数越高的字符占用越少的位数。 编码步骤这是一种变长的编码方式，具体步骤如下： 统计各种字符的出现次数构成一个序列 对序列进行排序 选取 2 个最小的作为叶子结点，父结点为两次数之和 将选出的两个数从序列中删除，将父结点加入序列 重复步骤 2，直到序列为空。 注意事项： 保持任何左侧结点都比右侧的兄弟结点小/大。 构造完成以后，给每一条路径填充权值 0 或 1。 上面的例子用哈夫曼编码，应该是这样： 最终会生成一颗这样的树： 然后从根结点开始，直到字符那个结点，这一路的权值拼接起来就得到了变长编码。 a b c d e f 00 011 0101 0100 10 11 现在，aaabbaacdeefdeaeff 编码后为 00000001101100000101010010101101001000101111。18 个字符共编成 44 个二进制位。压缩比为 $44 \\div 54 = 81$%。看起来不多，但是计算机中一个字符需要 8 个位存储，18 个字符共 144 位。这样算下来压缩比直接达到 $44 \\div 144 = 30$%！ 代码实现伪代码 1234567while (序列长度 &gt;= 1) &#123; 将序列排序 栈顶 2 个元素出栈 构造子树 将父结点的值入栈&#125;填充权值 123456789101112131415161718192021222324252627282930// DataElement.h#ifndef DATAELEMENT_H_INCLUDED#define DATAELEMENT_H_INCLUDED#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 10typedef struct Node &#123; char data; int value; struct Node* lNode; struct Node* rNode; int lWeight; int rWeight;&#125; Node;typedef struct Stack &#123; Node* datas[MAXSIZE]; int top;&#125; Stack;typedef struct &#123; char data; int times;&#125; seq;#endif 1234567891011121314151617181920212223242526272829// Huffman.h#ifndef HUFFMAN_H_INCLUDED#define HUFFMAN_H_INCLUDED#include &lt;stdbool.h&gt;#include &quot;DataElement.h&quot;#define len(x) sizeof(x)/sizeof(x[0])// 将序列排序bool sort(Stack*);// 出栈两个元素void pop(Stack* s, Node* nodeArr[2]);// 构造子树Node* buildSubTree(Node* nodeArr[2]);// 父结点入栈void push(Stack* s, Node* parent);bool initStack(Stack* s, seq arr[], int arrLen);void printStack(Stack* s);void frontPrint(Node* root);void midPrint(Node* root);void stuffWeight(Node* root);#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// Huffman.c#include &quot;Huffman.h&quot;// 将序列排序/** * @name 直接插入排序算法 * 循环数组长度 -1 次，每次循环将当前目标数与前面部分（已排好序）比较 * 前一个数大于当前数则交换位置，一直比较一直换，直到前面的数小于当前数时，退出比较，换下一个目标数继续比较。 */bool sort(Stack* s)&#123; int i; for (i = 1; i &lt; s-&gt;top + 1; i++) &#123; // 一共循环数组长度 -1 次 int j; for (j = i; j &gt; 0; j--) &#123; Node* prev = s-&gt;datas[i - 1]; Node* curr = s-&gt;datas[i]; if (prev-&gt;value &lt; curr-&gt;value) &#123; // 若前一个小于后一个，则交换两个结点，当前目标数位置-1 Node* tmp = s-&gt;datas[i - 1]; s-&gt;datas[i - 1] = s-&gt;datas[i]; s-&gt;datas[i] = tmp; tmp = NULL; i--; &#125; else &#123; break; &#125; &#125; &#125;&#125;// 出栈两个元素void pop(Stack* s, Node* nodeArr[2])&#123; nodeArr[0] = s-&gt;datas[s-&gt;top--]; nodeArr[1] = s-&gt;datas[s-&gt;top--];&#125;// 构造子树Node* buildSubTree(Node* nodeArr[2])&#123; Node* parent = (Node*)malloc(sizeof(Node)); parent-&gt;data = &#x27;-&#x27;; parent-&gt;value = nodeArr[0]-&gt;value + nodeArr[1]-&gt;value; parent-&gt;lNode = nodeArr[0]; parent-&gt;rNode = nodeArr[1]; parent-&gt;lWeight = parent-&gt;rWeight = -1; return parent;&#125;// 父结点入栈void push(Stack* s, Node* parent)&#123; s-&gt;datas[++s-&gt;top] = parent;&#125;// 填充每条路径上的权值void stuffWeight(Node* root)&#123; if (root) &#123; if (root-&gt;lNode) root-&gt;lWeight = 1; if (root-&gt;rNode) root-&gt;rWeight = 0; stuffWeight(root-&gt;lNode); stuffWeight(root-&gt;rNode); &#125;&#125;// 初始化栈bool initStack(Stack* s, seq arr[], int arrLen)&#123; int i; for (i = 0; i &lt; MAXSIZE; i++) s-&gt;datas[i] = NULL; s-&gt;top = -1; // 将数组填充进栈里 for (i = 0; i &lt; arrLen; i++) &#123; Node* node = (Node*)malloc(sizeof(Node)); node-&gt;data = arr[i].data; node-&gt;value = arr[i].times; node-&gt;lNode = node-&gt;rNode = NULL; node-&gt;lWeight = node-&gt;rWeight = -1; push(s, node); &#125; return true;&#125;// 前序遍历打印void frontPrint(Node* root)&#123; if (root != NULL) &#123; printf(&quot;%c %2d; %2d, %2d\\n&quot;, root-&gt;data, root-&gt;value, root-&gt;lWeight, root-&gt;rWeight); frontPrint(root-&gt;lNode); frontPrint(root-&gt;rNode); &#125;&#125;// 中序遍历打印void midPrint(Node* root)&#123; if (root != NULL) &#123; midPrint(root-&gt;lNode); printf(&quot;%c %2d; %2d, %2d\\n&quot;, root-&gt;data, root-&gt;value, root-&gt;lWeight, root-&gt;rWeight); midPrint(root-&gt;rNode); &#125;&#125; 123456789101112131415161718192021222324252627282930// main.c#include &quot;Huffman.c&quot;#include &quot;tools.c&quot;void BuildHuffman()&#123; seq arr[] = &#123; &#123; &#x27;a&#x27;, 6 &#125;, &#123; &#x27;b&#x27;, 2 &#125;, &#123; &#x27;c&#x27;, 1 &#125;, &#123; &#x27;d&#x27;, 2 &#125;, &#123; &#x27;e&#x27;, 4 &#125;, &#123; &#x27;f&#x27;, 3 &#125; &#125;; Stack s; initStack(&amp;s, arr, len(arr)); Node* popArr[2]; while (s.top &gt;= 1) &#123; sort(&amp;s); pop(&amp;s, popArr); Node* parent = buildSubTree(popArr); push(&amp;s, parent); &#125; stuffWeight(s.datas[s.top]); printStack(&amp;s); frontPrint(s.datas[s.top]); printf(&quot;\\n&quot;); midPrint(s.datas[s.top]);&#125;void main()&#123; BuildHuffman();&#125;","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"DataStruction 0x05 串","slug":"408/DataStruction/DataStruction [5-串]","date":"2021-02-23T08:00:40.000Z","updated":"2021-07-12T13:46:10.000Z","comments":true,"path":"posts/42822.html","link":"","permalink":"https://www.boii.xyz/posts/42822.html","excerpt":"什么是串？","text":"什么是串？ 5-串 串：0或N个字符组成的有限序列，一种限定了元素为字符的线性表。 长度：字符个数空串：0个元素子串：串中任意连续字符组成的子序列主串：包含子串的串 存储结构：串的实现可以用定长数组，也可以用变长的动态数组实现。 1234567// 定长数组#define MAX_SIZE 100typedef struct &#123; char str[MAX_SIZE + 1]; int length;&#125;Str; 123456// 变长动态数组typedef struct &#123; char *str; // 串 int length; // 串长度&#125;Str; 基本操作：赋值、取长度、比较、连接、复制、求子串、清空 当然串的操作还有非常多，比如返回字符在字符串中的位置，返回子串在字符串中的位置等等。 代码实现定义12345678910111213141516// DataElement.h#ifndef DATAELEMENT_H_INCLUDED#define DATAELEMENT_H_INCLUDED#define OK 1#define ERROR 0typedef int Status;/** 串结构 */typedef struct &#123; char* str; int length;&#125; Str;#endif // DATAELEMENT_H_INCLUDED 赋值12345678910111213141516171819202122232425262728Status Assign(Str* s, char* ch)&#123; int ch_length = 0; char* c = ch; while (*c) &#123; // 计算ch字符串长度 ++ch_length; ++c; &#125; if (ch_length == 0) &#123; // 如果是空串 s-&gt;str = NULL; s-&gt;length = 0; return OK; &#125; else &#123; // 开辟一块空间，+1 是为了放 \\0 结束符 s-&gt;str = (char*)calloc(ch_length + 1, sizeof(char)); // 分配失败返回ERROR if (s-&gt;str == NULL) return ERROR; // 逐个将ch的字符复制到s-&gt;str for (int i = 0; i &lt;= ch_length; i++) s-&gt;str[i] = *(ch + i); s-&gt;length = ch_length; return OK; &#125;&#125; 取长度1234int Length(Str* s)&#123; return s-&gt;length;&#125; 比较12345678910int compare(Str* s1, Str* s2)&#123; // 遍历时将两个字符串逐个比较 for (int i = 0; i &lt; s1-&gt;length &amp;&amp; i &lt; s2-&gt;length; i++) &#123; if (s1-&gt;str[i] != s2-&gt;str[i]) &#123; return s1-&gt;str[i] - s2-&gt;str[i]; &#125; &#125; return 0;&#125; 遍历是串中较为重要的操作。 逐个比较字符的ASCII码， 若s1 &lt; s2，返回负数； 若s1 &gt; s2，返回正数； 若s1 = s2，返回0. 连接连接分两种情况讨论 一种是定长数组实现的字符串的连接 如果A有剩余空间且剩余空间大于B长度，循环B长度逐个复制到A 如果A无剩余空间或剩余空间小于B长度，将A扩容，再循环B长度逐个复制到A 一种是变长数组实现的字符串的连接 变长数组一般没有剩余空间的情况，后面的空间是否是空闲空间也无从得知，所以变长数组的字符串在连接时，通常是开辟一块新的空间，长度为A的长度+B的长度，然后遍历A，逐个复制到新字符串，遍历B，逐个复制到新字符串A的后面，最后补\\0。 12345678910111213141516171819202122// 将 s2 连接到 s1 后面char* contact(Str* s1, Str* s2)&#123; // 创建一块新字符串空间，长度为 s1 + s2 char* new = (char*)calloc(s1-&gt;length + s2-&gt;length, sizeof(char)); int i = 0; while (i &lt; s1-&gt;length) &#123; // 把 s1 逐个字符赋值给新字符串 new[i] = s1-&gt;str[i]; i++; &#125; i = 0; while (i &lt; s2-&gt;length) &#123; // 把 s2 逐个字符赋值给新字符串 new[s1-&gt;length + i] = s2-&gt;str[i]; i++; &#125; new[s1-&gt;length + s2-&gt;length] = &#x27;\\0&#x27;; s1-&gt;length += s2-&gt;length; s1-&gt;str = new; // 让 s1 指向新字符串 return new;&#125; 复制12345678910char* copy(Str* dest, Str* src)&#123; int count = src-&gt;length &lt; dest-&gt;length ? src-&gt;length : dest-&gt;length; for (int i = 0; i &lt; count; i++) &#123; dest-&gt;str[i] = src-&gt;str[i]; &#125; dest-&gt;str[count] = &#x27;\\0&#x27;; return dest-&gt;str;&#125; 复制的时候，逐个将 src 字符串的字符 复制到 dest 字符串。 要注意的是，假设 dest 的长度为10，src 的长度为5，则将 src 覆盖到 dest 上，dest 上后面的几个字符但是不会被读取到 反过来则是 src 将 dest 整个覆盖，但是只能覆盖 dest 的字符个数，src 超出 dest 长度的字符会被丢弃。 所以在调用时要保证 dest 的长度比 src 的长。 取子串1234567891011121314151617181920/** * @description 从主串 base 的第 idx+1 个开始截取 len 个字符组成新的字符串 * @param base 主串 * @param idx 截取的起始下标 * @param len 截取字符数 */char* sub(Str* base, int idx, int len)&#123; // 越界或主串为空 if (idx + len &gt; base-&gt;length || base-&gt;length == 0) &#123; return NULL; &#125; // 分配空间，然后逐字符复制 char* substring = (char*)calloc(len, sizeof(char)); for (int i = 0; i &lt; len; i++) &#123; substring[i] = base-&gt;str[idx + i]; &#125; return substring;&#125; 清空1234567891011Status clear(Str* s)&#123; if (s-&gt;length == 0) &#123; return OK; &#125; for (int i = 0; i &lt; s-&gt;length; i++) &#123; s-&gt;str[i] = &#x27;\\0&#x27;; &#125; s-&gt;length = 0; return OK;&#125; 串的模式匹配 对某子串的定位操作。 主串也称作目标串 子串也称作模式串 思想：从主串首个位置起和模式串的首个字符比较，若相等，则逐一比较后续字符，否则从主串第二个字符开始，逐一比较后续字符，以此类推。匹配成功则返回模式串在主串中的位置，匹配失败则返回0. KMP 算法模式匹配主要有 BF 算法 和 KMP 算法。 BF 算法主要是一种暴力穷举，和上面介绍的思想一致。 KMP 算法就聪明多了，该算法充分体现了“失败是成功他妈”的道理，积极从上一次失败匹配中汲取信息，并应用到下一次匹配中，比起 BF 那种穷举法，KMP 会将模式串与失败位置对其再重新匹配。","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"DataStruction 0x04 队列","slug":"408/DataStruction/DataStruction [4-队列]","date":"2021-02-23T08:00:39.000Z","updated":"2021-07-12T09:24:51.000Z","comments":true,"path":"posts/50917.html","link":"","permalink":"https://www.boii.xyz/posts/50917.html","excerpt":"什么是队列？","text":"什么是队列？ 4-队列 队列是只允许在一端进行插入操作，在另一端进行删除操作的受限的线性表。 队列是一种 先进先出(FIFO) 的线性表，就像水管一样，从一头进去，从另一头出来 队列有两个指针，一个指向队头，只允许删除；一个指向队尾，只允许插入。 对于队列的操作有插入和删除，也称作入队和出队，不能从中间取。 顺序队：队列的每一个元素在一段连续的内存空间，用数组实现。 链队：队列的每一个元素不一定紧挨着，用链表实现。 循环队：队头连接着队尾。 队的主要操作包括：创建、初始化、入队、出队、判空、判满、清空队列。 循环队顺序队是基于数组实现的，当入队一个元素的时候，队尾指针+1，当队尾指针=MAX_SIZE时队满；当出队一个元素的时候，队头指针+1，当队头指针=MAX_SIZE时，说明队空。 但是！！ 当队头和队尾都 = MAX_SIZE 时，实际上队空，但是却无法入队新元素，这种现象称之为假溢出。 所以为了解决这个问题，我们可以用循环队列。 要实现循环队列，最重要的是怎么做才能让队头队尾指针在一个周期中循环。 答案是 front = (front + 1) % MAX_SIZE、rear = (rear + 1) % MAX_SIZE。 假设 MAX_SIZE == 8, front == 1，(front + 1) % MAX_SIZE等价于2 % 8 == 2 所以这条表达式，可以让队头队尾指针在 0~MAX_SIZE-1 这个周期中循环，也就是在 0, 1, 2, ... MAX_SIZE-1 中循环。 要素循环队列的两个状态 队空： q->rear == q->front 队满： (q->rear + 1) % MAX_SIZE == q->front 入队： 12q-&gt;rear = (q-&gt;rear + 1) % MAX_SIZE; q-&gt;data[q-&gt;rear] = x; 出队： 12q-&gt;front = (q-&gt;front + 1) % MAX_SIZE;X = q-&gt;data[q-&gt;front]; 定义123456789101112131415161718192021222324// DataElement.h#ifndef DATAELEMENT_H_INCLUDED#define DATAELEMENT_H_INCLUDED#define MAX_SIZE 10#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;typedef int Bool;typedef struct &#123; int id; char* name;&#125; Element;typedef struct &#123; Element datas[MAX_SIZE]; int front; int rear;&#125; SqQueue;#endif // DATAELEMENT_H_INCLUDED 创建12345Status Create(SqQueue* q)&#123; q-&gt;front = 0; q-&gt;rear = 0;&#125; 初始化12345678910111213Status Init(SqQueue* q, Element* datas, int length)&#123; if (length &gt; MAX_SIZE) &#123; return ERROR; &#125; if (!(q-&gt;front &amp;&amp; q-&gt;rear)) Create(q); for (int i = 0; i &lt; length; i++) &#123; EnQueue(q, datas[i]); &#125;&#125; 入队12345678910Status EnQueue(SqQueue* q, Element e)&#123; // 如果队满, 无法入队 if (isFull(q)) return ERROR; q-&gt;rear = (q-&gt;rear + 1) % MAX_SIZE; // 先把队尾移动一格 q-&gt;datas[q-&gt;rear] = e; // 再把数据放进去 return OK;&#125; 因为队尾指针 rear 一直指着最后一个元素，如果直接放数据会覆盖掉原本队尾的数据，所以需要先把队尾指针向后挪一格，再放数据。 出队12345678910Status DeQueue(SqQueue* q, Element* e)&#123; // 如果队空，无法出队 if (isEmpty(q)) return ERROR; q-&gt;front = (q-&gt;front + 1) % MAX_SIZE; *e = q-&gt;datas[q-&gt;front]; return OK;&#125; 因为队头指针 front 一直指着第一个元素前面一格，直接拿数据就不对了，所以需要先把队头指针先向后挪一个，指向真正的队头元素，再取数据。 判空1234Bool isEmpty(SqQueue* q)&#123; return q-&gt;front == q-&gt;rear;&#125; 判满1234Bool isFull(SqQueue* q)&#123; return q-&gt;front == (q-&gt;rear + 1) % MAX_SIZE;&#125; 打印队列123456789void Print(SqQueue* q)&#123; if (isEmpty(q)) printf(&quot;队列为空！&quot;); for (int i = q-&gt;front + 1; i &lt; q-&gt;rear + 1; i++) &#123; printf(&quot;%d \\t %s \\n&quot;, q-&gt;datas[i].id, q-&gt;datas[i].name); &#125;&#125; 测试数据123456789101112131415161718192021222324252627282930313233// main.c#include &quot;SqQueue.c&quot;#define len(X) sizeof(X) / sizeof(X[0])Element datas[] = &#123; &#123; 1, &quot;Iron Man&quot; &#125;, &#123; 2, &quot;Thor&quot; &#125;, &#123; 3, &quot;Captain&quot; &#125;, &#123; 4, &quot;Green Man&quot; &#125;&#125;;void main()&#123; SqQueue q; Create(&amp;q); Init(&amp;q, datas, len(datas)); printf(&quot;After Init(): \\n&quot;); Print(&amp;q); printf(&quot;\\n-------------------------------------\\n&quot;); Element el = &#123; 5, &quot;Big Man&quot; &#125;; EnQueue(&amp;q, el); printf(&quot;After EnQueue(): \\n&quot;); Print(&amp;q); printf(&quot;\\n-------------------------------------\\n&quot;); DeQueue(&amp;q, &amp;el); printf(&quot;After DeQueue(): \\n&quot;); printf(&quot;%d \\t %s&quot;, el.id, el.name);&#125; 链队链队相比循环队则简单多了，入队就是链表的插入，出队就是链表的删除，队空就是队头指针和队尾指针都为 NULL ，没有队满。 定义1234567891011121314151617181920212223242526// DataElement.h#ifndef DATAELEMENT_H_INCLUDED#define DATAELEMENT_H_INCLUDED#define OK 1#define ERROR 0typedef int Status;typedef struct &#123; int id; char* name;&#125; Element;typedef struct Node &#123; Element data; struct Node* next;&#125; Node;// 定义链队结构体typedef struct &#123; Node* front; Node* rear;&#125; LinkQueue;#endif // DATAELEMENT_H_INCLUDED 创建123456Status Create(LinkStack* q)&#123; q-&gt;front = NULL; q-&gt;rear = NULL; return OK;&#125; 在创建的时候，将两个队头队尾两个指针置空 初始化123456789Status Init(LinkQueue* q, Element* datas, int length)&#123; if (!isEmpty(q)) Create(q); for (int i = 0; i &lt; length; i++) &#123; EnQueue(q, datas[i]); &#125; return OK;&#125; 入队12345678910111213141516Status EnQueue(LinkQueue* q, Element e)&#123; Node* new = (Node*)malloc(sizeof(Node)); new-&gt;data = e; new-&gt;next = NULL; if (isEmpty(q)) &#123; // 如果队列为空，除了让队尾指向新结点，让队头也指向新结点 q-&gt;front = q-&gt;rear = new; return OK; &#125; else &#123; // 如果队列不为空，让旧的队尾元素指向新结点，队尾指针指向新结点 q-&gt;rear-&gt;next = new; q-&gt;rear = new; return OK; &#125; return ERROR;&#125; 入队就是让原本的队尾指向新的结点，这一步是让新结点加入链表；然后让队尾指针也指向新的结点，这一步是对队尾指针的更新。 如果队列为空时，队头指针和队尾指针一起指向新结点。 出队1234567891011121314151617181920212223Element DeQueue(LinkQueue* q, )&#123; Element e; if (isEmpty(q)) return e; if (q-&gt;front == q-&gt;rear) &#123; // 链队中只有一个元素时，出队后队空，所以需要恢复队头和队尾指针为空 e = q-&gt;rear-&gt;data; free(q-&gt;rear); q-&gt;front = q-&gt;rear = NULL; return e; &#125; // 链队中不止一个元素时 // 1. 取元素 e = q-&gt;front-&gt;data; // 2. 改链 Node* de = q-&gt;front; q-&gt;front = de-&gt;next; // 3. 释放空间 free(de); de = NULL; return e;&#125; 出队的时候要考虑三种情况： 队空，则返回一个空元素; 只有一个元素，出队后队头指针和队尾指针都要置空; 不止一个元素，则取元素、改链、释放空间，最后返回元素。 判空1234bool isEmpty(LinkQueue* q)&#123; return q-&gt;front == NULL &amp;&amp; q-&gt;rear == NULL;&#125; 清空链队123456789Status Clear(LinkQueue* q)&#123; if (isEmpty(q)) return OK; while (q-&gt;front) &#123; DeQueue(q); &#125; return OK;&#125; 销毁链队123456Status Destory(LinkQueue* q)&#123; Clear(q); free(q); return OK;&#125; 打印链队12345678910111213void Print(LinkQueue* q)&#123; if (isEmpty(q)) &#123; printf(&quot;队列为空！&quot;); return; &#125; Node* curr = q-&gt;front; while (curr) &#123; printf(&quot;%d \\t %s \\n&quot;, curr-&gt;data.id, curr-&gt;data.name); curr = curr-&gt;next; &#125;&#125; 完整代码顺序队、循环队1234567891011121314151617181920212223// DataElement.h#ifndef DATAELEMENT_H_INCLUDED#define DATAELEMENT_H_INCLUDED#define MAX_SIZE 10#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;typedef int Bool;typedef struct &#123; int id; char* name;&#125; Element;typedef struct &#123; Element datas[MAX_SIZE]; int front; int rear;&#125; SqQueue;#endif // DATAELEMENT_H_INCLUDED 1234567891011121314151617181920// SqQueue.h#ifndef DQQUEUE_H_INCLUDED#define DQQUEUE_H_INCLUDED#include &quot;DataElement.h&quot;Status Create(SqQueue* q);Status Init(SqQueue* q, Element* datas, int length);Status EnQueue(SqQueue* q, Element e);Status DeQueue(SqQueue* q, Element* e);Bool isEmpty(SqQueue* q);Bool isFull(SqQueue* q);void Print(SqQueue* q);#endif // DQQUEUE_H_INCLUDED 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// SqQueue.c#include &quot;SqQueue.h&quot;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;Status Create(SqQueue* q)&#123; q-&gt;front = 0; q-&gt;rear = 0;&#125;Status Init(SqQueue* q, Element* datas, int length)&#123; if (length &gt; MAX_SIZE) &#123; return ERROR; &#125; if (!(q-&gt;front &amp;&amp; q-&gt;rear)) Create(q); for (int i = 0; i &lt; length; i++) &#123; EnQueue(q, datas[i]); &#125;&#125;Status EnQueue(SqQueue* q, Element e)&#123; // 如果队满, 无法入队 if (isFull(q)) return ERROR; q-&gt;rear = (q-&gt;rear + 1) % MAX_SIZE; // 先把队尾移动一格 q-&gt;datas[q-&gt;rear] = e; // 再把数据放进去 return OK;&#125;Status DeQueue(SqQueue* q, Element* e)&#123; // 如果队空，无法出队 if (isEmpty(q)) return ERROR; q-&gt;front = (q-&gt;front + 1) % MAX_SIZE; *e = q-&gt;datas[q-&gt;front]; return OK;&#125;Bool isEmpty(SqQueue* q)&#123; return q-&gt;front == q-&gt;rear;&#125;Bool isFull(SqQueue* q)&#123; return q-&gt;front == (q-&gt;rear + 1) % MAX_SIZE;&#125;void Print(SqQueue* q)&#123; if (isEmpty(q)) printf(&quot;队列为空！&quot;); for (int i = q-&gt;front + 1; i &lt; q-&gt;rear + 1; i++) &#123; printf(&quot;%d \\t %s \\n&quot;, q-&gt;datas[i].id, q-&gt;datas[i].name); &#125;&#125; 1234567891011121314151617181920212223242526272829303132// main.c#include &quot;SqQueue.c&quot;#define len(X) sizeof(X) / sizeof(X[0])Element datas[] = &#123; &#123; 1, &quot;Iron Man&quot; &#125;, &#123; 2, &quot;Thor&quot; &#125;, &#123; 3, &quot;Captain&quot; &#125;, &#123; 4, &quot;Green Man&quot; &#125;&#125;;void main()&#123; SqQueue q; Create(&amp;q); Init(&amp;q, datas, len(datas)); printf(&quot;After Init(): \\n&quot;); Print(&amp;q); printf(&quot;\\n-------------------------------------\\n&quot;); Element el = &#123; 5, &quot;Big Man&quot; &#125;; EnQueue(&amp;q, el); printf(&quot;After EnQueue(): \\n&quot;); Print(&amp;q); printf(&quot;\\n-------------------------------------\\n&quot;); DeQueue(&amp;q, &amp;el); printf(&quot;After DeQueue(): \\n&quot;); printf(&quot;%d \\t %s&quot;, el.id, el.name);&#125; 链队123456789101112131415161718192021222324// DataElement.h#ifndef DATAELEMENT_H_INCLUDED#define DATAELEMENT_H_INCLUDED#define OK 1#define ERROR 0typedef int Status;typedef struct &#123; int id; char* name;&#125; Element;typedef struct Node &#123; Element data; struct Node* next;&#125; Node;typedef struct &#123; Node* front; Node* rear;&#125; LinkQueue;#endif // DATAELEMENT_H_INCLUDED 1234567891011121314151617181920212223// LinkQueue.h#ifndef LINKQUEUE_H_INCLUDED#define LINKQUEUE_H_INCLUDED#include &lt;stdbool.h&gt;#include &quot;DataElement.h&quot;Status Create(LinkQueue* q);Status InitLinkQ(LinkQueue* q, Element* datas, int length);Status EnQueue(LinkQueue* q, Element e);Element DeQueue(LinkQueue* q);Status Clear(LinkQueue* q);Status Destory(LinkQueue* q);bool isEmpty(LinkQueue* q);void Print(LinkQueue* q);#endif // LINKQUEUE_H_INCLUDED 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// LinkQueue.c#include &quot;LinkQueue.h&quot;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;Status Create(LinkQueue* q)&#123; q-&gt;front = NULL; q-&gt;rear = NULL; return OK;&#125;Status InitLinkQ(LinkQueue* q, Element* datas, int length)&#123; if (!isEmpty(q)) &#123; Create(q); &#125; for (int i = 0; i &lt; length; i++) &#123; EnQueue(q, datas[i]); &#125; return OK;&#125;Status EnQueue(LinkQueue* q, Element e)&#123; Node* new = (Node*)malloc(sizeof(Node)); new-&gt;data = e; new-&gt;next = NULL; // 如果队空，让队头也指向新结点 if (isEmpty(q)) &#123; q-&gt;front = q-&gt;rear = new; return OK; &#125; else &#123; // 队尾元素 指向新结点 q-&gt;rear-&gt;next = new; // 队尾指针 指向新结点 q-&gt;rear = new; return OK; &#125; return ERROR;&#125;Element DeQueue(LinkQueue* q)&#123; Element e; if (isEmpty(q)) return e; // 如果队中只有一个元素 if (q-&gt;front == q-&gt;rear) &#123; e = q-&gt;front-&gt;data; free(q-&gt;front); q-&gt;front = q-&gt;rear = NULL; return e; &#125; // 1. 改链 Node* de = q-&gt;front; q-&gt;front = de-&gt;next; // 2. 取元素 e = de-&gt;data; // 3. 释放空间 free(de); de = NULL; return e;&#125;bool isEmpty(LinkQueue* q)&#123; return q-&gt;front == NULL &amp;&amp; q-&gt;rear == NULL;&#125;Status Clear(LinkQueue* q)&#123; if (isEmpty(q)) &#123; return OK; &#125; while (q-&gt;front) &#123; DeQueue(q); &#125; return OK;&#125;Status Destory(LinkQueue* q)&#123; Clear(q); free(q); return OK;&#125;void Print(LinkQueue* q)&#123; if (isEmpty(q)) &#123; printf(&quot;队列为空！&quot;); return; &#125; Node* curr = q-&gt;front; while (curr) &#123; printf(&quot;%d \\t %s \\n&quot;, curr-&gt;data.id, curr-&gt;data.name); curr = curr-&gt;next; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940// main.c#include &quot;LinkQueue.c&quot;#define len(X) sizeof(X) / sizeof(X[0])Element datas[] = &#123; &#123; 1, &quot;Iron Man&quot; &#125;, &#123; 2, &quot;Thor&quot; &#125;, &#123; 3, &quot;Captain&quot; &#125;, &#123; 4, &quot;Green Man&quot; &#125;&#125;;void main()&#123; LinkQueue q; Create(&amp;q); InitLinkQ(&amp;q, datas, len(datas)); Print(&amp;q); printf(&quot;\\n-------------------------------------\\n&quot;); Element e = &#123; 5, &quot;Spider Man&quot; &#125;; EnQueue(&amp;q, e); Print(&amp;q); printf(&quot;\\n-------------------------------------\\n&quot;); Element de = DeQueue(&amp;q); printf(&quot;Element deleted: %d \\t %s \\n&quot;, de.id, de.name); printf(&quot;\\n-------------------------------------\\n&quot;); Print(&amp;q); printf(&quot;\\n-------------------------------------\\n&quot;); Clear(&amp;q); Print(&amp;q); printf(&quot;\\n-------------------------------------\\n&quot;); // Destory(&amp;q); // Print(&amp;q);&#125;","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"DataStruction 0x03 栈","slug":"408/DataStruction/DataStruction [3-栈]","date":"2021-02-23T08:00:38.000Z","updated":"2021-07-12T08:42:51.000Z","comments":true,"path":"posts/29925.html","link":"","permalink":"https://www.boii.xyz/posts/29925.html","excerpt":"什么是栈？","text":"什么是栈？ 3-栈 栈是一种只允许在一端进行插入和删除操作的操作受限的线性表。 栈的主要特点是**先进后出 (FILO)**，就像子弹夹一样，最先压进去的子弹最后打出来。 栈有一个指针，永远指向栈的最顶部，称作栈顶指针。 栈的另外一个概念是栈底指针，在顺序栈中可不实现，在链栈中必须实现。 对于栈的操作有插入和删除，也称作入栈和出栈，不能从中间取出，因为只有一个口。 顺序栈：栈的每一个元素存储在一段连续的内存空间，用数组实现。 链栈：栈的每一个元素不一定紧挨着，用链表实现。 栈的主要操作包括：创建、初始化、入栈、出栈、判空、判满、获取栈顶元素、清空栈。 栈的应用非常广，例如函数调用就是用栈实现的。栈这种前进后出的特点非常适合解决匹配问题。 顺序栈定义1234567891011121314151617181920212223242526#ifndef DATAELEMENT_H_INCLUDED#define DATAELEMENT_H_INCLUDED#define MAX_SIZE 10#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Bool;typedef int Status;/** 数据元素 */typedef struct &#123; int id; char* name;&#125; Element;/** 栈 */typedef struct &#123; Element datas[MAX_SIZE]; int top; // 栈顶指针&#125; Stack;#endif // DATAELEMENT_H_INCLUDED 创建1234Status Create(Stack *s) &#123; s-&gt;top = -1; return OK;&#125; 栈空条件有两种：s-&gt;top == -1、s-&gt;top == 0 这里采用 -1 这种，原因是不需要浪费一个元素大小的空间，另外操作起来也方便，因为数组下标是从0开始的。 初始化1234567891011Status Init(Stack* s, Element* datas, int length) &#123; if (length &gt; MAX_SIZE) return ERROR; if (s-&gt;top != -1) Create(s); for (int i = 0; i &lt; length; i++) push(s, datas[i]); return OK;&#125; 入栈1234567Status push(Stack* s, Element e) &#123; if (s-&gt;top &gt;= MAX_SIZE - 1) return ERROR; s-&gt;datas[++s-&gt;top] = e; return OK;&#125; 我们采用的是第一种栈空表示方式，栈顶指针永远指向栈顶元素，所以在将元素赋值压入栈之前，要先把栈顶指针抬起来 1 格，然后再把元素放进去。 s-&gt;datas[++s-&gt;top] = e 等价于 12s-&gt;top++; s-&gt;datas[s-&gt;top] = e 出栈123Element pop(Stack* s) &#123; return s-&gt;datas[s-&gt;top--];&#125; 出栈的道理相同，先把元素取出来，然后栈顶指针降下去1格。 s-&gt;datas[s-&gt;top--] 等价于 12s-&gt;datas[s-&gt;top]; s-&gt;top--; 获取栈顶元素获取栈顶元素不会出栈，就像把弹夹取下来看一眼，并不是打出去。 123Element get(Stack* s) &#123; return s-&gt;datas[s-&gt;top];&#125; 判空我们采用的是第一种栈空表示方式，所以只要判断栈顶指针是不是 s-&gt;top == -1即可。 123Bool isEmpty(Stack* s) &#123; return s-&gt;top == -1;&#125; 判满123Bool isFull(Stack* s) &#123; return s-&gt;top == MAX_SIZE - 1 ? TRUE : FALSE;&#125; 清空栈1234Status Clean(Stack* s) &#123; s-&gt;top = -1; return OK;&#125; 顺序栈的清空很简单，只需要把栈顶指针指向栈底即可，虽然原本的数据没有被销毁，但是后续push的数据会将其覆盖。即使没有覆盖，在栈中我们只需要关注栈顶指针 top 的指向即可，top 所指即为栈顶，不论 top 之上有没有数据。 至于销毁栈，需要在定义 Stack s 的地方 free(s) 。 打印栈1234void Show(Stack* s) &#123; for (int i = 0; i &lt;= s-&gt;top; i++) printf(&quot;%d \\t %s \\n&quot;, s-&gt;datas[i].id, s-&gt;datas[i].name);&#125; 测试数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;SqStack.c&quot;Element datas[] = &#123; &#123; 1, &quot;Iron Man&quot; &#125;, &#123; 2, &quot;Green Man&quot; &#125;, &#123; 3, &quot;Thor&quot; &#125;, &#123; 4, &quot;Doctor&quot; &#125;&#125;;int main()&#123; Stack s; Create(&amp;s); Init(&amp;s, datas, sizeof datas / sizeof datas[0]); Show(&amp;s); printf(&quot;\\n----------------------------------\\n&quot;); Element e = &#123; 5, &quot;Big Man&quot; &#125;; push(&amp;s, e); Show(&amp;s); printf(&quot;\\n----------------------------------\\n&quot;); Element pe = pop(&amp;s); pop(&amp;s); Show(&amp;s); return 0;&#125;// ---------------------------------------------------// Output:1 Iron Man 2 Green Man 3 Thor 4 Doctor ----------------------------------1 Iron Man 2 Green Man 3 Thor 4 Doctor 5 Big Man ----------------------------------1 Iron Man 2 Green Man 3 Thor 链栈定义12345678910111213141516171819202122232425262728293031#ifndef DATAELEMENT_H_INCLUDED#define DATAELEMENT_H_INCLUDED#define MAX_SIZE 10#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0typedef int Status;typedef int Bool;/** 数据元素 */typedef struct &#123; int id; char* name;&#125; Element;/** 链栈结点 */typedef struct Node &#123; Element data; struct Node* next;&#125; Node;/** 链栈 */typedef struct &#123; Node* next; int top;&#125; LStack;#endif // DATAELEMENT_H_INCLUDED 链栈稍微比顺序栈复杂一点点，但是换来不限栈大小的好处，所以在链栈中没有栈满的概念。 同时，链栈在入栈的时候需要手动分配空间，在出栈的时候需要把结点中的数据保存起来，销毁结点，再把数据返回。 创建12345Status Create(LStack* s) &#123; s-&gt;next = NULL; s-&gt;top = -1; return OK;&#125; 初始化123456789Status Init(LStack* s, Element* datas, int length) &#123; if (s-&gt;top != -1) Create(s); for (int i = 0; i &lt; length; i++) push(s, datas[i]); return OK;&#125; 入栈12345678910111213Status push(LStack* s, Element e) &#123;4// 建立新结点，分配空间 Node* new = (Node*)malloc(sizeof(Node)); // 判断分配空间是否成功 if (!new) return ERROR; new-&gt;data = e; // 插入到链表的首元结点，成为栈顶元素 new-&gt;next = s-&gt;next; s-&gt;next = new; s-&gt;top++;&#125; 这里的入栈使用的是头插法，即每个新插入的元素都会插在链表的首元结点的位置。 出栈123456789101112131415Element pop(LStack* s) &#123; Element res; if (isEmpty(s)) &#123; return res; &#125; Element res = s-&gt;next-&gt;data; // 将栈顶元素的数据复制一份 // 改链，原本指向栈顶元素，现在指向栈顶的下一个元素，使其成为新的栈顶 Node* p = s-&gt;next; s-&gt;next = p-&gt;next; // 将旧的栈顶元素释放空间 free(p); s-&gt;top--; return res;&#125; 链栈的出栈操作要记得把被弹出栈的旧栈顶元素释放。 获取栈顶元素123Element get(LStack* s) &#123; return s-&gt;next-&gt;data;&#125; 判空123Bool isEmpty(LStack* s) &#123; return s-&gt;top == -1;&#125; 清空栈12345678910111213141516171819Status Clean(LStack* s)&#123; if (s-&gt;top == -1) &#123; return OK; &#125; Node* deleted = s-&gt;next; Node* p; while (deleted) &#123; p = deleted-&gt;next; free(deleted); deleted = p; &#125; // s-&gt;next = NULL; // s-&gt;top = -1; Create(s); return OK;&#125; 清空链栈和销毁链表的操作是相同的，需要定义两个结点指针，相互配合实现整表销毁。 最后将栈置空，栈顶指针恢复到初试状态，所以这里调用了 Create()，等价于其上面两句表达式。 打印链栈123456789101112void Show(LStack* s) &#123; if (s-&gt;top == -1) &#123; printf(&quot;Stack is EMPTY!&quot;); return; &#125; Node* p = s-&gt;next; for (int i = s-&gt;top; i &gt; -1; i--) &#123; printf(&quot;%d \\t %s \\n&quot;, p-&gt;data.id, p-&gt;data.name); p = p-&gt;next; &#125;&#125; 测试数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &quot;LinkStack.c&quot;Element datas[] = &#123; &#123; 1, &quot;Iron Man&quot; &#125;, &#123; 2, &quot;Green Man&quot; &#125;, &#123; 3, &quot;Thor&quot; &#125;, &#123; 4, &quot;Doctor&quot; &#125;&#125;;int main()&#123; LStack s; Init(&amp;s, datas, 4); Show(&amp;s); printf(&quot;\\n----------------------------------\\n&quot;); Element e = &#123; 5, &quot;Big Man&quot; &#125;; push(&amp;s, e); Show(&amp;s); printf(&quot;\\n----------------------------------\\n&quot;); Element pe = pop(&amp;s); pop(&amp;s); Show(&amp;s); printf(&quot;\\n----------------------------------\\n&quot;); Clean(&amp;s); Show(&amp;s); return 0;&#125;// ---------------------------------------------------// Output:4 Doctor 3 Thor 2 Green Man 1 Iron Man ----------------------------------5 Big Man 4 Doctor 3 Thor 2 Green Man 1 Iron Man ----------------------------------3 Thor 2 Green Man 1 Iron Man ----------------------------------Stack is EMPTY! 共享栈 共享栈：指的是两个栈共用一个内存空间的一种栈结构。共享栈不需要用链式结构，因为共享栈为的是节省空间，用链式没有意义。 两个栈的栈底固定不变，讲两个栈顶设置在数组的两端，即 左边的栈 s0 的栈底设在 0 处，右边的栈 s1 的栈底设在 MAX_SIZE - 1 处。创建共享栈时，左栈的栈顶指针 topL = -1，右栈的栈顶指针 topR = MAX_SIZE，当两个栈顶相遇时栈满，这样可以尽可能地利用空间。 栈空 ↓ （topL == -1 &amp;&amp; topR == MAX_SIZE） 栈满 ↓ (topL == topR - 1) 普通状态 ↓ 定义共享栈的定义稍稍不同。 1234567891011121314151617181920212223242526#ifndef DATAELEMENT_H_INCLUDED#define DATAELEMENT_H_INCLUDED#define MAX_SIZE 10#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0#define LEFT 1 // 和顺序栈的定义相比多一个 LEFT 和 RIGHT 来标记方向#define RIGHT 999typedef int Bool;typedef int Status;typedef struct &#123; int id; char* name;&#125; Element;typedef struct &#123; Element datas[MAX_SIZE]; // 栈的存储空间，用数组来存储 int topL; // 左栈的栈顶指针 int topR; // 右栈的栈顶指针&#125; ShareStack;#endif // DATAELEMENT_H_INCLUDED 创建123456Status Create(ShareStack* s)&#123; s-&gt;topL = -1; s-&gt;topR = MAX_SIZE; return OK;&#125; 创建时，将两个指针初始化 初始化123456789101112131415161718Status Init(ShareStack* s, Element* datas, int length, int direction)&#123; if (length &gt; MAX_SIZE) &#123; return ERROR; &#125; if (direction == LEFT &amp;&amp; !isEmptyL(s)) &#123; s-&gt;topL == -1; &#125; if (direction == RIGHT &amp;&amp; !isEmptyR(s)) &#123; s-&gt;topR = MAX_SIZE; &#125; for (int i = 0; i &lt; length; i++) &#123; push(s, datas[i], direction); &#125; return OK;&#125; 共享栈需要多一个参数 direction，来指定将元素放入左栈还是右栈。 入栈1234567891011121314151617181920Status push(ShareStack* s, Element e, int direction)&#123; if (isFull(s)) &#123; return ERROR; &#125; switch (direction) &#123; case LEFT: s-&gt;datas[++s-&gt;topL] = e; return OK; case RIGHT: s-&gt;datas[--s-&gt;topR] = e; return OK; default: printf(&quot;Direction is ILLEGAL PARAMETER!&quot;); return ERROR; &#125;&#125; 出栈1234567891011121314151617181920212223Element pop(ShareStack* s, int direction)&#123; Element e; switch (direction) &#123; case LEFT: if (isEmptyL(s)) &#123; return e; &#125; e = s-&gt;datas[s-&gt;topL--]; return e; case RIGHT: if (isEmptyR(s)) &#123; return e; &#125; e = s-&gt;datas[s-&gt;topR--]; return e; default: printf(&quot;Direction is ILLEGAL PARAMETER!&quot;); break; &#125;&#125; 获取栈顶元素1234Element get(ShareStack* s, int direction)&#123; return s-&gt;datas[direction == LEFT ? s-&gt;topL : s-&gt;topR];&#125; 判空1234567891011121314Bool isEmpty(ShareStack* s)&#123; return s-&gt;topL == -1 &amp;&amp; s-&gt;topR == MAX_SIZE;&#125;Bool isEmptyL(ShareStack* s)&#123; return s-&gt;topL == -1;&#125;Bool isEmptyR(ShareStack* s)&#123; return s-&gt;topR == MAX_SIZE;&#125; 判满1234Bool isFull(ShareStack* s)&#123; return s-&gt;topL == s-&gt;topR - 1;&#125; 清空栈1234567891011121314151617181920Status Clean(ShareStack* s, int direction)&#123; if (isEmpty(s)) &#123; return OK; &#125; switch (direction) &#123; case LEFT: s-&gt;topL = -1; break; case RIGHT: s-&gt;topR = MAX_SIZE; break; default: return ERROR; &#125; return OK;&#125; 打印栈12345678910111213141516171819202122232425262728293031323334353637383940void Show(ShareStack* s, int direction)&#123; if (isEmpty(s)) &#123; printf(&quot;The Whole Share stack is EMPTY!\\n&quot;); &#125; switch (direction) &#123; // 打印左栈 case LEFT: if (isEmptyL(s)) &#123; printf(&quot;The Left Share stack is EMPTY!\\n&quot;); return; &#125; for (int i = 0, j = 1; i &lt;= s-&gt;topL; i++, j++) &#123; printf(&quot;No. %d is: %d \\t %s \\n&quot;, j, s-&gt;datas[i].id, s-&gt;datas[i].name); &#125; break; // 打印右栈 case RIGHT: if (isEmptyR(s)) &#123; printf(&quot;The Right Share stack is EMPTY!\\n&quot;); return; &#125; for (int i = s-&gt;topR, j = 1; i &lt; MAX_SIZE; i++, j++) &#123; printf(&quot;No. %d is: %d \\t %s \\n&quot;, j, s-&gt;datas[i].id, s-&gt;datas[i].name); &#125; break; // 如果传进来的不是 LEFT 也不是 RIGHT，则打印整个栈 default: for (int i = 0; i &lt; MAX_SIZE; i++) &#123; if (i &gt; s-&gt;topL &amp;&amp; i &lt; s-&gt;topR) &#123; // 超过左栈没到右栈的这段空白 printf(&quot;No. %d is EMPTY.\\n&quot;, i + 1); &#125; else &#123; printf(&quot;No. %d is: %d \\t %s \\n&quot;, i + 1, s-&gt;datas[i].id, s-&gt;datas[i].name); &#125; &#125; break; &#125;&#125; 测试数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;ShareStack.c&quot;#define len(X) sizeof(X) / sizeof(X[0])Element datas1[] = &#123; &#123; 1, &quot;Iron Man&quot; &#125;, &#123; 2, &quot;Green Man&quot; &#125;, &#123; 3, &quot;Thor&quot; &#125;, &#123; 4, &quot;Doctor&quot; &#125;&#125;;Element datas2[] = &#123; &#123; 12, &quot;Spider Man&quot; &#125;, &#123; 24, &quot;Wonder Woman&quot; &#125;, &#123; 35, &quot;Bat Man&quot; &#125;, &#123; 40, &quot;Super Man&quot; &#125;&#125;;int main()&#123; ShareStack ss; Create(&amp;ss); Init(&amp;ss, datas2, len(datas2), RIGHT); Show(&amp;ss, RIGHT); printf(&quot;\\n----------------------------------\\n&quot;); Init(&amp;ss, datas1, len(datas1), LEFT); Show(&amp;ss, LEFT); printf(&quot;\\n----------------------------------\\n&quot;); Show(&amp;ss, 10); return 0;&#125;// ---------------------------------------------------// Output:No. 1 is: 40 Super Man No. 2 is: 35 Bat Man No. 3 is: 24 Wonder Woman No. 4 is: 12 Spider Man ----------------------------------No. 1 is: 1 Iron Man No. 2 is: 2 Green Man No. 3 is: 3 Thor No. 4 is: 4 Doctor ----------------------------------No. 1 is: 1 Iron Man No. 2 is: 2 Green Man No. 3 is: 3 Thor No. 4 is: 4 Doctor No. 5 is EMPTY.No. 6 is EMPTY.No. 7 is: 40 Super Man No. 8 is: 35 Bat Man No. 9 is: 24 Wonder Woman No. 10 is: 12 Spider Man","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"DataStruction 0x02 线性表","slug":"408/DataStruction/DataStruction [2-线性表]","date":"2021-02-23T08:00:37.000Z","updated":"2021-07-11T07:21:54.000Z","comments":true,"path":"posts/21668.html","link":"","permalink":"https://www.boii.xyz/posts/21668.html","excerpt":"什么是线性表？","text":"什么是线性表？ 2-线性表 线性表指 0 或 n 个数据元素的有限序列 特点： 元素之间有序 元素个数有限 第一个无直接前驱元素 最后一个无直接后继元素 其余元素都有唯一一个直接前驱元素和唯一一个直接后继元素 线性表元素的个数 $n(n&gt;=0)$ 即为线性表的长度；当 n=0 时，称为空表。 非空表中每个数据元素都有一个确定的位置，如$a_1$是首个元素，$a_n$是最后元素，$a_i$是第$i$个元素（称 $i$ 为数据元素 $a_i$ 在线性表中的位序） 说句人话就是，像数组一样的数据结构就是线性表。比如拿 5 个苹果排成一行，从左到右依次编号 12345，第一个苹果前面没有苹果，最后一个苹果后面没有其他苹果，中间第 2、3、4 个苹果都有前一个苹果和后一个苹果，例如第 2 个苹果的前一个苹果是 1 号苹果，后一个是 3 号苹果。 ADT12345678910111213ADT 线性表(List)Data 线性表是数据对象集合为&#123;a1, a2, ..., an&#125;，每个元素的类型均为DataType。Operation InitList(*L): 初始化操作，建立一个空的线性表L。 ListEmpty(L): 线性表为空返回True， 否则返回False ClearList(*L): 将线性表清空。 GetElem(L, i, *e): 将线性表L中第i个位置元素的值返回给e。 LocateElem(L, e): 在线性表L中查找与给定值e相等的元素，查找成功返回元素在表中的序号，失败返回O。 ListInsert(*L, i, e): 在线性表L中第i个位置插入新元素e。 ListDelete(*L, i, *e): 删除线性表L中第i个位置元素，并用e返回其值。 ListLength(L): 返回线性表L的元素个数。endADT 顺序结构的线性表 线性表的顺序存储结构，指的是用一段连续的存储单元一次存储线性表的数据元素。例如数组，知道了第一个元素的地址，后面的元素都可以快速的计算出来。假设第一个元素的地址为 A，每个元素占 k 个字节，则可知第 i 个元素的地址为 A + i * k。 顺序结构在查找时，不论要查找的元素在任何位置，时间复杂度都为 $O(1)$，但在插入和删除时，平均时间复杂度为 $O(n)$。 顺序结构代码实现 先放上各专业术语的关系图，以做对照。 数据元素各种操作的基本单位是数据元素，数据元素又由各数据项构成。 在代码中，用 结构体类型(C语言中是结构体，Java等语言是类) 来实现数据元素，用各种 基本类型(int、char、float、其他结构体等) 来实现数据项。（注意数据项也可以是结构体） 1234567// 定义结构体struct Student&#123; char name[10]; int age;&#125;;typedef struct Student Stu; // 为结构体起别名，后续写代码的时候比较方便 或者写成这种： 1234typedef struct&#123; char name[10]; int age;&#125;Stu; 在实际应用中数据元素（结构体）名字以实际业务为准在以下例子中，则用 Element 指代 数据元素结构体。 1234typedef struct&#123; char name[10]; int age;&#125;Element; 数据对象这里数据对象指的就是线性表了。线性表中需要包含 N 个数据元素，N 个数据元素要使用数组存放；再加上一个count来统计数据元素个数。 注意是元素个数 (count of data elemment) 不是数组长度(length of array)。 数组长度一开始要预留好，是固定不变的；元素个数是变化的，增删插入之后都会变化，而数组长度不会。 123456789// DataElement.h#define len(X) sizeof X / sizeof X[0]#define MAX_SIZE 5typedef struct&#123; Element elemArr[MAX_SIZE]; // 用数组存放数据元素 int count; // Count of data element.&#125;SqList; 初始化123456789Status Init(SqList *L, Stu *studArr)&#123; int length = len(studArr); // 获取数组长度 if(length &gt; MAX_SIZE) return ERROR; // 检查数组长度是否超出预设长度 L-&gt;count = 0; // count 初始化为 0 for(int i = 0; i &lt; length; i++) Insert(L, i, studArr[i]); // 调用插入方法将元素插入到数组中（插入方法稍后实现） return OK;&#125; 1234567891011121314151617// main.c#include &quot;DataElement.h&quot;int main()&#123; // 定义一个线性表 SqList L; SqList *pL = &amp;L; // 定义一份数据集 Stu studArr = &#123; &#123;&quot;Boii&quot;, 18&#125;, &#123;&quot;Eva&quot;, 20&#125;, &#125;; // 初始化线性表 Init(pL, studArr); return 0;&#125; 获得元素123456789101112131415161718#define OK 1#define ERROR 0typedef uint Status;/** * 用pe返回 在线性表L中第position个元素 * @param *L 要操作是顺序表 * @param position 要查找的元素位置 * @param e 负责带回元素的元素指针 * @return 获得成功返回OK，失败返回ERROR */Status GetElem(SqList *L, int position, Element *e)&#123; if(L-&gt;count == 0 || position &lt; 1 || position &gt; L-&gt;count || e == NULL) return ERROR; *e = L-&gt;data[position-1]; return OK;&#125; 123456789//------------------------------------------------// 调用时SqList L;SqList *pL = &amp;L;Element e;Element *pe = &amp;e;if(GetElem(pL, 3, pe)) printf(&quot;%s %d&quot;, pe-&gt;name, pe-&gt;age); 函数中先是判断顺序表是否为空表（空表时 count 为 0），接着对位置进行判断，看看是否在合法范围内，还有指针是否为空；如果满足其中一个条件则返回 ERROR。最后对将目标元素赋值给 pe。 参数中使用的是 *L，即直接操作目标顺序表position 代表的是位置，从1开始的（注意不是下标，下标是从0开始的），所以是将 data[position-1] 返回去例如查找第5个元素，应该1211返回 data[4] 插入123456789101112131415161718192021/** * 将 e 插入到在线性表L中的第 idx 个元素 * @param *L 要操作是顺序表 * @param idx 要插入的元素下标 * @param e 要插入的元素的指针 * @return 插入成功返回OK，失败返回ERROR */Status Insert(SqList *L, int idx, Element *e)&#123; // 如果顺序表已满、或下标越界，返回ERROR if(L-&gt;count == MAX_SIZE || idx &lt; 0 || idx &gt; L-&gt;count) return ERROR; // 如果要插入的位置不在末尾，则从最后一个开始，一个一个往后挪 if(idx &lt; L-&gt;count) for(int i = L-&gt;count - 1; i &gt;= idx; i--) L-&gt;data[i + 1] = L-&gt;data[i]; // 将元素插入指定的 idx L-&gt;data[idx] = *e; L-count++; return OK;&#125; 思路： 表满时，插入失败 下标小于 0 或大于 count - 1 时，插入失败 插入位置在表尾，即 idx = count，直接插入 插入位置不在表尾，即 idx &lt; count，从末尾开始后一位给前一位，直到把 data[idx] 空出来 删除1234567891011121314151617181920212223/** * 将线性表L中的第 position 个元素删除，被删元素保存在 e 中 * @param *L 要操作是顺序表 * @param position 要查找的元素位置 * @param e 要删除的元素的指针 * @return 删除成功返回OK，失败返回ERROR */Status Delete(SqList *L, int position, Element *e)&#123; // 如果空表或者位置超出范围，返回ERROR if(L-&gt;count == 0 || position &lt; 1 || position &gt; L-&gt;count) return ERROR; // 将要删除的元素保存起来 if (e != NULL) *e = L-&gt;data[position - 1]; // 如果删除的不是末尾元素 if (position &lt; L-&gt;count) for(int i = position; i &lt; L-&gt;count; i++) L-&gt;data[i - 1] = L-&gt;data[i]; // 元素个数-1 L-&gt;count--; return OK;&#125; 思路： 如果空表，或者位置超出范围[1, count]，删除失败 先将要删除的元素保存起来 如果删除的不是末尾元素，从删除位置开始到顺序表末尾，后一个赋值给前一个，最后元素个数-1 如果删除的是末尾元素，直接元素个数-1 总结数组在查询时，不管元素在哪个位置，时间复杂度都为 O(1)，在删除和插入时，如果位置靠后则挪动的少，如果位置在最前，则整个数组都要挪动。换言之，插入或删除第 i 个元素，需要移动 i - 1个元素。平均移动次数为 (n - 1)/2。所以时间复杂度为O(n)。 顺序结构比较适合元素个数不太变化，而是更多存取数据的应用。 链式结构的线性表 线性表的链式结构是指，指的是用不连续的存储单元存储线性表的数据元素。 在链式结构中，除了存储数据元素之外，还要存储其后继元素的地址。存储数据元素信息的域称为数据域，存储后继元素地址的域称为指针域；这两部分共同组成一个结点，n个结点链结成一个链表，即为线性表的链式存储结构。 链表的起始结点称为头结点，头结点中的指针域称为头指针。头结点的数据域可以不存储任何信息，也可以存储线性表长度等附加信息；头结点的指针域指向第一个结点（第一个结点可以称为首元结点）；头结点的指针域为空时（即头指针为空时），为空链表。 因此，每个结点只包含一个后继指针域（指向后继元素的指针域），称为 单向链表；每个结点包含一个后继指针域（指向后继元素的指针域）和一个前驱指针域（指向前驱元素的指针域），称为双向链表； 链表的最后一个结点称为尾结点，尾结点的指针域可以为空（通常用 NULL 或 ^ 表示）尾结点的后继指针域为空时，称为 单链表；尾结点的后继指针域指向首元结点的地址时（指向首元结点不是头结点），称为 循环链表。 同理，尾结点的后继指针域指 $\\to$ 向首元结点的地址，首元结点的前驱指针域指 $\\to$ 向尾结点时，称为 双向循环链表。 单链表的代码实现定义结点1234567891011121314151617181920// 定义数据元素typedef struct Element &#123; char *name; int age;&#125; Element;// 定义结点typedef struct Node &#123; Element data; // 数据域 struct Node* next; // 指针域，指向本身类型定，称为自引用&#125; Node;// 为结点指针定义别名typedef Node* PNode;// 定义头结点typedef struct HeadNode &#123; int length; struct Node* next;&#125; HeadNode; 代码中，先是定义了数据元素的结构，然后定义结点。 定义结点的时候，分别定义了数据域和指针域。可以看到指针域其实是自身的指针，这样的实现称为自引用。 假设 p 是指向第 i 个结点的移动指针，则 p-&gt;data 的值第 i 个结点的数据，而 p-&gt;next 的值为下一个结点（即第 i + 1个结点）的地址。用 p = p-&gt;next; 可以让移动指针移动到第 i + 1 个结点，这时再使用 p-&gt;data 的值就为第 i + 1 个结点的数据。 最后为了方便表示，为这个结点类型的指针定义了一个类型别名 PNode。 1PNode p; 创建链表创建链表其实就是创建一个头结点，这个头结点很重要，对链表的操作都是从头结点开始的。 这里形参用的是指针形式，即直接操作该指针。所以在调用 Create() 时取了 link 的地址。 123456789Status Create(HeadNode *head) &#123; head-&gt;length = 0; head-&gt;next = null; return OK;&#125;// 调用时HeadNode link;Create(&amp;link); 插入结点插入节点的思路为： 创建新结点并给结点的数据域赋值 如果要插入的位置为 1（即首元节点），则将头结点的 next 给新节点，然后头结点的 next 指向新节点，长度 +1； 如果要插入的位置不为 1，则利用一个 node 指针遍历链表找到要插入位置的前一个结点，将前一个结点的 next 给新节点，然后前一个结点的 next 指向 新节点，长度 +1； 123456789101112131415161718192021222324252627282930313233Status Insert(HeadNode *head, Element e, int pos) &#123; // 如果插入位置超过数组长度，则返回ERROR if(pos &gt; head-&gt;length) return ERROR; // 1. 创建新节点并给新结点的数据域赋值 Node* newNode = (Node*)malloc(sizeof Node); newNode-&gt;data = e; newNode-&gt;next = NULL; // 2. 如果插入的位置为首元节点 if(pos == 1)&#123; newNode-&gt;next = head-&gt;next; head-&gt;next = newNode; head-&gt;length++; return OK; &#125; // 3. 如果插入的位置不是首元节点 // 声明一个移动指针遍历遍历直到达到要插入的位置的前一个结点 // 因为要到达前一个结点，所以这里走到 pos - 1 即可 Node* p = head-&gt;next; for(int i = 1; p &amp;&amp; i &lt; pos - 1; i++)&#123; p = p-&gt;next; &#125; newNode-&gt;next = p-&gt;next; p-&gt;next = newNode; head-&gt;length++; return OK;&#125;// 调用时Element e = &#123;&quot;Boii&quot;, 18&#125;;Insert(&amp;head, e, 4); 链表插入的重点在于要先将 前一个结点的指针域 新节点的指针域 newNode-&gt;next = p-&gt;next ，然后再把 新节点的地址给前一个结点的指针域 p-&gt;next = newNode ，这两者顺序不能颠倒，否则会插入失败。 初始化链表初始化链表时需要将头结点和元素数组传给函数 上面我们已经定义好了 创建链表函数，插入结点函数，所以在初始化时非常方便，只需要调用Create()创建链表，然后遍历元素数组，调用Insert()即可。 1234567891011121314151617181920Status Init(HeadNode *head, Element *datas)&#123; // 创建链表 if(Create(head))&#123; // 遍历元素数组 for(int i = 0; i &lt; (sizeof datas / sizeof datas[0]); i++) Insert(head, datas[i], i + 1); return OK; &#125; return ERROR;&#125;// 调用时Element datas = &#123; &#123;&quot;Alice&quot;, 18&#125;, &#123;&quot;Boii&quot;, 20&#125;, &#123;&quot;Candy&quot;, 22&#125;&#125;;HeadNode head;Init(&amp;head, datas); 读取结点假设现在要读取第 i 个结点，在读取结点之前，要先找到结点，然后把数据保存起来。 获得链表第 i 个数据的思路： 声明一个移动指针 p，让 p 指向第一个结点； 声明一个计数器 j， 初始化 j 从 1 开始（因为 j 是用来和 i 做比较的，i 是从1开始算的）； 当 j &lt; i 时，就遍历链表，一直让移动指针 p 向后移动并且 j++，直到 j == i； 若到链表末尾 p 为空，则说明没找到第 i 个数据； 否则查找成功，返回 p 指向的结点的数据。 123456789101112131415Status GetElem(PNode List, int i, Element *e) &#123; PNode p = List-&gt;next; // 指向头结点； int j = 1; // 初始化计数器 while(j &lt; i || p ) &#123; p = p-&gt;next; // 让移动指针指向下一个结点 j++; &#125; // 如果 p 为空 或者 j &gt; i, 说明没找到，返回 error if(!p || j &gt; i) return ERROR; *e = p-&gt;data; return OK;&#125; 删除结点删除思路： 创建一个结点指针 Node*来暂存要被删除的结点的地址 找到要被删除的结点的前一个结点 让前一个结点的 next 指向被删结点的 下一个结点 free 释放被删结点的内存 1234567891011121314151617181920212223242526Status Delete(HeadNode *head, int pos)&#123; if(pos &gt; head-&gt;length) return ERROR; Node* p = head-&gt;next; /* 1. 如果删除的是首元节点 */ if(pos == 1)&#123; head-&gt;next = p-&gt;next; head-&gt;length--; free(p); return OK; &#125; /* 2. 如果删除的不是首元结点 */ /* 先找到要删除结点的前一个结点 */ for(int i = 1; p &amp;&amp; i &lt; pos - 1; i++)&#123; p = p-&gt;next; &#125; /* 然后删除目标结点 */ Node *q = p-&gt;next; // 创建一个Node型指针暂存被删结点 p-&gt;next = q-&gt;next; // 让被删结点的前驱元素的 next 指向被删结点的后驱元素 head-&gt;length--; // 长度-1 free(q); // 释放被删结点的空间 q = p = NULL; // 指针置空 return OK;&#125; C语言需要自己管理内存，自己管理指针释放指针，所以在删除之前要先将被删除结点保存起来，改链（p-&gt;next = q-&gt;next）之后将被删除结点的内存释放，最后把函数里创建的指针置空。 删除 i 结点其实就是让 i - 1 结点指向 i + 1. 循环链表 循环链表与单链表相比多了一个尾元结点指向首元节点。可以把尾元结点的指针称为尾指针。 当遍历循环链表时，可以通过判断 尾元结点-&gt;next == 头结点-&gt;next得知是否遍历了一圈了。 其实循环链表可以有2种实现形式： 尾指针指向头结点 尾指针指向首元结点 可根据需要选择相应的设计。 在操作上，循环链表和单链表的区别主要在插入和删除上。 插入操作循环链表的插入操作要考虑4种情况 链表是否为空 插入位置为首元节点 插入位置为尾元结点 插入位置为中间结点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Status Insert(HeadNode *head, Element e, int pos)&#123; if(pos &gt; head-&gt;length) return ERROR; // 创建新结点 Node *newNode = (Node*)malloc(sizeof Node); newNode-&gt;data = e; newNode-&gt;next = NULL; /** 1. 链表为空 */ if(!head-&gt;length)&#123; newNode-&gt;next = newNode; // 让新结点的后继指针指向自己 head-&gt;next = newNode; // 让头结点指向新结点 head-&gt;length++; return OK; &#125; /** 链表不为空 */ /** 2. 插入位置为首元结点 */ if(pos == 1)&#123; // 先把新结点做插入操作 newNode-&gt;next = head-&gt;next; head-&gt;next = newNode; head-&gt;length++; // 找到尾结点 Node *last = head-&gt;next; for(int i = 0; i &lt; head-&gt;length; i++) last = last-&gt;next; // 让尾指针指向新结点 last-&gt;next = newNode; return OK; &#125; /** 3. 插入位置为尾元结点 */ if(pos == head-&gt;length)&#123; // 找到尾结点 Node *last = head-&gt;next; for(int i = 0; i &lt; head-&gt;length; i++) last = last-&gt;next; // 让新结点指向头结点，让尾结点指向新结点 newNode-&gt;next = head-&gt;next; last-&gt;next = newNode; head-&gt;length++; return OK; &#125; /** 4. 插入位置为中间结点*/ if(pos != head-&gt;length)&#123; // 找到目标位置的前一个 Node *p = head-&gt;next; for(int i = 1; p &amp;&amp; i &lt; pos - 1; i++) p = p-&gt;next; // 做普通插入操作 newNode-&gt;next = p-&gt;next; p-&gt;next = newNode; head-&gt;length++; return OK; &#125; &#125; 当链表为空时，插入新结点只需要让新结点指向自己，然后让头结点指向新结点即可 当链表不为空 插入位置为首元结点时，先做一个普通的插入操作，然后找到尾结点让尾指针指向新结点即可 插入位置为尾元结点时，找到尾元结点，让新结点指向头结点，让尾指针指向新结点即可 插入位置为中间结点时，找到目标位置前一个结点，做一个普通插入操作即可 循环链表删除操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758Status DeteleCLinkList(HeadNode* head, int pos)&#123; // 判断位置是否正确，或是否为空链表 if (isEmptyC(head) || pos &gt; head-&gt;length) return ERROR; // 如果是删除首元结点 if (pos == 1) &#123; Node* first = head-&gt;next; head-&gt;next = first-&gt;next; Node* last = GetLast(head); last-&gt;next-&gt;next = head-&gt;next; head-&gt;length--; free(first); return OK; &#125; // 如果是删除尾元结点 if (pos == head-&gt;length) &#123; Node* last = GetLast(head); last-&gt;next = head-&gt;next; head-&gt;length--; free(last); return OK; &#125; // 1、找到目标结点 Node* current = head-&gt;next; for (int i = 1; i &lt; pos - 1; i++) &#123; current = current-&gt;next; &#125; // 2、进行删除操作 Node* q = current-&gt;next; current-&gt;next = q-&gt;next; head-&gt;length--; free(q); return OK;&#125;/** 返回尾结点的前驱结点 */Node* GetLast(HeadNode* head)&#123; if (!head-&gt;length) &#123; printf(&quot;链表为空！&quot;); &#125; if (head-&gt;length == 1) &#123; return head-&gt;next; &#125; Node* last = head-&gt;next; for (int i = 0; i &lt; head-&gt;length - 1; i++) &#123; last = last-&gt;next; &#125; return last;&#125;","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"DataStruction 0x01 算法","slug":"408/DataStruction/DataStruction [1-算法]","date":"2021-02-23T08:00:36.000Z","updated":"2021-07-11T06:34:24.000Z","comments":true,"path":"posts/17036.html","link":"","permalink":"https://www.boii.xyz/posts/17036.html","excerpt":"什么是算法？","text":"什么是算法？ 1-算法算法：是解决特定问题求解步骤的描述；在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 算法特性： 输入：算法具有0或n个输入； 输出：算法至少有1或n个输出； 有穷性：算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一步骤在可接受的时间内完成； 确定性：算法的每一步骤都具有确定的含义，不会出现二义性； 可行性：算法的每一步骤都能够通过执行有限次数完成。 算法设计的要求： 正确性：指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能得到问题的正确答案； 可读性：算法设计的另一目的是为了便于阅读、理解和交流； 健壮性：当输入不合法数据时，算法也能做出相关处理，而不是产生异常； 高效性：算法设计应该尽量满足时间效率高和存储量低的需求。 算法效率的度量方法一个程序的运行时间，依赖于算法的好坏和问题的输入规模（输入规模：输入量的多少）。 测定运算时间最可靠的方法就是计算对运行时间有消耗的基本操作的执行次数。在分析程序运行时间时，最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤。 当输入规模变大以后，常数项、非最高阶项的影响微乎其微，所以判断一个算法的效率时，函数中的参数和其他次要项常常可以忽略，应该更关注主项（最高阶项）的阶数。 算法时间复杂度 在进行算法分析时，语句总的执行次数 $T(n)$ 是关于问题规模 $n$的函数，进而分析 $T(n)$ 随 $n$ 的变化情况并确定 $T(n)$ 的数量级。算法的时间复杂度，记作：$T(n) = O(f(n))$。表示随着问题规模 $n$ 的增大，算法执行时间的增长率和 $f(n)$ 的增长率相同。 算法时间复杂度常用大O表示法$O(1)$常数阶、$O(n)$线性阶、$O(n^2)$平方阶 大O阶的推导步骤为： 用常数1取代运行时间中所有的常数 只保留最高阶 除了$O(1)$，去除最高阶的系数 时间复杂度排序：$O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)$","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"DataStruction 0x00 绪论","slug":"408/DataStruction/DataStruction [0-绪论]","date":"2021-02-23T08:00:35.000Z","updated":"2021-07-11T06:03:25.000Z","comments":true,"path":"posts/44644.html","link":"","permalink":"https://www.boii.xyz/posts/44644.html","excerpt":"什么是数据结构？","text":"什么是数据结构？ 本系列文章系个人总结所写，执笔上偏于新手向，会有诸多用词不严谨之处，只为了方便理解。欢迎指正，拒绝指责。 绪论程序 是一系列指令的集合。程序设计 = 数据结构 + 算法 数据，由 N 个 0 和 1 组成，本质上是一串二进制代码，利于计算机计算，但不利于人类阅读思考。所以在此之上经过层层抽象，将计算机中的数据抽象出诸如 对象、实例、结点、数据对象 等概念。 数据结构，就是以 对象、实例、结点、数据对象 为单位，研究各个单位之间的关系。由此明确，在数据结构中需要研究两个东西： 单位、关系 单位数据的单位在数据结构中通常称为 数据对象，数据对象可以是一个人、一辆车、一个数字、一个字符、或者多种数据的组合，在代码中表现为结构体变量或对象。 而一个人，会有多种数据：名字（name）、年龄（age）、学号（ID），在代码中表现为结构体成员变量或对象成员变量。 而名字、年龄、学号这些，我们称为 数据项。 即 N 个数据项构成了数据对象 每个人都有学号、姓名、年龄，例如张三李四王五，但张三不是李四、王五不是赵六，他们都是各自独立的。 但他们都是人类，所以我们把人类称为 数据元素，在代码中表现为 结构体定义或类定义。 1234567891011121314// 结构体定义 &lt;--&gt; 数据元素typedef struct &#123; // 结构体成员变量 &lt;--&gt; 数据项 long ID; int age; char* name;&#125; Person;// 数据对象 &lt;--&gt; 结构体变量Person Zhangsan = &#123; 1213, 18, &quot;Boii&quot;&#125;; 关系说完单位，剩下就是关系了。 这些单位之间的关系，理论上有很多种：线性表、广义表、链表、栈、队、树、图；这种我们称为 逻辑结构。 而在代码、或者说物理上的实现，只有两种：顺序存储结构、链式存储结构；这些我们称为 物理结构。 逻辑结构逻辑上的各种关系可以分为 4 大类： 集合结构：各个单位之间，除了同属一个集合，没有别的关系；各个单位是“平等”的。 线性结构：各个单位之间是一对一的关系 树形结构：各个单位之间是一对多的关系 图形结构：各个单位之间是多对多的关系 集合结构比较少见，这里暂时不做讨论。我们主要讨论常见的线性、树形、图形结构。 物理结构程序是运行在内存中的，而内存是顺序排列的，没那么多花里胡哨的，而且受计算机物理实现所束缚，物理结构中： 要么是一个挨着一个的顺序存储结构，要么是单位（数据对象）之间并不一定挨着的链式存储结构。 两种结构都有各自的特点。 顺序存储结构 特点：数据对象之间在物理上一个挨着一个、有序，只要知道了第一个数据对象的地址，可以很快找到后面其他的数据对象。与此同时，为了保持这种一个挨着一个和有序的特点，当插入或者删除某一个数据对象时，后面的数据对象要一个一个往后挪腾出中间的位置，或者一个一个往前挪填补中间的空缺，导致插入和删除很慢。 优点：查找速度快。 缺点：插入和删除慢。 链式存储结构 特点：数据对象之间在物理上并不一定相互挨着、无序，要查找某一个数据对象时需要从第一个数据对象开始，一个接着一个往后一路查下去才能找到。与此同时，因为物理上不一定相互挨着，所以插入和删除时只需要修改前后的链条即可。 优点：插入和删除快。 缺点：查找速度慢。 这里的快慢，指的是计算机需要执行多次计算称为慢，计算机需要执行少量计算称为快。 ADT 抽象数据类型抽象数据类型是用来表示某一种逻辑结构（栈、队、树、...）的具体信息，具有什么样的操作 等等。 描述 ADT 的标准格式： 1234567891011121314ADT 抽象数据类型名Data 数据元素之间逻辑关系的定义Operation 操作1 初始条件 操作结果描述 操作2 ... ... 操作n ... ...endAD ADT 就像一张蓝图。在建房子之前我们需要先设计好房子的功能、结构等，之后再依照图纸开工。ADT 就是数据结构的图纸，事先定义好各种关系和操作，写起代码来才能有条不紊。 总结","categories":[{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"}]},{"title":"Hexo-文件下载功能","slug":"Hexo/Hexo-文件下载功能","date":"2020-08-23T08:00:35.000Z","updated":"2021-07-19T08:59:51.835Z","comments":true,"path":"posts/22089.html","link":"","permalink":"https://www.boii.xyz/posts/22089.html","excerpt":"So easy~","text":"So easy~ 操作方法效果：点击下载 在source目录下，新建download目录，和_posts、About、tags、categories等目录并列 将你需要分享的文件或者需要展示的图片之类，统一放到该download下 在写文章时，通过诸如 [点击下载](/download/xx.exe) 这样的链接，直接写入。其他，照旧 在 volantis主题下，可以这样写 &#123;% btn 点击下载, /download/xx.exe, fas fa-download %&#125; 注意： 全半角不要搞错。 必须是压缩文件（.exe | .zip | .rar | 7z |…），否则跳过去直接给你展示了不会触发下载的。","categories":[{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/categories/HEXO/"},{"name":"Git","slug":"Git","permalink":"https://www.boii.xyz/categories/Git/"},{"name":"Note","slug":"Note","permalink":"https://www.boii.xyz/categories/Note/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/tags/HEXO/"},{"name":"note","slug":"note","permalink":"https://www.boii.xyz/tags/note/"},{"name":"git","slug":"git","permalink":"https://www.boii.xyz/tags/git/"}]},{"title":"Python【Buildins】re","slug":"Python/Python【No-Buildins】re","date":"2020-08-23T03:17:48.000Z","updated":"2021-07-19T08:55:19.566Z","comments":true,"path":"posts/25647.html","link":"","permalink":"https://www.boii.xyz/posts/25647.html","excerpt":"Python的内置库——正则表达式","text":"Python的内置库——正则表达式 正则表达式是用来处理字符串的，重在处理规则 常用正则 年份匹配：^((19|20)\\d&#123;2&#125;)$ 手机号码：^1[3456789]\\d&#123;9&#125;$ E-mail地址：^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$ 网址URL：http://(/[\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]) re.findall(goal, source)匹配成功 返回一个列表，列表中有goal的字符串，找到n次就有n个匹配失败 返回一个空列表 1234567891011&gt;&gt;&gt; # 普通字符正则的匹配&gt;&gt;&gt;&gt;&gt;&gt; import re&gt;&gt;&gt; print(re.findall(&#x27;p&#x27;, &#x27;python&#x27;))[&#x27;p&#x27;]&gt;&gt;&gt; print(re.findall(&#x27;python&#x27;, &#x27;I like python&#x27;))[&#x27;python&#x27;]&gt;&gt;&gt; print(re.findall(&#x27;o&#x27;, &#x27;I love python&#x27;))[&#x27;o&#x27;, &#x27;o&#x27;]&gt;&gt;&gt; print(re.findall(&#x27;2&#x27;, &#x27;1234567890abcdefg&#x27;))[&#x27;2&#x27;] 预定义字符 \\d、\\D、\\s、\\S、\\w、\\W \\d：匹配所有数字，0~9 \\w：匹配包含下划线字符 [a-z|A-Z|0-9|_] \\s：匹配空白符、制表符、换行符 [\\n \\t] \\D：匹配所有非数字，^[0-9] \\W：匹配非正常字符 ^[a-z|A-Z|0-9|_] \\S：匹配非空白符、制表符、换行符 ^[\\n \\t] .：除了换行符之外所有字符 1234567891011121314&gt;&gt;&gt; print(re.findall(r&quot;\\d&quot;, &quot;1234657890abcdefg&quot;))[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;6&#x27;, &#x27;5&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;0&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;\\D&quot;, &quot;1234657890abcdefg&quot;))[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;\\w&quot;, &quot;1234657890abcd_%$#efg&quot;))[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;6&#x27;, &#x27;5&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;0&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;_&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;\\W&quot;, &quot;1234657890abcd_%$#efg&quot;))[&#x27;%&#x27;, &#x27;$&#x27;, &#x27;#&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;\\s&quot;, &quot;1234 657\\n890ab\\tcd_%$#efg&quot;))[&#x27; &#x27;, &#x27;\\n&#x27;, &#x27;\\t&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;\\S&quot;, &quot;1234 657\\n890ab\\tcd_%$#efg&quot;))[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;6&#x27;, &#x27;5&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;0&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;_&#x27;, &#x27;%&#x27;, &#x27;$&#x27;, &#x27;#&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;] 元字符 []、&#123;n&#125;、^、- []：匹配一个字符，括号内是或者的关系 ^：取反 (和这些元字符或\\d这些预定义字符一起用才是取反，否则和$一起做位置匹配) -：区间 ()：分组，匹配括号内的内容，不要括号两边的内容 123456789101112131415161718192021222324252627282930# 区间&gt;&gt;&gt; # 匹配123任意单个字符&gt;&gt;&gt; print(re.findall(r&quot;[123]&quot;, &quot;1234 657\\n890ab\\tcd_%$#efg&quot;))[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]&gt;&gt;&gt; # 匹配单个数字（\\d）或 空格换行制表符（\\s）&gt;&gt;&gt; print(re.findall(r&quot;[\\d\\s]&quot;, &quot;1234 657\\n890ab\\tcd_%$#efg&quot;))[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27; &#x27;, &#x27;6&#x27;, &#x27;5&#x27;, &#x27;7&#x27;, &#x27;\\n&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;0&#x27;, &#x27;\\t&#x27;]# 取反&gt;&gt;&gt; # 匹配单个非数字、非空格换行制表符&gt;&gt;&gt; print(re.findall(r&quot;[^\\d\\s]&quot;, &quot;1234 657\\n890ab\\tcd_%$#efg&quot;))[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;_&#x27;, &#x27;%&#x27;, &#x27;$&#x27;, &#x27;#&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;]# 范围&gt;&gt;&gt; # 匹配单个1-7之间的数字&gt;&gt;&gt; print(re.findall(r&quot;[1-7]&quot;, &quot;1234 657\\n890ab\\tcd_%$#efg&quot;))&gt;&gt;&gt; # 匹配单个a-d之间的字母&gt;&gt;&gt; print(re.findall(r&quot;[a-d]&quot;, &quot;1234 657\\n890ab\\tcd_%$#efg&quot;))&gt;&gt;&gt; # 匹配单个 1-7 或 a-d 的字符&gt;&gt;&gt; print(re.findall(r&quot;[1-7a-d]&quot;, &quot;1234 657\\n890ab\\tcd_%$#efg&quot;))# 分组&gt;&gt;&gt; # 匹配 左边a右边是a或b或c的两个字符&gt;&gt;&gt; print(re.findall(r&quot;a[abc]&quot;, &quot;aaabacad&quot;))[&#x27;aa&#x27;, &#x27;ab&#x27;, &#x27;ac&#x27;]&gt;&gt;&gt; # 第一步，匹配到[&#x27;aa&#x27;, &#x27;ab&#x27;, &#x27;ac&#x27;]&gt;&gt;&gt; # 第二步，不要括号两边的字符，也就是不要a，得到[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;a([abc])&quot;, &quot;aaabacad&quot;))[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] 重复匹配重复匹配默认是贪婪匹配的，会尽量匹配多位 &#123;n&#125;：表示前面的字符重复n次才被匹配成功。a&#123;3&#125;就匹配出：aaa &#123;n,m&#125;：表示前面的字符至少出现n次，至多出现m次，逗号左右不能有空格，贪婪匹配 &#123;n,m&#125;?：表示前面的字符至少出现n次，至多出现m次，逗号左右不能有空格，非贪婪匹配 &#123;n,&#125;：表示前面的字符至少出现n次，至多出现无穷次 ?：相当于&#123;0,1&#125;，表示前面的字符出现0次或1次 +：相当于&#123;1,&#125;，表示前面的字符至少出现1次 *：相当于&#123;0,&#125;，表示前面的字符出现0次或无穷次，贪婪匹配 +?：相当于&#123;1,&#125;?、&#123;1&#125;，表示前面的字符至少出现1次，非贪婪匹配 *?：相当于&#123;0,&#125;?、&#123;0&#125;，表示前面的字符至少出现0次，非贪婪匹配 \\：转义符，在需要匹配上面?+*几个符号的时候需要加上斜杠\\ 12345678910111213141516171819# &#123;n&#125;&gt;&gt;&gt; # 贪婪匹配连续3位都是数字&gt;&gt;&gt; print(re.findall(r&quot;\\d&#123;3&#125;&quot;, &quot;1234567890abcdefg&quot;))[&#x27;123&#x27;, &#x27;456&#x27;, &#x27;789&#x27;]&gt;&gt;&gt; # 贪婪匹配连续2位都是正常字符&gt;&gt;&gt; print(re.findall(r&quot;\\w&#123;2&#125;&quot;, &quot;12a3456789b0abcdefg&quot;))[&#x27;12&#x27;, &#x27;a3&#x27;, &#x27;45&#x27;, &#x27;67&#x27;, &#x27;89&#x27;, &#x27;b0&#x27;, &#x27;ab&#x27;, &#x27;cd&#x27;, &#x27;ef&#x27;]&gt;&gt;&gt; # 贪婪匹配至少2位至多4位的数字&gt;&gt;&gt; print(re.findall(r&quot;\\d&#123;2,4&#125;&quot;, &quot;1234567890abcdefg&quot;))[&#x27;1234&#x27;, &#x27;5678&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;\\d&#123;2,4&#125;&quot;, &quot;12a3456789b0abcdefg&quot;))[&#x27;12&#x27;, &#x27;3456&#x27;, &#x27;789&#x27;]&gt;&gt;&gt; # 非贪婪匹配至少2位至多4位的数字&gt;&gt;&gt; print(re.findall(r&quot;\\d&#123;2,4&#125;?&quot;, &quot;12a3456789b0abcdefg&quot;))[&#x27;12&#x27;, &#x27;34&#x27;, &#x27;56&#x27;, &#x27;78&#x27;]&gt;&gt;&gt; # 贪婪匹配出现至少2位的数字&gt;&gt;&gt; print(re.findall(r&quot;\\d&#123;2,&#125;&quot;, &quot;12a3456789b0abcdefg165465165&quot;))[&#x27;12&#x27;, &#x27;3456789&#x27;, &#x27;165465165&#x27;] 1234567891011121314151617# ? + *&gt;&gt;&gt; # 贪婪匹配0或1个数字，0个也在匹配范围内，所以匹配到非数字的时候是空字符串&gt;&gt;&gt; print(re.findall(r&quot;\\d?&quot;, &quot;12a3456789b0abcde_%&quot;))[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;&#x27;, &#x27;0&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;]&gt;&gt;&gt; # 贪婪匹配1或n个数字&gt;&gt;&gt; print(re.findall(r&quot;\\d+&quot;, &quot;12a3456789b0abcde_%&quot;))[&#x27;12&#x27;, &#x27;3456789&#x27;, &#x27;0&#x27;]&gt;&gt;&gt; # 非贪匹配1或n个数字&gt;&gt;&gt; print(re.findall(r&quot;\\d+?&quot;, &quot;12a3456789b0abcde_%&quot;))[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;0&#x27;]&gt;&gt;&gt; # 贪婪匹配1或n个数字&gt;&gt;&gt; print(re.findall(r&quot;\\d*&quot;, &quot;1234567890abcdefg&quot;))[&#x27;1234567890&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;]&gt;&gt;&gt; # 非贪匹配1或n个数字&gt;&gt;&gt; print(re.findall(r&quot;\\d*?&quot;, &quot;1234567890abcdefg&quot;))[&#x27;&#x27;, &#x27;1&#x27;, &#x27;&#x27;, &#x27;2&#x27;, &#x27;&#x27;, &#x27;3&#x27;, &#x27;&#x27;, &#x27;4&#x27;, &#x27;&#x27;, &#x27;5&#x27;, &#x27;&#x27;, &#x27;6&#x27;, &#x27;&#x27;, &#x27;7&#x27;, &#x27;&#x27;, &#x27;8&#x27;, &#x27;&#x27;, &#x27;9&#x27;, &#x27;&#x27;, &#x27;0&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;] 1234567891011121314151617181920# 转义符&gt;&gt;&gt; # 匹配a*b&gt;&gt;&gt; print(re.findall(r&quot;a\\*b&quot;, &quot;aab*ab*aaa*ba*b*a&quot;))[&#x27;a*b&#x27;, &#x27;a*b&#x27;]&gt;&gt;&gt; # 匹配b前面至少出现0次a&gt;&gt;&gt; print(re.findall(r&quot;a*b&quot;, &quot;aab*ab*aaa*ba*b*a&quot;))[&#x27;aab&#x27;, &#x27;ab&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27;]&gt;&gt;&gt; # 匹配a+b&gt;&gt;&gt; print(re.findall(r&quot;a\\+b&quot;, &quot;&quot;))[&#x27;a+b&#x27;]&gt;&gt;&gt; # 匹配b前面至少出现1次aprint(re.findall(r&quot;a+b&quot;, &quot;aab*ab*aa?ba*ba*b*a+b&quot;))[&#x27;aab&#x27;, &#x27;ab&#x27;]&gt;&gt;&gt; # 匹配a?bprint(re.findall(r&quot;a\\?b&quot;, &quot;aab*ab*aa?ba*ba*b*a+b&quot;))[&#x27;a?b&#x27;]&gt;&gt;&gt; # 匹配b前面至少出现0次至多出现1次aprint(re.findall(r&quot;a?b&quot;, &quot;aab*ab*aa?ba*ba*b*a+b&quot;))[&#x27;ab&#x27;, &#x27;ab&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;b&#x27;] 贪婪和非贪123456&gt;&gt;&gt; # 贪婪匹配 d开头d结尾，中间至少出现1位正常字符&gt;&gt;&gt; print(re.findall(r&quot;d\\w+d&quot;, &quot;dxxxxxxdxxxxxxd&quot;))[&#x27;dxxxxxxdxxxxxxd&#x27;]&gt;&gt;&gt; # 非贪匹配 d开头d结尾，中间至少出现1位正常字符&gt;&gt;&gt; print(re.findall(r&quot;d\\w+?d&quot;, &quot;dxxxxxxdxxxxxxd&quot;))[&#x27;dxxxxd&#x27;] 123456789101112131415&gt;&gt;&gt; html = &quot;&lt;li&gt;Boii&lt;/li&gt;&lt;li&gt;$18&lt;/li&gt;&lt;li&gt;男&lt;/li&gt;&lt;li&gt;i@tcp404.com&lt;/li&gt;&quot;&gt;&gt;&gt; # .是除了换行符以外所有字符&gt;&gt;&gt; # 贪婪匹配 &lt;li&gt;开头，&lt;/li&gt;结尾，中间至少一个非换行符的字符，共1个&gt;&gt;&gt; print(re.findall(r&quot;&lt;li&gt;.+&lt;/li&gt;&quot;, html))[&#x27;&lt;li&gt;Boii&lt;/li&gt;&lt;li&gt;$18&lt;/li&gt;&lt;li&gt;男&lt;/li&gt;&lt;li&gt;i@tcp404.com&lt;/li&gt;&#x27;]&gt;&gt;&gt; # 非贪匹配 &lt;li&gt;开头，&lt;/li&gt;结尾，中间至少一个非换行符的字符，共3个&gt;&gt;&gt; print(re.findall(r&quot;&lt;li&gt;.+?&lt;/li&gt;&quot;, html))[&#x27;&lt;li&gt;Boii&lt;/li&gt;&#x27;, &#x27;&lt;li&gt;$18&lt;/li&gt;&#x27;, &#x27;&lt;li&gt;男&lt;/li&gt;&#x27;, &#x27;&lt;li&gt;i@tcp404.com&lt;/li&gt;&#x27;]&gt;&gt;&gt; # 非贪匹配 &lt;li&gt;开头，&lt;/li&gt;结尾，中间至少一个非换行符的字符，且舍去开头结尾，&gt;&gt;&gt; # 即只取&lt;li&gt;&lt;/li&gt;中的内容，共3个&gt;&gt;&gt; print(re.findall(r&quot;&lt;li&gt;(.+?)&lt;/li&gt;&quot;, html))[&#x27;Boii&#x27;, &#x27;$18&#x27;, &#x27;男&#x27;, &#x27;i@tcp404.com&#x27;] 反向引用12345678910111213141516171819202122232425&gt;&gt;&gt; wordstr = &quot;&quot;&quot; &#x27;hello&#x27;, &quot;python&quot;, &#x27;love&quot;, &quot;haha&#x27; &quot;&quot;&quot;# 匹配 开头和结尾都是单引号或双引号，中间至少一个正常字符&gt;&gt;&gt; print(re.findall(r&quot;[&#x27;|\\&quot;]\\w+[&#x27;|\\&quot;]&quot;, wordstr))[&quot;&#x27;hello&#x27;&quot;, &#x27;&quot;python&quot;&#x27;, &#x27;\\&#x27;love&quot;&#x27;, &#x27;&quot;haha\\&#x27;&#x27;]# 匹配 开头和结尾都是单引号或双引号，中间至少一个正常字符，舍弃中间# 即 开头和结尾都是单或双引号，中间至少一个正常字符，然后把开头分一组，结尾分一组，中间无分组被舍弃&gt;&gt;&gt; print(re.findall(r&quot;(&#x27;|\\&quot;)\\w+(&#x27;|\\&quot;)&quot;, wordstr))[(&quot;&#x27;&quot;, &quot;&#x27;&quot;), (&#x27;&quot;&#x27;, &#x27;&quot;&#x27;), (&quot;&#x27;&quot;, &#x27;&quot;&#x27;), (&#x27;&quot;&#x27;, &quot;&#x27;&quot;)]# 匹配 开头和结尾都是单引号或双引号，中间至少一个正常字符，开头一组，中间一组，结尾一组，找到一份则组合成一个元组&gt;&gt;&gt; print(re.findall(r&quot;(&#x27;|\\&quot;)(\\w+)(&#x27;|\\&quot;)&quot;, wordstr))[(&quot;&#x27;&quot;, &#x27;hello&#x27;, &quot;&#x27;&quot;), (&#x27;&quot;&#x27;, &#x27;python&#x27;, &#x27;&quot;&#x27;), (&quot;&#x27;&quot;, &#x27;love&#x27;, &#x27;&quot;&#x27;), (&#x27;&quot;&#x27;, &#x27;haha&#x27;, &quot;&#x27;&quot;)]# 匹配 开头是单双引号，中间至少一个正常字符，结尾要与开头对应开头一组那个组相同# 开头一组，中间一组，结尾一组，找到一份则组合成一个元组&gt;&gt;&gt; print(re.findall(r&quot;(&#x27;|\\&quot;)(\\w+)(\\1)&quot;, wordstr))[(&quot;&#x27;&quot;, &#x27;hello&#x27;, &quot;&#x27;&quot;), (&#x27;&quot;&#x27;, &#x27;python&#x27;, &#x27;&quot;&#x27;)]# 用列表生成式取出每份的1号元素，就得到了内容。&gt;&gt;&gt; res = re.findall(r&quot;(&#x27;|\\&quot;)(\\w+)(\\1)&quot;, wordstr)&gt;&gt;&gt; li = [x[1] for x in res]&gt;&gt;&gt; print(li)[&#x27;hello&#x27;, &#x27;python&#x27;] 123456789101112# 校验密码，同样的字符不能连续出现3次&gt;&gt;&gt; print(re.findall(r&quot;(\\w)(\\1&#123;2,&#125;)&quot;, &quot;44888813abgggs&quot;))[(&#x27;8&#x27;, &#x27;888&#x27;), (&#x27;g&#x27;, &#x27;gg&#x27;)]# 第一个分组(\\w)匹配到是4，进入下一个元组，看到\\1替换成4，开始匹配重复：4出现至少2次则匹配成功，后面紧跟着只有一个4，所以匹配失败# 接着匹配到(\\w)是8，进入下一个分组，看到\\1替换成8，从第2个8开始匹配重复：8至少出现2次则匹配成功，除去第一个8被第一个分组取走，还剩3个8，匹配成功，这是贪婪匹配，所以会一直吃下去吃到遇见不是8停止，打包成元组# 接着1匹配失败，3匹配失败，ab都匹配失败# 接着匹配到(\\w)是g，进入下一个分组，看到\\1替换成g，从第2个g开始匹配重复：g至少出现2次则匹配成功，除去第一个g被第一个分组取走，还剩2个g，匹配成功，这是贪婪匹配，所以会一直吃下去吃到遇见不是g停止，打包成元组...res = re.findall(r&quot;(\\w)(\\1&#123;2,&#125;)&quot;, &quot;44888813abgggs&quot;)li = [x[0]+x[1] for x in res]print(li) # [&#x27;8888&#x27;, &#x27;ggg&#x27;] 位置匹配 ^：开头 $：结尾 这两个经常一起使用，用来限定位置常用于检验手机号、用户名、email地址等 例如匹配手机号 1234567891011121314# 手机位数正常的时候可以匹配成功&gt;&gt;&gt; print(re.findall(r&quot;\\d&#123;11&#125;&quot;, &quot;13700001111&quot;))[&#x27;13700001111&#x27;]# 但是手机位数不正常的时候也匹配成功了，所以要加以位置限制&gt;&gt;&gt; print(re.findall(r&quot;\\d&#123;11&#125;&quot;, &quot;137000011112233445&quot;))[&#x27;13700001111&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;^\\d&#123;11&#125;$&quot;, &quot;13700001111&quot;))[&#x27;13700001111&#x27;]&gt;&gt;&gt; print(re.findall(r&quot;^\\d&#123;11&#125;$&quot;, &quot;137000011112233445&quot;))[]","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"内置库","slug":"Python/内置库","permalink":"https://www.boii.xyz/categories/Python/%E5%86%85%E7%BD%AE%E5%BA%93/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.boii.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Python【Buildins】json","slug":"Python/Python【No-Buildins】json","date":"2020-08-22T04:17:48.000Z","updated":"2021-07-19T08:55:19.442Z","comments":true,"path":"posts/41814.html","link":"","permalink":"https://www.boii.xyz/posts/41814.html","excerpt":"Python的内置库——json处理","text":"Python的内置库——json处理 &#123;&quot;firstName&quot;:&quot;John&quot;, &quot;lastName&quot;:&quot;Doe&quot;&#125; 对于dictionaries，keys需要是字符串类型(字典中任何非字符串类型的key在编码时会先转换为字符串)。而且，在web应用程序中，顶层对象被编码为一个字典是一个标准做法。 这句话大概意思是： 用&#123;&#125; 开头和结尾 用str表示 key 用str, int, list, dict 表示 value list用[index]访问 dict用.key访问 json 字符串生成 python 对象：json.load()python 对象格式化为 json 字符串：json.dump() 数据类型转换对应表（python -&gt; json） Python JSON dict object list, tuple array str string int, float number True true False false None null 转换对应表（json -&gt; python） JSON Python object dict array list string str number(int) int number(real) float true True false False null None 常用方法 方法 功能 总结 json.dump(obj,fp) 将python数据类型转换并保存到json格式文件内 p -&gt; j,写入文件 json.dumps(obj) 将python数据类型转换为json格式的字符串 p -&gt; j json.load(fp) 从json格式的文件中读取数据并转换为python的类型 从文件读, j -&gt; p json.loads(str) 将json格式的字符串转换为python的类型 j -&gt; p 带s的是处理字符串不带s的是从文件里处理 Python -&gt; JSON json.dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw) json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw) obj：需要被转换的Python对象 fp：文件对象，要写入的文件 skipkeys： Fasle时：不是基本对象(int、str、bool、float)的键不会被跳过 True时：不是基本对象(int、str、bool、float)的键会被跳过 ensure_ascii： True：将非ASCII字符转义，例如中文 False：将非ASCII字符原样输出 allow_nan： True：对json规格范围外的float类型(nan、inf、-inf)序列化时会引发ValueError False：对json规格范围外的float类型(nan、inf、-inf)序列化时使用等价形式(NaN、Infinity、-Infinity) indent：指定缩进等级（非负整数/字符串） 0、负数、””：只添加换行符 None：不缩进 正整数：每层缩进同样数量的空格 字符串：如\\t，该字符串将被用于缩进每一层 sort_keys：按字典的键排序 default：其应该是一个函数，每当某个对象无法被序列化时它会被调用。它应该返回该对象的一个可以被 JSON 编码的版本或者引发一个 TypeError。 使用dumps() 123456789101112131415161718192021222324252627282930import json# 这是一个 python 字典对象py_dic = &#123; &#x27;firstName&#x27;: &#x27;Boii&#x27;, &#x27;j&#x27;: &#123; &#x27;x&#x27;: 1, &#x27;y&#x27;: &quot;2&quot;, &#x27;z&#x27;: 3 &#125;, &quot;lastName&quot;: &quot;Pro&quot;, &#x27;li&#x27;: [&quot;A&quot;, &#x27;b&#x27;, 3]&#125;print(&#x27;Python对象：&#x27;, end=&quot;&quot;)print(py_dic, end=&quot;\\t&quot;)print(type(py_dic))# 将一个 Python 对象转换成 json 字符串json_str = json.dumps(py_dic, sort_keys=True)print(&#x27;JSON字符串：&#x27;, end=&quot;&quot;)print(json_str, end=&quot;\\t&quot;)print(type(json_str))--------------------------------------------------# Output:Python对象：&#123;&#x27;firstName&#x27;: &#x27;Boii&#x27;, &#x27;j&#x27;: &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: &#x27;2&#x27;, &#x27;z&#x27;: 3&#125;, &#x27;lastName&#x27;: &#x27;Pro&#x27;, &#x27;li&#x27;: [&#x27;A&#x27;, &#x27;b&#x27;, 3]&#125; &lt;class &#x27;dict&#x27;&gt;JSON字符串：&#123;&quot;firstName&quot;: &quot;Boii&quot;, &quot;j&quot;: &#123;&quot;x&quot;: 1, &quot;y&quot;: &quot;2&quot;, &quot;z&quot;: 3&#125;, &quot;lastName&quot;: &quot;Pro&quot;, &quot;li&quot;: [&quot;A&quot;, &quot;b&quot;, 3]&#125; &lt;class &#x27;str&#x27;&gt; 可以发现，Python中都是使用单引号&#39;，JSON中都是使用双引号&quot; 123456789101112131415161718192021import json# 这是一个python 列表对象py_list = [1, 2, 3]print(&#x27;Python对象：&#x27;, end=&quot;&quot;)print(py_list, end=&quot;\\t&quot;)print(type(py_list))# 将一个 Python 对象转换成 json 字符串json_str = json.dumps(py_list, sort_keys=True)print(&#x27;JSON字符串：&#x27;, end=&quot;&quot;)print(json_str, end=&quot;\\t&quot;)print(type(json_str))--------------------------------------------------# Output:Python对象：[1, 2, 3] &lt;class &#x27;list&#x27;&gt;JSON字符串：[1, 2, 3] &lt;class &#x27;str&#x27;&gt; 使用dump() 123456789101112131415161718192021222324import jsonpy_dic = &#123; &#x27;firstName&#x27;: &#x27;Boii&#x27;, &#x27;j&#x27;: &#123; &#x27;x&#x27;: 1, &#x27;y&#x27;: &quot;2&quot;, &#x27;z&#x27;: 3 &#125;, &quot;lastName&quot;: &quot;Pro&quot;, &#x27;li&#x27;: [&quot;A&quot;, &#x27;b&#x27;, 3]&#125;# 将一个 Python 对象转换成 json 字符串，然后写入文件with open(&#x27;./py_dic.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: json.dump(py_dic, f, sort_keys=True)--------------------------------------------------# Output:没有输出，因为输出到文件中了# py_dic.json&#123;&quot;firstName&quot;: &quot;Boii&quot;, &quot;j&quot;: &#123;&quot;x&quot;: 1, &quot;y&quot;: &quot;2&quot;, &quot;z&quot;: 3&#125;, &quot;lastName&quot;: &quot;Pro&quot;, &quot;li&quot;: [&quot;A&quot;, &quot;b&quot;, 3]&#125; 有些教程中直接使用open()打开一个文件对象，然后将文件对象作为参数传入dump()，却没有使用close()关闭文件对象。这是错误的，会造成文件对象一直没有关闭而持续占用计算机资源。 解决方法：要么手动调用close()方法，要么用with语句 12345678f = open(&#x27;./py_dic.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;)json.dump(py_dic, f, sort_keys=True)f.close()或with open(&#x27;./py_dic.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: json.dump(py_dic, f, sort_keys=True) JSON -&gt; Python json.load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw) json.loads(s, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw) fp：文件对象，要写入的文件 object_hook：是一个可选的函数，它会被调用于每一个解码出的对象字面量（即一个 dict）。object_hook 的返回值会取代原本的 dict。这一特性能够被用于实现自定义解码器（如 JSON-RPC 的类型提示)。 parse_float、parse_int、parse_constant、 object_pairs_hook：都是编码解码器需要的参数 使用loads() 1234567891011121314151617181920import jsonStr = &#x27;&#123;&quot;name&quot;: &quot;Boii&quot;, &quot;age&quot;: 30, &quot;tel&quot;:[&quot;13800000000&quot;, &quot;13100880088&quot;], &quot;isonly&quot;:true&#125;&#x27;print(&#x27;JSON字符串：&#x27;, end=&quot;&quot;)print(Str, end=&#x27;\\t&#x27;)print(type(Str))# 将一个 json 字符串 转换成 Python 对象pythonObj = json.loads(Str)print(&#x27;Python对象：&#x27;, end=&quot;&quot;)print(pythonObj, end=&#x27;\\t&#x27;)print(type(pythonObj))--------------------------------------------------# Output:JSON字符串：&#123;&quot;name&quot;: &quot;Boii&quot;, &quot;age&quot;: 30, &quot;tel&quot;:[&quot;13800000000&quot;, &quot;13100880088&quot;], &quot;isonly&quot;:true&#125; &lt;class &#x27;str&#x27;&gt;Python对象：&#123;&#x27;name&#x27;: &#x27;Boii&#x27;, &#x27;age&#x27;: 30, &#x27;tel&#x27;: [&#x27;13800000000&#x27;, &#x27;13100880088&#x27;], &#x27;isonly&#x27;: True&#125; &lt;class &#x27;dict&#x27;&gt; 可以发现，Python中都是使用单引号&#39;，JSON中都是使用双引号&quot; 使用load()从json文件中读取转换成Python对象 1234567891011121314151617# py.json&#123;&quot;firstName&quot;: &quot;Boii&quot;, &quot;j&quot;: &#123;&quot;x&quot;: 2, &quot;y&quot;: &quot;2&quot;, &quot;z&quot;: 3&#125;, &quot;lastName&quot;: &quot;Pro&quot;, &quot;li&quot;: [&quot;A&quot;, &quot;b&quot;, 3]&#125;# j2p.pyimport jsonwith open(&#x27;./j2p.py&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: pythonObj = json.load(f) print(&#x27;Python对象：&#x27;, end=&quot;&quot;) print(pythonObj) print(type(pythonObj))--------------------------------------------------# Output:Python对象：&#123;&#x27;firstName&#x27;: &#x27;Boii&#x27;, &#x27;j&#x27;: &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: &#x27;2&#x27;, &#x27;z&#x27;: 3&#125;, &#x27;lastName&#x27;: &#x27;Pro&#x27;, &#x27;li&#x27;: [&#x27;A&#x27;, &#x27;b&#x27;, 3]&#125;&lt;class &#x27;dict&#x27;&gt; 总结1234567# Writing JSON datawith open(&#x27;data.json&#x27;, &#x27;w&#x27;) as f: json.dump(data, f)# Reading data backwith open(&#x27;data.json&#x27;, &#x27;r&#x27;) as f: data = json.load(f)","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"内置库","slug":"Python/内置库","permalink":"https://www.boii.xyz/categories/Python/%E5%86%85%E7%BD%AE%E5%BA%93/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"},{"name":"json","slug":"json","permalink":"https://www.boii.xyz/tags/json/"}]},{"title":"Python【Crawler】通用爬虫","slug":"Python/Crawler/Python【Crawler】1-通用爬虫","date":"2020-08-20T06:17:48.000Z","updated":"2021-07-19T10:05:31.953Z","comments":true,"path":"posts/33364.html","link":"","permalink":"https://www.boii.xyz/posts/33364.html","excerpt":"爬虫的基本用法","text":"爬虫的基本用法 Python 中原生的一款基于网络请求的模块，功能强大，简单便捷，效率极高。 &gt;_: pip install requests 基本使用 指定URL UA伪装 发起请求 —— requests.get() 或 requests.post() 获取响应数据 —— .json()或.text 持久化存储 —— f.write() 或 json.dump() 12345678910111213141516171819import requestsdef main(): # 1. 指定url url = &quot;https://www.sou.com&quot; # 2. UA伪装 header = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36 Edg/84.0.522.44&quot;&#125; # 3. 发起请求 response = requests.get(url=url, headers=header) # 4. 获取响应数据 page_text = response.text # 5. 持久化存储 with open(&quot;sogou.html&quot;, &quot;w&quot;, &quot;utf-8&quot;) as f: f.wirte(page_text) print(&quot;END&quot;)if __naim__ == &#x27;__main__&#x27;: main() 这种就是最基本的模拟浏览器进行爬取。通过requests就可以进行网络请求，从返回对象中得到数据。 url的获取方式主要通过自己查找分析如果只是普通的浏览网页，一般使用的是get方式如果携带参数，需要观察url中 ？ 后面的字段。 携带参数http协议中的请求方式分为get、post、put、patch、head、delete。最常用的请求为 get() 和 post()，这两种请求方式都可以携带参数。在浏览器中分析的时候可以观察 ? 后面的字段，有的是query，有的是q，可以通过浏览器中抓包工具进行分析 由此就可以确定 ? 前面是我们要的url： https://www.sogou.com/web?；url中的问号?可写可不写 接着可以确定查询字段是query，用个字典包装起来：param = &#123;&#39;query&#39;: &#39;python&#39;&#125; 同时在请求url下面可以看到请求方式是get，所以可以使用get方法进行请求：res = requests.get(url, param, headers=header) 观察响应标头的Content-Type发现，返回格式为text，则调用res.text获得返回内容：res_text = res.text 将返回的内容存储起来。搞定。 完整代码 1234567891011121314151617181920212223242526import requestsheader = &#123;&#x27;User-Agent&#x27;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36 Edg/84.0.522.44&quot;&#125;def main(): # 1. 指定url url = &quot;https://www.sogou.com/web?&quot; # 2. 获取查询内容 q = input(&#x27;Enter the contend you want to search: &#x27;) # 3. 设置好传输参数 param = &#123;&#x27;query&#x27;: q&#125; # 4. 发送请求 res = requests.get(url=url, params=param, headers=header) # 5. 获取返回内容 res_text = res.text # 6. 写入文件 with open(&#x27;./sogou.html&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: f.write(res_text)if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:Enter the contend you want to search: Python 1234567891011121314151617181920212223# sogou.html&lt;!DOCTYPE html&gt;&lt;html data-vtype=&quot;default&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; &lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;referrer&quot; content=&quot;always&quot;&gt;...... &lt;/script&gt;&lt;!-- BottomViewEnd opt --&gt; &lt;script crossorigin=&quot;anonymous&quot; src=&quot;//dlweb.sogoucdn.com/hhytrace/trace_2020072915.js&quot; async&gt;&lt;/script&gt;&lt;/body&gt;&lt;!-- bodyViewEnd --&gt;&lt;/html&gt;&lt;!-- 1596006531756 --&gt;&lt;!--STATUS total 14 time 1596006531756 page 0 maxEnd 1000 totalItems 8955--&gt;&lt;!--real_pageno:1--&gt;&lt;!--nodeserverinfo:rsync.doc04.web.1.gd.ted--&gt;&lt;!--searchhubserverinfo:doc09.web.1.gd.ted:5555--&gt;&lt;!--zly--&gt; requests模块中的get()、post()、put()等请求方法其实都是调用了request()方法。 request(method, url, **kwargs)get(url, params=None, **kwargs)post(url, data=None, json=None, **kwargs) 这里注意区分，get的参数是params，post的参数的data 抓取动态内容网页中有些数据不是静态的，而是动态获取，通过Ajax局部刷新。例如百度翻译 红框中的内容会根据输入框中内容的变化而变化，这就是动态获取当内容改变的时候，返回来的结果只会改变页面中红框的部分，这就是局部刷新 这种数据直接抓取页面是无效的，所以我们要通过浏览器抓包工具进行观察 可以把筛选器设置到 XHR ，这样可以只查看刷新时返回的数据 通过观察可以发现每输入一个字符就会发送一个sug，所以请求url应该是https://fanyi.baidu.com/sug才对 请求方式是post，携带参数是kw，所以参数部分应该这样写：data = &#123;kw: &#39;document&#39;&#125; 接着看到 Content-Type，返回数据格式是 json，那么就需要用 json 模块来处理。res_json = res.json() 最后可以使用 json.dump()将json格式直接写入数据，或者使用json.loads()转换成python对象，再用f.write()写入文件。 1234567891011121314151617181920import requestsheader = &#123;&#x27;User-Agent&#x27;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36 Edg/84.0.522.44&quot;&#125;def main(): # 1. 指定url url = &#x27;https://fanyi.baidu.com/sug&#x27; # 2. 获取查询内容，设置好请求参数 query = input(&quot;Enter the word you want to translate: &quot;) data = &#123;&#x27;kw&#x27;: query&#125; # 3. 发送请求 res = requests.post(url=url, data=data, headers=header) # 4. 获取返回内容 res_json = res.json() # 5. 写入文件 with open(&#x27;./translation.json&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: json.dump(res_json, fp, ensure_ascii=False)if __name__ == &#x27;__main__&#x27;: main()","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"https://www.boii.xyz/categories/Python/%E7%88%AC%E8%99%AB/"},{"name":"基础","slug":"Python/爬虫/基础","permalink":"https://www.boii.xyz/categories/Python/%E7%88%AC%E8%99%AB/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.boii.xyz/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Python【Crawler】聚焦爬虫","slug":"Python/Crawler/Python【Crawler】2-聚焦爬虫","date":"2020-08-20T06:17:48.000Z","updated":"2021-07-19T10:05:32.054Z","comments":true,"path":"posts/28995.html","link":"","permalink":"https://www.boii.xyz/posts/28995.html","excerpt":"过滤爬取到的数据，取出想要的部分","text":"过滤爬取到的数据，取出想要的部分 聚焦爬虫：爬取页面中指定的页面内容 编码流程 指定url 发起请求 获取响应数据 数据解析 持久化存储 数据解析分类 正则表达式 bs4 xpath (*) 数据解析原理 - 解析的局部文本内容都会在标签之间或标签的属性中存储 - 1. 进行标签的定位 - 2. 标签或者标签对应的属性中存储的数据值进行提取（即解析~~~~） 正则表达式爬取12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import osimport requestsimport re# UA伪装UA = &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36 Edg/84.0.522.44&#x27;header = &#123;&#x27;User-Agent&#x27;: UA&#125;# 存储目录folder = &#x27;./qiushi&#x27;if not os.path.exists(folder): os.mkdir(folder)def main(): # 分页处理 for i in range(1, 3): url = f&quot;https://www.qiushibaike.com/imgrank/page/&#123;i&#125;/&quot; # 1. 爬取整张页面 page_text = requests.get(url=url, headers=header).text # 2. 使用聚焦爬虫进行数据解析 images = data_parse(page_text) length = len(images) # 进度条所需 for index, image in enumerate(images): # 3. 发起请求并获得数据 image_content = requests.get(url=image, headers=header).content # 4. 持久化存储 image_name = image.split(&#x27;/&#x27;)[-1] image_path = os.path.join(folder, image_name) with open(image_path, &#x27;wb&#x27;) as f: f.write(image_content) # 进度打印 print(image_name + &#x27; 下载成功！&#x27;) print(f&#x27;&#123;index&#125; / &#123;length&#125;&#x27;, end=&#x27;\\r&#x27;) print(str(i) + &quot;/ 2 page&quot;)def data_parse(page_text): &quot;&quot;&quot; 解析出每张图片的url &quot;&quot;&quot; # 分析网页后整理出正则表达式 ex = r&#x27;&lt;div class=&quot;thumb&quot;&gt;.*?&lt;img src=&quot;(.*?)&quot; alt.*?&gt;&lt;/div&gt;&#x27; images = re.findall(ex, page_text, re.S) images = [&#x27;https:&#x27; + x for x in images] # 解析出来没有协议头，给增加上 return imagesif __name__ == &quot;__main__&quot;: main()--------------------------------------------------# Output:K7EUFEUIV3QY37P1.jpg 下载成功！DFIAAL32X5J35JP2.jpg 下载成功！...NXUA4X1CMQP22UPP.jpg 下载成功！FQILIKXCVMUIRXL8.jpg 下载成功！1/ 2 page95GRCYEUZANQ361J.jpg 下载成功！2SXBFKSSK3JD3G2M.jpg 下载成功！...5YTNS4JH0PLZAO58.jpg 下载成功！59CN77YAL198SM6M.jpg 下载成功！2/ 2 page 示例网页123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;测试bs4&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;百里守约&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;song&quot;&gt; &lt;p&gt;李清照&lt;/p&gt; &lt;p&gt;王安石&lt;/p&gt; &lt;p&gt;苏轼&lt;/p&gt; &lt;p&gt;柳宗元&lt;/p&gt; &lt;a href=&quot;https://www.song.com&quot; title=&quot;赵匡胤&quot; target=&quot;_self&quot;&gt; &lt;span&gt;this is span&lt;/span&gt; 宋朝是最强大的王朝，不是军队的强大，而是经济很强大，国民都很有钱 &lt;/a&gt; &lt;a href=&quot;&quot; class=&quot;du&quot;&gt;总为浮云能避日，长安不见使人愁&lt;/a&gt; &lt;img src=&quot;https://www.baidu.com/meinv.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;tang&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;https://www.baidu.com&quot; title=&quot;qing&quot;&gt;清明时节雨纷纷，路上行人欲断魂。借问酒家何处有，牧童遥指杏花村。&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.163.com&quot; title=&quot;qin&quot;&gt;秦时明月汉时光，万里长征人未还。但使龙城飞将在，不教胡马度阴山。&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.126.com&quot; alt=&quot;qi&quot;&gt;岐王宅里寻常见，崔久堂前几度闻。正是江南好风景，落花时节又逢君。&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.sina.com&quot; class=&quot;du&quot;&gt;杜甫&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.dudu.com&quot; class=&quot;du&quot;&gt;杜牧&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;杜小月&lt;/b&gt;&lt;/li&gt; &lt;li&gt;&lt;i&gt;度蜜月&lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.haha.com&quot; id=&quot;feng&quot;&gt;凤凰台上凤凰游，凤去台空江自流。吴宫花草埋幽径，晋代衣冠成古丘。&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 以下爬虫示例均以此网页示例为基础有点丑，将就一下。 bs4爬取安装win 下：&gt;_ pip install bs4&gt;_ pip install lxml Linux 下：&gt;_ pip install Beautifulsoup4 导入 from bs4 import BeautifulSoup 使用 创建bs对象并传入待解析对象 传入待解析对象为本地文件 1234from bs4 import BeautifulSoupwith open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 传入待解析对象为网络请求 123456from bs4 import BeautifulSoupimport requestsurl = &quot;https://www.baidu.com&quot;page_text = requests.get(url=url).textbs = BeautifulSoup(page_text, &#x27;lxml&#x27;) # 创建bs对象 定位数据 方法 用 返值 tagName 返回首tagName标签 bs4.element.Tag find(‘tagName’) 返回首tagName标签 bs4.element.Tag find(‘tagName’, class_/id/attrName=’value’) 返回首属性为value的tagName标签 bs4.element.Tag find_all(‘tagName’) 返回所符合要求的标签 bs4.element.ResultSet select([‘selector’ + ]’tagName’) 通过CS选择器+标签名定位标签,返回多个 bs4.element.ResultSet select_one([‘selector’ + ]’tagName’) 通过CS选择器+标签名定位标签,返回一个 bs4.element.Tag bs.tagName bs.tagName：返回文档中第一次出现tagName对应的标签 1234567891011121314with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 tag_a = bs.a # 定位数据 print(tag_a) print(type(tag_a)) # &lt;class &#x27;bs4.element.Tag&#x27;&gt;--------------------------------------------------# Output:&lt;a href=&quot;https://www.song.com&quot; target=&quot;_self&quot; title=&quot;赵匡胤&quot;&gt;&lt;span&gt;this is span&lt;/span&gt; 宋朝是最强大的王朝，不是军队的强大，而是经济很强大，国民都很有钱&lt;/a&gt;&lt;class &#x27;bs4.element.Tag&#x27;&gt; bs.find() bs.find()： find(&#39;tagName&#39;)：等同于 bs.tagName 12345678910111213with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 tag_div = bs.find(&#x27;div&#x27;) # 定位数据 print(tag_div) print(type(tag_div)) # &lt;class &#x27;bs4.element.Tag&#x27;&gt;--------------------------------------------------# Output:&lt;div&gt;&lt;p&gt;百里守约&lt;/p&gt;&lt;/div&gt;&lt;class &#x27;bs4.element.Tag&#x27;&gt; find(&#39;tagName&#39;, class_/is/attrName=&#39;value&#39;)：通过限定属性来定位标签 1234567891011with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 tag_a = bs.find(&#x27;a&#x27;, class_=&#x27;du&#x27;) # 定位数据 print(tag_a) print(type(tag_a)) # &lt;class &#x27;bs4.element.Tag&#x27;&gt;--------------------------------------------------# Output:&lt;a class=&quot;du&quot; href=&quot;&quot;&gt;总为浮云能避日，长安不见使人愁&lt;/a&gt;&lt;class &#x27;bs4.element.Tag&#x27;&gt; bs.find_all(&#39;tagName&#39;)：返回复合要求的所有标签（集合） 12345678910with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 tag_p = bs.find_all(&#x27;p&#x27;) # 定位数据 print(tag_p) print(type(tag_p)) # &lt;class &#x27;bs4.element.ResultSet&#x27;&gt;--------------------------------------------------# Output:[&lt;p&gt;百里守约&lt;/p&gt;, &lt;p&gt;李清照&lt;/p&gt;, &lt;p&gt;王安石&lt;/p&gt;, &lt;p&gt;苏轼&lt;/p&gt;, &lt;p&gt;柳宗元&lt;/p&gt;] bs.select() bs.select(&#39;selector&#39; + &#39;tagName&#39;)：可以通过CSS择器+标签名定位，包括层级选择器、标签选择器等 1234567891011with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 tag_div = bs.select(&#x27;#feng&#x27;) # 定位数据 print(tag_div) print(type(tag_div)) # &lt;class &#x27;bs4.element.ResultSet&#x27;&gt;--------------------------------------------------# Output:[&lt;a href=&quot;https://www.haha.com&quot; id=&quot;feng&quot;&gt;凤凰台上凤凰游，凤去台空江自流。吴宫花草埋幽径，晋代衣冠成古丘。&lt;/a&gt;]&lt;class &#x27;bs4.element.ResultSet&#x27;&gt; 123456789101112131415with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 tag1_a = bs.select(&#x27;.tang &gt; ul &gt; li &gt; a&#x27;) # 定位数据 tag2_a = bs.select(&#x27;.tang &gt;ul a&#x27;) # 定位数据 print(tag1_a) print(tag2_a) print(type(tag1_a)) # &lt;class &#x27;bs4.element.ResultSet&#x27;&gt;--------------------------------------------------# Output:[&lt;a href=&quot;https://www.baidu.com&quot; title=&quot;qing&quot;&gt;清明时节雨纷纷，路上行人欲断魂。借问酒家何处有，牧童遥指杏花村。&lt;/a&gt;, &lt;a href=&quot;https://www.163.com&quot; title=&quot;qin&quot;&gt;秦时明月汉时光，万里长征人未还。但使龙城飞将在，不教胡马度阴山。&lt;/a&gt;, &lt;a alt=&quot;qi&quot; href=&quot;https://www.126.com&quot;&gt;岐王宅里寻常见，崔久堂前几度闻。正是江南好风景，落花时节又逢君。&lt;/a&gt;, &lt;a class=&quot;du&quot; href=&quot;https://www.sina.com&quot;&gt;杜甫&lt;/a&gt;, &lt;a class=&quot;du&quot; href=&quot;https://www.dudu.com&quot;&gt;杜牧&lt;/a&gt;, &lt;a href=&quot;https://www.haha.com&quot; id=&quot;feng&quot;&gt;凤凰台上凤凰游，凤去台空江自流。吴宫花草埋幽径，晋代衣冠成古丘。&lt;/a&gt;][&lt;a href=&quot;https://www.baidu.com&quot; title=&quot;qing&quot;&gt;清明时节雨纷纷，路上行人欲断魂。借问酒家何处有，牧童遥指杏花村。&lt;/a&gt;, &lt;a href=&quot;https://www.163.com&quot; title=&quot;qin&quot;&gt;秦时明月汉时光，万里长征人未还。但使龙城飞将在，不教胡马度阴山。&lt;/a&gt;, &lt;a alt=&quot;qi&quot; href=&quot;https://www.126.com&quot;&gt;岐王宅里寻常见，崔久堂前几度闻。正是江南好风景，落花时节又逢君。&lt;/a&gt;, &lt;a class=&quot;du&quot; href=&quot;https://www.sina.com&quot;&gt;杜甫&lt;/a&gt;, &lt;a class=&quot;du&quot; href=&quot;https://www.dudu.com&quot;&gt;杜牧&lt;/a&gt;, &lt;a href=&quot;https://www.haha.com&quot; id=&quot;feng&quot;&gt;凤凰台上凤凰游，凤去台空江自流。吴宫花草埋幽径，晋代衣冠成古丘。&lt;/a&gt;]&lt;class &#x27;bs4.element.ResultSet&#x27;&gt; 123456789101112 with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 tag_div = bs.select_one(&#x27;.du&#x27;) # 定位数据 print(tag_div) print(type(tag_div)) # &lt;class &#x27;bs4.element.Tag&#x27;&gt; --------------------------------------------------# Output:&lt;a class=&quot;du&quot; href=&quot;&quot;&gt;总为浮云能避日，长安不见使人愁&lt;/a&gt;&lt;class &#x27;bs4.element.Tag&#x27;&gt; 解析数据 方法 用 返值 .text 返回标签下所有直系和非直系标签的所有本 str .get_text() 返回标签下所有直系和非直系标签的所有本 str .string 返回标签下所有直系标签的所有本 bs4.element.NavigableString 获取文本 bs.tagName.text/string/get_text()：获取标签之间的所有文本* text/get_text()：可以获取标签下直系和非直系的所有文本 123456789101112with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 txt_li = bs.find(&#x27;li&#x27;).text print(txt_li) print(type(txt_li)) # &lt;class &#x27;str&#x27;&gt; --------------------------------------------------# Output:清明时节雨纷纷，路上行人欲断魂。借问酒家何处有，牧童遥指杏花村。&lt;class &#x27;str&#x27;&gt; 123456789101112with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 txt_li = bs.find(&#x27;li&#x27;).get_text() print(txt_li) print(type(txt_li)) # &lt;class &#x27;str&#x27;&gt; --------------------------------------------------# Output:清明时节雨纷纷，路上行人欲断魂。借问酒家何处有，牧童遥指杏花村。&lt;class &#x27;str&#x27;&gt; string：只能获取标签下直系的文本，没有返回 None 123456789101112with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 txt_li = bs.find(&#x27;li&#x27;).string print(txt_li) print(type(txt_li)) # &lt;class &#x27;bs4.element.NavigableString&#x27;&gt; --------------------------------------------------# Output:清明时节雨纷纷，路上行人欲断魂。借问酒家何处有，牧童遥指杏花村。&lt;class &#x27;bs4.element.NavigableString&#x27;&gt; 获取属性 bs.tagName[&#39;attrName&#39;]：获取标签中的属性内容123456789101112with open(&#x27;./bs_test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: bs = BeautifulSoup(f, &#x27;lxml&#x27;) # 创建bs对象 txt_href = bs.find(&#x27;a&#x27;)[&#x27;href&#x27;] print(txt_href) print(type(txt_href)) # &lt;class &#x27;str&#x27;&gt; --------------------------------------------------# Output:https://www.song.com&lt;class &#x27;str&#x27;&gt; 案例 从诗词名句网下载一整部《论语》 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import timeimport requestsimport osfrom bs4 import BeautifulSoupUA = &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36 Edg/84.0.522.44&#x27;header = &#123;&#x27;User-Agent&#x27;: UA&#125;folder = &#x27;.\\\\爬虫\\\\论语&#x27;if not os.path.exists(folder): os.mkdir(folder)def req_catalog(url): &quot;&quot;&quot; 请求目录列表 &quot;&quot;&quot; return requests.get(url=url, headers=header).textdef catalog_parse(res_text): &quot;&quot;&quot; 解析目录列表 &quot;&quot;&quot; bs = BeautifulSoup(res_text, &#x27;lxml&#x27;) links = bs.select(&#x27;.book-mulu &gt; ul &gt; li &gt; a&#x27;) catalog_list = [[x.string, x[&#x27;href&#x27;]] for x in links] return catalog_listdef download_content(catalog_list): &quot;&quot;&quot; 请求内容页 &quot;&quot;&quot; url = &#x27;https://www.shicimingju.com&#x27; length = len(catalog_list) for index, elem in enumerate(catalog_list): # 请求数据 content_text = requests.get(url=url + elem[1], headers=header).text # 解析数据 content = contents_parse(content_text) # 持久化存储 filename = str(index + 1) + &#x27;-&#x27; + elem[0] + &#x27;.txt&#x27; filepath = os.path.join(folder, filename) with open(filepath, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: f.write(content) print(&quot;已下载：&quot; + str(index + 1) + &quot; / &quot; + str(length), end=&quot;\\r&quot;) return 1def contents_parse(page_text): &quot;&quot;&quot; 解析内容 &quot;&quot;&quot; bs = BeautifulSoup(page_text, &#x27;lxml&#x27;) contents = bs.select(&#x27;.chapter_content &gt; p&#x27;) # 取出所有p标签 texts = [x.string for x in contents] # 取出内容，过滤掉P标签 content = &#x27;&#x27; for i in texts: content += str(i) return contentdef main(): url = &quot;https://www.shicimingju.com/book/lunyu.html&quot; catalog_list = list() try: catalog_text = req_catalog(url) catalog_list = catalog_parse(catalog_text) print(&quot;下载成功！&quot;) if download_content(catalog_list) else print(&quot;下载失败&quot;) except TimeoutError: print(&quot;TimeoutError\\n&quot;) time.sleep(2) print(&quot;下载成功！&quot;) if download_content(catalog_list) else print(&quot;下载失败&quot;) except Exception: print(&quot;Exception\\n&quot;)if __name__ == &#x27;__main__&#x27;: main() xpath爬取最常用、通用性最强的，最便捷高效的一种解析方式。 解析步骤 实例化一个etree对象，并且需要将被解析的页面源码数据加载到该对象中。 通过调用etree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获 xpath定位到数据后返回的不是数据的内容，而已一个列表，里面放置了解析出来的Element对象 安装&gt;_: pip install lxml 导入 from lxml import etree 使用 创建etree对象并传入待解析对象 传入待解析对象为本地文件 tree = etree.parse(filePath) 传入待解析对象为网络请求 tree = etree.HTML(&#39;page_text&#39;) 定位数据：tree.xpath(xpath表达式) 在XPath中有7种节点：元素、属性、文本、文档、命名空间、处理指令、注释。 元素、属性、文本 为常用节点。 1234&lt;html&gt; 为文档节点&lt;li&gt;小米&lt;/li&gt; 为元素节点class=&#x27;blank&#x27; 为属性节点&lt;!-- 这里是注释 --&gt; 为注释节点 expression description nodeName 选择nodeName节点的所有子节点 / 从根节点或/前的节点开始，不跨层级匹配 // 从//前的节点开始，跨层级匹配 . 选择当前节点 .. 选择当前节点的父节点 @ 匹配元素属性 * 匹配所有节点 @* 匹配节点所有属性 [] 按索引定位 /：表示从根节点开始定位 / 放在最前面的时候表示根节点，不是放在最前面的时候表示 123456789101112131415161718from lxml import etreewith open(&#x27;./test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: f_content = f.read() tree = etree.HTML(f_content) r = tree.xpath(&#x27;/html/body/div/p&#x27;) print(r) print(type(r))--------------------------------------------------xpath 在匹配的时候是贪婪的，示例中有两个 div 下都有 p，所以匹配到了5个# Output:[&lt;Element p at 0x252e2de8780&gt;, &lt;Element p at 0x252e2de87c0&gt;, &lt;Element p at 0x252e2de8800&gt;, &lt;Element p at 0x252e2de8840&gt;, &lt;Element p at 0x252e2de8880&gt;]&lt;class &#x27;list&#x27;&gt; //：表示匹配多级 /a/b//c，就表示匹配 a 标签下的 b 标签下所有c标签 123456789101112131415161718192021from lxml import etreewith open(&#x27;./test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: f_content = f.read() tree = etree.HTML(f_content) r = tree.xpath(&#x27;/html//a&#x27;) # 等价于 r = tree.xpath(&#x27;//a&#x27;) print(r) print(type(r))--------------------------------------------------html节点下总共有8个a标签，所以匹配到8个element对象# Output:[&lt;Element a at 0x1e5f55e9680&gt;, &lt;Element a at 0x1e5f55e96c0&gt;, &lt;Element a at 0x1e5f55e9700&gt;, &lt;Element a at 0x1e5f55e9740&gt;, &lt;Element a at 0x1e5f55e9780&gt;, &lt;Element a at 0x1e5f55e9800&gt;, &lt;Element a at 0x1e5f55e9840&gt;, &lt;Element a at 0x1e5f55e9880&gt;]&lt;class &#x27;list&#x27;&gt; @：表示通过属性定位 tag[@attrName=&quot;attrValue&quot;]@后面加上属性名，比如class、id、href、src等等 1234567891011121314from lxml import etreewith open(&#x27;./test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: f_content = f.read() tree = etree.HTML(f_content) r = tree.xpath(&#x27;/html//div[@class=&quot;song&quot;]&#x27;) print(r) print(type(r))--------------------------------------------------html节点下总共有8个a标签，所以匹配到8个element对象# Output:[&lt;Element div at 0x24d64839640&gt;]&lt;class &#x27;list&#x27;&gt; []：表示通过索引定位 tag[index]这里是索引是从1开始的 12345678910111213141516171819from lxml import etreewith open(&#x27;./test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: f_content = f.read() tree = etree.HTML(f_content) print(tree.xpath(&#x27;/html//div[@class=&quot;song&quot;]/p[1]&#x27;)) print(tree.xpath(&#x27;/html//div[@class=&quot;song&quot;]/p[1]/text()&#x27;)) print(tree.xpath(&#x27;/html//div[@class=&quot;song&quot;]/p[2]&#x27;)) print(tree.xpath(&#x27;/html//div[@class=&quot;song&quot;]/p[3]&#x27;))--------------------------------------------------这里的下标是从1开始的# Output:[&lt;Element p at 0x1df3d4395c0&gt;][&#x27;李清照&#x27;][&lt;Element p at 0x1df3d439580&gt;][&lt;Element p at 0x1df3d439600&gt;]&lt;class &#x27;list&#x27;&gt; /text()：返回标签之间的文本，取文本 tag/text()：获取tag下直系的文本tag//text()：获取tag下直系和非直系的文本 12345678910111213141516171819from lxml import etreewith open(&#x27;./test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: f_content = f.read() tree = etree.HTML(f_content) r1 = tree.xpath(&#x27;/html//div[@class=&quot;song&quot;]/p[3]&#x27;) r2 = tree.xpath(&#x27;/html//div[@class=&quot;song&quot;]/p[3]/text()&#x27;) r3 = tree.xpath(&#x27;/html//div[@class=&quot;song&quot;]/p[3]/text()&#x27;)[0] print(r1) print(r2) print(r3)--------------------------------------------------# Output:[&lt;Element p at 0x1d4e4c29540&gt;][&#x27;苏轼&#x27;]苏轼&lt;class &#x27;list&#x27;&gt; /@attrName：返回标签的attrName属性的值 tag/@attrName：获取tag标签中的attrName属性的值 1234567891011121314151617from lxml import etreewith open(&#x27;./test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: f_content = f.read() tree = etree.HTML(f_content) r1 = tree.xpath(&#x27;//div[@class=&quot;song&quot;]/a/@href&#x27;) print(r1) r2 = tree.xpath(&#x27;//div[@class=&quot;song&quot;]/img/@src&#x27;) print(r2)--------------------------------------------------# Output:[&#x27;https://www.song.com&#x27;, &#x27;&#x27;][&#x27;https://www.baidu.com/meinv.jpg&#x27;]&lt;class &#x27;list&#x27;&gt; /@*：返回标签的所有属性的值 tag/@*：获取tag标签中的所有属性的值 12345678910111213from lxml import etreewith open(&#x27;./test.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f: f_content = f.read() tree = etree.HTML(f_content) r1 = tree.xpath(&#x27;//div[@class=&quot;song&quot;]/a[@target=&quot;_self&quot;]/@*&#x27;) print(r1)--------------------------------------------------# Output:[&#x27;https://www.song.com&#x27;, &#x27;赵匡胤&#x27;, &#x27;_self&#x27;]&lt;class &#x27;list&#x27;&gt; 案例 从彼岸图网下载4K图保存至本地 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import osfrom lxml import etreeimport requestsUA = &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.89 Safari/537.36 Edg/84.0.522.44&#x27;header = &#123;&#x27;User-Agent&#x27;: UA&#125;path = &#x27;./爬虫/4k&#x27;if not os.path.exists(path): os.mkdir(path)def get_url(): &quot;&quot;&quot; 获取所有图片地址 &quot;&quot;&quot; url = &#x27;http://pic.netbian.com/4kmeinv/&#x27; index_text = requests.get(url=url, headers=header).text tree = etree.HTML(index_text) a_list = tree.xpath(&#x27;//div[@id=&quot;main&quot;]/div[3]/ul/li/a&#x27;) # response.encoding = &#x27;utf-8&#x27; # 处理中文乱码方式1，不一定有效 img_list = list() for a in a_list: src: str = &#x27;http://pic.netbian.com&#x27; + a.xpath(&#x27;./@href&#x27;)[0] title: str = a.xpath(&#x27;./b/text()&#x27;)[0] + &#x27;.jpg&#x27; title = title.encode(&#x27;iso-8859-1&#x27;).decode(&#x27;gbk&#x27;) # 处理中文乱码方式2 img_list.append((title, src)) return img_listdef download_img(img_info): &quot;&quot;&quot; 下载图片 &quot;&quot;&quot; img_content = requests.get(url=img_info[1], headers=header).content filepath = os.path.join(path, img_info[0]) with open(filepath, &#x27;wb&#x27;) as f: f.write(img_content)def main(): img_list = get_url() for img_info in img_list: download_img(img_info)if __name__ == &#x27;__main__&#x27;: main()","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"https://www.boii.xyz/categories/Python/%E7%88%AC%E8%99%AB/"},{"name":"基础","slug":"Python/爬虫/基础","permalink":"https://www.boii.xyz/categories/Python/%E7%88%AC%E8%99%AB/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.boii.xyz/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Python【Crawler】爬虫总叙","slug":"Python/Crawler/Python【Crawler】0-爬虫总叙","date":"2020-08-20T04:17:48.000Z","updated":"2021-07-19T10:05:31.766Z","comments":true,"path":"posts/28223.html","link":"","permalink":"https://www.boii.xyz/posts/28223.html","excerpt":"工具人，啊不，工具蜘蛛。","text":"工具人，啊不，工具蜘蛛。 使用场景 通用爬虫：抓取系统重要组成部分，抓取的是一整张页面数据。 聚焦爬虫：建立在通用爬虫之上，抓取的是页面中特定的局部内容。 增量爬虫：检测网站中数据更新的情况，只会抓取网站中最新的数据。 矛与盾 反爬机制：门户网站，可以通过指定相应的策略或技术手段，防止爬虫程序进行爬取 检查User-Agent IP屏蔽 抗反爬策略：通过制定相关策略或技术手段破解门户网站的反爬机制。 UA伪装 IP代理 robots.txt 协议 —— 君子协议：规定了网站中哪些数据可以被爬虫爬取，哪些数据不可以被爬取 http 概念：服务器与客户端数据交互的一种形式 常用请求头信息： User-Agent：请求载体的身份载体 Connection：请求完毕后，是否断开连接 常用响应头信息： Content-Type：服务器响应回客户端的数据类型 https 安全的http协议","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"https://www.boii.xyz/categories/Python/%E7%88%AC%E8%99%AB/"},{"name":"基础","slug":"Python/爬虫/基础","permalink":"https://www.boii.xyz/categories/Python/%E7%88%AC%E8%99%AB/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.boii.xyz/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Python【Type】String","slug":"Python/Python【No-Type】String","date":"2020-07-26T03:17:48.000Z","updated":"2021-07-19T08:55:20.205Z","comments":true,"path":"posts/32620.html","link":"","permalink":"https://www.boii.xyz/posts/32620.html","excerpt":"关于String的详细笔记","text":"关于String的详细笔记 12345678910111213141516a = &#x27;hello&#x27;b = &quot;good&quot;c = &quot;&quot;&quot; 哈哈哈 &quot;&quot;&quot;d = &#x27;&#x27;&#x27; 呵呵呵 &#x27;&#x27;&#x27;str1 = &#x27;OK&#x27; # OKstr2 = &quot;OK&quot; # OKstr3 = &#x27;&#x27;&#x27;I&#x27;m OK.&#x27;&#x27;&#x27; # I&#x27;m OK.str4 = &quot;&quot;&quot;哈哈哈&quot;&quot;&quot; # 哈哈哈str4 = &quot;I&#x27;m ok.&quot; # I&#x27;m ok.str5 = &#x27;I\\&#x27;m ok.&#x27; # I&#x27;m ok.str6= &quot;I\\&quot;m ok.&quot; # I&quot;m ok.str7 = &#x27;I&quot;m ok.&#x27; # I&quot;m ok.str8 = &quot;&quot;&quot;I&#x27;m &quot;Iron Man&quot;.&quot;&quot;&quot; # I&#x27;m &quot;Iron Man&quot;.str9 = r&#x27;ab\\ncd&#x27; # ab\\ncdstr0 = R&#x27;ab\\ncd&#x27; # ab\\ncd 1234567891011str_1 = &#x27;&#x27;&#x27;这是一个段落，所以可以直接换行，不需反斜杠来声明语句未结束 直到遇到下一个三单引号，才认为结束但是换行会跟着换行，空格会跟着空格&#x27;&#x27;&#x27;&quot;&quot;&quot;str_1输出为：这是一个段落，所以可以直接换行，不需反斜杠来声明语句未结束 直到遇到下一个三单引号，才认为结束但是换行会跟着换行，空格会跟着空格&quot;&quot;&quot; 12345678910111213141516\\n 换行 \\t 缩进# 使用转义字符str_2 = &#x27;ab\\ncd&#x27;&#x27;&#x27;&#x27;str_2输出为：abcd&#x27;&#x27;&#x27;r&#x27;字符串&#x27; 表示不转义# 不转义str_3 = r&#x27;ab\\ncd&#x27; # ab\\ncd 转义字符 转义字符 描述 \\ 续行符 \\ 反斜杠 &#39; 单引号 &quot; 双引号 \\a 响铃 \\b 退格 \\e 转义 \\000 空 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车 \\f 换页 \\o 八进制 \\x 十六进制 下标123| P | y | t | h | o | n | 0 1 2 3 4 5 -6 -5 -4 -3 -2 -1 查找 find、index、rfind、rindex s.find(sub[, start[, end]) -&gt; ints.rfind(sub[, start[, end]) -&gt; ints.index(sub[, start[, end]) -&gt; ints.rindex(sub[, start[, end]) -&gt; int 没r找第一个，有r找最后一个find找不到返回-1，index找不到报错 12345678910s = &#x27;abcdefghijkl abundance gg&#x27;print(s.find(&#x27;g&#x27;)) # 返回字符串中第一个 g 的下标：6print(s.find(&#x27;z&#x27;)) # 找不到则返回 -1print(s.index(&#x27;g&#x27;)) # 返回字符串中第一个 g 的下标：6print(s.index(&#x27;z&#x27;)) # 找不到则报错print(s.rfind(&#x27;g&#x27;)) # 返回字符串中最后一个 g 的下标：24print(s.rfind(&#x27;z&#x27;)) # 找不到则返回 -1print(s.rindex(&#x27;g&#x27;)) # 返回字符串中最后一个 g 的下标：24print(s.rindex(&#x27;z&#x27;)) # 找不到则报错 判断 方法名 描述 startswith(value) 判断是否以 value 开始 endswith(value) 判断是否以 value 结束 isalpha() 判断是否全是字母 isdigit() 判断是否全是数字 isalnum() 判断是否全是字母或数字或字母+数字 isdecimal() 判断是否全是浮点数 isnumeric() 判断是否全是数值 islower() 判断是否全小写 isupper() 判断是否全大写 isspace() 判断是否全空格或\\t或\\n或\\r istitle() 判断是否所有单词都是首字母大写 isdigit() VS isdecimal() VS isnumeric()isdigit()True: Unicode数字，byte数字（单字节），全角数字（双字节），罗马数字False: 汉字数字Error: 无 isdecimal()True: Unicode数字，，全角数字（双字节）False: 罗马数字，汉字数字Error: byte数字（单字节） isnumeric()True: Unicode数字，全角数字（双字节），罗马数字，汉字数字False: 无Error: byte数字（单字节） 计数 count s.count(sub[, start[, end]) -&gt; int 12s = &#x27;abcdefghijkl abundance gg&#x27;print(s.count(&#x27;g&#x27;)) # 3. 字母 g 一共出现了3次 替换 replace s.replace(old, new[, count]) -&gt; str替换字符串中指定的内容，如果指定次数count， 则替换不会超过count次。 123s = &#x27;abcdefghijkl abundance gg&#x27;print(s.replace(&#x27;g&#x27;, &#x27;*&#x27;)) # abcdef*hijkl abundance **print(s.replace(&#x27;g&#x27;, &#x27;*&#x27;, 2)) # abcdef*hijkl abundance *g 分割 split、rsplit、partition、rpartition、splitlines s.split(sep[, maxsplit]) -&gt; list[str]：按 sep 分割，从左边开始，只分割两次s.rsplit(sep[, maxsplit]) -&gt; list[str]：按 sep 分割，从右边开始，只分割两次s.patition(sep) -&gt; tuple(str, str, str)：按 sep 分割，从左边开始，分成 (前部，分割符号，后部)s.rpartition(sep) -&gt; tuple(str, str, str)：按 sep 分割，从右边开始，分成 (前部，分割符号，后部) 1234567891011s1 = &#x27;Alice,Boii,Candy,Dannis,Eva,Fiona&#x27;print(s1.split(&#x27;,&#x27;)) # [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Candy&#x27;, &#x27;Dannis&#x27;, &#x27;Eva&#x27;, &#x27;Fiona&#x27;]print(s1.split(&#x27;,&#x27;, 2)) # [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Candy,Dannis,Eva,Fiona&#x27;]print(s1.rsplit(&#x27;,&#x27;, 2)) # [&#x27;Alice,Boii,Candy,Dannis&#x27;, &#x27;Eva&#x27;, &#x27;Fiona&#x27;]s2 = &#x27;2020.8.8拍摄.mp4&#x27;print(s2.partition(&#x27;.&#x27;)) # (&#x27;2020&#x27;, &#x27;.&#x27;, &#x27;8.8拍摄.mp4&#x27;)print(s2.rpartition(&#x27;.&#x27;)) # (&#x27;2020.8.8拍摄&#x27;, &#x27;.&#x27;, &#x27;mp4&#x27;) s.splitlines([keepends]) -&gt; list[str]：按换行符（\\n，\\r，\\r\\n）分割keepends – 在输出结果里是否保留换行符(‘\\r’, ‘\\r\\n’, \\n’)，默认为 False，不包含换行符，如果为 True，则保留换行符。 12345str1 = &#x27;ab c\\n\\nde fg\\rkl\\r\\n&#x27;print(str1.splitlines()) # [&#x27;ab c&#x27;, &#x27;&#x27;, &#x27;de fg&#x27;, &#x27;kl&#x27;]str2 = &#x27;ab c\\n\\nde fg\\rkl\\r\\n&#x27;print(str2.splitlines(True)) # [&#x27;ab c\\n&#x27;, &#x27;\\n&#x27;, &#x27;de fg\\r&#x27;, &#x27;kl\\r\\n&#x27;] 切片从字符串里截取一段指定的内容，生成一个新的字符串切片都是包头不包尾 具体参考 高级特性-&gt;切片 转换大小写12345678910s = &#x27;hello woRlD.good mornIng&#x27;# 将第一个字符转成大写，其他字符转成小写print(s.capitalize()) # Hello world.good morning# 将全部字符转成大写print(s.upper()) # HELLO WORLD.GOOD MORNING# 将全部字符转成小写print(s.lower()) # hello world.good morning# 将每个单词首字母转成大写print(s.title()) # Hello World.Good Morning 填充 s.ljust(weight, fillchar=&#39;&#39;) -&gt; strs.rjust(weight, fillchar=&#39;&#39;) -&gt; strs.center(weight, fillchar=&#39;&#39;) -&gt; str 不足 weight 的话，用 fillchar 填充，fillchar默认空格 123456print(&#x27;|&#x27; + &#x27;Monday&#x27;.ljust(10) + &#x27;|&#x27;) # |Monday |print(&#x27;|&#x27; + &#x27;Monday&#x27;.ljust(10, &#x27;^&#x27;) + &#x27;|&#x27;) # |Monday^^^^|print(&#x27;|&#x27; + &#x27;Monday&#x27;.rjust(10) + &#x27;|&#x27;) # | Monday|print(&#x27;|&#x27; + &#x27;Monday&#x27;.rjust(10, &#x27;#&#x27;) + &#x27;|&#x27;) # |####Monday|print(&#x27;|&#x27; + &#x27;Friday&#x27;.center(20, &#x27;*&#x27;) + &#x27;|&#x27;) # |*******Friday*******|print(&#x27;|&#x27; + &#x27;Friday&#x27;.center(4, &#x27;*&#x27;) + &#x27;|&#x27;) # |Friday| 修剪 s.lstrip(chars) -&gt; strs.rstrip(chars) -&gt; strs.strip(chars) -&gt; str 删除字符串 左边 / 右边 / 左边+右边 的 chars 字符 1234567print(&#x27;|&#x27; + &#x27; Couldy Sunny &#x27;.lstrip() + &#x27;|&#x27;) # |Couldy Sunny |print(&#x27;|&#x27; + &#x27; Couldy Sunny &#x27;.rstrip() + &#x27;|&#x27;) # | Couldy Sunny|print(&#x27;|&#x27; + &#x27; Couldy Sunny &#x27;.strip() + &#x27;|&#x27;) # |Couldy Sunny|print(&#x27;|&#x27; + &#x27; Couldy+Sunny+++&#x27;.lstrip(&#x27;+&#x27;) + &#x27;|&#x27;) # | Couldy+Sunny+++|print(&#x27;|&#x27; + &#x27; Couldy+Sunny+++&#x27;.rstrip(&#x27;+&#x27;) + &#x27;|&#x27;) # | Couldy+Sunny|print(&#x27;|&#x27; + &#x27; Couldy+Sunny+++&#x27;.strip(&#x27;+&#x27;) + &#x27;|&#x27;) # | Couldy+Sunny| 拼接 s.join(iterable) -&gt; str将 s 拼接到 iterable 的每一个元素上 1234567li = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Candy&#x27;, &#x27;Dannis&#x27;, &#x27;Eva&#x27;, &#x27;Fiona&#x27;]print(&#x27; - &#x27;.join(li)) # Alice - Boii - Candy - Dannis - Eva - Fionaprint(&#x27;+&#x27;.join(&#x27;Hello&#x27;)) # H+e+l+l+odic = &#123;&#x27;name1&#x27;: &#x27;Alice&#x27;, &#x27;name2&#x27;: &#x27;Boii&#x27;&#125;print(&#x27; - &#x27;.join(dic)) # name1 - name2 编码 ASCII 0~127共128个，占用 1byte 即 8bit 的长度，共使用了7位的长度，从0000 0000 到 0111 1111。 48-57 -&gt; 0-9，65-90 -&gt; A-Z，97-122 -&gt; a-z ISO-8859-1 0255共256个，占用 1byte 即 8bit 的长度，共使用了8位的长度，从 0000 0000到1111 1111。 0127与ASCII完全兼容，128~255是一些欧洲字母 Unicode 万国码，汉字每个占 3byte GBK 国标扩，汉字每个占 2byte 长度格式化不可变性字符串是不可变对象。当执行一个 str = &#39;abc&#39; 的语句时，python在字符串池中创建了一个字符串 &#39;abc&#39; ，然后在内存中创建一个变量 str指向字符串池中的 &#39;abc&#39; 如果对str进行修改 str = &#39;xyz&#39;python会在字符串池中再创建一个字符串 &#39;xyz&#39;，然后让变量 str 指向字符串池中的 &#39;xyz&#39;此时字符串池其实有 &#39;abc&#39; 和 &#39;xyz&#39;，只不过&#39;abc&#39;没有被指向， &#39;xyz&#39; 被str指向 所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回这样，就保证了不可变对象本身永远是不可变的。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"基础","slug":"Python/基础","permalink":"https://www.boii.xyz/categories/Python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【Feature】函数式编程","slug":"Python/Python【No-Feature】函数式编程","date":"2020-07-25T04:17:48.000Z","updated":"2021-07-19T08:55:20.014Z","comments":true,"path":"posts/31044.html","link":"","permalink":"https://www.boii.xyz/posts/31044.html","excerpt":"Python的高级特性2","text":"Python的高级特性2 函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ 函数的本质在学C语言指针的时候，会接触到一个概念：函数名是函数所在内存的地址，类似-数组名是数组的首元素的地址。 即使Python中没有指针一说，但是本质还是一样的。变量名是一个变量的地址函数名是一个函数的地址调用函数的时候其实是把参数传到函数本身所在的那块内存中去，函数名不过是一个媒介而已。在C中可以说，函数名就是个指针，指向一个函数在Python中可以说，函数名就是个变量，指向一个函数 既然函数名只是指向函数本身所在地址，那我换个名来指不也可以。 12345678910def sum(a, b): return a + bf = sumf(1, 2)---------------------------------# Output:3 如果放到交互模式中，可以更明显的看出来 123456789101112# 定义一个函数&gt;&gt;&gt; def sum(a, b):... return a + b...&gt;&gt;&gt; sum&lt;function sum at 0x000001F25AF6B280&gt;&gt;&gt;&gt; f=sum&gt;&gt;&gt; f&lt;function sum at 0x000001F25AF6B280&gt;&gt;&gt;&gt; f(3, 4)7 大概就这么回事儿 高阶函数 高阶函数：接受函数作为参数的函数def heigh_fn(a, b, fn) 既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 一个最简单的高阶函数： 123456789101112def abs(num): return (num) if num &gt;= 0 else (-num)def abs_add(a, b, fn): return fn(a) + fn(b)print(abs_add(8, -4, abs))---------------------------------# Output:12 这个高阶函数的过程大概是这样的a = 8b = -4fn = absfn(a) + fn(b) ==&gt; abs(8) + abs(-4) ==&gt; 12 返回函数 返回函数：返回值为函数的函数 通常函数都是返回int、str、list 这些变量，但是变量可以指向函数，那函数可以返回一个变量，不就也可以返回一个函数。 举个栗子实现一个求和函数。参数可变，可以是1个也可以是多个。 1234567891011121314def cal_sum(*args): sum = 0 for n in args: sum += n return sumresult = cal_sum(1, 2, 3, 4, 5)print(result)---------------------------------# Output:15 好，现在再写一个函数lazy_sum()，把这个函数cal_sum()作为返回值返回 1234567def lazy_sum(*args): def cal_sum(): sum = 0 for n in args: sum += n return sum return cal_sum 可以看到最后一句return cal_sum就把函数返回出来了。那么函数lazy_sum()就是一个返回函数 现在调用一下这个返回函数 123456789101112131415161718def lazy_sum(*args): print(&#x27;I am the return function.&#x27;) def cal_sum(): sum = 0 for n in args: sum += n return sum return cal_sumresult = lazy_sum(1, 2, 3, 4, 5)print(result)---------------------------------# Output:I am the return function.&lt;function lazy_sum.&lt;locals&gt;.cal_sum at 0x000001C8765CB310&gt; 哦嚯，lazy_sum()没有进行计算，但也看出来，lazy_sum()返回的是一个函数result此时是一个函数，这时候我们要去调用一次返回值result，才会进行计算 12345678910111213141516171819202122def lazy_sum(*args): print(&#x27;I am the return function.&#x27;) def cal_sum(): sum = 0 for n in args: sum += n return sum return cal_sumresult = lazy_sum(1, 2, 3, 4, 5)print(result)res = result()print(res)---------------------------------# Output:I am the return function.&lt;function lazy_sum.&lt;locals&gt;.cal_sum at 0x000001E02D07B310&gt;15 这就是为什么说 返回函数是惰性的。就是这么来的 为什么要返回一个函数在lazy_sum()中，有一句print语句。从输出中可以看出，返回函数本身是立即执行的，但是它返回出来的函数要再进行一次调用才会执行。 单独一个返回函数并没有太大作用，但是返回函数和高阶函数结合起来，是不是就有意思了。接收一个函数，然后把这个函数返回出去。在返回之前是不是可以进行一些操作？ 假如现在有一个需求：求和；实现完了之后，产品经理又加需求：除了求和还要打印一下求和用了多长时间，也就是计时功能。那么现在你有两个办法 一是在求和函数里实现这个计时功能，但是这样就在一个函数里做了两件事情。即不优雅，也不好维护。这里举例是简单的求和，实际开发中可能是跟复杂的功能。 二是把计时函数写出来，然后把求和函数传给计时函数，在计时函数中给求和函数加上计时功能，之后再把这个有计时功能的求和函数返回出去。 计时函数这种接收函数 -&gt; 增强函数 -&gt; 返回函数的函数就叫闭包 不仅可以用在计时功能，还能用在日志功能，我只要把求和函数写好，传给日志函数就可以获得日志功能。函数只做一件事情，其他事情由别的函数做，需要什么功能把函数往里面一丢，还你一个增强版的。Amazing！这就叫面向切面编程 闭包、装饰器、面向切面编程闭包 闭包 = 高阶函数 + 返回函数即，一个接收函数作为参数，又返回一个函数的函数，就叫做闭包作用：增强函数功能、面向切面编程（AOP） 无参闭包123456789101112131415161718192021222324import timedef print_hello(): print(&#x27;hello!&#x27;)def cal_time(fn): def improve_fn(): start_time = time.time() fn() end_time = time.time() print(&#x27;耗时：&#123;&#125;&#x27;.format(end_time - start_time)) return improve_fnimprove_print_hello = cal_time(print_hello)improve_print_hello()# 也可以写做 cal_time(print_hello)()---------------------------------# Output:hello!耗时：0.0009620189666748047 栗子中，print_hello()只负责打印hello，cal_time()负责把传进来的函数增强然后返回出去所以cal_time就是一个闭包 带参闭包上面的栗子，print_hello()不需要参数，所以在无参闭包中可以顺利通过但是如果一个函数有参，那无参闭包就会抛出TypeError错误。 想要带参很简单。 123456789101112131415161718192021222324import timedef add(a, b): print(a + b)def cal_time(fn): def improve_fn(*args, **kwargs): # 在这里写下形参 start_time = time.time() fn(*args, **kwargs) # 调用的时候传进去 end_time = time.time() print(&#x27;耗时：&#123;&#125;&#x27;.format(end_time - start_time)) return improve_fncal_time(add)(1, 2)---------------------------------# Output:3耗时：0.00800633430480957 接收的函数有返回值接收的函数有返回值的话，应该在闭包里对函数调用的时候把参数接收下来，然后进行返回。 1234567891011121314151617181920212223242526import timedef add(a, b): return a + bdef cal_time(fn): def improve_fn(*args, **kwargs): start_time = time.time() count = fn(*args, **kwargs) # 调用函数之后用一个变量接收返回值 end_time = time.time() print(&#x27;耗时：&#123;&#125;&#x27;.format(end_time - start_time)) return count # 然后把返回值返回出去 return improve_fnresult = cal_time(add)(5, 12)print(result)---------------------------------# Output:耗时：0.000962018966674804717 装饰器 装饰器是闭包的语法糖——@闭包名或@闭包名(参数)语法糖只是一个更方便的写法，完全可以等价转换为非语法糖的代码 装饰器、闭包，本质上也是函数，说装饰器的同时也是在说闭包 保留原函数的元信息装饰器（闭包）的原理就是把原函数当作参数传进装饰器中，经过增强后返回一个新的增强版原函数这说明返回出来的增强版函数和原来的函数不是同一个了（在内存中创建了一个新的） 既然不是在原函数上进行改造，这就导致函数的元信息（文档字符串、注解、参数签名等）都丢失了解决方法就是使用functools库中的@wraps装饰器来把原函数的元信息复制过来。 先看看不保留元信息的样子 12345678910111213141516171819202122232425262728293031323334353637import time# 装饰器函数def cal_time(fn): &#x27;&#x27;&#x27; Decorator that report the execution time. &#x27;&#x27;&#x27; def improve_fn(*args, **kwargs): start = time.time() result = fn(*args, **kwargs) end = time.time() print(fn.__name__, end - start) return result return improve_fn# 原函数@cal_timedef countdown(n): &#x27;&#x27;&#x27; Count down &#x27;&#x27;&#x27; while n &gt; 0: n -= 1if __name__ == &#x27;__main__&#x27;: countdown(10_000) print(countdown.__doc__) # 没有使用wrap，所以元信息都丢失了---------------------------------# Output:countdown 0.0010008811950683594None 再看看使用了@wraps的样子 12345678910111213141516171819202122232425262728293031323334353637383940import timefrom functools import wraps# 装饰器函数def cal_time(fn): &#x27;&#x27;&#x27; Decorator that report the execution time. &#x27;&#x27;&#x27; @wraps(fn) def improve_fn(*args, **kwargs): start = time.time() result = fn(*args, **kwargs) end = time.time() print(fn.__name__, end - start) return result return improve_fn# 原函数@cal_timedef countdown(n): &#x27;&#x27;&#x27; Count down &#x27;&#x27;&#x27; while n &gt; 0: n -= 1if __name__ == &#x27;__main__&#x27;: countdown(10000) print(countdown.__doc__) # 使用了wrap，所以元信息没有丢失---------------------------------# Output:countdown 0.0010025501251220703 Count down 无参装饰器1234567891011121314151617181920212223242526272829303132333435363738394041import timefrom functools import wrapsdef cal_time(fn): &#x27;&#x27;&#x27; Decorator that report the execution time. &#x27;&#x27;&#x27; @wraps(fn) def improve_fn(*args, **kwargs): start = time.time() result = fn(*args, **kwargs) end = time.time() print(fn.__name__, &#x27;used time:&#x27;, end - start) return result return improve_fn# 装饰器里不需要携带参数@cal_timedef add(a, b): return a + bres = add(5, 6)print(res)# 等价于## def add(a, b):# return a + b## improve_add = cal_time(add)# res = improve_add(5, 6)# print(res)---------------------------------# Output:add used time: 0.011 带参装饰器1234567891011121314151617181920212223242526272829303132333435363738394041import timefrom functools import wrapsdef cal_time(msg): # 第一层，接收装饰器参数 print(&#x27;First floor:&#x27;, msg) def decorator(fn): # 第二层，接收函数 print(&#x27;Second floor:&#x27;, msg) @wraps(fn) def improve_fn(*args, **kwargs): # 第三层，增强函数 print(&#x27;Third floor:&#x27;, msg) start = time.time() result = fn(*args, **kwargs) end = time.time() print(&#x27;Used time:&#x27;, end - start) return result return improve_fn return decorator@cal_time(&#x27;I am the message.&#x27;)def countdown(time=10000): while time &gt; 0: time -= 1if __name__ == &#x27;__main__&#x27;: countdown()---------------------------------# Output:First floor: I am the message.Second floor: I am the message.Third floor: I am the message.Used time: 0.000997781753540039 有参装饰器和无参装饰器的区别仅仅只是多了一层函数而已也就是在无参装饰器的基础上多一层函数来接收装饰器参数而已。注意带参装饰器即使不填参数也要写上括号 装饰器只在第一次被调用去装饰函数时对原函数进行增强 增强时机：第一调用之前 增强次数：只增强一次 面向切面编程如果说类里面的继承是纵向继承，那面向切面编程可以理解为横向继承 纵向继承中，子类继承了父类非私有属性和方法；同属一个父类的子类都有相同的父类属性和方法横向继承中，是给子类增加了一些功能；同属一个父类的子类不见得有相同的功能。 就好比，一个爹生了两个娃，两个娃都有手有脚的，这是继承自爹那里的（纵向继承）但是一个娃点亮了游泳的技能，另一个娃点亮了跳舞的技能（横向继承）这俩娃生了俩孙子，肯定也是有手有脚的，但不一定会游泳跳舞。 所以面向切面编程中，这种闭包、装饰器之类的通常是用在编写通用工具类上。 匿名函数 lambda [parameters]: expression冒号前面的parameters表示匿名函数的形参列表，冒号后面的expression表示要return的语句parameters可以有也可以没有。匿名函数有个限制——只能有一个表达式，不用写return，返回值就是该表达式的结果。 匿名函数类似于 es6 中的简头函数 举个栗子： 12def add(a, b): return a + b 写成匿名函数就是 1lambda a, b: a + b 写成简头函数就是 1(a, b) =&gt; a + b 匿名函数可以作为实参、返回值，在这些场景中应用的比较多。 匿名函数作为实参 123456789101112131415161718192021# 普通写法def abs(num): return (num) if num &gt;= 0 else (-num)def abs_add(a, b, fn): return fn(a) + fn(b)print(abs_add(8, -4, abs))---------------------------------# 匿名函数写法def abs_add(a, b, fn): return fn(a) + fn(b)result = abs_add(8, -4, lambda x: x if x &gt;= 0 else -x) # 匿名函数作为实参print(result)---------------------------------# Output:12 匿名函数作为返回值 123456789def build(x, y): return lambda: x * x + y * y # 匿名函数作为返回值build(2, 3)---------------------------------# Output:13 总结 函数名的本质：函数起始地址 高阶函数：接收函数作为参数的函数 返回函数：返回一个函数（即返回一个函数地址）的函数，是惰性的 闭包：接收函数作为参数，并返回一个函数的函数（闭包=高阶函数+返回函数） 装饰器：闭包的语法糖，@闭包名字 匿名函数：lambda 参数: 返回值","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"高级特性","slug":"Python/高级特性","permalink":"https://www.boii.xyz/categories/Python/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://www.boii.xyz/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"Python【Feature】工具类","slug":"Python/Python【No-Feature】工具类","date":"2020-07-24T05:17:48.000Z","updated":"2021-07-19T08:55:19.889Z","comments":true,"path":"posts/18591.html","link":"","permalink":"https://www.boii.xyz/posts/18591.html","excerpt":"Python的高级特性3","text":"Python的高级特性3 map将传入的函数作用于可迭代对象的每一个元素上 map(function, iterable)参数：map 可以接受两个参数，第一个是函数，第二个是可迭代对象作用：将可迭代对象的每一个元素放在 function 中进行处理返回：map 返回的是一个 map 对象，这是一个可迭代对象 举个栗子： 1234567891011# 使用map示例alpha = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]m = map(lambda x: x + &#x27;i&#x27;, alpha)print(m)print(list(m)) # 返回的map对象用m接收，然后转换成列表，打印出来--------------------------------------------------# Output:&lt;map object at 0x000001D50CEBAD00&gt;[&#x27;ai&#x27;, &#x27;bi&#x27;, &#x27;ci&#x27;, &#x27;xi&#x27;, &#x27;yi&#x27;, &#x27;zi&#x27;] 如果不使用 map 函数，应该这样写 12345678910111213141516171819# 不适用map的示例alpha = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]def add_alpha(list1): &quot;&quot;&quot; 遍历list1，每个元素都加上 i 然后放进 list2 中 &quot;&quot;&quot; list2 = list() for alpha in list1: list2.append(alpha + &#x27;i&#x27;) return list2m = add_alpha(alpha)print(m)print(type(m))--------------------------------------------------# Output:[&#x27;ai&#x27;, &#x27;bi&#x27;, &#x27;ci&#x27;, &#x27;xi&#x27;, &#x27;yi&#x27;, &#x27;zi&#x27;]&lt;class &#x27;list&#x27;&gt; 效果是一样的，但是并没有像 map 那么简洁 同样，上面的示例还可以使用更简洁的办法，用列表生成式前提是其逻辑比较简单，如果复杂还是要另外编写 操作函数，然后传给 map() 1234567alpha = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]print([x + &#x27;i&#x27; for x in alpha])--------------------------------------------------# Output:[&#x27;ai&#x27;, &#x27;bi&#x27;, &#x27;ci&#x27;, &#x27;xi&#x27;, &#x27;yi&#x27;, &#x27;zi&#x27;] 此外，因为返回出来的已经不是原本放进去的可迭代对象了，所以即使元组不能修改，map 也能进行操作 123456789101112131415# 对元组进行操作m = (12, 23, 28, 19, 16, 30)print(&#x27;m source: &#x27;, id(m)) # 打印原元组的地址m = map(lambda x: x * x, m) # 对元组进行操作print(&#x27;m operated:&#x27;, id(m)) # 打印修改后元组的地址print(&#x27;m is a&#x27;, m) # 打印结果显示 m 是个 map对象print(list(m)) # 把 m 转成列表打印出来--------------------------------------------------# Output:m source: 2599500087840m operated: 2599500555024m is a &lt;map object at 0x0000025D3E4EA310&gt;[144, 529, 784, 361, 256, 900] filter对可迭代对象进行过滤Python2 中 filter 是个内置函数, Python3 中 filter 是个内置类 filter(condition_function, iterable)参数：filter 可以接收两个参数，第一个是函数，第二个是可迭代对象作用：将 可迭代对象 的每一个元素放在 function 中进行过滤，满足 function 中的过滤规则便返回返回：filter 返回的是一个 filter对象，这是一个可迭代对象。 123456789101112131415# filter 示例f = [12, 23, 28, 19, 16, 30]print(&#x27;f source: &#x27;, id(f)) # 打印原元组的地址f = filter(lambda x: x &gt;= 18, f) # 对 列表进行过滤，过滤出大于等于18的元素print(&#x27;f operated:&#x27;, id(f)) # 打印修改后元组的地址print(&#x27;f is a&#x27;, f) # 打印结果显示 f 是个 filter对象print(list(f)) # 把 f 转成列表打印出来--------------------------------------------------# Output:f source: 2379695132608f operated: 2379696090368f is a &lt;filter object at 0x0000022A10F0AD00&gt;[23, 28, 19, 30] 同样，filter 也可以对元组操作，简单的过滤规则也可以用列表生成式代替 12345678# 用列表生成式实现简单过滤f = [12, 23, 28, 19, 16, 30]print([x for x in f if x &gt;= 18])--------------------------------------------------# Output:[23, 28, 19, 30] reducereduce 不是内置函数，必须导入 from functools import reducereduce(function, sequence, initial=_initial_missing) 参数：reduce 第一个参数接收一个带两个形参的函数，第二个参数接收一个序列作用：把函数作用在一个序列上，函数必须接收两个参数，reduce 把结果继续和序列的下一个元素做累计运算返回：一个计算结果 听起来有点绕，用示例解释 12345678910111213from functools import reducedef foo(x, y): return x + yscores = [100, 89, 76, 87]r = reduce(foo, scores)print(r)--------------------------------------------------# Output:352 在 reduce 中会一次次调用scores中的元素放到foo函数中进行计算第一轮：x = 100, y = 89, result = 189第二轮：x = result, y = 76, result = 265 (即 189 + 76)第三轮：x = result, y = 87, result = 352 (即 265 + 87)最后把 result 也就是 352 返回出去 上面的例子中的序列还是比较简单的，如果遇到复杂的数据对象，则不能这么简单处理 1234567891011121314151617181920212223242526from functools import reducedic = [ &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 18, &#x27;score&#x27;: 78&#125;, &#123;&#x27;name&#x27;: &#x27;Boii&#x27;, &#x27;age&#x27;: 17, &#x27;score&#x27;: 89&#125;, &#123;&#x27;name&#x27;: &#x27;Candy&#x27;, &#x27;age&#x27;: 19, &#x27;score&#x27;: 65&#125;, &#123;&#x27;name&#x27;: &#x27;Dannis&#x27;, &#x27;age&#x27;: 22, &#x27;score&#x27;: 99&#125;]def foo(x, y): return x[&#x27;score&#x27;] + y[&#x27;score&#x27;] # 第二轮就会出错r = reduce(foo, dic)print(r)--------------------------------------------------# Output:Traceback (most recent call last): File &quot;d:/---Programming---/Python/Project/练习/mo2.py&quot;, line 58, in &lt;module&gt; r = reduce(foo, dic) File &quot;d:/---Programming---/Python/Project/练习/mo2.py&quot;, line 55, in foo return x + y[&#x27;score&#x27;]TypeError: unsupported operand type(s) for +: &#x27;dict&#x27; and &#x27;int&#x27; 哦嚯，报错。报错信息为：unsupported operand type(s) for +: ‘dict’ and ‘int’不支持 字典对象和整型做 相加操作 既然说相加，看来问题出在foo函数身上以上面的方式再进行一次推导第一轮：x = {‘name’: ‘Alice’, ‘age’: 18, ‘score’: 78}, y = {‘name’: ‘Boii’, ‘age’: 17, ‘score’: 89},则 x[‘score’] = 78, y[‘score’] = 89, result = 167第二轮：x = result, y = {‘name’: ‘Candy’, ‘age’: 19, ‘score’: 65},则 x[‘score’] =… 问题就出在这 第一次计算之后result 给了x，x就成了整型，当然取不出 score 解决方法，改为 return x + y[&#39;score&#39;] 1234567891011121314151617181920212223242526from functools import reducedic = [ &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 18, &#x27;score&#x27;: 78&#125;, &#123;&#x27;name&#x27;: &#x27;Boii&#x27;, &#x27;age&#x27;: 17, &#x27;score&#x27;: 89&#125;, &#123;&#x27;name&#x27;: &#x27;Candy&#x27;, &#x27;age&#x27;: 19, &#x27;score&#x27;: 65&#125;, &#123;&#x27;name&#x27;: &#x27;Dannis&#x27;, &#x27;age&#x27;: 22, &#x27;score&#x27;: 99&#125;]def foo(x, y): return x + y[&#x27;score&#x27;] # 一个字典 + 一个整型，依然报错r = reduce(foo, dic)print(r)--------------------------------------------------# Output:Traceback (most recent call last): File &quot;d:/---Programming---/Python/Project/练习/mo2.py&quot;, line 58, in &lt;module&gt; r = reduce(foo, dic) File &quot;d:/---Programming---/Python/Project/练习/mo2.py&quot;, line 55, in foo return x + y[&#x27;score&#x27;]TypeError: unsupported operand type(s) for +: &#x27;dict&#x27; and &#x27;int&#x27; 依然报错，这回问题出在第一轮x = {‘name’: ‘Alice’, ‘age’: 18, ‘score’: 78}，y[‘score’] = 89一个是字典一个是整型 解决方法，设置初始值 123456789101112131415161718192021from functools import reducedic = [ &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 18, &#x27;score&#x27;: 78&#125;, &#123;&#x27;name&#x27;: &#x27;Boii&#x27;, &#x27;age&#x27;: 17, &#x27;score&#x27;: 89&#125;, &#123;&#x27;name&#x27;: &#x27;Candy&#x27;, &#x27;age&#x27;: 19, &#x27;score&#x27;: 65&#125;, &#123;&#x27;name&#x27;: &#x27;Dannis&#x27;, &#x27;age&#x27;: 22, &#x27;score&#x27;: 99&#125;]def foo(x, y): return x + y[&#x27;score&#x27;]r = reduce(foo, dic, 0)print(r)--------------------------------------------------# Output:331 第一轮：x = 0, y = {‘name’: ‘Alice’, ‘age’: 18, ‘score’: 78}, 则 y[‘score’] = 78, result = 78第二轮：x = result, y ={‘name’: ‘Boii’, ‘age’: 17, ‘score’: 89}, 则 y[‘score’] = 89, result = 167第三轮：x = result, y ={‘name’: ‘Candy’, ‘age’: 19, ‘score’: 65}, 则 y[‘score’] = 65, result = 232第四轮：x = result, y ={‘name’: ‘Dannis’, ‘age’: 22, ‘score’: 99}, 则 y[‘score’] = 99, result = 331最后把 331 返回出去","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"高级特性","slug":"Python/高级特性","permalink":"https://www.boii.xyz/categories/Python/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://www.boii.xyz/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"Python【Feature】高级特性","slug":"Python/Python【No-Feature】高级特性","date":"2020-07-24T03:17:48.000Z","updated":"2021-07-19T08:55:19.693Z","comments":true,"path":"posts/44742.html","link":"","permalink":"https://www.boii.xyz/posts/44742.html","excerpt":"Python的高级特性1","text":"Python的高级特性1 切片 Slice [startWith : end : step]切片适用于 list、tuple、stringstartWith是包含，end则不包含 注意：切片是从左往右切的如果用正索引开始，就要用 正索引 或 逆索引 结束，例如 s[1:5] 或 s[1:-3] ！如果用逆索引开始，就要用 逆索引 结束（s[-1:1] 这样只会返回空字符串，正确应该是 s[-5:-1]）！逆索引记得不要弄颠倒了。（s[-1:-3] 这样只会返回空字符串，正确应该是s[-3:-1]） 索引123| P | y | t | h | o | n | 0 1 2 3 4 5 # 从左往右，下标从0开始 -6 -5 -4 -3 -2 -1 # 从右往左，下标从-1开始 12345678910111213141516171819202122&gt;&gt;&gt; s = &#x27;Python&#x27;&gt;&gt;&gt; s[0]&#x27;P&#x27;&gt;&gt;&gt; s[0:-1] # 结束索引不被截取&#x27;Pytho&#x27;&gt;&gt;&gt; s[:5] # 起始索引可以省略不写，代表从第一位开始截取&#x27;Pytho&#x27;&gt;&gt;&gt; s[0:] # 结束索引可以省略不写，代表截取至最后一位&#x27;Python&#x27;&gt;&gt;&gt; s[:] # 等于复制了一整个&#x27;Python&#x27;&gt;&gt;&gt; s[1:4]&#x27;yth&#x27;&gt;&gt;&gt; s[1:-2]&#x27;yth&#x27;&gt;&gt;&gt; s[-2:1] # 逆索引开始，不能以正索引结束&#x27;&#x27;&gt;&gt;&gt; s[-5:-2]&#x27;yth&#x27;&gt;&gt;&gt; s[-2:-5] # 只能从左往右切&#x27;&#x27; 12345678910111213141516171819&gt;&gt;&gt; l = list(range(100))&gt;&gt;&gt; l[10:20][10, 11, 12, 13, 14, 15, 16, 17, 18, 19]&gt;&gt;&gt; l[10:20:3][10, 13, 16, 19]&gt;&gt;&gt; l[80::3][80, 83, 86, 89, 92, 95, 98]&gt;&gt;&gt; l[:10:3][0, 3, 6, 9]&gt;&gt;&gt; l[::10][0, 10, 20, 30, 40, 50, 60, 70, 80, 90]&gt;&gt;&gt; l[::-10][99, 89, 79, 69, 59, 49, 39, 29, 19, 9] 迭代 Iteration判断是否迭代对象 可以用过 collections 的 Iterable 类型，用 isinstance()判断 一个对象是否是可迭代对象 1234567891011121314from collections import Iterablestr = &#x27;abc&#x27;l = [1, 2, 3]t = (1, 2, 3)d = &#123;1: 1, 2: 2, 3: 3&#125;s = (&#123;1, 2, 3&#125;)print(isinstance(str, Iterable)) # Trueprint(isinstance(l, Iterable)) # Trueprint(isinstance(t, Iterable)) # Trueprint(isinstance(d, Iterable)) # Trueprint(isinstance(s, Iterable)) # Trueprint(isinstance(123, Iterable)) # False 整数字面量不是可迭代对象 迭代 List 列表类型数据123456s = &#x27;abcdefg&#x27;for value in s: print(value, end=&#x27; &#x27;)# Output：a b c d e f g 1234567891011121314# 可以通过 enumerate() 给string，list，tuple 等生成下标s = &#x27;abcdefg&#x27;for i, value in enumerate(s): print(i, value)# Output：0 a1 b2 c3 d4 e5 f6 g 123456789l = [&#x27;a&#x27;, True, (1, 2), 43]for i, value in enumerate(l): print(i, value)# Output:0 a1 True2 (1, 2)3 43 123456789101112131415161718# 同时引用两个变量for x, y in [(11, 12), (21, 22), (31, 32)]: print(x, y)# Output:11 1221 2231 32######################################################for x, y, z in [(11, 12, 13), (21, 22, 23), (31, 32, 33)]: print(x, y, z)# Output:11 12 1321 22 2331 32 33 迭代 Dict 键-值对类型数据 默认情况下，Dict迭代的是key，如果要迭代value，可以用 for value in d.values()如果要同时迭代key 和 value， 可以用 for k, v in d.items() 123456789101112131415161718192021222324252627282930d = &#123;&#x27;a&#x27;: &#x27;Alice&#x27;, &#x27;b&#x27;: &#x27;Boii&#x27;, &#x27;c&#x27;: &#x27;Cai&#x27;&#125;for i in d: print(i)# Output:abc#############################################d = &#123;&#x27;a&#x27;: &#x27;Alice&#x27;, &#x27;b&#x27;: &#x27;Boii&#x27;, &#x27;c&#x27;: &#x27;Cai&#x27;&#125;for i in d.values(): print(i)# Output:AliceBoiiCai#############################################d = &#123;&#x27;a&#x27;: &#x27;Alice&#x27;, &#x27;b&#x27;: &#x27;Boii&#x27;, &#x27;c&#x27;: &#x27;Cai&#x27;&#125;for k, v in d.items(): print(k, &#x27;-&#x27;, v)# Output:a - Aliceb - Boiic - Cai 列表生成式 List Comprehensions列表生成式 [ i-expression for i in Iterations ][ i-expression for i in Iterations if expression ][ i-expression if expression else expression for i in Iterations ] 123[ ··· for ··· in ··· ][ ··· for ··· in ··· if ··· ][ ··· if ··· else ··· for ··· in ··· ] 列表生成式是一种非常简洁的语法，可以大幅度的压缩代码阅读方式： [i-expression for i in Iterations]遍历迭代对象 Iterations，将每个元素 e 放到 i-expression中运算后，作为这个列表 list 的元素 [i-expression for i in Iterations if expression]遍历迭代对象 Iterations，将每个元素 e 放到 if 中的 expression中运算后，放到 i-expression 中运算，然后作为这个列表 list 的元素 [i-expression if expression else expression for i in Iterations]遍历迭代对象 Iterations，将每个元素 e 放到 if else 中的 expression中运算后，放到 i-expression 中运算，然后作为这个列表 list 的元素 for 前的 if else 可以看成三目运算符，这样比较好理解 三目运算符：True时执行 if expression else Flase时执行 对比一下：[ i-expression if expression else expression for i in Iterations ] 代入一下：[ True时执行 if expression else Flase时执行 for i in Iterations ] 一句话：原本有10个，for…if 后不一定有 10 个， if…else…for 以后有10个，不过可能不尽相同。两句话：for 前必 else，for 后不else。 注意：i-expression 的计算变量和 for 里的临时变量要相同 普通列表生成式 123456789101112131415# range(1, 11) 生成1~10 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]# for in 遍历这10个数# 每次遍历都把当前元素拿到 i-expression 即 x * x 做相乘计算# 然后作为列表的元素# 注意 for 的临时变量是 x，i-expression 的变量也是 x，这两个要相同# 这里是计算出1~10每个数的平方&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]# 把一个 List 中所有字符串变小写&gt;&gt;&gt; L = [&#x27;Hello&#x27;, &#x27;World&#x27;, &#x27;IBM&#x27;, &#x27;Apple&#x27;]&gt;&gt;&gt; [s.lower() for s in L][&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;ibm&#x27;, &#x27;apple&#x27;] for 里带 if 筛选的列表生成式 12345678910# range(1, 11) 生成1~10 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]# for in 遍历这10个数# 每次遍历都把当前元素拿到 if 里计算, 得到 [2, 4, 6, 8, 10]# 然后放到 i-expression 即 x * x 做相乘计算得到 [4, 16, 36, 64, 100]# 最后作为列表的元素# 这里是筛选出偶数，然后计算平方&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 双循环的列表生成式 1234# 还可以使用双循环，生成全排列&gt;&gt;&gt; [m + n for m in &#x27;ABC&#x27; for n in &#x27;XYZ&#x27;][&#x27;AX&#x27;, &#x27;AY&#x27;, &#x27;AZ&#x27;, &#x27;BX&#x27;, &#x27;BY&#x27;, &#x27;BZ&#x27;, &#x27;CX&#x27;, &#x27;CY&#x27;, &#x27;CZ&#x27;] 多变量的列表生成式 1234# 一个循环多个变量也是可以的&gt;&gt;&gt; d = &#123;&#x27;x&#x27;: &#x27;A&#x27;, &#x27;y&#x27;: &#x27;B&#x27;, &#x27;z&#x27;: &#x27;C&#x27; &#125;&gt;&gt;&gt; [k + &#x27;-&#x27; + v for k, v in d.items()][&#x27;y-B&#x27;, &#x27;x-A&#x27;, &#x27;z-C&#x27;] for 前带 if 的列表生成式 123456789101112# # range(1, 11) 生成1~10 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]# for in 遍历这10个数# 每次遍历都把当前元素拿到 for 前的 if else三目运算符里计算# x if x % 2 == 0 else -x ,偶数正常输出, 奇数变负数，得到 [-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]# 最后作为列表的元素&gt;&gt;&gt; [x if x % 2 == 0 else -x for x in range(1, 11)][-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]# 再稍微改动下# 把 x if x % 2 == 0 else x + 10 看作三目运算符就很好理解&gt;&gt;&gt; [x if x % 2 == 0 else x + 10 for x in range(1, 11)][11, 2, 13, 4, 15, 6, 17, 8, 19, 10] 其他生成式除了列表生成式，还有字典生成式、元组生成式，其实现都是一样的 123&#123;k: v for k, v in d.items()&#125;&#123;k: v for k, v in d.items() if condition&#125;&#123;k: v if condition else k: -v for k, v in d.items() &#125; 元组生成式 生成一个生成器对象，下面将会讲到。 错误示范12345678910111213# for 后 if 加 else&gt;&gt;&gt; [x for x in range(1, 11) if x % 2 == 0 else 0] File &quot;&lt;stdin&gt;&quot;, line 1 [x for x in range(1, 11) if x % 2 == 0 else 0] ^SyntaxError: invalid syntax# for 前 if 不加 else&gt;&gt;&gt; [x if x % 2 == 0 for x in range(1, 11)] File &quot;&lt;stdin&gt;&quot;, line 1 [x if x % 2 == 0 for x in range(1, 11)] ^SyntaxError: invalid syntax 总结 for...in... 最先，if 或 if else 随后，i-expression 最后 for 前 if 必加 else，for 后 if 不加 else for 前 if 是对 for的输出进行处理，for 后 if 是对for的输出进行控制过滤 生成器 Generator普通形式元组生成式 生成一个生成器对象，通过for或者next遍历,遍历后，原生成器对象就不存在了 ( i-expression for i in Iterations )( i-expression for i in Iterations if expression )( i-expression if expression else expression for i in Iterations ) 123(··· for ··· in ··· )(··· for ··· in ··· if ··· )(··· if ··· else ··· for ··· in ··· ) 生成器，是一种一边循环一边计算的机制比如现在需要一个1到100W的平方的列表，用列表生成式表示为[ x * x for x in range(1000000)]但如果只需要经常访问前面几个元素，则浪费了很大的空间而生成器是保存了一种算法，它不会直接创建100W个数，而是等到调用的时候通过计算获得也就是说：列表生成式是一种缩写，生成器是一种算法 生成器 vs 列表生成式：列表生成式 是使用 []，生成器 是使用 ()列表生成式是一个列表，可以直接列出所有元素；生成器要用next()或遍历来列出所有元素 12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; L = [ x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; G = ( x * x for x in range(10) )&gt;&gt;&gt; G&lt;generator object &lt;genexpr&gt; at 0x00000204807D8D60&gt;&gt;&gt;&gt; next(G)0&gt;&gt;&gt; next(G)1&gt;&gt;&gt; next(G)4&gt;&gt;&gt; next(G)9&gt;&gt;&gt; next(G)16&gt;&gt;&gt; next(G)25&gt;&gt;&gt; next(G)36&gt;&gt;&gt; next(G)49&gt;&gt;&gt; next(G)64&gt;&gt;&gt; next(G)81&gt;&gt;&gt; next(G)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration 生成器是算法，是规律，是计算方式，通过next(G)计算出G的下一个元素的值，直到最后一个元素没有更多元素的时候，抛出StopIteration错误但是这种不断调用next()的方法显然不科学， 所以一般都是用for循环 123456G = ( x * x for x in range(10) )for i in G: print(i, end=&#x27; &#x27;)# Output:0 1 4 9 16 25 36 49 64 81 函数形式生成器的另一种实现方式是 函数形式 12345def funcName(): sth while True: yield sth sth 普通函数通过return语句返回生成器通过yield语句返回，并在下次调用时从yield语句处继续yield可以看成return，都是返回一个值出去只不过使用yield在下次调用时会从yield处继续。 实例例如打印杨辉三角 1234567891011 1 / \\ 1 1 / \\ / \\ 1 2 1 / \\ / \\ / \\ 1 3 3 1 / \\ / \\ / \\ / \\ 1 4 6 4 1 / \\ / \\ / \\ / \\ / \\1 5 10 10 5 1 期待输出是这样的 12345678910# [1]# [1, 1]# [1, 2, 1]# [1, 3, 3, 1]# [1, 4, 6, 4, 1]# [1, 5, 10, 10, 5, 1]# [1, 6, 15, 20, 15, 6, 1]# [1, 7, 21, 35, 35, 21, 7, 1]# [1, 8, 28, 56, 70, 56, 28, 8, 1]# [1, 9, 36, 84, 126, 126, 84, 36, 9, 1] 实现思路：先看杨辉三角的规律：头尾都是1，中间是上一层第n个+第n+1个，每一层都是list而且第一层比较特殊，是 [1]可以先把杨辉三角核心的算法搞定。 核心算法12L = [1]L = [1] + [L[n] + L[n+1] for n in range(len(L)-1)] +[1] [1] + [L[n] + L[n+1] for n in range(len(L)-1)] +[1] 就是核心算法了把他拆开来看，可以发现这个表达式是由中间段加上头尾的 [1] 组成的 再看中间段 [L[n] + L[n+1] for n in range(len(L)-1)]这是一个列表生成式range(len(L)-1)会生成 0 1 2 … 假设当前为第5层，准备生成 [1, 4, 6, 4, 1]当前的 L 是 [1, 3, 3, 1]，那么len(L)则是4，range(len(L) - 1)则等价于range(3),会生成 0 1 2 [L[n] + L[n+1] for n in range(len(L)-1)]则等价于[L[0]+L[1], L[1]+L[2], L[2]+L[3]] 则等价于[ 1 + 3, 3 + 3, 3 + 1 ]则等价于[4, 6, 4] 正好就是中间段再加上头尾两个 [1]： [1, 4, 6, 4, 1] 做成生成器因为第一层 特殊，所以用小括号列表生成式()做不出来，改用函数形式 12345def triangles(): L = [1] while True: yield L L = [1] + [L[x]+L[x+1] for x in range(len(L)-1)] + [1] 第一次迭代生成器triangles时，会执行 L = [1]，然后进入循环，遇到yield L把L返回出去 第二次迭代生成器triangles时，会从yield L处继续，然后执行核心算法 L = [1] + [L[x]+L[x+1] for x in range(len(L)-1)] + [1]之后继续循环，又遇到yield L，把更新过的 L 返回出去 接着第三次，第四次… 其实有点类似 C 语言中被static修饰的局部变量，函数调用完不会被销毁，程序结束才销毁 遍历输出12345for n, t in enumerate(triangles()): results.append(t) n += 1 if n == 10: break 生成器也是一个可迭代对象，所以可以用 for...in...来迭代输出enumerate()赋予了对应的下标这个生成器可以无限循环下去，可以获得无穷层，这里打印10层作为示范即可 最后可以得到期待输出： 12345678910[1][1, 1][1, 2, 1][1, 3, 3, 1][1, 4, 6, 4, 1][1, 5, 10, 10, 5, 1][1, 6, 15, 20, 15, 6, 1][1, 7, 21, 35, 35, 21, 7, 1][1, 8, 28, 56, 70, 56, 28, 8, 1][1, 9, 36, 84, 126, 126, 84, 36, 9, 1] 完整代码1234567891011121314151617181920212223242526272829303132def triangles(): L = [1] while True: yield L L = [1] + [L[x]+L[x+1] for x in range(len(L)-1)] + [1]results = []for n, t in enumerate(triangles()): results.append(t) n += 1 if n == 10: breakfor t in results: print(t)if results == [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1], [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]]: print(&#x27;测试通过!&#x27;)else: print(&#x27;测试失败!&#x27;) 总结普通形式-生成器：把列表生成式的[]换成()函数形式-生成器：函数中带yield，下一次调用时会从yield处继续 迭代器 Iterator 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。 可迭代对象：可以直接作用于 for 循环的对象统称为可迭代对象Iterable可迭代对象Iterable： List、Tuple、Dict、Set、String； 生成器Generator、带yield的Generator Function 可以用isinstance(obj, Iterable)判断是否是可迭代对象 迭代器：不但可以作用于 for 循环，还可以被next()函数调用并不断返回下一个值则称为迭代器：Iterator。生成器Generator、带yield的Generator Function就是迭代器可以用isinstance(obj, Iterator)判断是否是迭代器 所以：Generator、Generator Function 既是 Iterator，也是 Iterable而 List、Tuple、Dict、Set、String 仅仅只是 Iterable，但是，使用iter()函数可以使他们变成迭代器Iterator 1234&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter(&#x27;Boii&#x27;), Iterator)True 迭代器的本质Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算 自定义可迭代类只要类中实现了__iter__()方法，这个类的对象就是可迭代对象Iterable。只要类中实现了__iter__()和__next__()方法，这个类就是个迭代器Iteratorn。 __iter__()方法必须返回一个迭代器。那么代码就是这样子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 1. 创建一个类class Classmate: def __init__(self): self.names = list() def add(self, value): self.names.append(value) # 2. 实现__iter__方法，返回一个迭代器 def __iter__(self): &quot;&quot;&quot;只有实现了__iter__方法，才能可迭代&quot;&quot;&quot; return ClassmateIterator(self) # __iter__ 必须返回一个迭代器对象# 3. 创建一个迭代器class ClassmateIterator: &quot;&quot;&quot;实现了__iter__和__next__方法，才是一个迭代器&quot;&quot;&quot; def __init__(self, obj): self.obj = obj self.current_num = 0 # 4. 迭代器需要实现 __iter__, __next__方法 def __iter__(self): pass def __next__(self): &quot;&quot;&quot;实现了__iter__和__next__方法，才是一个迭代器&quot;&quot;&quot; if self.current_num &lt; len(self.obj.names): res = self.obj.names[self.current_num] self.current_num += 1 return res else: raise StopIterationif __name__ == &#x27;__main__&#x27;: clsm = Classmate() clsm.add(123) clsm.add(456) clsm.add(789) # 通过循环检查classmate对象是否可迭代 for i in clsm: print(i)--------------------------------------------------# Output:123456789 总结起来就是：创建一个类并实现__iter__()方法去返回一个迭代器创建一个类并实现__iter__()和__next__()方法，使其成为迭代器。 这样看起来好像为了实现一个迭代器又生成了一个迭代器既然我是想造一个迭代器，__iter__()方法有需要返回一个迭代器对象，那我返回自己不行吗？ 可以！ 1234567891011121314151617181920212223242526272829303132333435363738394041# 1. 创建一个类class Classmate: def __init__(self): self.names = list() self.current_num = 0 def add(self, value): self.names.append(value) # 2. 实现__iter__方法，返回一个迭代器 def __iter__(self): &quot;&quot;&quot;只有实现了__iter__方法，才能可迭代&quot;&quot;&quot; return self # __iter__ 必须返回一个迭代器对象，这里就返回自己就行 # 3. 实现__next__方法，这个方法会在外部使用next(Iterator)时调用。 def __next__(self): &quot;&quot;&quot;实现了__iter__和__next__方法，才是一个迭代器&quot;&quot;&quot; if self.current_num &lt; len(self.names): res = self.names[self.current_num] self.current_num += 1 return res else: raise StopIterationif __name__ == &#x27;__main__&#x27;: clsm = Classmate() clsm.add(123) clsm.add(456) clsm.add(789) # 通过循环检查classmate对象是否可迭代 for i in clsm: print(i)--------------------------------------------------# Output:123456789 总结 可迭代对象和迭代器，通过函数iter()转换 迭代器：数据流，变长，惰性的 继承关系：Iterable&gt;Iterator&gt;Generator(参考python doc) Iterable：list、tuple、dict、set、str、Iterator、Generator等 Iterator转化成Iterator：Iterator=iter(Iterable) 自定义迭代类时必须实现__iter__()和__next__()方法 __iter__()方法必须返回一个迭代器","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"高级特性","slug":"Python/高级特性","permalink":"https://www.boii.xyz/categories/Python/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-20】操作文件和目录","slug":"Python/Basic/Python【No-20】操作文件和目录","date":"2020-07-21T08:41:48.000Z","updated":"2021-07-19T10:05:08.444Z","comments":true,"path":"posts/9832.html","link":"","permalink":"https://www.boii.xyz/posts/9832.html","excerpt":"文件正常操作","text":"文件正常操作 Python的自带模块 os 可以进行许多与操作系统相关的操作。 例如查看当前系统类型 123&gt;&gt;&gt; import os&gt;&gt;&gt; os.name&#x27;nt&#x27; nt表示windows，posix表示Linux/Unix/Mac OS X 在Linux/Unix/Max OS X上想获得更详细的信息，可以使用uname()，不过在windows上不提供 123&gt;&gt;&gt; import os&gt;&gt;&gt; os.uname()posix.uname_result(sysname=&#x27;Darwin&#x27;, nodename=&#x27;MichaelMacPro.local&#x27;, release=&#x27;14.3.0&#x27;, version=&#x27;Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64&#x27;, machine=&#x27;x86_64&#x27;) 再例如查看环境变量，os.environ 123&gt;&gt;&gt; import os&gt;&gt;&gt; os.environenviron(&#123;&#x27;ALLUSERSPROFILE&#x27;: &#x27;C:\\\\ProgramData&#x27;, &#x27;APPDATA&#x27;: &#x27;C:\\\\Users\\\\pr919\\\\AppData\\\\Roaming&#x27;, &#x27;ASL.LOG&#x27;: &#x27;Destination=file&#x27;, &#x27;CATALINA_HOME&#x27;: &#x27;D:\\\\---Programming---\\\\IntelliJ IDEA\\\\apache-tomcat-8.5.42&#x27;, ..., &#x27;WT_SESSION&#x27;: &#x27;245de0da-1ef4-4cda-93ca-c132289e2c9c&#x27;&#125;) 这样就列出了所有环境变量了 如果要获得某一条，可以用os.environ.get(&#39;key&#39;) 123&gt;&gt;&gt; import os&gt;&gt;&gt; os.environ.get(&#x27;JAVA_HOME&#x27;)&#x27;C:\\\\Program Files\\\\Java\\\\jdk1.8.0_201&#x27; 获得当前目录 getcwd os.getcwd() 123&gt;&gt;&gt; import os&gt;&gt;&gt; os.getcwd()&#x27;C:\\\\Users\\\\pr919&#x27; 列出目录 listdir、walk os.listdir(path)，单层列出；path可以是绝对路径或相对路径，不填默认当前目录os.walk(path)，遍历列出； listdir() 列出path下一层的目录和文件，不包括子目录 12345678910111213141516171819202122232425&gt;&gt;&gt; import os&gt;&gt;&gt; os.listdir()&gt;&gt;&gt; os.listdir(r&#x27;D:\\---Programming---\\Python\\Python&#x27;)[&#x27;DLLs&#x27;, &#x27;Doc&#x27;, &#x27;include&#x27;, &#x27;Lib&#x27;, &#x27;libs&#x27;, &#x27;LICENSE.txt&#x27;, &#x27;NEWS.txt&#x27;, &#x27;python-3.8.3-amd64.exe&#x27;, &#x27;python.exe&#x27;, &#x27;python3.dll&#x27;, &#x27;python38.dll&#x27;, &#x27;pythonw.exe&#x27;, &#x27;Scripts&#x27;, &#x27;tcl&#x27;, &#x27;Tools&#x27;, &#x27;vcruntime140.dll&#x27;, &#x27;vcruntime140_1.dll&#x27;]&gt;&gt;&gt; for i in os.listdir(r&#x27;D:\\---Programming---\\Python\\Python&#x27;):... print(i)...DLLsDocincludeLiblibsLICENSE.txtNEWS.txtpython-3.8.3-amd64.exepython.exepython3.dllpython38.dllpythonw.exeScriptstclToolsvcruntime140.dllvcruntime140_1.dll walk() 列出path下的目录和文件，包括子目录 1234567891011121314151617181920212223242526272829303132import oscwd = os.getcwd()for i in os.walk(cwd): print(i, end=&#x27;\\n\\n&#x27;)--------------------------------------------------# Output:(&#x27;D:\\\\Project&#x27;, [&#x27;weather&#x27;, &#x27;__pycache__&#x27;], [&#x27;app.config&#x27;, &#x27;io.txt&#x27;, &#x27;mo.py&#x27;, &#x27;mo2.py&#x27;, &#x27;my.log&#x27;, &#x27;test.py&#x27;])(&#x27;D:\\\\Project\\\\weather&#x27;, [&#x27;.idea&#x27;, &#x27;__pycache__&#x27;], [&#x27;city_code.csv&#x27;, &#x27;city_code.txt&#x27;, &#x27;query.py&#x27;, &#x27;Ui_weather.py&#x27;, &#x27;weather.py&#x27;, &#x27;weather.ui&#x27;])(&#x27;D:\\\\Project\\\\weather\\\\.idea&#x27;, [&#x27;inspectionProfiles&#x27;], [&#x27;misc.xml&#x27;, &#x27;modules.xml&#x27;, &#x27;weather.iml&#x27;, &#x27;workspace.xml&#x27;])(&#x27;D:\\\\Project\\\\weather\\\\.idea\\\\inspectionProfiles&#x27;, [], [&#x27;Project_Default.xml&#x27;])(&#x27;D:\\\\Project\\\\weather\\\\__pycache__&#x27;, [], [&#x27;query.cpython-37.pyc&#x27;, &#x27;Ui_weather.cpython-37.pyc&#x27;])(&#x27;D:\\\\Project\\\\__pycache__&#x27;, [], [&#x27;mo.cpython-38.pyc&#x27;, &#x27;Person.cpython-38.pyc&#x27;]) os.walk(path)返回的是一个生成器 generator每次返回一个元组，元组中共有三个元素：(root, dirs, files) 第一个root是一个string，表示当前层的路径 第二个dirs是一个list，表示当前层拥有的目录 第三个files是一个list，表示当前层拥有的文件 创建目录 mkdir、makedirs os.mkdir(path)，创建单层目录；path可以是相对路径或绝对路径如果目录已存在，会抛出FileExistsError错误。 1234# 标准创建目录流程dirpath = &#x27;iodir&#x27;if not os.path.exists(dirpath): os.mkdir(dirpath) os.makedirs(dir/subdir)，创建多层目录；如果目录已存在，会抛出FileExistsError错误。 1234# 创建多层目录dirpath = &#x27;iodir/subiodir&#x27;if not os.path.exists(dirpath): os.makedirs(dirpath) 删除目录 rmdir、shutil.rmtree os.rmdir(path)，删除空目录；path可以说相对路径或绝对路径如果目录不存在，会抛出FileNotFoundError错误。如果目录不为空，会抛出OSError错误。 12345678910111213141516# 标准删除目录流程import osdirpath = &#x27;iodir&#x27;if os.path.exists(dirpath): os.rmdir(dirpath)--------------------------------------------------# Output:没任何输出，删除目录成功目录下不为空，输出：Traceback (most recent call last): ...OSError: [WinError 145] 目录不是空的。: &#x27;iodir&#x27; shutil,rmtree(path)，删除非空目录；如果目录不存在，会抛出FileNotFoundError错误。 iodir下有一个io.txt文件，执行shuitl.rmtree()如下 123456789101112131415import os, shuitldirpath = &#x27;iodir&#x27;if os.path.exists(dirpath): shuitl.rmtree(dirpath)--------------------------------------------------# Output:没任何输出，删除目录成功目录不存在，输出：Traceback (most recent call last): ...FileNotFoundError: [WinError 3] 系统找不到指定的路径。: &#x27;iodir&#x27; 删除文件 os.remove(filename)；删除单个文件 12345import osfilename = &#x27;io.txt&#x27;if os.path.exists(filename): os.remove(filename) 路径拼接 join os.path.join()不用的操作系统路径分隔符是不同的例如在windows下是\\，在Linux/Unix/Mac OS X下是/所以保险起见，在拼接路径的时候用os提供的os.path.join()函数。这样在不同操作系统中运行代码的时候都可以得到正确的路径拼接。 123456789101112import osdir = os.path.join(&#x27;gpdir&#x27;, &#x27;padir&#x27;, &#x27;subdir&#x27;)print(dir)--------------------------------------------------# Output in windows:gpdir\\padir\\subdir# Output in Linux/Unixgpdir/padir/subdir 路径拆分 split os.path.split()返回值是一个双元素元组，第一个元素是路径的前部分，第二个元素是最后级别的目录或文件名 12345&gt;&gt;&gt; os.path.split(&#x27;gpdir\\padir\\subdir&#x27;)(&#x27;gpdir\\\\padir&#x27;, &#x27;subdir&#x27;)&gt;&gt;&gt; os.path.split(&#x27;gpdir/padir/subdir&#x27;)(&#x27;gpdir/padir&#x27;, &#x27;subdir&#x27;) 获取文件扩展名 splitext os.path.splitext()返回值是一个双元素元组，第一个元素是路径前部分，第二个元素是最后级别文件的扩展名 1234567891011&gt;&gt;&gt; os.path.splitext(&#x27;gpdir/padir/subdir/io.txt&#x27;)(&#x27;gpdir/padir/subdir/io&#x27;, &#x27;.txt&#x27;)&gt;&gt;&gt; os.path.splitext(&#x27;gpdir/padir/subdir&#x27;)(&#x27;gpdir/padir/subdir&#x27;, &#x27;&#x27;)&gt;&gt;&gt; os.path.splitext(&#x27;gpdir\\padir\\subdir\\io.txt&#x27;)(&#x27;gpdir\\\\padir\\\\subdir\\\\io&#x27;, &#x27;.txt&#x27;)&gt;&gt;&gt; os.path.splitext(&#x27;gpdir\\padir\\subdir&#x27;)(&#x27;gpdir\\\\padir\\\\subdir&#x27;, &#x27;&#x27;) 文件、目录重命名 os.rename(oldName, newName)可以对文件或目录进行重命名 123&gt;&gt;&gt; .rename(&#x27;testdir&#x27;, &#x27;newtestdir&#x27;)&gt;&gt;&gt; os.rename(&#x27;test.txt&#x27;, &#x27;iotest.py&#x27;) 判断是目录还是文件 os.path.isdir(path)os.path.isfile(path) 示例列出当前目录下所有目录 12&gt;&gt;&gt; [x for x in os.listdir() if os.path.isdir(x)][&#x27;.lein&#x27;, &#x27;.local&#x27;, &#x27;.m2&#x27;, &#x27;.npm&#x27;, &#x27;.ssh&#x27;, &#x27;.vim&#x27;, &#x27;Applications&#x27;, &#x27;Desktop&#x27;, ...] 列出当前目录下所有.py文件 12&gt;&gt;&gt; [x for x in os.listdir() if os.path.isfile(x) and os.path.splitext(x)[1] == &#x27;.py&#x27;][&#x27;apis.py&#x27;, &#x27;config.py&#x27;, &#x27;models.py&#x27;, &#x27;test_db.py&#x27;, &#x27;urls.py&#x27;, &#x27;wsgiapp.py&#x27;]","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"IO","slug":"Python/进阶/IO","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/IO/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-19】文件读写","slug":"Python/Basic/Python【No-19】文件读写","date":"2020-07-20T07:41:48.000Z","updated":"2021-07-19T10:05:08.306Z","comments":true,"path":"posts/3887.html","link":"","permalink":"https://www.boii.xyz/posts/3887.html","excerpt":"文件基本操作","text":"文件基本操作 同步和异步的区别就在于是否等待IO执行的结果。好比你去麦当劳点餐，你说“来个汉堡”，服务员告诉你，对不起，汉堡要现做，需要等5分钟，于是你站在收银台前面等了5分钟，拿到汉堡再去逛商场，这是同步IO。 你说“来个汉堡”，服务员告诉你，汉堡需要等5分钟，你可以先去逛商场，等做好了，我们再通知你，这样你可以立刻去干别的事情（逛商场），这是异步IO。 很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。 文件读写其实都是由操作系统完成的，现代操作系统是不允许普通程序直接操作磁盘的，所以读写文件就是请求操作系统打开一个文件对象（又称：文件描述符），通过操作系统提供的接口从这个文件对象中读取数据或写入数据 同步IO12&gt;&gt;&gt; with open(file_path, &#x27;r/w/a&#x27;) as alias:··· do sth r ：读w ：覆盖写a+：追加写 读 read读取的过程：1. 打开文件；2. 读取文件；3. 关闭文件 第一步：f = open(&#39;/user/boii/io_note.txt&#39;, &#39;r&#39;) 用python内置的open()函数打开一个文件对象， 第一个参数传入读的文件的路径，第二个参数传入r为读取的意思 如果打开成功，open()会返回一个文件对象； 如果打开失败，open()会抛出一个IOError错误。 第二步：f.read() 通过read()方法，可以将全部内容读取出来。 第三步：f.close() 文件打开成功后，必须使用close()方法关闭文件。 因为文件对象会占用操作系统资源，且操作系统同一时间能打开的文件数量也有限。 文件打开失败后，会产生IOError，则不会调用f.close() 综合起来可以这么写： 12345678910111213try: f = open(&#x27;/user/boii/io_note.txt&#x27;, &#x27;r&#x27;) # 打开文件 print(f.read()) # 读取文件except IOError as e: print(e)else: f.close() # 关闭文件--------------------------------------------------# Output:# 如果文件打开成功，会输出（文件全部内容）：io# 如果文件打开失败，会输出：[Errno 2] No such file or directory: &#x27;/user/boii/io_note.txt&#x27; 但是这样太繁琐，一点也不符合Python优雅的气质。所以 Python 引入了with语句来自动帮我们调用close()方法 12with open(&#x27;/user/boii/io_note.txt&#x27;, &#x27;r&#x27;) as f: print(f.read()) 指定字节 read(size) file_obj.read(size) read()方法不填写参数，直接读取文件全部内容。如果一个文件太大，全部读取会爆内存的。所以可以通过指定 size 的方式指定读取 size 个字节的内容。 12345678910111213141516# io.txtHello Python!I am Boii.I am learning.--------------------------------------------------# io_read.pywith open(&#x27;io.txt&#x27;, &#x27;r&#x27;) as f: data = f.read(8) # 读取前8个字节 print(data)--------------------------------------------------# Output:Hello Py 跳过字节 seek(size) file_obj.seek(size) 通过 seek()可以在读取之前跳过 size 个字节，再开始读取 1234567891011121314151617# io.txtHello Python!I am Boii.I am learning.--------------------------------------------------# io_read.pywith open(&#x27;io.txt&#x27;, &#x27;r&#x27;) as f: f.seek(3) data = f.read(8) # 读取前8个字节 print(data)--------------------------------------------------# Output:lo Pytho 读取一行 readline() file_obj.readline() readline()方法会读取文件的一行，遇到\\n就认为是一行 1234567891011121314151617# io.txtHello Python!I am Boii.I am learning.--------------------------------------------------# io_read.pywith open(&#x27;io.txt&#x27;, &#x27;r&#x27;) as f: data = f.readline() # 读取第一行 print(data)--------------------------------------------------# Output:Hello Python! 这样只能读取一行，可以使用 while 循环一行一行的读取 1234567891011121314151617181920# io.txtHello Python!I am Boii.I am learning.--------------------------------------------------# io_read.pywith open(&#x27;io.txt&#x27;, &#x27;r&#x27;) as f: data = f.readline() # 读取第一行 while data: print(data, end=&#x27;&#x27;) data = f.readline() # 接着读下一行--------------------------------------------------# Output:Hello Python!I am Boii.I am learning. 读取多行 readlines() file_obj.readlines() readlines()方法会一次性读取文件中多行内容，最后返回一个 list，一个元素一行内容。 12345678910111213141516171819# io.txtHello Python!I am Boii.I am learning.--------------------------------------------------# io_read.pywith open(&#x27;io.txt&#x27;, &#x27;r&#x27;) as f: datas = f.readlines() # 读取多行 for line in datas: print(line, end=&#x27;&#x27;)--------------------------------------------------# Output:Hello Python!I am Boii.I am learning. 效果是一样的。 写 write写入的过程：1. 打开文件；2. 写入文件；3. 关闭文件 写入同样可以使用with语句，with语句自动会关闭文件读文件的时候如果文件不存在，会抛出 IOError 错误写文件的时候如果文件不存在，会创建文件 写入有两种，一种是覆盖原有内容写入新内容；一种是在原有内容基础上追加新内容。覆盖写在open()函数中要传入 w，追加写在open()函数中要传入a 写入单行 wirte()12345678910111213# io_write.pycontend = &#x27;&#x27;&#x27;I am the contend which be writed down into file.Hello Python!&#x27;&#x27;&#x27;with open(&#x27;io.txt&#x27;, &#x27;w&#x27;) as f: f.write(contend) # 写入文件--------------------------------------------------# io.txtI am the contend which be writed down into file.Hello Python! 写入多行 writelines() file_obj.writelines(str) 当有多行要写入的时候，除了上面用 &#39;&#39;&#39;的多行字符串，可以用 writelines(list)来将内容一次写入。第一个参数接受的是一个 list 列表 或 string 字符串 12345678910# io_write.pydatas = [&#x27;Hello Python!&#x27;, &#x27;I am Boii&#x27;, &#x27;I like coding&#x27;]with open(&#x27;io.txt&#x27;, &#x27;w&#x27;) as f: f.writelines(datas) # 写入文件--------------------------------------------------# io.txtHello Python!I am BoiiI like coding 跟预设结果不一样，并没有换行符。可以直接给datas的每个元素加上\\n但是这种办法很费力，且很多时候内容不是你决定的，这时候 列表生成式 就排上用场了。 12345678910111213# io_write.pydatas = [&#x27;Hello Python!&#x27;, &#x27;I am Boii&#x27;, &#x27;I like coding&#x27;]with open(&#x27;io.txt&#x27;, &#x27;w&#x27;) as f: new_datas = [line + &#x27;\\n&#x27; for line in datas] f.writelines(new_datas) # 写入文件--------------------------------------------------# io.txtHello Python!I am BoiiI like coding 追加写1234567891011121314151617# io_write.pycontend = &#x27;&#x27;&#x27;I am the contend which be writed down into file.Hello Python!&#x27;&#x27;&#x27;with open(&#x27;io.txt&#x27;, &#x27;a&#x27;) as f: f.write(contend) # 写入文件--------------------------------------------------# io.txt 第一次执行I am the contend which be writed down into file.Hello Python!# io.txt 第二次执行I am the contend which be writed down into file.Hello Python!I am the contend which be writed down into file.Hello Python! 打开模式打开模式有很多，大致分为： 字符 意义 r 读取（默认） w 覆盖写 a 追加写 x 排他性创建，如果文件已存在则失败 b 二进制模式 t 文本模式（默认） + 可读可写 表中的字符组合起来就有丰富的打开方式r只读，r+可读可写，rb只读一个二进制文件（图片音视频等）w只覆盖写，w+可读可覆盖写，wb只覆盖写一个二进制文件a只追加写，a+可读可追加写，以此类推 字符编码要读取非UTF-8编码的文件，需要给open()函数传入encoding参数 例如打开一个GBK编码的文件 123&gt;&gt;&gt; with open(&#x27;io.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;gbk&#x27;) as f:··· print(f.read())Hello Python! 但有时候打开的文件编码不规范，混杂了多种编码的字符，而打开时只能按一种编码打开，所以势必会造成乱码。这种乱码的处理可以用 errors参数。 open(filepath, mode, encoding=&#39;value&#39;, errors=&#39;value&#39;)errors参数的值有 ignore：直接忽略 strict：引发ValueError异常。与默认值None效果相同 replace_sign：会将错误的地方替换为指定的replace_sign符号 其他","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"IO","slug":"Python/进阶/IO","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/IO/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-18】协程","slug":"Python/Basic/Python【No-18】协程","date":"2020-07-19T06:41:48.000Z","updated":"2021-07-19T10:05:08.174Z","comments":true,"path":"posts/37243.html","link":"","permalink":"https://www.boii.xyz/posts/37243.html","excerpt":"协程，时间管理大师","text":"协程，时间管理大师 线程是系统级别的，由操作系统调度协程是程序级别的，由程序根据需要自己调度 协程可以想象成线程里的线程，也就是将一个线程里多个任务分拆给多个协程。 使用线程的时候是：线程执行遇到耗时（阻塞）的地方，再开一个线程，去执行这个耗时的任务，原本的线程继续执行。就好比我在算题，算着算着计算量比较大比较耗时，我就叫了小明帮我算，我继续算下面的。 使用协程的时候是：利用别的协程执行耗时操作时的那点时间切换去别的协程继续执行，也就是在协程之间反复横跳。就好比我在算题，算着算着计算量有点大，就先做别的题，回头自己再继续把题算完 协程的优点： 无需线程上下文切换的开销，因为都在同一个线程里，避免了无意义的调度，由此可以提高性能。 无需原子操作锁定及同步的开销 方便切换控制流，简化编程模型 高并发+高扩展性+低成本：一个CPU支持上万个协程都不是问题。所以很适合高并发处理。 缺点： 因为协程都是程序调度的，所以需要程序员承担调度的责任，同时也失去了标准线程使用多CPU的能力 无法利用多核资源：协程的本质是个单线程，不能同时用上单个CPU的多个核。协程需要和进程配合才能运行在多CPU上，不过绝大部分应用都没有这个必要，除非是CPU密集型应用 进行阻塞操作（如IO）会阻塞掉整个程序。 使用 yield 实现并发123456789101112131415161718192021222324252627282930313233343536373839404142import time def task_1(): while True: print(&quot;&#123;:-^16s&#125;&quot;.format(&quot;task_1&quot;)) time.sleep(0.1) yielddef task_2(): while True: print(&quot;&#123;:-^16s&#125;&quot;.format(&quot;task_2&quot;)) time.sleep(0.1) yielddef main(): t1 = task_1() t2 = task_2() # 先让t1运行一会儿，当t1中遇到yield的时候，再返回到main()的while循环 # 然后执行t2，当它遇到yield的时候，再次切换到t1中 # 就这样t1/t2/t1/t2...交替运行，最终实现了多任务...协程 while True: next(t1) next(t2)if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:-----task_1----------task_2----------task_1----------task_2----------task_1----------task_2----------task_1----------task_2----------task_1----------task_2-----... 使用 greenlet 实现并发&gt;_: pip install greenlet 123456789101112131415161718192021222324252627282930313233343536from greenlet import greenletimport timedef task_1(): while True: print(&quot;&#123;:-^16s&#125;&quot;.format(&quot;task_1&quot;)) gr2.switch() # 切换到 gr2中，也就是 task_2() 中运行 time.sleep(0.5)def task_2(): while True: print(&quot;&#123;:-^16s&#125;&quot;.format(&quot;task_2&quot;)) gr1.switch() # 切换到 gr1中，也就是 task_1() 中运行 time.sleep(0.5)gr1 = greenlet(task_1)gr2 = greenlet(task_2)# 切换到 gr1中，也就是 task_1() 中运行gr1.switch--------------------------------------------------# Output:-----task_1----------task_2----------task_1----------task_2----------task_1----------task_2----------task_1----------task_2----------task_1----------task_2-----... 使用 gevent 实现并发 import geventgevent.spawn(funcName, args) 先看看没有阻塞操作的时候： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 没有阻塞import geventdef task_1(n): for i in range(n): print(gevent.getcurrent(), i)def task_2(n): for i in range(n): print(gevent.getcurrent(), i)def task_3(n): for i in range(n): print(gevent.getcurrent(), i)def main(): g1 = gevent.spawn(task_1, 5) g2 = gevent.spawn(task_2, 5) g3 = gevent.spawn(task_3, 5) g1.join() g2.join() g3.join()if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:&lt;Greenlet at 0x1f6eaf0cd00: task_1(5)&gt; 0&lt;Greenlet at 0x1f6eaf0cd00: task_1(5)&gt; 1&lt;Greenlet at 0x1f6eaf0cd00: task_1(5)&gt; 2&lt;Greenlet at 0x1f6eaf0cd00: task_1(5)&gt; 3&lt;Greenlet at 0x1f6eaf0cd00: task_1(5)&gt; 4&lt;Greenlet at 0x1f6eaf0ce10: task_2(5)&gt; 0&lt;Greenlet at 0x1f6eaf0ce10: task_2(5)&gt; 1&lt;Greenlet at 0x1f6eaf0ce10: task_2(5)&gt; 2&lt;Greenlet at 0x1f6eaf0ce10: task_2(5)&gt; 3&lt;Greenlet at 0x1f6eaf0ce10: task_2(5)&gt; 4&lt;Greenlet at 0x1f6eaf0cbf0: task_3(5)&gt; 0&lt;Greenlet at 0x1f6eaf0cbf0: task_3(5)&gt; 1&lt;Greenlet at 0x1f6eaf0cbf0: task_3(5)&gt; 2&lt;Greenlet at 0x1f6eaf0cbf0: task_3(5)&gt; 3&lt;Greenlet at 0x1f6eaf0cbf0: task_3(5)&gt; 4 gevent 是利用协程阻塞的时候去执行别的协程这里没有阻塞操作，所以并不会发生什么变化，跟普通函数调用一样，更提不上并发 现在来加点阻塞操作看看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 有阻塞import geventdef task_1(n): for i in range(n): print(gevent.getcurrent(), i) # time.sleep(0.1) # 在gevent中，time.sleep()这种阻塞操作是不起作用的 gevent.sleep(0.1)def task_2(n): for i in range(n): print(gevent.getcurrent(), i) gevent.sleep(0.1)def task_3(n): for i in range(n): print(gevent.getcurrent(), i) gevent.sleep(0.1)def main(): g1 = gevent.spawn(task_1, 5) g2 = gevent.spawn(task_2, 5) g3 = gevent.spawn(task_3, 5) g1.join() g2.join() g3.join()if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 0&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 0&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 0&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 1&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 1&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 1&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 2&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 2&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 2&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 3&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 3&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 3&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 4&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 4&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 4 上述代码 建立了三个 gevent 对象，里面分别转载了 task_1、task_2、task_3 三个执行函数。接着三个 gevent 对象都使用 join 方法运行了执行函数在三个执行函数中又用了 gevent.sleep() 模拟阻塞操作（在实际开发中并不会专门用sleep去阻塞，而是在执行到 IO 等耗时操作时，gevent自动切换。） 在执行 task_1 的时候，打印了第一句，然后遇到了 gevent.sleep() 的阻塞操作，切换到 task_2 ，打印了第二局，又遇到阻塞，又切换…一直到全部执行完毕 另外，task_1 中的 time.sleep() 在 gevent 管理的协程中是不起作用的，需要使用 gevent.sleep() 才行。 这就带来一个问题：如果我的代码是开发完了才加入了 gevent ，那岂不是要把很多地方手动改到 gevent 能接受。还好 gevent 提供了一个补丁 gevent 补丁 from gevent import monkeymonkey.patch_all()一定要写在最上方 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import timeimport geventfrom gevent import monkeymonkey.patch_all() # 打补丁def task_1(n): for i in range(n): print(gevent.getcurrent(), i) time.sleep(0.1)def task_2(n): for i in range(n): print(gevent.getcurrent(), i) time.sleep(0.1)def task_3(n): for i in range(n): print(gevent.getcurrent(), i) time.sleep(0.1)def main(): g1 = gevent.spawn(task_1, 5) g2 = gevent.spawn(task_2, 5) g3 = gevent.spawn(task_3, 5) g1.join() g2.join() g3.join()if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 0&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 0&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 0&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 1&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 1&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 1&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 2&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 2&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 2&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 3&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 3&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 3&lt;Greenlet at 0x1433a62b370: task_1(5)&gt; 4&lt;Greenlet at 0x1433a62b590: task_2(5)&gt; 4&lt;Greenlet at 0x1433a62b480: task_3(5)&gt; 4 joinall有没有发现 g1.join()g2.join()g3.join() 写了三个join不如给他来个一次性 gevent.joinall(spawn_list, timeout=None, raise_error=False, count=None) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import timeimport geventfrom gevent import monkeymonkey.patch_all()def task_1(n): for i in range(n): print(gevent.getcurrent(), i) time.sleep(0.1)def task_2(n): for i in range(n): print(gevent.getcurrent(), i) time.sleep(0.1)def task_3(n): for i in range(n): print(gevent.getcurrent(), i) time.sleep(0.1)def main(): # joinall 接受一个 spawn 列表 gevent.joinall([ gevent.spawn(task_1, 5), gevent.spawn(task_2, 5), gevent.spawn(task_3, 5) ]， timeout=5)if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:&lt;Greenlet at 0x12e8cba9d00: task_1(5)&gt; 0&lt;Greenlet at 0x12e8cba9e10: task_2(5)&gt; 0&lt;Greenlet at 0x12e8cba9bf0: task_3(5)&gt; 0&lt;Greenlet at 0x12e8cba9d00: task_1(5)&gt; 1&lt;Greenlet at 0x12e8cba9e10: task_2(5)&gt; 1&lt;Greenlet at 0x12e8cba9bf0: task_3(5)&gt; 1&lt;Greenlet at 0x12e8cba9d00: task_1(5)&gt; 2&lt;Greenlet at 0x12e8cba9e10: task_2(5)&gt; 2&lt;Greenlet at 0x12e8cba9bf0: task_3(5)&gt; 2&lt;Greenlet at 0x12e8cba9d00: task_1(5)&gt; 3&lt;Greenlet at 0x12e8cba9e10: task_2(5)&gt; 3&lt;Greenlet at 0x12e8cba9bf0: task_3(5)&gt; 3&lt;Greenlet at 0x12e8cba9d00: task_1(5)&gt; 4&lt;Greenlet at 0x12e8cba9e10: task_2(5)&gt; 4&lt;Greenlet at 0x12e8cba9bf0: task_3(5)&gt; 4 只管在 joinall 里创建 spawn 对象就行，其他不用管，gevent 自己会处理好的这也是最常用的方法","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"进程、线程","slug":"Python/进阶/进程、线程","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-17】线程","slug":"Python/Basic/Python【No-17】线程","date":"2020-07-18T05:41:48.000Z","updated":"2021-07-19T10:05:08.082Z","comments":true,"path":"posts/34736.html","link":"","permalink":"https://www.boii.xyz/posts/34736.html","excerpt":"线程，是操作系统调度的单位","text":"线程，是操作系统调度的单位 一个程序写完了，放在硬盘里不运行，叫做程序一个程序写完了，放到内存里跑起来，叫做进程一个进程中至少有一个线程，称为主线程一个线程要干很多事情，有些事情很耗时，就创建个子线程，让子线程去做，主线程继续下一步 当有多个线程的时候，CPU会轮流切换执行，每个线程执行多长时间叫做时间片比如 t1 分到了0.001秒的时间片，t2 分到了0.002秒的时间片显然这么短时间是不够执行的，所以CPU会快速的切来切去，这样就看起来好像能执行多任务多任务就是你可以同时听歌、写文档、挂QQ等等，但其实同一时刻CPU只执行一个线程只不过切换的快，时间片也很小，所以人感觉不出来。 线程的执行顺序是由操作系统决定的，开发者左右不了。 子线程由主线程创建，子线程关闭后留下的辣鸡由主线程清理一旦主线程挂了，子线程全部挂掉。主线程会等待所有子线程结束后才结束 单线程操作 123456789101112131415161718192021222324252627282930313233343536import timedef say_hi(): for i in range(5): print(&#x27;Hi!&#x27;) time.sleep(1) # 耗时操作def say_yes(): for i in range(5): print(&#x27;Yes!&#x27;) time.sleep(1) # 耗时操作def main(): say_hi() say_yes()if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:Hi!Hi!Hi!Hi!Hi!Yes!Yes!Yes!Yes!Yes! 多线程操作 123456789101112131415161718192021222324252627282930313233343536373839import timeimport threading # 导入 threading 模块def say_hi(): for i in range(5): print(&#x27;Hi!&#x27;) time.sleep(1) # 耗时操作def say_yes(): for i in range(5): print(&#x27;Yes!&#x27;) time.sleep(1) # 耗时操作def main(): t1 = threading.Thread(target=say_hi) # 创建一个线程对象 t2 = threading.Thread(target=say_yes) # 创建一个线程对象 t1.start() # 启动线程 t2.start() # 启动线程if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:Hi!Yes!Hi!Yes!Hi!Yes!Yes!Hi!Hi!Yes! 单线程和多线程的区别就像这个栗子 你要来一段热舞rap， 单线程的操作是：rap完再热舞，或者热舞完再rap 多线程的操作是：边热舞边rap 创建子线程并启动创建线程操作可以分为三步： 导入 threading 模块 创建一个Thread对象 通过Thread对象启动线程 创建一个Thread对象的时候可以传入参数threading.Thread(group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, *, daemon=None) group 应该为 None；为了日后扩展 ThreadGroup 类实现而保留。 target：线程中需要执行的函数。默认是 None，表示不需要调用任何方法。 name：线程名称。默认情况下，由 “Thread-N” 格式构成一个唯一的名称，其中 N 是小的十进制数。 args：用于调用目标函数的参数元组。默认是 ()。（必须是可迭代对象） kwargs：用于调用目标函数的关键字参数字典。默认是 {}。（必须是可迭代对象） daemon不是None，线程将被显式的设置为守护模式，不管该线程是否是守护模式。 daemon=None，线程将继承当前线程的守护模式属性。 如果子类重载了构造函数，必须先调用父类构造器Thread.__init__()，再做其他事情。 函数方式函数方式适合于 —— 一个线程中要做的事情比较少，一个函数就能搞定。 导入 threading 模块 创建一个Thread对象并把函数传进去 通过Thread对象启动线程 123456789import threading # 1. 导入 thrading 模块def funcName(): # 需要子线程执行的函数 passt1 = threading.Thread(target=funcName) # 2. 创建一个Thread对象并把函数传进去t1.start() # 3. 启动线程 继承方式继承方式适合于 —— 一个线程里面做的事情比较复杂，需要分成多个函数来做。 导入 threading 模块 创建一个类继承 Thread 类 重写 run 方法 创建一个继承了 Thread 类的对象 用start方法启动线程 12345678910import threading # 1. 导入 threading 模块class clsName(threading.Thread): # 2. 继承Thread类 def run(self): # 3. 重写run方法 print(self.name) # self.name 保存的是当前线程的名称t1 = clsName() # 4. 创建一个继承了 Thread 类的对象t1.start() # 5. 启动线程 t1.start()只会去调用run方法。如果类中还有其他方法，只能在类中调用，不能用 t1去调用。也就是说，继承了 Thread 的类的之类，除了run方法，其他方法都可以定义成私有的（公有的外面也不能调用啊） 12345678910111213141516171819202122232425import threadingclass MyThread(threading.Thread): def run(self): print(self.name) self.__say_hi() self.__say_yes() def __say_hi(self): print(&#x27;Hi!&#x27;) def __say_yes(self): print(&#x27;Yes!&#x27;)t1 = MyThread()t1.start()--------------------------------------------------# Output:Thread-1Hi!Yes! 插队 join() join([timeout])当某个线程对象成功调用了 join() 方法之后，会优先获得CPU的资源，让其他线程等待知道这个线程对象执行结束后，才把资源让给别的线程 1234567891011121314151617181920212223242526272829303132333435363738394041424344import threadingdef f1(n): for i in range(n): print(threading.current_thread().getName())def f2(n): for i in range(n): print(threading.current_thread().getName() + &quot;------&quot; + str(i))def main(): t1 = threading.Thread(target=f1, args=(5,)) t2 = threading.Thread(target=f2, args=(5,)) t1.start() t2.start() for i in range(5): print(threading.current_thread().getName())if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:Thread-1Thread-1MainThreadThread-2------0MainThreadThread-2------1MainThreadThread-2------2MainThreadMainThreadThread-2------3Thread-2------4Thread-1Thread-1Thread-1 可以看到，没有加 join 方法，所以主线程 和 t1 和 t2 相互争抢资源。如果现在需要 t1 这个线程执行完再给其他线程执行，也就是说要求 t1 独占一段时间那就让 t1 调用 join() 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445import threadingdef f1(n): for i in range(n): print(threading.current_thread().getName())def f2(n): for i in range(n): print(threading.current_thread().getName() + &quot;------&quot; + str(i))def main(): t1 = threading.Thread(target=f1, args=(5,)) t2 = threading.Thread(target=f2, args=(5,)) t1.start() t1.join() t2.start() for i in range(5): print(threading.current_thread().getName())if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:Thread-1Thread-1Thread-1Thread-1Thread-1Thread-2------0Thread-2------1MainThreadThread-2------2MainThreadThread-2------3MainThreadThread-2------4MainThreadMainThread 这样就实现了 t1 独占资源，完成后才给其他线程 查看所有线程 threading.enumerate()以列表形式返回当前所有存活的 Thread 对象。该列表包含守护线程，current_thread() 创建的虚拟线程对象和主线程。它不包含已终结的线程和尚未开始的线程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import timeimport threadingdef say_hi(): for i in range(3): print(&#x27;Hi!&#x27;) time.sleep(1)def say_yes(): for i in range(3): print(&#x27;Yes!&#x27;) time.sleep(1)def main(): t1 = threading.Thread(target=say_hi) t2 = threading.Thread(target=say_yes) t1.start() t2.start() while True: print(threading.enumerate()) if len(threading.enumerate()) &lt;= 1: break time.sleep(1)if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:Hi!Yes![&lt;_MainThread(MainThread, started 1292)&gt;, &lt;Thread(Thread-1, started 7968)&gt;, &lt;Thread(Thread-2, started 3796)&gt;][&lt;_MainThread(MainThread, started 1292)&gt;, &lt;Thread(Thread-1, started 7968)&gt;, &lt;Thread(Thread-2, started 3796)&gt;]Hi!Yes!Hi!Yes![&lt;_MainThread(MainThread, started 1292)&gt;, &lt;Thread(Thread-1, started 7968)&gt;, &lt;Thread(Thread-2, started 3796)&gt;][&lt;_MainThread(MainThread, started 1292)&gt;, &lt;Thread(Thread-1, started 7968)&gt;] 多线程共享全局变量假设现在有个任务，去抓取某个网站上所有的照片，然后发送到某个邮箱。这里就可以分成两个子任务，一个抓取照片，一个发送照片于是我们可以创建一个线程负责抓取照片，一个线程负责发送照片 那么可以发现，照片是两个线程都要用到的数据。所以我们应该把照片设置为全局变量，这样两个线程才可以进行合作。 在多线程任务中，全局变量是可以给每一个线程共享的。 123456789101112131415161718192021222324252627282930313233import threadingg_num = 10 # 全局变量def add1(): global g_num g_num += 5 print(&quot;add1----------- %d&quot; % g_num)def add2(): print(&quot;add2----------- %d&quot; % g_num)def main(): t1 = threading.Thread(target=add1, name=&#x27;add1&#x27;) t2 = threading.Thread(target=add2, name=&#x27;add2&#x27;) t1.start() t2.start() print(&quot;main----------- %d&quot; % g_num)if __name__ == &quot;__main__&quot;: main()--------------------------------------------------# Output:add1----------- 15add2----------- 15main----------- 15 从栗子中可以看出，线程t1中的add1对全局变量g_num进行了修改在线程t2的add2对g_num进行访问的时候访问到的是修改后的值在主线程的main方法中访问也是修改后的值。 所以：全局变量对于任何一个线程，包括主线程，来说都是共享的。 锁全局变量对于任何一个线程来说都是共享的，那就一定会引发争抢资源的情况，这是由CPU的运行机制导致的。如果对同一个全局变量，两个线程一个写一个读倒还好，但是如果两个同时写就会引发各种问题。特别是在银行、金融领域，会引发更大的问题。比如一边转了帐还没收到突然出现问题，转账的扣钱了，收账的没收到，那就凉凉了~ 所以为了解决这种缺陷，引入了锁的概念。举个栗子，很多人上一个厕所，前面的进去了得锁门吧？办完事了开锁出来后面的才能进去，上锁，办事儿。锁就是这样的概念。哪个线程先抢到锁哪个就先执行，执行完了释放锁，下一个线程抢到了就锁上…..这叫做同步控制 互斥锁 创建锁：mutex = threading.Lock()，默认没有上锁的锁定：mutex.acquire(blocking=True, timeout=1)解锁：mutex.release() acquire(blocking=True, timeout=1) 成功获得锁返回True，否则返回Flase blocking：设置为True时，会一直等到前面的锁释放然后锁定，设置为Flase则不会。 timeout：浮点型，单位——秒； 值为正数时，等待时长为设定的秒数 值为-1时，将无限等待 blocking=Flase时，timeout不起作用。 release() 锁被锁定时，重置为未锁定。锁没被锁定时，引发RuntimeError错误。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import threadingimport timeg_num = 0mutex = threading.Lock()def add1(num): global g_num mutex.acquire() for i in range(num): g_num += 1 mutex.release() print(&quot;add1----------- %d&quot; % g_num)def add2(num): global g_num mutex.acquire() for i in range(num): g_num += 1 mutex.release() print(&quot;add2----------- %d&quot; % g_num)def main(): t1 = threading.Thread(target=add1, args=(1_000_000, )) t2 = threading.Thread(target=add2, args=(1_000_000, )) t1.start() t2.start() time.sleep(2) print(&quot;main----------- %d&quot; % g_num)if __name__ == &quot;__main__&quot;: main()--------------------------------------------------# Output:add1----------- 1000000add2----------- 2000000main----------- 2000000 死锁锁并非只有一个，可以有多个。有多个锁，就可能发生死锁。 举个栗子，电影里经常能看见的镜头——俩人打架不分上下，A锁住了B的脚踝，B锁住了A的脖子。A：你放开我B：你先放开我A：你放开我我就放开你B：你先放开我，我再放开你A：凭什么我先放B：那我也不放…2000 year later…两人死了。The end. 这就是死锁，互不相让，互相锁了对方需要的资源，都等着对方先释放 线程A上了A锁干活，线程B上了B锁，这是两把锁，所以相安无事。运行着运行着线程A需要一份资源，这份资源被线程B上了锁用着呢；线程B也需要一份资源，这份资源被线程A上了锁用着呢。这时候线程A和线程B都在等对方释放锁，就这么一直等一直等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import timeimport threadingclass ThreadLockA(theading.Thread): def run(self): mutexA.acquire() # 使用A锁上锁 print(self.name + &#x27;-----------doA--up--&#x27;) time.sleep(1) # 这里会上锁失败，因为上面 time.sleep(1)的时候B锁已经被上锁了 # 或者此线程后执行，A锁已经被上锁了，会上锁失败。 # 所以死锁会发生在这 mutexB.acquire() # 请求B锁上锁 print(self.name + &#x27;-----------doA--down--&#x27;) mutexB.release() mutexA.release() # 对A锁进行解锁class ThreadLockB(threading.Thread)； def run(self): mutexB.acquire() # 使用B锁上锁 print(self.name + &#x27;-----------doB--up--&#x27;) time.sleep(1) # 这里会上锁失败，因为上面 time.sleep(1)的时候A锁已经被上锁了 # 或者此线程后执行，A锁已经被上锁了，会上锁失败。 # 所以死锁会发生在这 mutexA.acquire() print(self.name + &#x27;-----------doB--down--&#x27;) mutexA.release() mutexB.release() # 对B锁进行解锁mutexA = threading.Lock()mutexB = threading.Lock()if __name__ == &#x27;__main__&#x27;: t1 = ThreadLockA() t2 = ThreadLockB() t1.start() t2.start()--------------------------------------------------# Output:-----------doA--up-------------doB--up--···这里已经卡死了 为了避免这种情况，又两种方法 程序设计时要尽量避免（使用银行家算法） 添加超时时间等","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"进程、线程","slug":"Python/进阶/进程、线程","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-16】进程","slug":"Python/Basic/Python【No-16】进程","date":"2020-07-17T04:41:48.000Z","updated":"2021-07-19T10:05:07.982Z","comments":true,"path":"posts/19751.html","link":"","permalink":"https://www.boii.xyz/posts/19751.html","excerpt":"进程，是资源分配的单位","text":"进程，是资源分配的单位 程序：例如xxx.py这是程序，是静态的进程：一个程序运行起来后，代码+用到的资源 称之为进程，它是操作系统分配资源的基本单元。 进程，是资源分配的单位线程，是操作系统调度的单位 进程的状态工作中，任务数往往大于CPU核心数，即一定有一些任何正在执行，而另外一些任务在等待CPU进行执行因此进程有不同的状态 进程的状态分为：新建、就绪、运行、等待（堵塞）、死亡 就绪态：运行的条件都已经具备，正在等在CPU执行 执行态：CPU正在执行其功能 等待态：等待某些条件满足；例如一个程序sleep了，就处于等待态 进程就好像流水线。一个进程就是一条流水线，每条流水线之间是相互独立的；流水线履带上的产品就是全局变量；流水线上的工人就是线程； 产品（全局变量）对于同一条流水线的工人（线程）来说是共享的，每个人都可以访问流水线（进程）之间是相互独立的，不能流水线A的产品可以被流水线B访问，那不就乱套了。 创建进程创建进程分为三步： 导入 multiprocessing 模块 创建一个 Process 对象 通过 Process 对象启动线程 创建一个 Process对象的时候可以传入参数multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, *, daemon=None) 应始终使用关键字参数调用构造函数。 group：应该始终是 None ；它仅用于兼容 threading.Thread 。 target：是由 run() 方法调用的可调用对象。它默认为 None ，意味着什么都没有被调用。 name：是进程名称 args：是目标调用的参数元组。 kwargs：是目标调用的关键字参数字典。 daemon： 如果提供，则键参数 daemon 将进程 daemon 标志设置为 True 或 False 。 如果是 None （默认值），则该标志将从创建的进程继承。 如果子类重载了构造函数，必须先调用父类构造器Process.__init__()，再做其他事情。 1234567891011121314151617181920212223242526272829303132333435import multiprocessingimport timedef say_hi(): while True: print(&quot;Hi-------&quot;) time.sleep(1)def say_yes(): while True: print(&quot;Yes------&quot;) time.sleep(1)def main(): p1 = multiprocessing.Process(target=say_hi) p2 = multiprocessing.Process(target=say_yes) p1.start() p2.start()if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:Hi-------Yes------Hi-------Yes------Hi-------Yes------Hi-------... 进程间通信进程间的通信有很多中方式，比如通过带网络功能的socket，或者队列Queue 假设两个进程之间要通信，进程A向内存中的Queue放要通信的内容，进程B去Queue中取即可。进程是运行在内存中的，Queue也是运行在内存中的，所以速度很快。Queue对于进程来说是共享的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import multiprocessing as pdef download_from_web(q): &quot;&quot;&quot;下载数据&quot;&quot;&quot; # 模拟从网上下载的数据 data = [11, 22, 33, 44] # 向队列中写入数据 for temp in data: if not q.full(): # 如果队列未满 q.put(temp) # 通过 put 将内容放进队列 print(&quot;download: 下载完成并存入队列&quot;)def analysis_data(q): &quot;&quot;&quot;数据处理&quot;&quot;&quot; # 从队列中获取数据 data = list() # 模拟数据处理 while True: data.append(q.get()) # 通过 get 取队列中的内容 if q.empty(): # 如果队列为空则退出 break print(&quot;analysis:&quot;, data)def main(): # 1.创建一个队列 q = p.Queue(3) # 2.创建多个进程，将队列的应用当作实参传递到里面 p1 = p.Process(target=download_from_web, args=(q, )) p2 = p.Process(target=analysis_data, args=(q, )) p1.start() p2.start()if __name__ == &quot;__main__&quot;: main()def download_from_web(q): &quot;&quot;&quot;下载数据&quot;&quot;&quot; # 模拟从网上下载的数据 data = [11, 22, 33, 44] # 向队列中写入数据 for temp in data: q.put(temp) print(&quot;download: 下载完成并存入队列&quot;)def analysis_data(q): &quot;&quot;&quot;数据处理&quot;&quot;&quot; # 从队列中获取数据 data = list() # 模拟数据处理 while True: data.append(q.get()) if q.empty(): break print(&quot;analysis:&quot;, data)def main(): # 1.创建一个队列 q = p.Queue(3) # 2.创建多个进程，将队列的应用当作实参传递到里面 p1 = p.Process(target=download_from_web, args=(q, )) p2 = p.Process(target=analysis_data, args=(q, )) p1.start() p2.start()if __name__ == &quot;__main__&quot;: main()--------------------------------------------------# Output:download: 下载完成并存入队列analysis: [11, 22, 33, 44] q.put(obj[, block[, timeout]) obj：要传递的内容 block：阻塞，默认True True，队列满了以后会一直等待 Flase，队列满了之后会抛出queue.Full错误 timeout：浮点型，单位——秒，默认None； 值为正数时，等待时长为设定的秒数 值为-1时，将无限等待 blocking=Flase时，timeout不起作用。 如果队列关闭已经关闭会抛出ValueError（3.8+）q.put_nowait(obj)相当于q.put(block=Flase) q.get([block[, timeout]) block：阻塞，默认True True，队列空了以后会一直等待 Flase，队列空了之后会抛出queue.Empty错误 timeout：浮点型，单位——秒，默认None； 值为正数时，等待时长为设定的秒数 值为-1时，将无限等待 blocking=Flase时，timeout不起作用。 如果队列关闭已经关闭会抛出ValueError（3.8+）q.get_nowait()相当于q.get(block=Flase) 进程池进程的创建和消费是很耗费资源的，而实际情况中可能出现成千上百万个进程需要执行，这时候不可能每个进程都单独创建和销毁这些进程大同小异，但是进程的创建和销毁是相同的。于是我们可以把创建和销毁的工作抽取出来，通过更换进程的内容，以此达到较小开销的目的。这种技术叫做 进程池 进程池就好比公园里的湖，进程就好比船。你作为老板，今天来了一个人要划船，你去买一艘船，客人划完了你把船卖了。明天再来两个客人，你又去买两艘船，客人划完了你又把船卖了。万一来了一万个客人，你…没钱买船了哈哈哈。这是普通的进程使用方法。 你作为老板，先买好N艘船（开启进程池），来了一个客人，上船，用完了换你，下一个客人上去…等到哪天生意不做了关门，就把船一起卖掉关门（关闭进程池）。这是进程池的使用方法。省下了买船卖船（创建和销毁进程）的功夫。 进程池中最大容量能同时容纳多少个进程是由开发者指定的，具体多少个要经过测试人员压力测试以后得出一个合适的数量。当进程池创建以后，不会立即工作，而是等到有进程被创建了才开始工作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from multiprocessing import Poolimport osimport timeimport randomdef work(msg): print(&quot;Process-&#123;&#125; running, pid：&#123;&#125;&quot;.format(msg, os.getpid())) start = time.time() time.sleep(random.random() * 2) end = time.time() print(&quot;Process-&#123;&#125; finish, time consuming：&#123;:.2f&#125;&quot;.format(msg, end - start))def main(): po = Pool(3) # 定义一个进程池，最大进程数为3 for i in range(1, 11): # Pool.apply_async(要调用的目标, (传递给目标的参数元组,)) # 每次循环将会用空闲出来的子进程去调用目标 po.apply_async(work, (i, )) print(&quot;------start------&quot;) po.close() # 关闭进程池，关闭后po不在接收新的请求 po.join() # 等待po中所有子进程执行完后再关闭，必须放在close语句后 print(&quot;-------end-------&quot;)if __name__ == &#x27;__main__&#x27;: main()--------------------------------------------------# Output:------start------Process-1 running, pid：20364Process-2 running, pid：15912Process-3 running, pid：16504Process-2 finish, time consuming：1.01Process-4 running, pid：15912Process-3 finish, time consuming：1.03Process-5 running, pid：16504Process-4 finish, time consuming：0.17Process-6 running, pid：15912Process-5 finish, time consuming：0.23Process-7 running, pid：16504Process-1 finish, time consuming：1.50Process-8 running, pid：20364Process-6 finish, time consuming：1.43Process-9 running, pid：15912Process-8 finish, time consuming：1.65Process-10 running, pid：20364Process-9 finish, time consuming：0.55Process-7 finish, time consuming：1.99Process-10 finish, time consuming：0.20-------end------- 创建进程池创建进程池总共分步： 导入 multiprocessing 模块 创建一个 Pool 对象并指定最大进程数 使用apply()或apply_async()方法 使用close()方法停止接收进程 使用join()方法声明等待子进程完毕再关闭进程池","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"进程、线程","slug":"Python/进阶/进程、线程","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-15】进程线程总叙","slug":"Python/Basic/Python【No-15】进程线程总叙","date":"2020-07-16T02:41:48.000Z","updated":"2021-07-19T10:05:07.881Z","comments":true,"path":"posts/46855.html","link":"","permalink":"https://www.boii.xyz/posts/46855.html","excerpt":"进程是内存资源分配的单位线程是操作系统调度的单位，真正执行任务的是线程协程是线程中任务细分下来的单位","text":"进程是内存资源分配的单位线程是操作系统调度的单位，真正执行任务的是线程协程是线程中任务细分下来的单位 代码是由线程执行的线程必须在进程中运行线程可以拆分成多个协程 从图中可以看出一个进程中有1或多个线程，进程就像一个容器一样，是内存资源分配的单位线程是由操作系统调度的，把CPU计算资源给哪个线程使用是操作系统管的每个线程里或多或少有几个协程，这些是程序管理的 程序 &gt; 进程 &gt; 线程 &gt; 协程 代码写好了，躺在硬盘了，那叫程序 代码拿到内存里跑，那叫进程 程序觉得一个主进程不够，可以再开N个子进程 进程只是一个容器，需要干活的，所以得有线程 进程觉得一个主线程不够，可以再开N个子线程 线程觉得有很多耗时操作（如读写文件、网络请求），想把等待的时间利用起来做其他还没完成的任务，可以搞出很多个协程 这么多个概念，其被发明的目的都是为了更高效的利用计算机 在上古时代，单CPU-单核，在同一时间内只能做一件事情，不可能像现在这样又听歌又上网又写文档人们发现CPU的计算速度奇高，所以利用了时间片(就是短到人类无法发现的时长)多次切换运行程序，雨露均沾这样 单CPU-单核 也能实现多个任务同时进行。不过这只是看起来像是在同时运行，如果你能暂停时间，你会发现CPU只是在执行某一个程序而已。这种让CPU资源在程序之间反复横跳，从而实现多任务的技术，叫做并发 那如果我就是想要按下时间暂停按钮的时候，真的有多个程序在一起执行怎么办？再加个CPU咯。这叫并行 举个栗子现在有一个玩具厂，厂里面有2个车间：一个生产玩具，一个生产家电每个车间有N条流水线，每条流水线上有N个工人，每个工人都有各自的任务车间需要地方搭建，还需要电力供应 我们捋一捋关系： 发电机 -&gt; CPU厂 -&gt; 内存车间 -&gt; 进程流水线 -&gt; 线程工人 -&gt; 任务 车间没建起来，就像代码放在硬盘里，代码扔硬盘里不就叫程序么 把 车间 建到 厂房 里用起来，那些 车间 就成了 有用的车间把 代码 放到 内存 里跑起来，那些 代码 就成了 进程 车间 搭好了得有 流水线 来 组装产品啊进程 建好了还得有 线程 来 执行任务啊 所以每个车间至少有一条主流水线所以每个进程至少有一个主线程 车间 一开始只有一条主流水线做全部步骤，有天发现有个步骤特别麻烦进程 一开始只有一个主线程做所有事情，有天发现有个操作特别耗时 于是主流水线就再拉了一条副流水线来负责这个麻烦的步骤，自己继续下一步，再有麻烦步骤就继续加副流水线于是主线程开启一个子线程来负责这个耗时操作，主线程继续执行，再有耗时操作就继续加子线程 有一天单子太多，一条车间不够，那就加条副车间咯，再不够再加有一天计算量太大，一个进程不够，那就加个子进程咯，再不够再加 而且副车间得更主车间一模一样而且子进程得完全复制主进程，包括代码、状态等等 并且，一个车间挂了没事，不会影响其他车间并且，一个进程挂了没事，不会影响其他进程 那现在车间之间 要传递零件怎么办，搭个管子，直接溜过去，先放的别人就先拿到那现在进程之间要进行通信怎么办，用队列或者管道呗，先放的就先拿到 那流水线之间要传递东西怎么办？放车间的工具车上不就完了那线程之间要通信怎么办？用全局变量不就完了 流水线跟车间可不一样，要是哪条副流水线挂了是会影响整个车间的线程跟进程可不一样，要是哪个子线程挂了是会影响整个进程的 主流水线要是挂了，整个车间完犊子主线程要是挂了，整个进程完犊子 有的流水线就一个工人，有的流水线有多个工人，这个工人动作慢了，就把螺丝刀给别的工人先用有的线程就一个协程，有的线程有多个协程，这个协程阻塞了，就把运行权给别的协程 这种积极利用等待时间安排其他工人的模式，叫做高效利用时间这种积极利用等待时间做其他任务的形式，叫做协程 那现在发电机只有一个，生产玩具的车间要用，生产家电的车间要用，老板又想两个车间同时生产那现在CPU只有一个，进程A要用，进程B要用，用户又想两个进程使用运行 那就让发电机快速在两个车间之间快速切换，哪个车间有电了立马干活，没电了立马暂停那就让CPU资源在两个进程之间反复横跳，哪个进程被选中了立马运行，时间片到了立马暂停 因为速度非常快，所以老板看着以为两个车间都启动了因为速度非常快，所以用户真的以为两个任务同时运行，这叫并发 有一天老板发财，加了一台发电机，这下两个车间都有电了，真正的两个车间同时生产有一天用户发财，加了一个CPU，这下两个进程都有资源了，真正实现两个进程同时运行，这叫并行 进程占的资源比较大，但是安全，一个进程挂掉不会导致另外一个进程挂掉线程切换开销更小协程利用等待的时间做别的事，但是需要程序承担调度责任 在不考虑 GIL（全局锁）的情况下，优先用协程、再用线程、最后用进程","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"进程、线程","slug":"Python/进阶/进程、线程","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-14】枚举类","slug":"Python/Basic/Python【No-14】枚举类","date":"2020-07-15T02:41:48.000Z","updated":"2021-07-19T10:05:07.784Z","comments":true,"path":"posts/17751.html","link":"","permalink":"https://www.boii.xyz/posts/17751.html","excerpt":"枚举类型在 Python3.4 新增到标准库","text":"枚举类型在 Python3.4 新增到标准库 创建枚举有两种方法创建枚举 基于 class 语法创建 基于 Function API 创建 第一步，导入Enum类 1from enum import Enum 基于 class 语法创建12345678910from enum import Enumclass Weekend(Enum)； Mon = 1 Tue = 2 Wed = 3 Thr = 4 Fri = 5 Sat = 6 Sun = 7 上面例子 定义了 Weekend 枚举类型 定义了 Weekend 的枚举成员 Weekend.Mon，Weekend.Tue… 为每一个枚举成员赋值。如Weekend.Mon 的值为1。值可以指定为其他类型，不是必须整型 枚举成员包含两个属性：name和value 1234&gt;&gt;&gt; Weekend.Mon.nameMon&gt;&gt;&gt; Weekend.Mon.value1 定义string类型的值 12345678910111213from enum import Enumclass Weekend(Enum)； Monday = &#x27;Mon&#x27; Tuesday = &#x27;Tue&#x27; Wednesday = &#x27;Wed&#x27; Thursday = &#x27;Thu&#x27; Friday = &#x27;Fri&#x27; Saturday = &#x27;Sat&#x27; Sunday = &#x27;Sun&#x27;&gt;&gt;&gt; Weekend.Monday.value&#x27;Mon&#x27; 基于 Function API 创建 Enum(enum name, enumerators)第一个参数 enum name 表示枚举名称，第二个参数enumerators 表示枚举成员列表枚举成员列表有三种方式： 使用字符串表示，各成员名使用空格隔开。成员的值从1开始自动递增Enum(&#39;enum_name&#39;, &#39;member1 member2 member3 ... memberN&#39;) 使用元组表示，成员的值从1开始自动递增Enum(&#39;enum_name&#39;, (&#39;member1&#39;, &#39;member2&#39;, &#39;member3&#39;, ... , &#39;memberN&#39;)) 使用字典表示，字典可以指定枚举成员的值，其中字典的键为枚举成员名，值为枚举成员的值Enum(&#39;enum_name&#39;, &#123;&#39;member1_key&#39;: memberl_value, &#39;member_key2&#39;: member2_value,...&#125;) 123456789from enum import Enum# 以下三句表达式互相等价weekend = Enum(&#x27;week&#x27;,&#x27;Mon Tue Wed Thu Fri Sat Sun&#x27;)weekend = Enum(&#x27;week&#x27;,(&#x27;Mon&#x27;, &#x27;Tue&#x27;, &#x27;Wed&#x27;, &#x27;Thu&#x27;, &#x27;Fri&#x27;, &#x27;Sat&#x27;, &#x27;Sun&#x27;)weekend = Enum(&#x27;week&#x27;,&#123;&#x27;Mon&#x27;:1, &#x27;Tue&#x27;:2, &#x27;Wed&#x27;:3, &#x27;Thu&#x27;:4, &#x27;Fri&#x27;:5, &#x27;Sat&#x27;:6, &#x27;Sun&#x27;:7&#125;)&gt;&gt;&gt; weekend.Mon.value1 访问枚举成员访问枚举成员有三种方式： 使用点号(“.”)引用 使用value获取，值对应的枚举成员 使用枚举成员名 12345678910111213141516171819202122from enum import Enumclass Weekend(Enum): Mon = 1 Tue = 2 Wed = 3 Thr = 4 Fri = 5 Sat = 6 Sun = 7# 按值访问print(Weekend(5)) # Weekend.Fri# 按枚举名访问print(Weekend[&#x27;Sun&#x27;]) # Weekend.Sun# 访问成员的名称print(Weekend.Tue.name) # Tue# 访问成员的值print(Weekend.Thr.value) # 4 枚举遍历如果把枚举当作 Dict 来看，枚举类.枚举成员名是key，赋给枚举成员的值是value 123456789101112131415161718192021222324252627282930313233print(&quot;name: member | value&quot;)print(&quot;-&quot; * 25)for name, member in Weekend.__members__.items(): print(name + &quot; : &quot; + str(member) + &quot; | &quot; + str(member.value))# Output:name: member | value-------------------------Mon : Weekend.Mon | 0Tue : Weekend.Tue | 1Wed : Weekend.Wed | 2Thr : Weekend.Thr | 3Fri : Weekend.Fri | 4Sat : Weekend.Sat | 5Sun : Weekend.Sun | 6&gt;&gt;&gt; print(Weekend.__members__)&#123;&#x27;Mon&#x27;: &lt;Weekend.Mon: 0&gt;, &#x27;Tue&#x27;: &lt;Weekend.Tue: 1&gt;, &#x27;Wed&#x27;: &lt;Weekend.Wed: 2&gt;, &#x27;Thr&#x27;: &lt;Weekend.Thr: 3&gt;, &#x27;Fri&#x27;: &lt;Weekend.Fri: 4&gt;, &#x27;Sat&#x27;: &lt;Weekend.Sat: 5&gt;, &#x27;Sun&#x27;: &lt;Weekend.Sun: 6&gt;&#125;&gt;&gt;&gt; type(Weekend.__members__)&lt;class &#x27;mappingproxy&#x27;&gt; 枚举比较枚举成员并非整型，而是一种映射类型，是不能做大小比较的当时可以做相等比较 12345678&gt;&gt;&gt; Weekend.Mon == Weekend.MonTrue&gt;&gt;&gt; Weekend.Mon == Weekend.TueFalse&gt;&gt;&gt; Weekend.Mon != Weekend.TueTrue&gt;&gt;&gt; Weekend.Mon == 0False 限定枚举唯一性限定枚举唯一性是指 限制枚举类中的枚举成员 的 名称和值都不重复 限定枚举唯一性非常简单导入 unique类，然后在自定义的枚举类前加上装饰器 @unique 1234567891011from enum import Enum, unique@uniqueclass Weekend: Mon = 0 Tue = 1 Wed = 2 Thr = 3 Fri = 4 Sat = 5 Sun = 6","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"OPP","slug":"Python/OPP","permalink":"https://www.boii.xyz/categories/Python/OPP/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-13】魔术方法","slug":"Python/Basic/Python【No-13】魔术方法","date":"2020-07-14T02:41:48.000Z","updated":"2021-07-19T10:05:07.676Z","comments":true,"path":"posts/39743.html","link":"","permalink":"https://www.boii.xyz/posts/39743.html","excerpt":"魔术方法即类的内置方法","text":"魔术方法即类的内置方法 __str__() 触发时机:使用print(对象)或者str(对象)的时候触发参数：一个self接收对象返回值：必须是字符串类型作用：print（对象时）进行操作，得到字符串，通常用于快捷操作调用方式：print(obj) 另外，还有一个与__str__()相同的子方法：__repr__()，效果一样，适用于调试时，区别在于&gt;&gt;&gt; print(obj) 时调用的是 __str__()&gt;&gt;&gt; obj 时调用的是 __repr__() 12345678910111213141516171819202122232425// Javapublic class Person&#123; String name = &quot;&quot;; int age = 0; public Person(String name, int age)&#123; this.name = name; this.age = age; &#125; ... public String toString() &#123; return &quot;name: &quot; + this.name + &quot;, age: &quot; + this.age; &#125;&#125;Person p = new Person(&quot;Boii&quot;, 18);system.out.println(p);// Output:// name: Boii, age: 18 123456789101112131415161718# Pythonclass Person: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return &quot;name: &quot; + self.name + &quot;, age: &quot; + self.age __repr__ = __str__ # 偷懒写法p = Person(&quot;Boii&quot;, 18)print(p)# Output:# name: Boii, age: 18 __call__() 调用对象的魔术方法触发时机:将对象当作函数调用时触发 对象()参数:至少一个self接收对象，其余根据调用时参数决定返回值：根据情况而定作用：可以将复杂的步骤进行合并操作，减少调用的步骤，方便使用调用方式：obj() 123456789101112131415161718192021222324252627class Athlete: def prepare(self): print(&#x27;The athlete is preparing...&#x27;) def warm_up(self): print(&#x27;The athlete is warming up...&#x27;) def attend(self): print(&#x27;The athlete attended.&#x27;) def run(self): print(&#x27;The athlete ran.&#x27;) def __call__(self): self.prepare() self.warm_up() self.attend() self.run()athlete = Athlete()athlete()# Output:The athlete is preparing...The athlete is warming up...The athlete attended.The athlete ran. 示例中只是简单调用自身函数，实际过程中可能会有更多如开启线程，调用别的类等复杂操作 很多时候，需要判断一个对象能否被调用，能被调用的对象就是一个Callable函数，和带有 __call__()的类对象就是Callable可以通过 callable(obj)来判断一个对象是否可以被调用 __iter__() 调用对象的魔术方法触发时机：对象被用于 for...in参数：至少一个self接收对象返回值：根据情况而定作用：使类具有可迭代的能力调用方式：for...in obj 如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。 以斐波那契数列为例，写一个Fib类，可以作用于for循环： 12345678910111213141516171819202122232425class Fib(object): def __init__(self): self.a, self.b = 0, 1 # 初始化两个计数器a，b def __iter__(self): return self # 实例本身就是迭代对象，故返回自己 def __next__(self): self.a, self.b = self.b, self.a + self.b # 计算下一个值 if self.a &gt; 100000: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值&gt;&gt;&gt; for n in Fib():... print(n)...11235...4636875025 __getitem__()__getattr__() 触发时机：获取不存在的对象成员时触发参数：1接收当前对象的self，一个是获取成员名称的字符串返回值：必须有值作用:为访问不存在的属性设置值注意：getattribute无论何时都会在getattr之前触发，触发了getattribute就不会在触发getattr了","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"OPP","slug":"Python/OPP","permalink":"https://www.boii.xyz/categories/Python/OPP/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-12】私有化","slug":"Python/Basic/Python【No-12】私有化","date":"2020-07-13T02:41:48.000Z","updated":"2021-07-19T10:05:07.584Z","comments":true,"path":"posts/45109.html","link":"","permalink":"https://www.boii.xyz/posts/45109.html","excerpt":"类的私有化","text":"类的私有化 Python 是动态语言，可以在程序运行过程中动态地给class加上属性或方法。这种不加以节制的特性很容易造成烂代码一堆。对此 Python 提供了一些解决方案。 slots 变量绑定白名单 __slots__ = (attributes_of_tuple)写在类变量处attributes_of_tuple是个元组，元组中每一个元素要用string型。 123class ClsName: __slots__ = (&#x27;name&#x27;, &#x27;age&#x27;) ... 示例，在交互模式中： 1234567891011# 没有白名单，可以随意绑定属性&gt;&gt;&gt; class Person:... pass...&gt;&gt;&gt; p = Person()&gt;&gt;&gt; p.name = &#x27;Boii&#x27;&gt;&gt;&gt; p.age = 18&gt;&gt;&gt; p.score = 100&gt;&gt;&gt; print(p.name, p.age, p.score)Boii 18 100 123456789101112# 使用了白名单，只能绑定白名单上的属性&gt;&gt;&gt; class Person:... __slots__ = (&#x27;name&#x27;, &#x27;age&#x27;)...&gt;&gt;&gt; p = Person()&gt;&gt;&gt; p.name = &#x27;Boii&#x27; # 白名单中的属性，可以绑定&gt;&gt;&gt; p.age = 18 # 白名单中的属性，可以绑定&gt;&gt;&gt; p.score = 100 # 白名单中没有的属性，绑定失败# 白名单中没有 score，所以绑定失败Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#x27;Person&#x27; object has no attribute &#x27;score&#x27; 示例，在模块文件中： 12345678910111213class Person: __slots__ = (&#x27;score&#x27;, &#x27;gender&#x27;) def __init__(self, name, age): self.name = name self.age = age# 白名单中没有 name 和 age，所以连创建对象都会失败person = Person(&#x27;Boii&#x27;, 20)# Output:AttributeError: &#x27;Person&#x27; object has no attribute &#x27;name&#x27; 1234567891011121314151617181920212223class Person: __slots__ = (&#x27;name&#x27;, &#x27;age&#x27;, &#x27;score&#x27;, &#x27;gender&#x27;) def __init__(self, name, age): self.name = name self.age = agep = Person(&#x27;Boii&#x27;, 20)print(p.name, p.age)p.name = &#x27;Kali&#x27; # 白名单中存在，可以修改p.age = 30 # 白名单中存在，可以修改p.score = 100 # 白名单中存在，可以绑定p.gender = &#x27;male&#x27; # 白名单中存在，可以绑定print(p.name, p.age, p.score, p.gender)# Output:Boii 20Kali 30 100 male 使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。 @property当一个类中有不想给外界随便访问或修改的属性时，可以将该变量变成 private 型的例如 __age = 18 这样的属性只能在类中访问和修改，外界要进行访问和修改只能通过类中的getter、setter方法。例如： 12345678910111213141516class Person: def __init__(self, age): self.__age = age def get_age(self): return self.__age def set_age(self, value): if value &gt; 0 and value &lt; 200: self.__age = valuep = Person(20)print(p.get_age()) # 20p.set_age(18)print(p.get_age()) # 18 通过 getter、setter ，在访问和修改的时候比较麻烦，要通过调用方法。使用 装饰器@property 则可以比较方便，像变量一样去访问和修改 使用方法1234567891011121314151617181920class ClsName: def __init__(self, attributeName): self.__attributeName = attributeName # 要先写getter @property def attributeName(self): return self.__attributeName # 再写setter @attributeName.setter def attributeName(self, value): self.__attributeName = valuecls = ClsName()print(cls.attributeName) # 访问cls.attributeName = value # 修改 现在改写上面 Person 类的例子： 12345678910111213141516171819class Person: def __init__(self, age): self.__age = age @property def age(self): return self.__age @age.setter def age(self, value): if value &gt; 0 and value &lt; 200: self.__age = valuep = Person(18)print(p.age) # 18p.age = 20print(p.age) # 20","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"OPP","slug":"Python/OPP","permalink":"https://www.boii.xyz/categories/Python/OPP/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-11】类和对象","slug":"Python/Basic/Python【No-11】类和对象","date":"2020-07-12T02:41:48.000Z","updated":"2021-07-19T10:05:07.480Z","comments":true,"path":"posts/7031.html","link":"","permalink":"https://www.boii.xyz/posts/7031.html","excerpt":"模具和产品：类和对象","text":"模具和产品：类和对象 封装、继承、多态 Class 类就像模具，用模具制作出来的产品叫做对象 123456789101112131415161718192021222324252627# 不带继承的类class ClsName: # 类名 # 静态字段，通过类访问 print(ClsName.name), 在内存中只保存一份 name = &#x27;&#x27; age = 0 # public类变量，任何区域都能访问 _weight = 0 # protected类变量，当前类和子类和同一模块中才能访问 __height = 0 # private类变量，只有当前类才能访问 # 构造方法 def __init__(self,[para1[, para2[, paraN]): &quot;&quot;&quot; 这里是类文档 &quot;&quot;&quot; # 普通字段，通过实例来访问 print(clsInstance.para1), 每个实例中都保存 self.para1 = para1 self.para2 = para2 # 类方法 def method(self): &quot;&quot;&quot; 这里是方法注释 &quot;&quot;&quot; &lt;statement&gt; # 类的私有方法 def __private_method(self): &lt;statement&gt;# 继承了别的类的类class ClsName(BaseClsName1[, Base2[, Base3[, BaseN]): # 括号内是这个类所继承的父类 &lt;statement&gt; self这是方法和函数的区别之处：不管是什么方法都要有self这个参数，再写其他参数这个self是唯一的不可缺少的，它等价于java 和 C++中的this但是调用方法的时候不需要给它赋值当这样调用对象的方法时：myobject.method(arg1,arg2)，解释器会解释为MyClass.method(myobject, arg1, arg2)，这就是方法的自动传值 类变量 VS 对象变量类变量或者说静态字段都是一个东西。（类变量 == 静态字段、类属性）对象变量或者说普通字段也都是一个东西。（对象变量 == 普通字段、实例属性） 顾名思义，类变量就是属于类的变量对象变量就是属于对象（实例）的变量 差别定义： 123456789class Person: # 类变量、静态字段、类属性 eyes = 2 nose = 1 def __init__(self, name, age): # 对象变量、普通字段、实例属性 self.name = name self.age = age 实例化： 12345678910111213# 创建两个对象（实例化）p1 = Person(&#x27;Boii&#x27;, 20)p2 = Person(&#x27;Cai&#x27;, 18)# 访问静态变量print(Person.eyes) # 2 通过类名访问print(p1.eyes) # 2 通过对象访问print(p2.nose) # 1 通过对象访问# 访问对象变量print(p1.name) # Boiiprint(p2.name) # Cai 修改类变量以后： 12345# 修改静态变量Person.eyes = 1print(p1.eyes) # 1print(p2.eyes) # 1 12345# 修改对象变量p1.age = 50print(p1.age) # 50print(p2.age) # 18, 改了对象A的，对象B是不受影响的 类变量，是属于类的，存在类那块内存中，类变量被该类创建出来的对象共享。例如上图中，最上面的表格中就是类本身占的内存，其中就有类变量 eyes 和 nose下面两个小表格就是对象 p1 和 p2 各自占的空间，其中就保存着对象变量 name，age 修改类变量 eyes 和 nose 后，对象 p1 和 p2 去访问 eyes 和 nose 就会访问到修改后的值修改对象变量 name 或 age 后，对象之间互不影响。 假设一个类创建了两个对象A 和 B这时内存中其实是有三块空间的，一块是类的，一块是对象A的，一块是对象B的。 当通过类名.类变量访问的时候，是访问类那块内存里的类变量的当通过类名.类变量修改的时候，是修改类那块内存里的类变量的 当通过对象.类变量访问的时候，是系统跑去类那块内存里访问类变量的当通过对象.类变量修改的时候，是系统跑去类那块内存里复制类变量到对象那块内存里的 此时通过类名.类变量修改，再通过对象.类变量访问，其实访问的是对象自己内存里的那个类变量 1234567891011121314151617181920212223242526272829303132333435363738class Person: # 类变量、静态字段 eyes = 2 def __init__(self, name, age): self.name = name self.age = age# 创建两个对象p1 = Person(&#x27;Boii&#x27;, 20)p2 = Person(&#x27;Cai&#x27;, 18)# 通过类 访问静态变量print(Person.eyes) # 2# 通过对象 访问静态变量print(p1.eyes) # 2print(p2.eyes) # 2### 通过类 修改静态变量Person.eyes = 1# 再通过类 访问静态变量print(Person.eyes) # 1# 再通过对象 访问静态变量print(p1.eyes) # 1print(p2.eyes) # 1### 通过对象 修改对象变量p1.eyes = 50# 再通过类 访问静态变量print(Person.eyes) # 1# 再通过对象 访问静态变量print(p1.eyes) # 50 此时personA的内存里已经有eyes这个变量了print(p2.eyes) # 1 注意 p1 中 已经多了一个 eyes 的变量了 另外但是注意，如果静态变量是字典 dict，则不管怎么访问怎么修改，得到的都是一致的 看下面的例子类变量中有一个字典类型 d 123456789class Person: # 类变量、静态字段 eyes = 2 d = &#123;1: &#x27;A&#x27;, 2: &#x27;B&#x27;&#125; def __init__(self, name, age): # 对象变量、普通字段 self.name = name self.age = age 创建两个对象，然后通过对象修改类变量，和通过对象修改字典类型类变量 123456789101112# 创建两个对象p1 = Person(&#x27;Boii&#x27;, 20)p2 = Person(&#x27;Cai&#x27;, 18)# 通过类 修改静态变量, 改动的是类空间里的eyesPerson.eyes = 1# 通过对象 修改静态变量, 是复制一份eyes到对象空间里并修改p1.eyes = 3# 通过对象 修改静态字典变量, 并不会复制一份d到对象空间里p1.d[1] = 50 可以看到通过类名修改后，类空间里的eyes被修改了通过对象修改类变量之后，对象空间里多了一个 eyes 变量并且已经修改了通过对象修改字典类型类变量之后，没有复制一份，而是修改了类空间里字典的值 小结 类变量，又称静态字段、类属性 对象变量，又称普通字段、实例属性 类变量是所有对象共有的，对象变量是对象自己独有的 类变量可以通过 类名.类变量、对象.类变量访问 类变量可以通过 类名.类变量、对象.类变量修改 通过 对象.类变量 修改时，除非该类变量是字典类型，否则都会把类变量复制一份到对象中去 实例方法、类方法、静态方法实例方法 最普通最常用的方法。类中定义的非私有的方法，每个对象在被创建以后都有自己的实例方法。 定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）； 如`p1.instanceMethod()`，Python 解释器会把对象 p1 传给self参数 调用：只能由实例对象调用。 1234567891011121314class Person: ... ... # 定义实例方法 def walk(self, step): return f&quot;I walked &#123;step&#125; steps.&quot;p1 = Person()print(p1.walk(5)) # 调用实例方法-------------------------------Output:I walked 5 steps. 类方法 @classmethod 属于类的方法，和类变量一样，所有对象共享类方法 定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）； 如p1.clsMethod 或 Person.clsMethod，Python解释器会把类 Person 传给 cls 参数 调用：类对象或实例对象都可以调用。 12345678910class Person: __count = 0 def __init__(self): Person.__count += 1 ... ... @classmethod def get_count(cls): return cls.__count 静态方法 @staticmethod用来存放逻辑性的代码，逻辑上属于类，但是和类本身没有关系，即，在静态方法中，不会涉及到类中的属性和方法的操作。可以理解为静态方法是个独立的、单纯的函数，仅仅托关于某个类的名称空间中，便于使用和维护。 定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法； 调用：类对象或实例对象都可以调用。 构造方法 def __init__(self)就是类的构造方法 构造方法的形参可以有1~N个。而参数self是必选的首个的，这个self相当于this。self可以换成其他，但是为避免争议和歧义，最好用self 对于一个对象，可以自由的增加属性或者说对象变量、普通字段，但是通过构造方法，可以强制要求在实例化对象时传入必须的参数。 1234567891011121314class Animal: def __init__(self): passanimalA = Animal() # self 不需要传入animalA.weigth = 180 # 可以自由的增加对象属性class Person: def __init__(self, name, age): passpersonA = Person(&#x27;Boii&#x27;, 20) # 创建对象时必须给 name 和 agepersonB = Person() # ！！错误 访问限制 不加下划线，仅变量名/方法名 = public，任何区域都可以访问一条下划线+变量名/方法名 = protected，当前类和子类和同一模块才可以访问两条下划线+变量名/方法名 = private， 当前类才可以访问 12345678910111213# public 示例class Person: def __init__(self, name): self.name = name # public 属性 def show(self): print(self.name) # 类内部可以访问person = Person(&#x27;Boii&#x27;)print(person.name) # Boii 类外部也可以访问 1234567891011121314151617181920212223242526272829303132333435# protected 示例## Person.py beginclass Person: def __init__(self, name): self._name = name # protected 属性 def show(self): print(self._name) # 当前类中可以访问person = Person(&#x27;Boii&#x27;)person.show() # Boii## Person.py end## Student.py beginfrom Person import Personclass Student(Person): def __init__(self, name, age): super().__init__(name) # 在子类中通过 super().__init__() 访问 self.age = age def show(self): print(f&#x27;姓名：&#123;self._name&#125;, 年龄：&#123;self.age&#125;&#x27;)student = Student(&#x27;Boii&#x27;, 20)student.show() # 姓名：Boii, 年龄：20## Student.py end 1234567891011121314151617181920212223242526# private 示例class Person: def __init__(self, name): self.__name = name def show(self): print(self.__name) def get_name(self): return self.__name def set_name(self, name): self.__name = nameperson = Person(&#x27;Boii&#x27;)print(person.__name) # 错误！！只能在类中访问私有变量print(person.get_name()) # Boii, 通过get方法访问person.set_name(&#x27;Alice&#x27;) # 通过set方法改变print(person.get_name()) # Alice private变量实际上是因为 python解释器对外把 __name 改成了 _Person__name，依然可以通过person._Person__name来访问，但是强烈建议不要这么做。 点击查看更多关于访问限制、私有化的问题 封装、继承和多态 面向对象三大特性：封装、继承、多态封装把一类东西共通的属性、行为定义在一个类中，就是封装。 继承一个类，继承了别的类以后，这个类叫做子类被继承的类，叫做基类、父类、超类继承以后，子类就拥有了父类的全部 非private 功能Python中，子类可以同时继承多个父类 多态在子类中编写与父类同名的方法，叫做方法重写，适用于父类功能不能满足子类要求时。这称之为多态当父类子类的方法相同时，总是会优先调用子类的方法 123456789101112131415161718class Animal: def run(self): print(&#x27;Running---&#x27;)class Dog(Animal): # 继承父类 Animal passclass Cat(Animal): # 继承父类 Animal def run(self): # 方法重写 print(&#x27;Cat is Running---&#x27;)dog = Dog()dog.run() # Running---cat = Cat()cat.run() # Cat is Running--- 继承 class ClsName(BaseClass)在继承中，父类和子类都有的方法（同名的方法），会优先调用子类的；子类没有的，才调用父类的子类中不定义构造方法__init__()，会调用父类的构造方法__init__() 单继承在单继承中：如果父类构造方法有参数，则子类必须有构造方法，并调用父类的构造方法且传参 1234567891011121314# 子类没有__init__，默认调用父类的__init__# 父类的__init__没有参数，所以子类可以不写__init__class Person: def __init__(self): self.name = &quot;Anonymity&quot; self.age = 18class Student(Person): passs = Student() 1234567891011121314# 父类的__init__有参数，子类必须有__init__，并调用父类的__init__且传参class Person: def __init__(self, name): self.name = nameclass Student(Person): def __init__(self, name, age): self.age = age super().__init__(name)s = Student(&quot;Boii&quot;, 18) 多继承在多继承中：如果子类没有__init__()，会调用第一个父类的__init__()如果第一个父类没有__init__()，会找第二个父类，以此类推… 其中，只要任何一个父类的__init__()有参数，子类就必须有__init__()来调用父类的__init__() 如果有超过一个父类的__init__()有参数，则应该写作 BaseClsName.__init__(self, paras) 或 BaseClsName(type, obj).__init__(paras) 123456789101112131415161718192021class BaseA: def __init__(self, name, age): self.name = name self.age = ageclass BaseB: def __init__(self, gender, nationality): self.gender = gender self.nationality = nationalityclass Student(BaseA, BaseB): def __init__(self, name, age, gender, nationality): BaseA(Student, self).__init__(name, age) BaseB.__init__(self, gender, nationality)s = Student(&quot;Boii&quot;, 18, &quot;male&quot;, &quot;China&quot;) 钻石继承 菱形继承是指：子类 sub 继承了 父类 A，B，而父类 A，B又共同继承了祖父类 Base 12345 [Base] ↗ ↖[A] [B] ↖ ↗ [sub] 由于Python的机制，解释器在创建 sub类对象时会找到 A 的 构造方法，接着找到 Base 的构造方法然后再找 B 的构造方法，接着找到 Base 的构造方法，这样等于重复调用了 Base 的构造方法 1234567891011121314151617181920212223242526272829303132class Base: def __init__(self): print(&quot;Base.__init__&quot;)class A(Base): def __init__(self): Base.__init__(self) print(&quot;A.__init__&quot;)class B(Base): def __init__(self): Base.__init__(self) print(&quot;B.__init__&quot;)class sub(A, B): def __init__(self): A.__init__(self) B.__init__(self) print(&quot;sub.__init__&quot;)sub()# Output:Base.__init__A.__init__Base.__init__B.__init__sub.__init__ Base 的 __init__()被调用了两次 这时候可以改写 sub，A，B 的 __init__()为super().__init__ 123456789101112131415161718192021222324252627282930class Base: def __init__(self): print(&quot;Base.__init__&quot;)class A(Base): def __init__(self): super().__init__() print(&quot;A.__init__&quot;)class B(Base): def __init__(self): super().__init__() print(&quot;B.__init__&quot;)class sub(A, B): def __init__(self): super().__init__() print(&quot;sub.__init__&quot;)sub()# Output:Base.__init__B.__init__A.__init__sub.__init__ 多态的好处如上示例，多态使得继承之后还可以进行扩展，但是多态还有另一个好处。 示例中，Animal 是父类，Dog 和 Cat 是子类。Animal 是 Animal 类型；Dog 是 Dog 类型，也是 Animal 类型；Cat 同理 12345678910111213141516&gt;&gt;&gt; animal = Animal()&gt;&gt;&gt; dog = Dog()&gt;&gt;&gt; cat = Cat()&gt;&gt;&gt; isinstance(animal, Animal)True&gt;&gt;&gt; isinstance(dog, Dog)True&gt;&gt;&gt; isinstance(dog, Animal)True&gt;&gt;&gt; isinstance(cat, Cat)True&gt;&gt;&gt; isinstance(cat, Animal)True&gt;&gt;&gt; isinstance(animal, Dog)False 一句话总结就是，对象的类型是自身类+父类，而所有类都自动继承自 object类 因为这个特性，使得python更加灵活 假设现在有个函数，这个函数接受一个animal类型对象 123def run_twice(animal): animal.run() animal.run() 在调用的时候： 123456789101112131415&gt;&gt;&gt; animal = Animal()&gt;&gt;&gt; dog = Dog()&gt;&gt;&gt; cat = Cat()&gt;&gt;&gt; run_twice(animal)Running---Running---&gt;&gt;&gt; run_twice(cat)Cat is Running---Cat is Running---&gt;&gt;&gt; run_twice(dog)Running---Running--- 可以发现，这个接受Animal类型的函数，不仅可以接受Animal类及其子类的对象，还可以根据传入对象的不同实现不同的效果即使再定义一个类继承Animal，然后创建对象传入 run_twice()，依然可以实现相同的效果，而且不需要改动run_twice() 同理，所有的类都继承自object，如果是run_twice(object)，则可以接受任何类型的对象所以，对于一个变量，只需要知道其父类Animal，就可以放心的使用，在调用时animal.run()是作用在animal还是dog还是cat，由运行时该对象的确切类型决定。 调用方只管调用，不管细节。每当新增一种Animal子类时，只要确保run()方法编写正确，不用管run_twice()怎么实现。这就是&lt;开闭原则&gt;: 对扩展开放：允许新增Animal子类； 对修改封闭：不需要修改依赖Animal类型的run_twice()等函数 多态在静态语言和动态语言中的区别多态的这种特性在动态语言和静态语言中还有些区别. 像java这种静态语言，run_twice(Animal)传入的对象必须是Animal类型或其子类，否则无法调用run()方法。而python这种动态语言，则不一定要传入Animal类型，只需要保证传入的对象有一个run()方法就可以。这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。 123class Timer: def run(self): print(&#x27;Start---&#x27;) 像这个类，没有继承Animal，但依然可以传给run_twice(Animal)。 示例： 12345678910111213141516171819202122232425262728class Animal(object): # 编写Animal类 def run(self): print(&quot;Animal is running...&quot;)class Dog(Animal): # Dog类继承Amimal类，没有run方法 passclass Cat(Animal): # Cat类继承Animal类，有自己的run方法 def run(self): print(&#x27;Cat is running...&#x27;) passclass Car(object): # Car类不继承，有自己的run方法 def run(self): print(&#x27;Car is running...&#x27;)class Stone(object): # Stone类不继承，也没有run方法 passdef run_twice(animal): animal.run() animal.run()run_twice(Animal())run_twice(Dog())run_twice(Cat())run_twice(Car())run_twice(Stone()) 输出： 12345678910Animal is running...Animal is running...Animal is running...Animal is running...Cat is running...Cat is running...Car is running...Car is running...AttributeError: &#x27;Stone&#x27; object has no attribute &#x27;run&#x27;","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"OPP","slug":"Python/OPP","permalink":"https://www.boii.xyz/categories/Python/OPP/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-10】模块","slug":"Python/Basic/Python【No-10】模块","date":"2020-07-11T02:41:48.000Z","updated":"2021-07-19T10:05:07.384Z","comments":true,"path":"posts/65033.html","link":"","permalink":"https://www.boii.xyz/posts/65033.html","excerpt":"一个py文件就是一个模块","text":"一个py文件就是一个模块 模块 Module 一个 .py文件就称之为一个模块 module 好处： 提高了代码的可维护性； 可以被其他地方应用； 可以避免命名冲突。 importimport加载的模块分为四个通用类别： 使用python编写的代码（py文件）； 已被编译为共享库或DLL的C或C++扩展； 包好一组模块的包 使用C编写并链接到python解释器的内置模块. 包 Package 模块的上一级称为包 package 包是一个文件夹，可以通过包来组织模块，避免冲突。 一个包里必须含有一个__init__.py __init__.py可以是空文件，也可以有Python代码 __init__.py本身就算一个模块，它的模块名就是包名 包里面还可以有包 123456789101112MyPackage ├─ web │ ├─ __init__.py │ ├─ utils.py │ └─ test.py ├─ dirc │ ├─ utils.py │ └─ test.py │ ├─ __init__.py ├─ main.py └─ utils.py 顶层包为 MyPackage子包为 web普通目录 dirc （因为它没有__init__.py文件）test.py的模块名为MyPackage.web.testutils.py有两个，模块名分别为MyPackage.web.utils和MyPackage.utils 自己创建模块时注意命名不要与系统模块冲突要检查系统中是否存在该模块，可以在交互环境下执行 import abc，若成功说明系统存在此模块。 1234&gt;&gt;&gt; import aabbcccTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ModuleNotFoundError: No module named &#x27;aabbccc&#x27; 使用模块1234567891011121314151617181920212223#!/usr/bin/env python3# -*- coding: utf-8 -*-&quot;Here is the module documentation&quot;__author__ = &#x27;Boii&#x27;import sysdef test(): args = sys.argv if len(args) == 1: print(&#x27;Hello, world!&#x27;) elif len(args) == 2: print(&#x27;Hello, %s!&#x27; % args[1]) else: print(&#x27;Too many arguments!&#x27;)if __name__ == &#x27;__main__&#x27;: test() 标准模块文件模板 #!/usr/bin/env python3 是向Unix / Linux / Mac 系统声明本文件是Python3文件 # -*- coding: utf-8 -*- 表示本文件使用标准utf-8编码，虽然Python3之后默认支持中文，但为保稳妥还是写上 &quot;Here is the module documentation&quot;是模块文档注释，任何模块的第一个字符串都被视为模块的文档注释。可以通过模块名.__doc__获得。 __author__ = &#39;Boii&#39;是作者。可以通过模块名.__author__获得。 标准模块文件模板也可以不写，并不影响。 导入、参数列表、name import sys引入了内置模块sys args = sys.argv，这里sys.argv是参数列表，是一个 list，保存的是通过命令执行本文件的时候所带的参数。但该 list的第一个元素永远是文件名。 例如上面的文件名为Hello.py，则运行命令python Hello.py后sys,argv为[&#39;Hello.py&#39;]. 如果执行的命令为python Hello.py Boii，则sys.argv为[&#39;Hello.py&#39;, &#39;Boii&#39;] if __name__ == &#39;__main__&#39;: test()如果这个文件是独立运行的，则 if 为 True，如果这个文件是被导入的，则 if 为 False。 1234$ python Hello.pyHello, world!$ python Hello.py BoiiHello, Boii! ↑ 通过命令独立运行这个文件，所以 if 为 True，执行了 test() 函数 1234567$ pythonPython 3.8.3&gt;&gt;&gt;&gt;&gt;&gt; import Hello&gt;&gt;&gt;&gt;&gt;&gt; Hello.test()Hello, world! ↑ 通过导入的方式运行这个文件，所以 if 为 False，没有执行 test() 函数，等到 Hello.test() 主动调用时才执行了 test() 函数 总结一个 .py 文件就是一个模块 module一个带有 __init__.py 的文件夹就是一个包 package","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"OPP","slug":"Python/OPP","permalink":"https://www.boii.xyz/categories/Python/OPP/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-9】测试","slug":"Python/Basic/Python【No-9】测试","date":"2020-07-10T02:41:48.000Z","updated":"2021-07-19T10:05:07.254Z","comments":true,"path":"posts/54509.html","link":"","permalink":"https://www.boii.xyz/posts/54509.html","excerpt":"程序的必经之路：测试","text":"程序的必经之路：测试 测试分为 单元测试、组件测试、系统测试、性能测试，逐级上升。所谓的测试驱动开发(TDD：Test-Driven Development)，就是说每写完一个小功能，就要做一个完整的单元测试，每次进行改动以后都要进行一次单元测试，以确保功能正常。 每个单元测试都通过以后就可以进行组件测试，所有组件测试都通过就可以进行系统测试，系统测试通过就可以进行性能测试，性能测试类似于“烤机”，测试系统的最大承受能力，承受峰值等等。 单元测试单元测试就是对一个模块、一个函数或者一个类进行正确性检验的检测工作举个栗子： 对一个求绝对值函数 abs(num)，可以编写一下几个测试用例： 输入正数 如 1、4.1、5.9，期待返回正整数 1、4.1、5.9 输入负数 如 -1.5、-3.7、20，期待返回正整数 1.5、3.7、20 输入 0，期待返回 0 输入非数值类型 如 None、[]、&#123;&#125;，期待抛出TypeError。 将上面4个测试用例放到一个测试模块里，就是一个完整单元测试。单元测试能通过了，说明这个函数功能正常，如果不通过，要么函数有问题，要么测试用例有问题。所以要修复直到单元测试能够通过。 这样做的好处是，如果我们对abs()做了修改，只要再进行一次单元测试，可以通过，就说明修改没有影响函数的功能。如果不通过则要找出问题，修改到通过单元测试为止。极大程度上确保该模块行为仍然是正确的。 文档测试一个函数、模块、类的第一个匿名字符串，就是文档。如 123456789101112def func(): &#x27;&#x27;&#x27; 这里是文档 &#x27;&#x27;&#x27; passclass cls: &#x27;&#x27;&#x27; 这里是文档 &#x27;&#x27;&#x27; pass 文档的内容可以作为测试集来进行测试。第一步：编写文档。文档中 &gt;&gt;&gt;的行会被执行，这与在交互模式下执行语句的相同的。第二步：if __name__ == &#39;__main__&#39;: import doctest; doctest.testmod()第三步：运行文件 例如上面的绝对值函数abs()可以这样写 123456789101112131415161718192021def abs(num): &#x27;&#x27;&#x27; The function will return the absolute value of num. &gt;&gt;&gt; abs(11) 11 &gt;&gt;&gt; abs(-41) 41 &gt;&gt;&gt; abs(0) 0 &gt;&gt;&gt; abs(&#x27;a&#x27;) Traceback (most recent call last): ... TypeError: &#x27;&gt;=&#x27; not supported between instances of &#x27;str&#x27; and &#x27;int&#x27; &#x27;&#x27;&#x27; return n if n &gt;= 0 else (-n)if __name__ == &#x27;__main__&#x27;: import doctest doctest.testmod() 文档中以 &gt;&gt;&gt; 表示测试用例，并在下行写出结果。如果测试结果正确，则什么也不会输出。 小结doctest非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含doctest的注释提取出来。用户看文档的时候，同时也看到了doctest。 Unittest 环境搭建：Python已内置Unittest框架，直接import unittest 四大组件： test fixture：setUp（前置条件）、tearDown（后置条件），用于初始化测试用例及清理和释放资源 test case：测试用例，通过继承unittest.TestCase实现用例的继承。在Unittest中，测试用例都是通过test前缀或后缀来识别的。 def test_xxx(self)、def xxx_test(self) test suite：测试套件，即测试用例的集合。 test runner：运行器，一般通过runner来调用suite去执行测试。 运行机制：通过在main函数中，调用unittest.main()运行所有内容 1234567891011121314151617181920212223242526272829303132import unittestclass forTest(unittest.TestCase): # 初始化 def setUp(self) -&gt; None: print(&#x27;setUp&#x27;) # 释放 def tearDown(self) -&gt; None: print(&#x27;tearDown&#x27;) # 测试用例1 def test_a(self): print(&#x27;a&#x27;) # 测试用例2 def test_b(self): print(&#x27;b&#x27;)if __name__ == &#x27;__main__&#x27;； unittest.main()--------------------------------------------------# Output:setUpatearDownsetUpbtearDown","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"错误与调试","slug":"Python/进阶/错误与调试","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B0%83%E8%AF%95/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-8】调试","slug":"Python/Basic/Python【No-8】调试","date":"2020-07-09T02:41:48.000Z","updated":"2021-07-19T10:05:07.064Z","comments":true,"path":"posts/24435.html","link":"","permalink":"https://www.boii.xyz/posts/24435.html","excerpt":"开发的必经之路：调试","text":"开发的必经之路：调试 大型项目中，一般都是使用日志来调试程序。不过有时候有一小块代码想做调试的时候，可以用print和assert。 print &amp; assertprint() 就是常见的打印函数。 凡是用print()的地方都可以用 断言assert语句代替 1234567891011121314151617# 用printdef foo(s): n = int(s) if n == 0: print(&quot;n is zero!&quot;) else: return 10 / nfoo(&#x27;0&#x27;)--------------------------------------------------# Output:Traceback (most recent call last): ...ZeroDivisionError: division by zero 123456789101112131415# 用assertdef foo(s): n = int(s) assert n == 0 , &quot;n is zero!&quot; return 10 / nfoo(&#x27;0&#x27;)--------------------------------------------------# Output:Traceback (most recent call last): ...AssertionError: n is zero! 当assert后面的表达式为 False 时，则抛出 AssertionError错误 assert expression等价于 12if not expression: raise AssertionError assert expression [,arguments]等价于 12if not expression: rasise AssertionError(arguments) 例如：断言当前系统为 linux 12import sysassert (linux in sys.platform), &quot;该代码只能在 linux 系统下执行&quot; 日志模块 loggingPython 标准库中有一个日志模块 logging，相当于 java 中的 log4j 在软件开发阶段或部署开发环境时，为了尽可能详细的查看应用程序的运行状态来保证上线后的稳定性，我们可能需要把该应用程序所有的运行日志全部记录下来进行分析，这是非常耗费机器性能的。 当应用程序正式发布或在生产环境部署应用程序时，我们通常只需要记录应用程序的异常信息、错误信息等，这样既可以减小服务器的I/O压力，也可以避免我们在排查故障时被淹没在日志的海洋里。 logging 日志等级把日志分为6个等级 Level value Description NOTEST 0 DEBUG 10 最详细的日志信息，典型应用场景是 问题诊断 INFO 20 通常只记录关键节点信息，用于确认一切都是按照我们预期的那样进行工作 WARNING 30 当某些不期望的事情发生时记录的信息，但是此时应用程序还是正常运行的 ERROR 40 由于一个更严重的问题导致某些功能不能正常运行时记录的信息 CRITICAL 50 当发生严重错误，导致应用程序不能继续运行时记录的信息 日志等级是从下到上依次升高的（值越大等级越高）即：NOTEST &lt; DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL，而日志的信息量是依次减少的； 开发应用程序或部署开发环境时，可以使用DEBUG或INFO级别的日志获取尽可能详细的日志信息来进行开发或部署调试；应用上线或部署生产环境时，应该使用WARNING或ERROR或CRITICAL级别的日志来降低机器的I/O压力和提高获取错误日志信息的效率。 日志级别的指定通常都是在应用程序的配置文件中进行指定的。 logging 配置 loggong.basicConfig(**kwargs) **kwargs 可以接收关键字参数如下： 参数名称 描述 取值范围 filename 指定日志输出目标文件的文件名，指定该设置项后日志信息就不会被输出到控制台了 string filemode 指定日志文件的打开模式，默认为’a’。该选项要在filename指定时才有效 a、w format 指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序 详见下表 datefmt 指定日期/时间格式，该选项要在format中包含时间字段%(asctime)s时才有效 datefmt level 指定日志器的日志级别 logging.DEBUG、logging.INFO… stream 指定日志输出目标stream。 sys.stdout、sys.stderr以及网络stream style 指定format格式字符串的风格，可取值为，默认为’%’ %、{、$ handlers 该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。 一个创建了多个Handler的可迭代对象 filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常。 format 参数的取值表 名称 使用格式 描述 asctime %(asctime)s 日志事件发生的时间–人类可读时间，如：2003-07-08 16:49:45,896 created %(created)f 日志事件发生的时间–时间戳，就是当时调用time.time()函数返回的值 relativeCreated %(relativeCreated)d 日志事件发生的时间相对于logging模块加载时间的相对毫秒数（目前还不知道干嘛用的） msecs %(msecs)d 日志事件发生的时间的毫秒部分 ————— ——————- —————————————————————————- levelname %(levelname)s 该日志记录的文字形式的日志级别（’DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’） levelno %(levelno)s 该日志记录的数字形式的日志级别（10,20,30,40,50） lineno %(lineno)d 调用日志记录函数的源代码所在的行号 funcName %(funcName)s 调用日志记录函数的函数名 name %(name)s 所使用的日志器名称，默认是’root’， message %(message)s 日志记录的文本内容，通过 msg % args计算得到的 ————— ——————- —————————————————————————- pathname %(pathname)s 调用日志记录函数的源码文件的全路径 filename %(filename)s pathname的文件名部分，包含文件后缀 module %(module)s filename的名称部分，不包含后缀 ————— ——————- —————————————————————————- process %(process)d 进程ID processName %(processName)s 进程名称，Python 3.1新增 thread %(thread)d 线程ID threadname %(thread)s 线程名称 12345678910111213import loggingLOG_FORMAT = &quot;%(asctime)s - %(levelname)s - %(message)s&quot; # 日志打印格式DATE_FORMAT = &quot;%Y-%m-%d %H:%M:%S&quot; # 时间打印格式# 配置日志logging.basicConfig(filename=&#x27;my.log&#x27;, level=logging.DEBUG, format=LOG_FORMAT, datefmt=DATE_FORMAT)logging.debug(&quot;This is a debug log.&quot;)logging.info(&quot;This is a info log.&quot;)logging.warning(&quot;This is a warning log.&quot;)logging.error(&quot;This is a error log.&quot;)logging.critical(&quot;This is a critical log.&quot;) 以上代码 配置了日志文件，级别设置为 DEBUG，输出格式为 日志发生时间 - 日志等级 - 日志信息 执行后结果如下： 执行第二次后结果如下： 如果要让日志格式好看点，还可以指定宽度。比如执行 日志等级 的打印宽度为 8，在 s 前面加上宽度即可：%(levelname)8s如果要左对齐，则写上减号 -：%(levelname)-8s 123456789101112131415# 导入模块import loggingLOG_FORMAT = &quot;%(asctime)s - %(levelname)-8s - %(message)s&quot; # 日志打印格式DATE_FORMAT = &quot;%Y-%m-%d %H:%M:%S&quot; # 时间打印格式# 配置日志logging.basicConfig(filename=&#x27;my.log&#x27;, level=logging.DEBUG, format=LOG_FORMAT, datefmt=DATE_FORMAT)# 打日志logging.debug(&quot;This is a debug log.&quot;)logging.info(&quot;This is a info log.&quot;)logging.warning(&quot;This is a warning log.&quot;)logging.error(&quot;This is a error log.&quot;)logging.critical(&quot;This is a critical log.&quot;) 左对齐：%(levelname)-8s 右对齐：%(levelname)8s logging 模块使用 用法： 导入 logging 配置(可选) 打日志 logging 模块提供了两种记录日志的方式： 使用 logging 提供的模块级别的函数 使用 logging 日志系统的四大组件 logging所提供的模块级别的日志记录函数也是对logging日志系统相关类的封装而已。 函数用法常用模块级别函数 Function Description logging.debug(msg, *args, **kwargs) 创建一条严重级别为 DEBUG 的日志记录 logging.info(msg, *args, **kwargs) 创建一条严重级别为 INFO 的日志记录 logging.warning(msg, *args, **kwargs) 创建一条严重级别为 WARNNING 的日志记录 logging.error(msg, *args, **kwargs) 创建一条严重级别为 ERROR 的日志记录 logging.critical(msg, *args, **kwargs) 创建一条严重级别为 CRITICAL 的日志记录 logging.log(msg, *args, **kwargs) 创建一条严重级别为 LOG 的日志记录 logging.basicConfig(**kwargs) 对root logger进行一次性配置 1234567891011121314151617181920212223242526import logging # 导入模块# 打日志logging.debug(&quot;This is a debug log.&quot;)logging.info(&quot;This is a info log.&quot;)logging.warning(&quot;This is a warning log.&quot;)logging.error(&quot;This is a error log.&quot;)logging.critical(&quot;This is a critical log.&quot;)或import logging #导入模块# 打日志logging.log(logging.DEBUG, &quot;This is a debug log.&quot;)logging.log(logging.INFO, &quot;This is a info log.&quot;)logging.log(logging.WARNING, &quot;This is a warning log.&quot;)logging.log(logging.ERROR, &quot;This is a error log.&quot;)logging.log(logging.CRITICAL, &quot;This is a critical log.&quot;)--------------------------------------------------# Output:WARNING:root:This is a warning log.ERROR:root:This is a error log.CRITICAL:root:This is a critical log. 这里只输出 warning 级别以上的信息。这是因为默认的日志等级是 warning ，所以 debug 和 info 级别的信息就被忽略了。logging 只输出 大于等于 所设置级别以上的日志信息。这点可以在 logging.basicConfig()中设置","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"错误与调试","slug":"Python/进阶/错误与调试","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B0%83%E8%AF%95/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-7】错误处理","slug":"Python/Basic/Python【No-7】错误处理","date":"2020-07-08T02:41:48.000Z","updated":"2021-07-19T10:05:06.921Z","comments":true,"path":"posts/63024.html","link":"","permalink":"https://www.boii.xyz/posts/63024.html","excerpt":"语言必修课：错误处理","text":"语言必修课：错误处理 错误处理 try...except1...[exceptN...[finally...] 123456try: 可能会出现异常的代码except 异常类型 [as 别名]： 出现异常后的处理finally: 不管是否出现异常最后都会执行的代码 示例： 1234567891011121314151617181920# 出现 除零的异常 示例try: print(&quot;Try---------&quot;) r = 10/0 print(&quot;result: &quot;, r)except ZeroDivisionError as e: print(&quot;Except------&quot;, e)finally: print(&quot;Finally-----&quot;)print(&quot;END&quot;)--------------------------------------------------# Output:Try---------Except------ division by zeroFinally-----END try 语句块中的代码遇到异常后会跳转到 except 语句块执行而 finally 语句块不管有没有异常最后都会执行。当然，也可以没有 finally 语句 1234567891011121314151617181920# 没有异常的示例try: print(&quot;Try---------&quot;) r = 10/2 print(&quot;result: &quot;, r)except ZeroDivisionError as e: print(&quot;Except------&quot;, e)finally: print(&quot;Finally-----&quot;)print(&quot;END&quot;)--------------------------------------------------# Output:Try---------result: 5Finally-----END 捕获多个异常捕获异常不止可以捕获一个，还可以捕获多个 123456789101112131415161718192021try: print(&quot;Try---------&quot;) r = 10 / int(&#x27;a&#x27;) print(&quot;result: &quot;, r)except ValueError as e: print(&#x27;ValueError: &#x27;, e)except ZeroDivisionError as e: print(&quot;ZeroDivisionError: &quot;, e)finally: print(&quot;Finally-----&quot;)print(&quot;END&quot;)--------------------------------------------------# Output:Try---------ValueError: invalid literal for int() with base 10: &#x27;a&#x27;Finally-----END else 语句在 except 后面还可以加一个 else 语句块 1234567891011121314151617181920212223242526# else 语句在没有异常的情况下 示例try: print(&quot;Try---------&quot;) r = 10 / int(&#x27;2&#x27;) print(&quot;result: &quot;, r)except ValueError as e: print(&#x27;ValueError: &#x27;, e)except ZeroDivisionError as e: print(&quot;ZeroDivisionError: &quot;, e)else: print(&quot;Else--------No Error!&quot;)finally: print(&quot;Finally-----&quot;)print(&quot;END&quot;)--------------------------------------------------# Output:Try---------result: 5.0Else--------No Error!Finally-----END else 语句不同于finally 语句。finally 语句是有无异常都会执行，else 语句会在没有异常的情况下执行 123456789101112131415161718192021222324# else 语句在有异常的情况下 示例try: print(&quot;Try---------&quot;) r = 10 / int(&#x27;a&#x27;) print(&quot;result: &quot;, r)except ValueError as e: print(&#x27;ValueError: &#x27;, e)except ZeroDivisionError as e: print(&quot;ZeroDivisionError: &quot;, e)else: print(&quot;Else--------No Error!&quot;)finally: print(&quot;Finally-----&quot;)print(&quot;END&quot;)--------------------------------------------------# Output:Try---------ValueError: invalid literal for int() with base 10: &#x27;a&#x27;Finally-----END 优点：跨越多层调用例如现在 A() 调用 B()，B() 调用 C()，在 C() 出错了，只要 A() 捕获到了，就可以处理。 12345678910111213141516171819202122def C(s): return 10 / int(s)def B(s): return C(s) * 2def A(): try: B(&#x27;0&#x27;) except Exception as e: print(&quot;Error:&quot;, e) finally: print(&quot;Finally------&quot;)A()--------------------------------------------------# Output:Error: division by zeroFinally------ 虽然错误是在 C() 出现，但是在 A() 也能捕获。如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。 错误是个class所有的错误类型都继承自 BaseException，如果捕获到了一个父类错误，其子类错误不会被捕获。例如： 123456try: foo()except ValueError as e: print(&#x27;ValueError&#x27;)except UnicodeError as e: print(&#x27;UnicodeError&#x27;) 第二个except永远捕获不到 UnicodeError，因为UnicodeError是ValueError的子类。即使有UnicodeError，也被第一个except捕获了。 错误类继承关系12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StopAsyncIteration +-- AttributeError 属性错误 +-- AssertionError 断言错误 +-- BufferError 缓冲错误 +-- EOFError 文件结束符错误 +-- MemoryError 内存错误 +-- ReferenceError +-- SystemError 系统错误 +-- TypeError 类型错误 +-- ArithmeticError 算术错误 | +-- FloatingPointError | +-- OverflowError | +-- ZeroDivisionError +-- ImportError 导入错误 | +-- ModuleNotFoundError +-- LookupError | +-- IndexError | +-- KeyError +-- NameError 命名错误 | +-- UnboundLocalError +-- OSError 操作系统错误 | +-- BlockingIOError IO阻塞错误 | +-- ChildProcessError 子进程错误 | +-- ConnectionError | | +-- BrokenPipeError | | +-- ConnectionAbortedError | | +-- ConnectionRefusedError | | +-- ConnectionResetError | +-- FileExistsError | +-- FileNotFoundError | +-- InterruptedError | +-- IsADirectoryError | +-- NotADirectoryError | +-- PermissionError | +-- ProcessLookupError | +-- TimeoutError +-- RuntimeError 运行时错误 | +-- NotImplementedError | +-- RecursionError +-- SyntaxError 同步错误 | +-- IndentationError | +-- TabError +-- ValueError 值错误 | +-- UnicodeError | +-- UnicodeDecodeError | +-- UnicodeEncodeError | +-- UnicodeTranslateError +-- Warning 警告 +-- DeprecationWarning +-- PendingDeprecationWarning +-- RuntimeWarning +-- SyntaxWarning +-- UserWarning +-- FutureWarning +-- ImportWarning +-- UnicodeWarning +-- BytesWarning +-- ResourceWarning 抛出错误错误是 class， 捕获错误实质上就是捕获到该 class 的一个实例。因此，错误是可以有意创建并抛出的。 try...except...是承接错误，而raise是抛出错误 123456789101112131415161718192021222324def register(): username = input(&quot;请输入用户名：&quot;) if len(username) &lt; 6: raise Exception(&quot;用户名长度必须6位以上&quot;) else: print(&quot;输入的用户名是:&quot;, username)register()--------------------------------------------------# Output1:请输入用户名：adminTraceback (most recent call last): File &quot;d:/---Programming---/Python/Project/mo2.py&quot;, line 9, in &lt;module&gt; register() File &quot;d:/---Programming---/Python/Project/mo2.py&quot;, line 4, in register raise Exception(&quot;用户名长度必须6位以上&quot;)Exception: 用户名长度必须6位以上# Output2:请输入用户名：administor输入的用户名是: administor 在 if 中主动raise抛出错误，但是调用register()的地方没有try...except来捕获错误，所以最后由解释器处理，打印出了错误信息 1234567891011121314151617181920212223242526def register(): username = input(&quot;请输入用户名：&quot;) if len(username) &lt; 6: raise Exception(&quot;用户名长度必须6位以上&quot;) else: print(&quot;输入的用户名是：&quot;, username)try: register()except Exception as e: print(e) print(&quot;注册失败&quot;)else: print(&quot;注册成功&quot;)--------------------------------------------------# Output1:请输入用户名：admin用户名长度必须6位以上注册失败# Output2:请输入用户名：administor输入的用户名是: administor注册成功 在 if 处 raise抛出错误，在register()使用了try...except捕获错误，然后进行了处理。 自定义错误主动抛出错误，这个错误可以是自己定义的 class，因为错误也是 class。 1234567891011121314151617181920212223242526272829class NameUndercutting(Exception): passdef register(): username = input(&quot;请输入用户名：&quot;) if len(username) &lt; 6: raise Exception(&quot;用户名长度必须6位以上&quot;) else: print(&quot;输入的用户名是：&quot;, username)try: register()except NameUndercutting as e: print(e) print(&quot;注册失败&quot;)else: print(&quot;注册成功&quot;)--------------------------------------------------# Output1:请输入用户名：admin用户名长度必须6位以上注册失败# Output2:请输入用户名：administor输入的用户名是: administor注册成功","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"错误与调试","slug":"Python/进阶/错误与调试","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B0%83%E8%AF%95/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-6】函数","slug":"Python/Basic/Python【No-6】函数","date":"2020-07-07T03:17:48.000Z","updated":"2021-07-19T10:05:06.814Z","comments":true,"path":"posts/9049.html","link":"","permalink":"https://www.boii.xyz/posts/9049.html","excerpt":"一等公民：函数","text":"一等公民：函数 定义函数123def functionName(paramters): function body [return] 调用函数1funcName([paras]) 返回值 不管有没有 return 函数都会返回有 return 时函数返回相应的值没有 return 时函数返回 None return None 可以简写为 return 返回多个值python 函数可以返回多个值但其本质其实是返回一个多元素的Tuple，因为语法上tuple可以省略括号，所以看起来像返回多个值如果显式的返回一个list，dict，tuple，set，则是返回值本身 1234567891011121314import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(x, y)151.96152422706632 70.0&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(r)(151.96152422706632, 70.0) 空函数 空函数可以作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。 12def func(): pass 参数参数检查 python解释器会检查参数 个数 ，但不会检查参数 类型类型检查需要自己做可以使用内置函数 isinstance(obj,class_of_tuple) 并抛出错误 12345678def my_abs(x): return x if x &gt;= 0 else -x# 添加检查类型def my_abs(x): if not isinstance(x, (int, float)): # 检查类型 raise TypeError(&#x27;bad operand type&#x27;) # 抛出错误 return x if x &gt;= 0 else -x isinstance() isinstance(被检查对象,检查类型元组)isinstance() 接受两个参数，第一个是被检查对象，第二个是要求的类型元组类型元组中只要有一个被满足，则返回True，反之返回False 默认参数、可变参数和关键字参数默认参数 = def funcName( [para1 ... ,] paraN = defaultValue)当参数的值不确定的时候，就可以使用默认参数 默认参数 para1 = defaultValue 必须放在最后面当有多个默认参数的情况下，想指定某个默认参数不使用默认，可以将默认参数的形参名带上默认参数必须指向不变对象！ 12345678910111213def power(x,n=2): s = 1 while n &gt; 0: s *= x n -= 1 return s&gt;&gt;&gt; power(5)25&gt;&gt;&gt; power(5, 2)25&gt;&gt;&gt; power(5, 3)125 当有多个默认参数的情况下，想指定某个默认参数不使用默认，可以将默认参数的形参名带上 1234567891011121314151617181920212223242526def enroll(name, gender, age=6, city=&#x27;SWA&#x27;): print(name) print(gender) print(age) print(city)&gt;&gt;&gt; enroll(&#x27;Boii&#x27;, &#x27;M&#x27;, 23, &#x27;BJ&#x27;)BoiiM23BJ&gt;&gt;&gt; enroll(&#x27;Boii&#x27;, &#x27;M&#x27;, 23)BoiiM23SWA&gt;&gt;&gt; enroll(&#x27;Boii&#x27;, &#x27;M&#x27;, city=&#x27;NJ&#x27;)BoiiM6NJ&gt;&gt;&gt; enroll(&#x27;Boii&#x27;, &#x27;M&#x27;)BoiiM6SWA 默认参数必须指向不变对象！ 1234567891011121314def add_end(L=[]): L.append(&#x27;END&#x27;) return L&gt;&gt;&gt; add_end([1,2,3])[1,2,3,&#x27;END&#x27;]&gt;&gt;&gt; add_end([&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;])[&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;END&#x27;]# 坑来了&gt;&gt;&gt; add_end()[&#x27;END&#x27;] # 这里还是正常的&gt;&gt;&gt; add_end()[&#x27;END&#x27;, &#x27;END&#x27;] # 这里就不正常了 猜测可能是python内部在使用默认参数的时候会创建对象，比如这个list，但是这个对象不会被销毁导致的 改进： 12345678910def add_end(L=None) if L is None: L = [] L.append(&#x27;END&#x27;) return L &gt;&gt;&gt; add_end()[&#x27;END&#x27;]&gt;&gt;&gt; add_end()[&#x27;END&#x27;] 可变参数 * 可变参数可以接收 0~N个参数 def funcName( [para1 ... ,] *paraN)当参数的个数不确定的时候，就可以使用可变参数 *paraN形参和实参都可以使用可变参数。形参 使用可变参数，则是告诉调用者我可以接受0~N个参数，实参 使用可变参数，则是告诉函数我已经打包好了。 可变参数的 实际原理：其实可变参数在函数被调用时，将所有参数自动打包成一个tuple，然后传递给函数函数接收到之后再解构这个tuple，或者通过 for 迭代 遍历这个tuple来使用里面的元素 12345678910111213141516def calc(*numbers): # 形参 使用可变参数，则是告诉调用者我可以接受0~N个参数 sum = 0 for n in numbers: sum += n*n return sum&gt;&gt;&gt; calc(1, 2)5&gt;&gt;&gt; calc()0&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(nums[0], nums[1], nums[2]) # 这种分散一个个的参数在传递之前也是被自动打包成一个tuple的14&gt;&gt;&gt; calc(*nums) # 实参 使用可变参数，则是告诉函数我已经打包好了14 关键字参数 ** 这种方式，调用者可以传入 0~N 个关键字参数，关键字 key 随意 def funcName( [para1 ... ,] **key_paraN)即通过关键字来指定参数，或者说通过键-值对的方式来传实参而在函数里，形参 关键字参数 **paraN 将传过来的这些键-值对打包成一个dict 其原理跟可变参数类似 可变参数 *paraN 是把 除了必选参数外的所有参数 打包成一个tuple传给函数 关键字参数 **paraN 是把 除了必选参数外的所有参数 打包成一个dict传给函数 之后函数内部可以通过 for 迭代 遍历这个dict来使用里面的键-值对因为是使用键-值对的方式，所以传参时的 传给关键字参数的参数顺序是无所谓的 123456789101112131415161718192021222324def person(name, age, **kv): print(&#x27;name:&#x27;, name, &#x27;--&#x27; , &#x27;age:&#x27;, age, &#x27;--&#x27; , &#x27;other:&#x27; kv)# 只填必选参数的调用方法&gt;&gt;&gt; person(&#x27;Boii&#x27;, 23)name: Boii -- age: 23 -- other: &#123;&#125;# 填了必选参数和自定义参数的调用方法&gt;&gt;&gt; person(&#x27;Boii&#x27;, 23, city=&#x27;SWA&#x27;)name: Boii -- age: 23 -- other: &#123;&#x27;city&#x27;:&#x27;SWA&#x27;&#125;&gt;&gt;&gt; person(&#x27;Adam&#x27;, 45, gender=&#x27;M&#x27;, job=&#x27;Engineer&#x27;)name: Adam -- age: 45 -- other: &#123;&#x27;gender&#x27;: &#x27;M&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;# 关键字实参的顺序无所谓&gt;&gt;&gt; person(&#x27;Adam&#x27;, 45, job=&#x27;Engineer&#x27;, gender=&#x27;M&#x27;)name: Adam -- age: 45 -- other: &#123;&#x27;job&#x27;: &#x27;Engineer&#x27;, &#x27;gender&#x27;: &#x27;M&#x27;&#125;# 还可以自己把参数打包成dict，然后传给函数, 原理和可变参数类似&gt;&gt;&gt; d = &#123;&#x27;job&#x27;: &#x27;Engineer&#x27;, &#x27;gender&#x27;: &#x27;M&#x27;&#125;&gt;&gt;&gt; person(&#x27;Adam&#x27;, 45, **d)name: Adam -- age: 45 -- other: &#123;&#x27;job&#x27;: &#x27;Engineer&#x27;, &#x27;gender&#x27;: &#x27;M&#x27;&#125; 命名关键字参数 *， def funcName( [para1 ... ,] *, key_paraN)对比关键字参数 ↓def funcName( [para1 ... ,] **key_paraN) 区别于关键字参数： 如果想要求调用者在调用的时候必须用你给的 key，则可以用 命名关键字参数 *, key_paraN 这种方式，调用者必须 遵循个数 和 关键字 123456789101112131415161718def person(*, city, nationality): print(&#x27;city:&#x27;, city) print(&#x27;nationality:&#x27;, nationality)&gt;&gt;&gt; person(city=&#x27;SWA&#x27;, nationality=&#x27;China&#x27;)city: SWAnationality: China&gt;&gt;&gt; person(nationality=&#x27;China&#x27;, city=&#x27;SWA&#x27;)city: SWAnationality: China# 错误示例&gt;&gt;&gt; person()TypeError: person() missing 2 required keyword-only arguments: &#x27;city&#x27; and &#x27;nationality&#x27;&gt;&gt;&gt; person(&#x27;SWA&#x27;, &#x27;China&#x27;)TypeError: person() takes 0 positional arguments but 2 were given 123456789101112131415161718192021def person(name, age, *, city, nationality): print(&#x27;name:&#x27;, name) print(&#x27;age:&#x27;, age) print(&#x27;city:&#x27;, city) print(&#x27;nationality:&#x27;, nationality)&gt;&gt;&gt; person(&#x27;Boii&#x27;, 23, city=&#x27;SWA&#x27;, nationality=&#x27;China&#x27;)name: Boiiage: 23city: SWAnationality: China&gt;&gt;&gt; person(&#x27;Boii&#x27;, 23, nationality=&#x27;China&#x27;, city=&#x27;SWA&#x27;)name: Boiiage: 23city: SWAnationality: China# 错误示例&gt;&gt;&gt; person(city=&#x27;SWA&#x27;, nationality=&#x27;China&#x27;)TypeError: person() missing 2 required positional arguments: &#x27;name&#x27; and &#x27;age&#x27; 参数组合 在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 123456789101112131415161718192021def f1(a, b, c=0, *args, **kw): print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;args =&#x27;, args, &#x27;kw =&#x27;, kw)def f2(a, b, c=0, *, d, **kw): print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;d =&#x27;, d, &#x27;kw =&#x27;, kw)&gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27;)a = 1 b = 2 c = 3 args = (&#x27;a&#x27;, &#x27;b&#x27;) kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27;, x=99)a = 1 b = 2 c = 3 args = (&#x27;a&#x27;, &#x27;b&#x27;) kw = &#123;&#x27;x&#x27;: 99&#125;&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = &#123;&#x27;ext&#x27;: None&#125; 最神奇的是通过一个tuple和dict，你也可以调用上述函数： 1234567891011121314151617181920def f1(a, b, c=0, *args, **kw): print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;args =&#x27;, args, &#x27;kw =&#x27;, kw)def f2(a, b, c=0, *, d, **kw): print(&#x27;a =&#x27;, a, &#x27;b =&#x27;, b, &#x27;c =&#x27;, c, &#x27;d =&#x27;, d, &#x27;kw =&#x27;, kw)&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = &#123;&#x27;d&#x27;: 99, &#x27;x&#x27;: &#x27;#&#x27;&#125;&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = &#123;&#x27;d&#x27;: 99, &#x27;x&#x27;: &#x27;#&#x27;&#125;&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = &#123;&#x27;d&#x27;: 88, &#x27;x&#x27;: &#x27;#&#x27;&#125;&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = &#123;&#x27;x&#x27;: &#x27;#&#x27;&#125; 所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。！！虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。 递归函数 自己调用自己递归要素： 自己调用自己 有判断条件 （没判断就死循环了，会导致溢出） 有变量迭代 （没变量迭代就死循环了） 1234567def fact(n): return 1 if n == 1 else n * fact(n-1)&gt;&gt;&gt; fact(5)120&gt;&gt;&gt; fact(10)3628800 计算 fact(5) 的时候 ===&gt; fact(5)===&gt; 5 * fact(4)===&gt; 5 * (4 * fact(3))===&gt; 5 * (4 * (3 * fact(2)))===&gt; 5 * (4 * (3 * (2 * fact(1))))===&gt; 5 * (4 * (3 * (2 * 1)))===&gt; 5 * (4 * (3 * 2))===&gt; 5 * (4 * 6)===&gt; 5 * 24===&gt; 120","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"基础","slug":"Python/基础","permalink":"https://www.boii.xyz/categories/Python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-5】运算符","slug":"Python/Basic/Python【No-5】运算符","date":"2020-07-06T09:28:48.000Z","updated":"2021-07-19T10:05:06.695Z","comments":true,"path":"posts/11720.html","link":"","permalink":"https://www.boii.xyz/posts/11720.html","excerpt":"基础难点：运算符","text":"基础难点：运算符 算术运算符以下假设变量a为10，变量b为21： 运算符 描述 实例 + 加 两个对象相加 a + b 输出结果 31 - 减 得到负数或是一个数减去另一个数 a - b 输出结果 -11 * 乘 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 210 / 除 x 除以 y b / a 输出结果 2.1 % 取模 返回除法的余数 b % a 输出结果 1 ** 幂 返回x的y次幂 a**b 为10的21次方 // 取整除 向下取接近商的整数 -9//2输出结果为-5 比较运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 == 等于 比较对象是否相等 (a == b) 返回 False。 != 不等于 比较两个对象是否不相等 (a != b) 返回 True。 &gt; 大于 返回x是否大于y (a &gt; b) 返回 False。 &lt; 小于 返回x是否小于y (a &lt; b) 返回 True。 &gt;= 大于等于 返回x是否大于等于y。 (a &gt;= b) 返回 False。 &lt;= 小于等于 返回x是否小于等于y。 (a &lt;= b) 返回 True。 所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。 赋值运算符以下假设变量a为10，变量b为20： 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c **= a 等效于 c = c ** a //= 取整除赋值运算符 c //= a 等效于 c = c // a := 海象运算符，可在表达式内部为变量赋值。 海象运算符/成为运算符/命名表达式运算符例1 1234567age = 20if age&gt; 18: print(&#x27;Adult&#x27;)# 使用海象if (age := 20) &gt; 18: print(&#x27;Adult&#x27;) 例2 123456789L = [1, 2, 3]n = len(L)if n &gt; 2: print(&#x27;Length of L is&#x27;, len(L))# 使用海象L = [1, 2, 3]if (n := len(L)) &gt; 2: print(&#x27;Length of L is&#x27;, n) 可以理解为 len(L) 的返回值赋值给n，然后判断 n&gt;2这样做的好处可以提升运行效率 因为在需要多次调用函数这种会降低运行效率的时候我们通常会减少相同的函数调用，将函数调用后的返回值保存在一个变量里然后 频繁调用函数 换成 频繁使用这个变量 但是这样就需要多一行保存返回值的表达式而 海象运算符 或者说 成为运算符 则兼顾了两者，即使用了变量保存返回值，又不用多一行代码。 12345678910n = 0while n &lt; 3: print(n) # 0,1,2 n += 1 # 当转换为海象运算符时w = 0while (w := w + 1) &lt; 3: print(w) # 1,2 12345678while True: p = input(&quot;Enter the password: &quot;) if p == &quot;the password&quot;: break # 当转换为海象运算符时while (p := input(&quot;Enter the password: &quot;)) != &quot;the password&quot;: continue 位运算符按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：下表中变量 a 为 60，b 为 13二进制格式如下： 12345678910111213a = 0011 1100 # 60b = 0000 1101 # 13-----------------a&amp;b = 0000 1100 # 12a|b = 0011 1101 # 61a^b = 0011 0001 # 49~a = 1100 0011 # 195 运算符 描述 实例 &amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a &amp; b) 输出结果 12 ，二进制解释： 0000 1100 | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a| b) 输出结果 61 ，二进制解释： 0011 1101 ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。 &lt;&lt; 左移动运算符：运算数的各二进位全部左移N位.高位丢弃，低位补0。 a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000 &gt;&gt; 右移动运算符：运算数的各二进位全部右移N位， a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111 a &lt;&lt; 1 等价于 a * 2a &lt;&lt; 2 等价于 a * 2 * 2a &gt;&gt; 1 等价于 a / 2a &gt;&gt; 2 等价于 a / 2 / 2a ^= a 等价于 a = a ^ a 等价于置零 a = 0a = a ^ (~a) + 1 等价于置零 a = 0~a + 1 为a的补码 逻辑运算符Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 成员运算符除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 身份运算符身份运算符用于比较两个对象的存储单元 运算符 描述 实例 is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。 id() id() 函数用于获取对象内存地址 12345678#id()&gt;&gt;&gt;a = &#x27;runoob&#x27;&gt;&gt;&gt; id(a)4531887632&gt;&gt;&gt; b = 1&gt;&gt;&gt; id(b)140588731085608 三目运算符 true if expression else flase满足表达式时 if 表达式 else 不满足表达式时 12345678&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 2&gt;&gt;&gt; h = a + b if a &lt; b else a - b&gt;&gt;&gt; h3&gt;&gt;&gt; q = (a + b) if (a &lt; b) else (a - b)&gt;&gt;&gt; q3 运算符优先级以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~、+、- 按位取反、正、负 *、/、%、// 乘，除，求余数和取整除 +、- 加、减 &lt;&lt;、&gt;&gt; 左移、右移 &amp; 按位与 ^、| 按位异或、按位或 &lt;=、&lt;、&gt;、&gt;= 比较运算符 ==、!= 等于运算符 =、%=、/=、//=、-=、+=、*=、**= 赋值运算符 is、is not 身份运算符 in、not in 成员运算符 and、or、not 逻辑运算符","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"基础","slug":"Python/基础","permalink":"https://www.boii.xyz/categories/Python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-4】数据类型","slug":"Python/Basic/Python【No-4】数据类型","date":"2020-07-05T13:41:48.000Z","updated":"2021-07-19T10:05:06.563Z","comments":true,"path":"posts/39690.html","link":"","permalink":"https://www.boii.xyz/posts/39690.html","excerpt":"基础知识：数据类型","text":"基础知识：数据类型 常见内置类型 内置类型：None（全局只有一个）数值类型：int、float、complax（复数）、bool迭代类型序列类型：list、bytes、range、tuple、string、array映射类型：dict集合类型：set、frozenset上下文管理类型：with 可变类型：list、set、dict不可变类型：int、float、string、tuple 基本数据类型整型可以是任意大小的整数与数学上的表示方法一样 如：1，100，-800，0可以用十六进制表示法 如：0xFF00, 0xab54f 常用基本运算 加（+） 减（-） 乘（*） 除（/） 模（%） 1234567891011121314&gt;&gt;&gt; 3 + 25&gt;&gt;&gt; 3 - 21&gt;&gt;&gt; 3 * 26&gt;&gt;&gt; 3 / 21.5&gt;&gt;&gt; 2 + 3 * 414&gt;&gt;&gt; (2 + 3) * 420&gt;&gt;&gt; 17 % 32 除法运算 （/）永远返回浮点型 12&gt;&gt;&gt; 9 / 33.0 乘方（**） 截断除法、整数除（//） 123456&gt;&gt;&gt; 3 ** 29&gt;&gt;&gt; 3 ** 327&gt;&gt;&gt; 17 // 35 包含多种混合类型运算数的运算会把整数转换为浮点数 12&gt;&gt;&gt; 4 * 3.75 - 114.0 浮点数即小数 如：1.2，524.33，-9.11如果是很大或很小的浮点数，必须用科学计数法表示，用e+指数代替底数 10^指数，如： 1.23×10^9 就是 1.23e9 或 12.3e8， 0.000012 就是 1.2e-5浮点数运算可能会有四舍五入的误差 字符串123456str1 = &#x27;OK&#x27; # OKstr2 = &quot;OK&quot; # OKstr3 = &quot;I&#x27;m ok.&quot; # I&#x27;m ok.str4 = &#x27;I\\&#x27;m ok.&#x27; # I&#x27;m ok.str5 = &quot;I\\&quot;m ok.&quot; # I&quot;m ok.str6 = &#x27;I&quot;m ok.&#x27; # I&quot;m ok. 1234567891011str7 = &#x27;&#x27;&#x27;这是一个段落，所以可以直接换行，不需反斜杠来声明语句未结束 直到遇到下一个三单引号，才认为结束但是换行会跟着换行，空格会跟着空格&#x27;&#x27;&#x27;&quot;&quot;&quot;str7输出为：这是一个段落，所以可以直接换行，不需反斜杠来声明语句未结束 直到遇到下一个三单引号，才认为结束但是换行会跟着换行，空格会跟着空格&quot;&quot;&quot; 12345678910111213141516\\n 换行 \\t 缩进# 使用转义字符str8 = &#x27;ab\\ncd&#x27;&#x27;&#x27;&#x27;str8输出为：abcd&#x27;&#x27;&#x27;r&#x27;字符串&#x27; 表示不转义# 不转义str9 = r&#x27;ab\\ncd&#x27; # ab\\ncd 转义字符 转义字符 描述 \\ 续行符 \\ 反斜杠 &#39; 单引号 &quot; 双引号 \\a 响铃 \\b 退格 \\e 转义 \\000 空 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车 \\f 换页 \\o 八进制 \\x 十六进制 布尔值 True False 可以用 and , or , not 运算 空值 空值是一个特殊的值，用 None 表示。None 不等于 0，0 是有意义的.全局只有一个None 复合数据类型列表 List 一种有序的、可变的 元素集合用 [ ] 标识 可随机添加和删除其中的元素可理解为可变的数组是一种复合数据类型List 中的元素可以不同类型区别于元组Tuple：List 中的元素可变 123&gt;&gt;&gt; name = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;]&gt;&gt;&gt; print(name)[&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;] List索引123| P | y | t | h | o | n | 0 1 2 3 4 5 # 从左往右，下标从0开始 -6 -5 -4 -3 -2 -1 # 从右往左，下标从-1开始 List的增删改查初始化 listName = [element1, element2, element3, …] 增追加到末尾 append listName.append(value) 1234&gt;&gt;&gt; name = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;]&gt;&gt;&gt; name.append(&#x27;Fit&#x27;)&gt;&gt;&gt; name[&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;, &#x27;Fit&#x27;] 插入到指定位置 insert listName.insert(index, value) 1234&gt;&gt;&gt; name = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;]&gt;&gt;&gt; name.insert(3, &#x27;Fit&#x27;)&gt;&gt;&gt; name[&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Fit&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;] 删删除末尾元素 pop listName.pop() 123456&gt;&gt;&gt; name = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;]&gt;&gt;&gt; &gt;&gt;&gt; name.pop()&#x27;Eva&#x27;&gt;&gt;&gt; name[&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;] 删除指定位置元素 pop listName.pop(index)或del listName[index] 1234567&gt;&gt;&gt; name = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;]&gt;&gt;&gt; name.pop(3)&#x27;Dannie&#x27;&gt;&gt;&gt; name[&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Eva&#x27;]&gt;&gt;&gt; del name[2][&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Eva&#x27;] 改 修改某个元素，直接给该元素赋新值即可listName[index] = value 12345&gt;&gt;&gt; name = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;]&gt;&gt;&gt; &gt;&gt;&gt; name[2] = &#x27;Cai&#x27;&gt;&gt;&gt; name[&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Cai&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;] 查 使用下标来访问List中的元素listName[index] 12345name = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;]print(name[0]) # &#x27;Alice&#x27; 访问List第一个元素print(name[1]) # &#x27;Boii&#x27; 访问List第二个元素print(name[-1]) # &#x27;Eva&#x27; 访问List最后一个元素 获得长度 len() len(List名) 123&gt;&gt;&gt; name = [&#x27;Alice&#x27;, &#x27;Boii&#x27;, &#x27;Chen&#x27;, &#x27;Dannie&#x27;, &#x27;Eva&#x27;]&gt;&gt;&gt; len(name)5 List中元素可以不同类型123&gt;&gt;&gt; L = [&#x27;Boii&#x27;, 23, True, &#x27;https://tcp404.com&#x27;]&gt;&gt;&gt; L[&#x27;Boii&#x27;, 23, True, &#x27;https://tcp404.com&#x27;] List嵌套List 类似于多维数组的概念 12345&gt;&gt;&gt; l_main = [&#x27;Boii&#x27;, 23, [&#x27;https://&#x27;, &#x27;tcp404&#x27;, &#x27;.com&#x27;], 443]&gt;&gt;&gt; len(l_main)4&gt;&gt;&gt; len(l_main[2])3 等价于 1234567&gt;&gt;&gt; l_sub = [&#x27;https://&#x27;, &#x27;tcp404&#x27;, &#x27;.com&#x27;]&gt;&gt;&gt; l_main = [&#x27;Boii&#x27;, 23, l_sub, 443]#获取 tcp404可以用一下方式&gt;&gt;&gt; l_main[2][1]&#x27;tcp404&#x27; 空List123456&gt;&gt;&gt; L = []&gt;&gt;&gt; len(L)0&gt;&gt;&gt; li = list()&gt;&gt;&gt; len(li)0 元组 Tuple 一种 有序的、不可变的 元素集合用 ( ) 标识 Tuple中的元素一旦初始化就不可变可理解为不可变的数组是一种复合数据类型Tuple中的元素可以不同类型区别于List：Tuple 中的元素 不可变 初始化 tupleName = (elem1, elem2, elem3, …) Tuple索引123| P | y | t | h | o | n | 0 1 2 3 4 5 # 从左往右，下标从0开始 -6 -5 -4 -3 -2 -1 # 从右往左，下标从-1开始 Tuple的增删改查 Tuple不可变，所以不可以 增加、删除、修改，只能查询查询与List相同 查 tupleName[index] 1234567&gt;&gt;&gt; T = (1, 2, &#x27;Boii&#x27;)&gt;&gt;&gt; T[2]&#x27;Boii&#x27;&gt;&gt;&gt; T[0]1&gt;&gt;&gt; T(1, 2, &#x27;Boii&#x27;) 空Tuple ()123&gt;&gt;&gt; tr = ()&gt;&gt;&gt; tr() 定义单元素的Tuple (element，) 为避免与数学的括号混淆，定义一个元素的Tuple时，要在元素后加上逗号 123&gt;&gt;&gt; tr = (&#x27;Boii&#x27;,)&gt;&gt;&gt; tr(&#x27;Boii&#x27;,) 且在python解释中： tr = (1) 会被认为是 tr = 1, tr 就变成一个普通的整型变量 tr = (‘Boii’) 会被认为是 tr = ‘Boii’, tr 就变成一个普通的字符串变量 1234567891011&gt;&gt;&gt; tr = (1) # 等价于 tr = 1&gt;&gt;&gt; tr1&gt;&gt;&gt; tr = (&#x27;Boii&#x27;) # 等价于 tr = &#x27;Boii&#x27;&gt;&gt;&gt; tr&#x27;Boii&#x27;&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; tr = (&#x27;Boii&#x27;,) # √ 正确定义单元素Tuple&gt;&gt;&gt; tr(&#x27;Boii&#x27;,) Tuple不可变的意义 因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 ！！！不可变Tuple中的可变元素 Tuple的不可变指的是Tuple指向的元素不可变如果元素中有 可变的Listlist ，那么Tuple依然可以修改 12345&gt;&gt;&gt; t = (&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;A&#x27;, &#x27;B&#x27;])&gt;&gt;&gt; t[2][0] = &#x27;X&#x27;&gt;&gt;&gt; t[2][1] = &#x27;Y&#x27;&gt;&gt;&gt; t(&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;X&#x27;, &#x27;Y&#x27;]) 定义Tuplet时 修改Tuplet的元素后 字典 Dict 一种 无序的、可变的 键-值对集合用 &#123; &#125; 标识 键key 必须是不可变对象 （如字符串、整数。而list，tuple这些不可以作为key）键key 不可以重复键key 可以不同类型，但不建议键key 可以是变量，但是这个变量必须指向字符串、整数这类不可变对象 Dictionary VS List Dict 查找和插入的速度极快，不会随着key的增加而变慢； Dict 需要占用大量的内存，内存浪费多。 List 查找和插入的时间随着元素的增加而增加； List 占用空间小，浪费内存很少。 初始化 dictName = { key1 : value1, key2 : value2, key3 : value3, … } 1234d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;# 键可以不同类型dd = &#123;&#x27;a&#x27;:&#x27;Alice&#x27;, &#x27;b&#x27;:&#x27;Boii&#x27;, 18:&#x27;Kk&#x27;&#125; Dict索引 Dict的索引就是 键key。 Dict的增删改查和判断增 dictName[key] = value 1234567891011&gt;&gt;&gt; d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;&gt;&gt;&gt; d[&#x27;AC&#x27;] = &#x27;diu&#x27;&gt;&gt;&gt; d&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4, &#x27;AC&#x27;:&#x27;diu&#x27;&#125;# 使用变量作为key&gt;&gt;&gt; d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;&gt;&gt;&gt; a = &#x27;x&#x27;&gt;&gt;&gt; d[a] = &#x27;what&#x27;&gt;&gt;&gt; d&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4, &#x27;x&#x27;:&#x27;what&#x27;&#125; 删 pop、del dictName.pop(key)del dictName[key] 123456&gt;&gt;&gt; d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;&gt;&gt;&gt; d.pop(&#x27;a&#x27;)&#123;&#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;&gt;&gt;&gt; del d[&#x27;c&#x27;]&#123;&#x27;b&#x27;: 2, &#x27;d&#x27;: 4&#125; 改 dictName[key] = newValue因为key不能重复，所以如果key不存在，会变成添加，如果key存在，newValue会覆盖oldValue 1234567&gt;&gt;&gt; d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;&gt;&gt;&gt; d[&#x27;a&#x27;] = 25&gt;&gt;&gt; d&#123;&#x27;a&#x27;: 25, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;&gt;&gt;&gt; d[&#x27;e&#x27;] = 15&gt;&gt;&gt; d&#123;&#x27;a&#x27;: 25, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4, &#x27;e&#x27;: 15&#125; 查 get dictName.get(key)如果key存在，返回对应的value如果key不存在，返回None 123d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;d.get(&#x27;a&#x27;) # 1d.get(&#x27;z&#x27;) # None dictName.get(key, return)如果key存在，返回对应的value如果key不存在，返回指定的返回值return，return可以是整型、字符串，甚至是List等 12345678910&gt;&gt;&gt; d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;&gt;&gt;&gt; &gt;&gt;&gt; d.get(&#x27;z&#x27;, 0)0&gt;&gt;&gt; d.get(&#x27;z&#x27;, &#x27;No This Key&#x27;)&#x27;No This Key&#x27;&gt;&gt;&gt; d.get(&#x27;z&#x27;, [0, 0])[0, 0]&gt;&gt;&gt; d.get(&#x27;z&#x27;, &#123;1:&#x27;a&#x27;, 2:&#x27;b&#x27;&#125;)&#123;1:&#x27;a&#x27;, 2:&#x27;b&#x27;&#125; 判断 in、not in key in dictName 12345&gt;&gt;&gt; d = &#123;&#x27;a&#x27;: 25, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;&gt;&gt;&gt; &#x27;b&#x27; in dTrue&gt;&gt;&gt; &#x27;z&#x27; in dFalse 集合 Set 一种 无序的、不重复的、可变的 的元素的集合用 set([ ]) 或 &#123;key, key, ...&#125; 标识 类似数学概念中的集合可以通过 Dict 来理解：Set 是一种不存储 value 的 Dict（因为key不能重复）是一种复合数据类型Set 中的元素可以不同类型 Set索引 Set 是无序的，所以没有索引，只有元素，或者说只有key 初始化 setName = set(key_list)setName = {key1, key2, key3, …} 1234567891011&gt;&gt;&gt; s1 = set([1, 2, 3, &#x27;a&#x27;, (32, &#x27;a&#x27;, False), 55])&gt;&gt;&gt; s1&#123;1, 2, 3, 55, (32, &#x27;a&#x27;, False), &#x27;a&#x27;&#125;&gt;&gt;&gt; s2 = set(&#x27;abadfgaae&#x27;)&gt;&gt;&gt; s2&#123;&#x27;g&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;d&#x27;, &#x27;a&#x27;&#125;&gt;&gt;&gt; s3 = &#123;1,2,3,4,4,4,5,5&#125;&gt;&gt;&gt; s3&#123;1, 2, 3, 4, 5&#125; Set的增删改查增 add、update setName.add(key) 只能添加基本数据类型setName.update(key) 可以添加基本数据类型和复合数据类型 123456789&gt;&gt;&gt; s3 = set([1,2,3,4,4,4,5,5])&gt;&gt;&gt; s3.add(7)&gt;&gt;&gt; s3&#123;1, 2, 3, 4, 5, 7&#125;&gt;&gt;&gt; s3.update([&#x27;a&#x27;, &#x27;b&#x27;])&gt;&gt;&gt; s3&#123;1, 2, 3, 4, 5, 7, &#x27;a&#x27;, &#x27;b&#x27;&#125; 删除 remove、discard、pop setName.remove(key) 删除指定元素，如果元素不存在会存在错误setName.discard(key) 删除指定元素，如果元素不存在不会存在错误setName.pop() 随机删除一个元素 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; s = set([1, 2, 3, 4, 7, 4, 15, 4, 5, 5])&gt;&gt;&gt; s&#123;1, 2, 3, 4, 5, 7, 15&#125;&gt;&gt;&gt; s.remove(5)&gt;&gt;&gt; s&#123;1, 2, 3, 4, 7, 15&#125;&gt;&gt;&gt; s.remove(20)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 20&gt;&gt;&gt; s.discard(15)&gt;&gt;&gt; s&#123;1, 2, 3, 4, 7&#125;&gt;&gt;&gt; s.discard(20)&gt;&gt;&gt;&gt;&gt;&gt; s.pop()4&gt;&gt;&gt; s&#123;2, 3, 1, 7&#125;&gt;&gt;&gt; s.pop()3&gt;&gt;&gt; s&#123;2, 1, 7&#125;&gt;&gt;&gt; s.pop()2&gt;&gt;&gt; s&#123;1, 7&#125; 改 remove + add Set 中没有改的办法，因为集合是无序的，改一个元素没有意义只能删除要改的key，然后添加新的key setName.remove(key)setName.add(key) 查强制类型转换 函数 描述 int(x [,base]) 将x转换为一个整数 long(x [,base] ) 将x转换为一个长整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个Tuple list(s) 将序列 s 转换为一个List set(s) 转换为可变集合 dict(d) 创建一个Dict。d 必须是一个序列 (key,value)Tuple。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 unichr(x) 将一个整数转换为Unicode字符 ord(x) 将一个字符转换为它的ASCII十进制整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 12345678910111213141516 数字 整数 -1 0 1 浮点 -0.1 0.0 1.0 二进制 0b11 结果 3 八进制 0o77 结果 63 16进制 0xFF 结果 255 字符串 &lt;class &#x27;str&#x27;&gt; 纯字符串 &#x27;str&#x27; &quot;str&quot; &#x27;&#x27;&#x27;str&#x27;&#x27;&#x27; &quot;&quot;&quot;str&quot;&quot;&quot; 字符串数字(二进制 0b) &#x27;0b0&#x27; 转成字符 str(0b10) 结果 &#x27;2&#x27; ## 可以前置补零str(0b00000010) 字符串数字(八进制 0o) &#x27;0o0&#x27; 转换字符 str(0o77) 结果 &#x27;63&#x27; ## 可以前置补零str(0o0077) 字符串数字(十进制) &#x27;0&#x27; 转换字符 str(100) 结果 &#x27;100&#x27; ## 不能前置补零 字符串数字(16进制 0x) &#x27;0x0&#x27; 转换字符 str(0xFF) 结果 &#x27;255&#x27; ## 可以前置补零str(0x00FF)二进制 &lt;class &#x27;bytes&#x27;&gt; 二进制字节表示 b&#x27;&#x27; # ASCII 字符 0-9 a-z A-Z 等 数字 转 字符串1234567891011## 255(10进制) 0b11(2进制) 0xFF(16进制)## (10进制数)&gt;&gt;&gt; bin(255) &#x27;0b11111111&#x27;&gt;&gt;&gt; oct(255) &#x27;0o377&#x27;&gt;&gt;&gt; hex(255) &#x27;0xff&#x27;## (2进制数)&gt;&gt;&gt; bin(0b11) &#x27;0b11&#x27;&gt;&gt;&gt; hex(0xFF) &#x27;0xff&#x27;## (16进制数)&gt;&gt;&gt; bin(0xFF) &#x27;0b11111111&#x27;&gt;&gt;&gt; hex(0xFF) &#x27;0xff&#x27; 字符串 转 数字（十进制数）123456789101112131415## &#x27;123&#x27;(以10进制解析) &#x27;10&#x27;(以2进制解析) &#x27;a&#x27;(以16进制解析)## (10进制表示的字符串)&gt;&gt;&gt; int(&#x27;123&#x27;) 123 ## 十进制字符转十进制数字&gt;&gt;&gt; int(&#x27;123&#x27;,10) 123 ## 默认是十进制## (二进制表示的字符串)&gt;&gt;&gt; int(&#x27;100&#x27;,2) 4 ## 二进制的 100 等于 十进制的 4（可以不加前置 0b）&gt;&gt;&gt; int(&#x27;0b100&#x27;,2) 4 ## 二进制的 100 等于 十进制的 4&gt;&gt;&gt; int(&#x27;0b0100&#x27;,2) 4 ## 可以前置补零## (16进制表示的字符串)&gt;&gt;&gt; int(&#x27;a&#x27;,16) 10 ## 16进制的 a 等于 十进制的 10（可以不加前置 0x）&gt;&gt;&gt; int(&#x27;0xa&#x27;,16) 10 ## 16进制的 a 等于 十进制的 10&gt;&gt;&gt; int(&#x27;0x0a&#x27;,16) 10 ## 16进制的 a 等于 十进制的 10（可以前置补零）&gt;&gt;&gt; int(&#x27;10&#x27;,16) 16 ## 16进制的10 等于 十进制的 16（可以不加前置 0x）&gt;&gt;&gt; int(&#x27;0x10&#x27;,16) 16 ## 16进制的10 等于 十进制的 16&gt;&gt;&gt; int(&#x27;0x0010&#x27;,16) 16 ## 16进制的10 等于 十进制的 16（可以前置补零） 数字 转 数字123456789101112131415## 0b11 0xFF## 十进制 转 十进制&gt;&gt;&gt; int(255) 255 # 无意义操作&gt;&gt;&gt; 255 255 # 无意义操作## 二进制 转 十进制&gt;&gt;&gt; int(0b11) 3 # 可加前置零 int(0b0011)&gt;&gt;&gt; 0b11111111 255 # 等价## 16进制 转 十进制&gt;&gt;&gt; int(0xFF) 255&gt;&gt;&gt; 0xff 255 # 等价 且 忽略大小写&gt;&gt;&gt; 0xFF 255 # 等价 且 忽略大小写## 十进制 转 二进制（使用 数字 转 字节码/字符）255 等价 0b11111111## 十进制 转 16进制（使用 数字 转 字节码/字符）255 等价 0xff 字符串 转 字节码123456789101112&gt;&gt;&gt; bytes(&#x27;abc&#x27;,&#x27;utf-8&#x27;) b&#x27;abc&#x27;&gt;&gt;&gt; bytes(&#x27;编程&#x27;,&#x27;utf-8&#x27;) b&#x27;\\xe7\\xbc\\x96\\xe7\\xa8\\x8b&#x27;&gt;&gt;&gt; bytes(&#x27;Python3编程&#x27;,&#x27;utf-8&#x27;) b&#x27;Python3\\xe7\\xbc\\x96\\xe7\\xa8\\x8b&#x27;&gt;&gt;&gt; &#x27;Python3编程&#x27;.encode(&#x27;UTF-8&#x27;) b&#x27;Python3\\xe7\\xbc\\x96\\xe7\\xa8\\x8b&#x27;&gt;&gt;&gt; S = &#x27;Python3编程&#x27; &#x27;Python3编程&#x27;&gt;&gt;&gt; B = bytes(S,&#x27;utf-8&#x27;) b&#x27;Python3\\xe7\\xbc\\x96\\xe7\\xa8\\x8b&#x27;&gt;&gt;&gt; FMT = str(len(B)) + &#x27;s&#x27; &#x27;13s&#x27;&gt;&gt;&gt; struct.pack(FMT,B) b&#x27;Python3\\xe7\\xbc\\x96\\xe7\\xa8\\x8b&#x27;## 以16进制数字写的字符串，直接转成一样的字节码（2个16进制字符才是一个字节）&gt;&gt;&gt; bytes.fromhex(&#x27;01&#x27;) b&#x27;\\x01&#x27; # 单字节&gt;&gt;&gt; bytes.fromhex(&#x27;0001&#x27;) b&#x27;\\x00\\x01&#x27; # 双字节&gt;&gt;&gt; bytes.fromhex(&#x27;aabbccddeeff&#x27;) b&#x27;\\xaa\\xbb\\xcc\\xdd\\xee\\xff&#x27; # 多字节 字节码 转 字符串1234567## 取出16进制表示的内容&gt;&gt;&gt; b&#x27;abc&#x27;.decode(&#x27;UTF-8&#x27;) &#x27;abc&#x27;&gt;&gt;&gt; b&#x27;Python3\\xe7\\xbc\\x96\\xe7\\xa8\\x8b&#x27;.decode(&#x27;UTF-8&#x27;) &#x27;Python3编程&#x27;&gt;&gt;&gt; b&#x27;\\xaa\\xbb\\xcc\\xdd\\xee\\xff&#x27;.hex() &#x27;aabbccddeeff&#x27;&gt;&gt;&gt; b&#x27;0&#x27;.hex() &#x27;30&#x27; ## 字符0在ASCII码上的数字（数字是16进制表示）== 48（十进制）&gt;&gt;&gt; b&#x27;1&#x27;.hex() &#x27;31&#x27;&gt;&gt;&gt; b&#x27;z&#x27;.hex() &#x27;7a&#x27; 数字 转 字节码（是二进制，用16进制显示）123456789101112131415161718# 10进制数 转 字节码import struct&gt;&gt;&gt; struct.pack(&#x27;B&#x27;,0) b&#x27;\\x00&#x27;&gt;&gt;&gt; struct.pack(&#x27;B&#x27;,1) b&#x27;\\x01&#x27;&gt;&gt;&gt; struct.pack(&#x27;B&#x27;,101) b&#x27;e&#x27; ## 101 对应 16进制的 0x65（此处返回值是显示为当前整数 101 对应的 ASCII字符 e）&gt;&gt;&gt; struct.pack(&#x27;B&#x27;,255) b&#x27;\\xff&#x27; # 无符号最大单字符可以表示的数字&gt;&gt;&gt; struct.pack(&#x27;&gt;i&#x27;,255) b&#x27;\\x00\\x00\\x00\\xff&#x27; # 4字节大端表示的数字&gt;&gt;&gt; struct.pack(&#x27;&lt;i&#x27;,255) b&#x27;\\xff\\x00\\x00\\x00&#x27; # 4字节小端表示的数字# 2进制数 转 字节码import struct&gt;&gt;&gt; struct.pack(&#x27;B&#x27;,0b11111111) b&#x27;\\xff&#x27;&gt;&gt;&gt; struct.pack(&#x27;&gt;i&#x27;,0b111) b&#x27;\\x00\\x00\\x00\\x07&#x27; # 0b111 等于 7（10进制）&gt;&gt;&gt; struct.pack(&#x27;&gt;i&#x27;,0b1111) b&#x27;\\x00\\x00\\x00\\x0f&#x27; # 0b1111 等于 15（10进制）&gt;&gt;&gt; struct.pack(&#x27;&gt;i&#x27;,0b11111) b&#x27;\\x00\\x00\\x00\\x1f&#x27; # 0b11111 等于 31（10进制）# 16进制数 转 字节码import struct&gt;&gt;&gt; struct.pack(&#x27;B&#x27;,0xff) b&#x27;\\xff&#x27;&gt;&gt;&gt; struct.pack(&#x27;&gt;i&#x27;,0xfff) b&#x27;\\x00\\x00\\x0f\\xff&#x27; 字节码 转 数字1234567891011import struct 16进制表现 10进制等值&gt;&gt;&gt; struct.unpack(&#x27;B&#x27;, b&#x27;\\xff&#x27;) (255,) # 单字节&gt;&gt;&gt; struct.unpack(&#x27;&gt;i&#x27;, b&#x27;\\x00\\x00\\x00\\xff&#x27;) (255,) # 4字节，大端模式&gt;&gt;&gt; struct.unpack(&#x27;&lt;i&#x27;, b&#x27;\\x00\\x00\\x00\\xff&#x27;) (-16777216,) # 4字节，小端模式## 手动 转换字节码 -&gt; 字符串&gt;&gt;&gt; B = b&#x27;\\xe9&#x27;&gt;&gt;&gt; S = B.hex()&gt;&gt;&gt; S # 值 &#x27;e9&#x27;字符串（16进制格式）-&gt; 数字（10进制）&gt;&gt;&gt; int(S,16) # 值 233 ASCII 字符 和 数字字节 b’\\x05’字符串 ‘\\x05’将一个整数 (0-1114111) 转换为 一个字符（整数对应的 ASCII 字符）ValueError: chr() arg not in range(0x110000) 1234567&gt;&gt;&gt; chr(0) &#x27;\\x00&#x27;&gt;&gt;&gt; chr(1) &#x27;\\x01&#x27;&gt;&gt;&gt; chr(97) &#x27;a&#x27;&gt;&gt;&gt; chr(1114111) &#x27;\\U0010ffff&#x27;&gt;&gt;&gt; len(chr(101)) 1 # 长度为 1个字符&gt;&gt;&gt; len(chr(1114111)) 1 # 长度为 1个字符 将一个 ASCII字符 转换为 一个整数12345678&gt;&gt;&gt; ord(&#x27;\\x00&#x27;) 0&gt;&gt;&gt; ord(&#x27;\\x01&#x27;) 1&gt;&gt;&gt; ord(&#x27;a&#x27;) 97&gt;&gt;&gt; ord(&#x27;0&#x27;) 48&gt;&gt;&gt; ord(&#x27;1&#x27;) 49&gt;&gt;&gt; ord(&#x27;A&#x27;) 65&gt;&gt;&gt; ord(&#x27;Z&#x27;) 90&gt;&gt;&gt; ord(&#x27;\\U0010ffff&#x27;) 1114111 ASCII 字符 和 bin(字节)12345678from binascii import b2a_hex, a2b_hex&gt;&gt;&gt; a2b_hex(&#x27;ab&#x27;)b&#x27;\\xab&#x27;&gt;&gt;&gt; b2a_hex(b&#x27;ab&#x27;)b&#x27;6162&#x27;&gt;&gt;&gt; a2b_hex(b&#x27;6162&#x27;)b&#x27;ab&#x27; 总结 (摘自 羋虹光)int 类型解析较小的整数会很频繁的被使用，所以python将这些对象放置到了一个池子中，每次需要这些对象的时候就到池子中获取这个值，避免多次的重复创建对象引起的许多不必要的开销。这个池子内的数字范围是[-5, 257), 所以都是从池子里面取值，自然id不变。 float类型解析对于float类型的使用自然没有int那么频繁，并且float类型也不好定义哪些常用，也就没有池子给到这个类型，所以每次重新创建即可。 tuple类型解析对于tuple类型，与float类型的思维相似，所以也是每次重新创建。 string类型解析单词类型的str由于被重复使用的概率比较大，所以在python中为单词类型的str做了一个缓存，也就是说如果是单词类型的str， 会被存储到一个字典(dict)中，字典的内容是字符串为key， 地址为value。当有一个字符串需要创建，就先去访问这个字典，如果存在则返回字典中字符串的地址，如果不存在，则返回新创建的地址，并将这个字符串添加进入字典。这是字符串的intern机制。","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"基础","slug":"Python/基础","permalink":"https://www.boii.xyz/categories/Python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-3】判断和循环","slug":"Python/Basic/Python【No-3】判断和循环","date":"2020-07-04T12:41:48.000Z","updated":"2021-07-19T10:05:06.395Z","comments":true,"path":"posts/6930.html","link":"","permalink":"https://www.boii.xyz/posts/6930.html","excerpt":"程序结构：判断与循环","text":"程序结构：判断与循环 Judgment&amp;circulation ！！不要用浮点数比较相等！！ 判断123456if condition: print()elif condition: print()else: print() 例如 12345678age = 20if age &gt; = 6: print(&#x27;teenager&#x27;)elif age &gt;= 18: print(&#x27;adult&#x27;)else: print(&#x27;kid&#x27;) 还可以简写 123456if x: print(&#x27;True&#x27;)或if x: print(&#x27;True&#x27;) 只要 x 是非零数值、非空字符串、非空list、非空tuple，也不是None，就判断为True，否则为False 循环for12for x in Iterable: do sth 例如 1234567Li = [1, 2, 3, 4, 5, 6]sum = 0for x in Li: sum += xprint(sum)# 21 123456sum = 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]: sum = sum + xprint(sum)#55 range()1234&gt;&gt;&gt; range(5)0, 1, 2, 3, 4&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4] 12345678# 从1加到100sum = 0for x in range(101): sum = sum + xprint(sum)# 5050 while12while condition: do sth 1234567sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print(sum) break 跳出整个循环，且不执行else子句 continue 跳出本次循环 else else 子句会在循环不满足条件退出时执行但如果 break 跳出循环时，不会执行else子句 123456789101112131415sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2else: print(&#x27;else&#x27;) # 循环结束后会执行这句话print(sum)---------------------------------# Output:else2500 12345678910111213141516sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2 if n &lt; 10: break # n 小于 10的时候会跳出循环，并且不会执行 else 子句else: print(&#x27;else&#x27;)print(sum)---------------------------------# Output:2475 pass pass 语句什么也不做。当语法上需要一个语句，但程序需要什么动作也不做时，可以使用它。 12345678&gt;&gt;&gt; while True:... pass # Busy-wait for keyboard interrupt (Ctrl+C)&gt;&gt;&gt; class MyEmptyClass:... pass&gt;&gt;&gt; def initlog(*args):... pass # Remember to implement this!","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"基础","slug":"Python/基础","permalink":"https://www.boii.xyz/categories/Python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-2】基础","slug":"Python/Basic/Python【No-2】基础","date":"2020-07-03T09:40:48.000Z","updated":"2021-07-19T10:05:06.214Z","comments":true,"path":"posts/38014.html","link":"","permalink":"https://www.boii.xyz/posts/38014.html","excerpt":"Python 基础知识","text":"Python 基础知识 输入 &amp; 输出输出 print(‘输出内容’) 12345&gt;&gt;&gt; print(300) # 300&gt;&gt;&gt; print(100 + 200) # 300&gt;&gt;&gt; print(&#x27;100 + 200 =&#x27;, 100 + 200) # 100 + 200 = 300&gt;&gt;&gt; print(&#x27;Hello World!&#x27;) # Hello World!&gt;&gt;&gt; print(&#x27;The quick&#x27;, &#x27;brown for&#x27;, &#x27;jumps over.&#x27;) # The quick brown for jumps over. 输入 承接变量 = input(‘提示信息’) 123456&gt;&gt;&gt; name = input()Boii&gt;&gt;&gt; name&#x27;Boii&#x27;&gt;&gt;&gt; print(name)Boii 1234# name.pyname = input(&#x27;Please enter your name:&#x27;)print(&#x27;Hello&#x27;, name) &gt;_: python name.py Please enter your name: BoiiHello Boii 变量 大小写英文、数字、下划线_ 不能数字开头 大小写敏感 不能用关键字 不需要声明类型 简洁明了，信达雅原则。变量名用名词，函数名方法名用动词 由于python是动态语言，不需要声明类型，所以命名尽量体现类型或用前缀体现。如 i_age, fPrice, b_flag 慎用字母O和I 12345678910111213a = 1 # a是一个整型b = 1.0 # b是一个浮点型c = &#x27;abc&#x27; # c是一个字符串d = True # d是一个布尔值e = None # e是一个空值# 多个变量同时赋值a = b = c = 1# 以上语句, 内存中会创建一个空间,值为1; 再创建三个空间a, b, c, 存放1的地址，即指向1那块内存x, y, z = 1, 2, &quot;Boii&quot;# 以上语句, x为1, y为2, z为Boii 变量实际上是指向12345&gt;&gt;&gt; a = &#x27;ABC&#x27;&gt;&gt;&gt; b = a&gt;&gt;&gt; a = &#x27;XYZ&#x27;&gt;&gt;&gt; print(b)ABC a = &#39;ABC&#39; b = a a = &#39;XYZ&#39; 数据类型数据类型.md 运算符运算符 缩进Python以缩进来区分代码块。连续的相同缩进视为同一代码块，同一作用域，如同C中的花括号。 按照约定俗成，4个空格为一个缩进。在IDE中最好设置好tab自动转换为4个空格 多行语句如果一个语句太长，可以使用 \\ 声明此语句未结束 123total = item_one + \\ item_two + \\ item_three 注释12345678910111213# 这是单行注释&#x27;&#x27;&#x27;这是多行注释，使用单引号这是多行注释，使用单引号这是多行注释，使用单引号&#x27;&#x27;&#x27;&quot;&quot;&quot;这是多行注释，使用双引号这是多行注释，使用双引号这是多行注释，使用双引号&quot;&quot;&quot;","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"基础","slug":"Python/基础","permalink":"https://www.boii.xyz/categories/Python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"Python【No-1】总叙","slug":"Python/Basic/Python【No-1】总叙","date":"2020-07-02T02:41:48.000Z","updated":"2021-07-19T10:05:05.942Z","comments":true,"path":"posts/15463.html","link":"","permalink":"https://www.boii.xyz/posts/15463.html","excerpt":"关于Python","text":"关于Python 语言哲学： 简洁 类型：解释型语言、动态语言、面向对象（一切皆对象） 缺点： 速度慢 代码不能加密 语言思想： 一切皆对象 函数是一等公民 解释器CPython 默认解释器。 PyPy 目标是执行速度，采用JIT技术，对python代码进行动编译。但是与CPython不同。 PyPy VS CPython Jython Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。 IronPython IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Python代码编译成.Net的字节码。 命令行模式 &amp; 交互模式命令行模式┌──────────────────────────────────────┐│Command Prompt - □ x │├──────────────────────────────────────┤│Microsoft Windows [Version 10.0.0] ││(c) 2015 Microsoft Corporation. All rights reserved. ││ ││C:&gt; _ ││ │└──────────────────────────────────────┘ 可以切换到文件所在目录下，然后输入 python 文件名.py 来执行python文件 Python交互模式┌────────────────────────────────────────┐│Command Prompt - python - □ x │├────────────────────────────────────────┤│Microsoft Windows [Version 10.0.0] ││(c) 2015 Microsoft Corporation. All rights reserved. ││ ││C:&gt; python ││Python 3.7 … on win32 ││Type “help”, … for more information. ││&gt;&gt;&gt; 100 + 200 ││300 ││&gt;&gt;&gt; _ ││ │└────────────────────────────────────────┘ 输入 python 进入交互模式， 输入 exit() 或 quit() 退出交互模式 文件名 扩展名：.py 文件名：英文字母、数字、下划线 直接运行.py文件 Win Linux Mac 前提： 在hello.py文件的第一行加上一个特殊的注释 #!/usr/bin/env python3 ， 如123#!/usr/bin/env python3print(&quot;Hello World!&quot;) 通过命令给hello.py文件执行权限1$ chmod a+x hello.py 中文编码 Python2 默认编码格式是：ASCII，使用中文会出错解决方法：在文件开头加入 # -*- coding: UTF-8 -*- 或 # coding=utf-8 1234#!/usr/bin/python# -*- coding: UTF-8 -*-print(&quot;放码过来&quot;) Python3 默认编码格式是：UTF-8，所以无需指定编码格式注意：py文件需要存储格式为 UTF-8 123#!/usr/bin/env python3print(&quot;放码过来&quot;) 但最好还是加上 1234#!/usr/bin/env python3# -*- coding: UTF-8 -*-print(&quot;放码过来&quot;) python的一切皆对象123456789101112131415161718192021# 示例如下a=2019b=&quot;一切皆对象&quot;print(type(2019))print(type(int))print(type(b))print(type(str))class Student: passstu = Student()print(type(stu))print(type(Student))print(int.__bases__)print(str.__bases__)print(Student.__bases__)print(type.__bases__)print(object.__bases__)print(type(object))print(type(type)) 运行结果： 12345678910111213&lt;class &#x27;int&#x27;&gt; # 2019是由int这个类创建的实例&lt;class &#x27;type&#x27;&gt; # int这个类是由type这个类创建的实例&lt;class &#x27;str&#x27;&gt; # 同上&lt;class &#x27;type&#x27;&gt;&lt;class &#x27;__main__.Student&#x27;&gt; # stu是类Student创建的实例&lt;class &#x27;type&#x27;&gt; # 类Student是由type这个类创建的实例(&lt;class &#x27;object&#x27;&gt;,) # 类int的基类是object这个类(&lt;class &#x27;object&#x27;&gt;,) # 同上(&lt;class &#x27;object&#x27;&gt;,) # 同上(&lt;class &#x27;object&#x27;&gt;,) # 重点：类type的基类也是object这个基类() # 重点：类object没有基类&lt;class &#x27;type&#x27;&gt; # 难点：类object是由类type创建的实例&lt;class &#x27;type&#x27;&gt; # 难点：类type是由type类自身创建的实例 对于上面图片的解读如下： object是一切对象：list、str、dict、tuple的基类，同时object是type的实例 类type是自身的实例，同时type也继承自object类 由结论1和结论2，得出一切皆对象，同时一切皆继承自object类 类object是一切对象的基类类object是类type的实例 类type继承自类object类type是类type的实例 一切皆对象，一切皆继承自object类","categories":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"基础","slug":"Python/基础","permalink":"https://www.boii.xyz/categories/Python/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"}]},{"title":"VUE-note-day2","slug":"Vue/VUE-note-day2","date":"2020-04-09T03:34:38.000Z","updated":"2020-04-09T03:34:38.000Z","comments":true,"path":"posts/37390.html","link":"","permalink":"https://www.boii.xyz/posts/37390.html","excerpt":"Vue 的细节是真的多.","text":"Vue 的细节是真的多. v-text123456789101112&lt;div id=&quot;app&quot;&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; 等价于 &lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;Hello World !&#x27;, &#125; &#125;);&lt;/script&gt; // 显示结果 ==&gt;&gt; Hello World 等价于 Hello World. v-once 形式: v-once 值: 无 作用: 限定所在元素只被渲染一次, 完成后即使值更新了也不再渲染 不管是用 v-text = “msg” 还是用 都会实时的更新,也就是当msg 的值改变的时候, 显示的结果也会改变. 如果只想渲染一次, 可以加上v-once 12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; 不等价于 &lt;span v-text=&quot;msg&quot; v-once&gt;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;Hello World !&#x27;, &#125; &#125;); app.msg = &quot;Hello&quot;&lt;/script&gt; 显示结果 ==&gt;&gt; Hello World 不等价于 Hello v-html 形式: v-html = “variable” 值: variable -&gt; string, 取自于data{} 里的属性 ! WARN: 容易导致XSS攻击. 所以, 只在可信内容上使用. 永不用在用户提交的内容上。 作用: 更新元素的innerHTML. 内容按普通的HTML插入, 不会被编译 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;span v-html=&quot;dodo&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; dodo: &#x27;&lt;h2&gt;Hello&lt;/h2&gt;&#x27; &#125; &#125;);&lt;/script&gt;&lt;!-- 渲染结果 =&gt;&gt; --&gt;&lt;div id=&quot;app&quot;&gt; &lt;span v-html=&quot;dodo&quot;&gt; &lt;h2&gt;Hello&lt;/h2&gt; &lt;/span&gt;&lt;/div&gt;&lt;!--显示结果 ==&gt;&gt; --&gt;Hello v-on 形式： v-on:event[.qualifier] = “Function | Inline statements | Object” 缩写： @event[.qualifier] = “Function | Inline statements | Object” 值： event -&gt; 要监听的事件， 如click， keyup等 qualifier -&gt; 修饰符，监听事件做一些限定 methods -&gt; 当所监听的事件触发时的响应方法 Inline statements -&gt; 内联语句 Object -&gt; [2.4.0]新增，使用键值对对象作为响应事件，但是不支持任何修饰器 作用： 绑定监听事件。事件类型由event参数指定， 修饰符： .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .capture - 添加事件侦听器时使用 capture 模式。 .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .&#123;keyCode | keyAlias&#125; - 只当事件是从特定键触发时才触发回调。 .native - 监听组件根元素的原生事件。 .once - 只触发一次回调。 .left - (2.2.0) 只当点击鼠标左键时触发。 .right - (2.2.0) 只当点击鼠标右键时触发。 .middle - (2.2.0) 只当点击鼠标中键时触发。 .passive - (2.3.0) 以 &#123; passive: true &#125; 模式添加侦听器 1234567891011121314151617181920212223242526&lt;!--方法处理器--&gt;&lt;button v-on:click=&quot;Function1&quot;&gt;&lt;/button&gt;&lt;!-- 动态事件（2.6.0+） --&gt;&lt;button v-on:[event]=&quot;dosth&quot;&gt;&lt;/button&gt;&lt;!-- 内联语句 --&gt;&lt;button v-on:click=&quot;dosth(&#x27;hello&#x27;, $event)&quot;&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;button @click=&quot;dosth&quot;&gt;&lt;/button&gt;&lt;!-- 停止冒泡 --&gt;&lt;button @click.stop=&quot;dosth&quot;&gt;&lt;/button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent=&quot;dosth&quot;&gt;&lt;/button&gt;&lt;!-- 没有表达式的阻止默认行为 --&gt;&lt;form @click.prevent&gt;&lt;/form&gt;&lt;!-- 串联修饰符 --&gt;&lt;button @click.stop.prevent=&quot;dosth&quot;&gt;&lt;/button&gt;&lt;!-- 键修饰符.键名 --&gt;&lt;button @keyup.enter=&quot;onEnter&quot;&gt;&lt;!-- 键修饰符.键码 --&gt;&lt;button @keyup.13=&quot;onEnter&quot;&gt;&lt;!-- 点击回调只触发一次 --&gt;&lt;button @click.once=&quot;dosth&quot;&gt;&lt;/button&gt;&lt;!-- 对象语法（2.4.0+） --&gt;&lt;button v-on=&quot;&#123;keyup: dosthA, keydown: dosthB&quot;&gt;&lt;/button&gt; v-bind 形式： v-bind:AttributeOrProperty[.qualifier] = “value” 缩写： :AttributeOrProperty=”value” 值： AttributeOrProperty -&gt; 标签的原生属性或特性 value -&gt; 标签原生属性所对应的值 作用：将属性或特性与变量绑定在一起，实现动态修改 修饰符： .prop - 作为一个 DOM property 绑定而不是作为 attribute 绑定。(差别在哪里？) .camel - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持) .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 绑定一个属性 --&gt;&lt;img v-bind:src=&quot;imageSrc&quot;&gt;&lt;!-- 动态 attribute 名 (2.6.0+) --&gt;&lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;&lt;!-- 缩写 --&gt;&lt;img :src=&quot;imageSrc&quot;&gt;&lt;!-- 动态 attribute 名缩写 (2.6.0+) --&gt;&lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;&lt;!-- 内联字符串拼接 --&gt;&lt;img :src=&quot;&#x27;/path/to/images/&#x27; + fileName&quot;&gt;&lt;!-- class 绑定 --&gt;&lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;&lt;!-- style 绑定 --&gt;&lt;div :style=&quot;&#123; fontSize: size + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;&lt;!-- 绑定一个有属性的对象 --&gt;&lt;div v-bind=&quot;&#123; id: someProp, &#x27;other-attr&#x27;: otherProp &#125;&quot;&gt;&lt;/div&gt;&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;&lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;&lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;&lt;!-- XLink --&gt;&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt; v-model 形式： v-model[.qualifier] = “variable” 值：variable -&gt; 双向数据绑定的变量，通过这个变量实现数据与视图之间的绑定 ! WARN: 只能在 &lt;input&gt;、&lt;select&gt;、&lt;textarea&gt; 和组件上使用 作用： 实现双向数据绑定 修饰符： .lazy - 取代 input 监听 change 事件, 懒加载，会等到失焦才更新 .number - 输入字符串转为有效的数字，限制只有数字有效， 但是如果先输入字符串则该修饰符无效 .trim - 输入首尾空格过滤 1234567891011&lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;p&gt;v-model.lazy&lt;input type=&quot;text&quot; v-model.lazy=&quot;msg&quot;&gt;&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;Hello World !&#x27; &#125; &#125;);&lt;/script&gt; 加了lazy修饰符， 所以会等到input输入框失去焦点才渲染更新","categories":[{"name":"Note","slug":"Note","permalink":"https://www.boii.xyz/categories/Note/"},{"name":"Vue","slug":"Vue","permalink":"https://www.boii.xyz/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.boii.xyz/tags/Vue/"}]},{"title":"VUE-note-day1","slug":"Vue/VUE-note-day1","date":"2020-04-08T04:05:50.000Z","updated":"2020-04-08T04:05:50.000Z","comments":true,"path":"posts/37710.html","link":"","permalink":"https://www.boii.xyz/posts/37710.html","excerpt":"疫情在家真的无聊 T_T，学点Vue吧","text":"疫情在家真的无聊 T_T，学点Vue吧 v-if &amp; v-else-if &amp; v-elsev-if 形式: v-if = “express | variable” 值: true -&gt; 渲染[^1] | false -&gt; 不渲染 作用: vue的一个内部指令, 用在html标签中, 作为标签的一个属性. 用来判断是否渲染所在的标签. 其作用相当于C语言中的 if判断语句 123&lt;div id=&quot;app&quot;&gt; &lt;div v-if=&quot;isLogin&quot;&gt;欢迎来到XXX.&lt;/div&gt;&lt;/div&gt; 12345678&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; isLogin: true &#125; &#125;);&lt;/script&gt; v-else-if [2.1.0新增] 形式: v-else-if = “express | variable” 值: true -&gt; 渲染 | false -&gt; 不渲染 ! WARN: 必须紧跟在 v-if 或 v-else-if后面, 否则将不被识别. 作用: 其作用相当于C语言中的 else if 判断语句. v-else 形式: v-else 值: 无 作用: 同 v-if 一样, vue的一个内部指令, 用在html标签中. ! WARN: 必须紧跟在 v-if 或 v-else-if后面, 否则将不被识别. 综合示例1234567&lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt; A &lt;/div&gt;&lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt; B &lt;/div&gt;&lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt; C &lt;/div&gt;&lt;div v-else&gt; Not A/B/C &lt;/div&gt; key 管理可复用元素 形式: key = “unique-value” 值: 不固定, 只要是全局唯一即可 作用: vue为了高效渲染使得加载速度变快, 会复用已有元素, 有时候有的元素虽然相同但是我们不想被复用, 可以在元素中添加key属性来避免被vue复用. 使用了key属性的元素会被重新渲染而不是复用 官网示例12345678&lt;template v-if=&quot;loginType === &#x27;username&#x27;&quot;&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot;&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=&quot;Enter your email address&quot;&gt;&lt;/template&gt; 这个例子, 如果input 输入框内有内容, 在切换的时候不会被清空, 因为被vue复用了. 12345678&lt;template v-if=&quot;loginType === &#x27;username&#x27;&quot;&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt;&lt;/template&gt; 而这个例子, 如果&lt;input&gt;输入框内有内容, 在切换时会被清空, 因为不会被复用而是重新渲染. 但是 &lt;label&gt;依然会被高效复用, 因为没有key属性. key属性作用: 避免被复用, 使之重新渲染 v-show 形式: v-show = “express | variable” 值: true -&gt; 显示[^4] | false -&gt; 不显示 作用: vue的一个内部指令, 用在html标签中, 用于判断所在标签是否显示, 而不是是否渲染 1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;h1 v-show=&quot;right&quot;&gt;Hello!&lt;/h1&gt; &lt;!--当right为true时, 该标签会被显示, 为false时不显示--&gt; &lt;h2 v-show=&quot;status === 1&quot;&gt; 当status为1时显示 &lt;/h2&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data:&#123; right: true, status: 2 &#125; &#125;);&lt;/script&gt;渲染后的结果:&lt;h1 style=&quot;display:block;&quot;&gt;Hello!&lt;/h1&gt;&lt;h2 style=&quot;display:none;&quot;&gt; 当status为1时显示 &lt;/h2&gt; v-if VS v-show渲染: v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-show只是简单地基于 CSS 进行切换。 渲染时机: v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多——不管初始条件是什么，元素总是会被渲染， 开销: v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。 因此: 如果需要非常频繁地切换，则使用 v-show 较好； 如果在运行时条件很少改变，则使用 v-if 较好。 v-for数组作为数据源 形式: 渲染一个数组 v-for = “alias in source” 或 v-for = “alias of source” v-for = “(alias, index) in source” 值: source -&gt; 数据源, 是一个数组 alias -&gt; 别名, 遍历时的临时变量 index -&gt; 索引(下标), 默认的, 可以取别的名, 但是约定俗成是 index ! WARN: 别名和索引的位置不能换. 即使换了解释器也默认按照 第一个参数是临时变量, 第二个参数是索引, in 后面的参数是数据源 的规则来解释 哪个元素要被循环渲染就写在哪个元素里作为它的属性. 作用: 将数组里的每一个值渲染到标签的插值[^7]中. 12345678910111213141516171819202122232425&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;age in DemoArray&quot;&gt;&#123;&#123;age&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; DemoArray: [20, 30, 44, 10, 33] &#125; &#125;);&lt;/script&gt;// 渲染结果=&gt;&gt;&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li&gt;20&lt;/li&gt; &lt;li&gt;30&lt;/li&gt; &lt;li&gt;44&lt;/li&gt; &lt;li&gt;10&lt;/li&gt; &lt;li&gt;33&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; // 显示结果 ==&gt;&gt; 20 30 44 10 33 排序 计算的工作都在computed里完成 排序实现在vue对象中的computed, 但是computed里的键名不能和data里的键名相同. 而我们要按排序后的数组渲染, 所以 html 里要改成 v-for = “age in sortArray” 12345678910&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;age in DemoArray&quot;&gt;&#123;&#123;age&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;4...&lt;/script&gt; 123456789101112131415161718&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; DemoArray: [20, 30, 44, 10, 33] &#125;, computed: &#123; /** 错误写法. 键名重复 DemoArray: function()&#123; return this.DemoArray.sort((a, b) =&gt; a - b); &#125; */ sortItems: function()&#123; return this.DemoArray.sort((a, b) =&gt; a - b); &#125; &#125; &#125;);&lt;/script&gt; 因为 javascript 自带的 bug, 对数组排序 DemoArray.sort()是把每个数组元素的最前面的一位[^5], 所以排序出来是有问题的. 导致这个 bug 的原因我猜想是因为 js 是弱类型语言, 解释器也不知道你这个数组里到底是字符串还是数字还是什么, 又得给你排序, 所以干脆统统按 给字符串排序 的方法处理. 修复方法就是自己实现一个函数. 上述代码中用了箭头函数使得更加简洁. 关键代码即 (a, b) =&gt; a - b 数组更新会修改原数组的方法: 变异方法 push() pop() shift() unshift() splice() sort() reverse() 通过这些方法修改数组, 会触发视图的更新. 不会修改原数组的方法: 非变异方法 filter() concat() slice() 它们不会改变原始数组，而返回一个新数组。 当使用非变异方法时，可以用新数组替换旧数组： 1234567891011var app = new Vue (&#123; el: &#x27;#app&#x27;, data:&#123; items: [ &#123;msg: &quot;m1&quot;&#125;, &#123;msg: &quot;m2&quot;&#125; ] &#125;&#125;);// 替换 app.items = app.items.filter( item =&gt; item.items.match(/mmm/) ) ; ? 这里不清楚怎么实现的, 但是官网的说法是: 并非丢弃现有DOM而重新渲染整个列表, 因为Vue里有些智能的方法, 所以, 数组在改动不大的情况下去替换原有数组的非常高效的, 不必担心. 至于怎么个智能法没说, 有待深挖. 数组更新的注意事项问题:由于不靠谱的JavaScript的限制, 以下两种方法的更新Vue是无法检测到的 利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 修改数组的长度时，例如：vm.items.length = newLength 12345678var app = new Vue(&#123; ... data: &#123; array: [0,1,2,3,4,5,6,7,8] &#125;&#125;);app.array[3] = 10 //Vue 检测不到更新, 也不会触发视图更新app.array.length = 8 //Vue 检测不到更新 解决: 问题1123456789101112131415161718192021Vue.set(vm.items, indexOfItem, newValue), // 例如: Vue.set(app.array, 2, 10)// ==&gt;&gt; [0,1,10,3,4,5,6,7,8]或vm.items.splice(indexOfItem, 1, newValue), // 例如: app.array.splice(3, 1, 50)// ==&gt;&gt; [0,1,2,50,4,5,6,7,8] // 关于这个1,可以是任何数, // 0则不吃掉任何元素, // 1则吃掉array[indexOfItem]那个元素,// 2则吃掉array[indexOfItem] 和 array[indexOfItem + 1]两个元素// 以此类推// 例如: app.array.splice(2,2,30)// ==&gt;&gt; [0,1,30,5,6,7,8] 或vm.$set(vm.items, indexOfItem, newValue)// 例如: app.$set(app.array, 2, 10)// ==&gt;&gt; [0,1,10,3,4,5,6,7,8] 解决: 问题21app.array.splice(新长度值) 对象作为数据源 形式: 渲染一个对象 v-for = “value in object” v-for = “(value, key) in object” v-for = “(value, key, index) in object” 值: object -&gt; 数据源, 是一个对象, 要遍历的是它的所有属性 value -&gt; 别名, 遍历时的临时变量, 输出的是每一个属性的值 key -&gt; 索引(键名), 默认的, 可以取别的名, 但是约定俗成是 key, 输出的是每一个属性(键值对)的键名 index -&gt; 索引(下标), 默认的, 可以取别的名, 约定俗成是index, 输出的是每一个属性的下标[^6]. ! WARN: 和遍历数组一样, 键名索引和下标索引的位置不要换. 即使换了解释器也是按照 第一个参数是临时变量,第二个参数是键名索引, 第三个参数是下标索引, in 后面是数据源的规则解释. 哪个元素要被循环渲染就写在哪个元素里作为它的属性. 作用: 将对象里的每一个属性(键值对)的值渲染到标签的插值[^7]中. 123456789101112131415161718192021222324252627&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(val, key, idx) in obj&quot;&gt;&#123;&#123;idx&#125;&#125;-&#123;&#123;key&#125;&#125;-&#123;&#123;val&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; obj:&#123; prop1: &#x27;key1&#x27;, prop2: 20, prop3: true &#125; &#125; &#125;);&lt;/script&gt;// 渲染结果 =&gt;&gt;&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li&gt;0-prop1-key1&lt;/li&gt; &lt;li&gt;1-prop2-20&lt;/li&gt; &lt;li&gt;2-prop3-true&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; // 显示结果 ==&gt;&gt; 0-prop1-key1 1-prop2-20 2-prop3-true 对象更新的注意事项问题:由于不靠谱的JavaScript的限制, 对象属性的添加或删除 Vue是检测不到的 12345678var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; a: 1 &#125;&#125;);app.b = 2 // Vue检测不到, 不会更新视图 解决方法app.a app.b 这里a和b叫做根级别响应式属性, 是不允许动态添加的, 但是根级别属性的属性是可以动态添加的. 12345678var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; root:&#123; child: 1 &#125; &#125;&#125;);// app.root 不允许动态添加, app.root.child允许动态添加 添加单个属性的方法 12345678Vue.set(rootAttribute, childKey, childValue)// 例如: Vue.set(app.root, &#x27;age&#x27;, 10)// ==&gt;&gt; data: &#123;// root: &#123; child: 1, age: 10&#125;// &#125;或vm.$set(rootAttribute, childKey, childValue)// 例如: app.$set(app.root, &#x27;age&#x27;, 10) 添加多个属性的方法: 使用 Object.assign() 或 _.extend() 1app.root = Object.assign(&#123;&#125;, app.root, &#123; age: 27, favoriteColor: &#x27;Vue Green&#x27; &#125;) 数组对象作为数据源的排序 计算处理同样是在computed中. 重新定义一个函数, 并作出处理 在v-for调用时 把数据源换成刚刚定义的函数名 12345678computed: &#123;4...4//数组对象方法排序:4sortStudents: function () &#123;4 var key = &quot;age&quot;;4 return this.students.sort((a, b) =&gt; a[key] &lt; b[key] ? -1 : (a[key] &gt; b[key] ? 1 : 0)) &#125;&#125; 范围作为数据源形式: 渲染一个对象 v-for = “value in object” v-for = “(value, key) in object” v-for = “(value, key, index) in object” 值: object -&gt; 数据源, 是一个对象, 要遍历的是它的所有属性 value -&gt; 别名, 遍历时的临时变量, 输出的是每一个属性的值 key -&gt; 索引(键名), 默认的, 可以取别的名, 但是约定俗成是 key, 输出的是每一个属性(键值对)的键名 index -&gt; 索引(下标), 默认的, 可以取别的名, 约定俗成是index, 输出的是每一个属性的下标[^6]. ! WARN: 和遍历数组一样, 键名索引和下标索引的位置不要换. 即使换了解释器也是按照 第一个参数是临时变量,第二个参数是键名索引, 第三个参数是下标索引, in 后面是数据源的规则解释. 哪个元素要被循环渲染就写在哪个元素里作为它的属性. 作用: 将对象里的每一个属性(键值对)的值渲染到标签的插值[^7]中. 形式: v-for=” n in range” 值: n -&gt; 别名, 遍历时的临时变量 range -&gt; 数据源, 遍历的范围 123&lt;div&gt; &lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;/div&gt; 显示结果 ==&gt;&gt; 1 2 3 4 5 6 7 8 9 10 v-for 和 v-if 一起用时尽量不要把v-for 和 v-if 放在同一个标签里 但他们处在同一个标签内时, v-for 的优先级比 v-if 高 1234&lt;!--尽量不要--&gt;&lt;li v-for=&quot;todo in todos&quot; v-if=&quot;!todo.isComplete&quot;&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt; 1234567&lt;!--上面是特殊情况下的写法, 下面是正常情况下的规范写法--&gt;&lt;ul v-if=&quot;todos.length&quot;&gt; &lt;li v-for=&quot;todo in todos&quot;&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No todos left!&lt;/p&gt; [^1]:渲染, 加载完DOM树之后就开始在页面上加载, 这个过程叫做渲染[^2]:加载, 当浏览器接收到服务器返回的html文件时, 会读取所有html标签形成一颗DOM树[^3][^3]:DOM树, 全部html标签的树状结构[^4]:display: block[^5]:如果是字符串就,第一位就是第一个字符; 如果是数字,第一位就是最大位的那个数字, 比如39的第一位是3[^6]:对象中的属性都是键值对, 属性的下标从0开始, 先定义的属性(键值对)下标就靠前[^7]:插值, HTML标签中间用 &#123;&#123; 插值 &#125;&#125; 包起来的地方","categories":[{"name":"Note","slug":"Note","permalink":"https://www.boii.xyz/categories/Note/"},{"name":"Vue","slug":"Vue","permalink":"https://www.boii.xyz/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.boii.xyz/tags/Vue/"}]},{"title":"全站变灰的实现","slug":"Hexo/全站变灰的实现","date":"2020-04-06T02:47:03.000Z","updated":"2020-04-06T02:47:03.000Z","comments":true,"path":"posts/43293.html","link":"","permalink":"https://www.boii.xyz/posts/43293.html","excerpt":"哀悼日-全站变灰的实现","text":"哀悼日-全站变灰的实现 前言作为一个关心家国大事的青年，在国家有难时因争相出手付出举手之劳，虽然现在时和平年代，但是也会经历 918公祭日、哀悼日等。 每到这些日子，警报响彻神州, 江水呜咽，山川悲鸣; 大江南北，长城内外，国家以最高的祭奠向英雄哀悼，人民以最深的怀念为英雄送行。 除了现场祭奠，线上我们也想表达自己对那些烈士、英雄和逝世同胞的深切哀悼，那么可以通过全站变灰的方式，遮去往日绚烂的色彩，跳脱的动效为他们沉寂。 下面将介绍如何让全站变灰。 青铜操作作为 铂金CV工程师 先来一顿 青铜段 操作: 用最广告的引擎搜索: 全站变灰 点进广告最多的论坛, 将关键代码进行数据读取: Ctrl + C 来到自己的站点启动全站检测: F12 找到html标签, 在style面板中进行数据写入: Ctrl + V 完美~ 白银操作接下来就要进行 白银段 操作了: 这里我用的是Volantis这个主题, 你要找到你自己主题里生成 &lt;head&gt;&lt;/head&gt;标签的那个文件. 进入网站根目录, 找到 themes\\volantis\\layout_partial\\head.ejs 在 &lt;head&gt;&lt;/head&gt; 标签内添加 themes\\volantis\\layout\\_partial\\head.ejs12345678910&lt;style&gt; html &#123; -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); _filter: none; &#125;&lt;/style&gt; 保存,推送: hexo g -d 做到这里其实就够了. 但是你也可以进阶一下 黄金操作再来顿 黄金段 操作: 在刚刚添加 &lt;style&gt;...&lt;/style&gt; 标签外面再套上一句ejs的判断语句 themes\\volantis\\layout\\_partial\\head.ejs123456789101112&lt;% if (theme.style.mourn) &#123; %&gt;&lt;style&gt; html &#123; -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); _filter: none; &#125;&lt;/style&gt;&lt;% &#125; %&gt; 在你的主题目录的配置文件 themes\\volantis\\_config.yml 中, 添加 mourn: true themes\\volantis\\_config.yml123style: ... mourn: true # 哀悼: 全站变灰 保存,推送: hexo g -d 这样当你要关掉的时候就不用再跑去head.ejs中删除了, 直接在主题配置文件中把mourn: false 就行了. 开启 -> mourn: true 关闭 -> mourn: false 也可以把mourn放到最外层, 只要让 mourn字段 前面没有空格就行, 相应的 &lt;% if (theme.style.mourn) &#123; %&gt; 要改成 &lt;% if (theme.mourn) &#123; %&gt; 这是yaml的语法, 不懂的出门左转 铂金操作最后是 铂金段 操作 推送毕竟需要时间, 如果我们想要实现准时准点时间一到自动全站变灰,那就要升级下操作了.只需要把刚刚的代码修改一下. themes\\volantis\\layout\\_partial\\head.ejs1234567891011121314151617&lt;% if (theme.style.mourn.switch)&#123; %&gt;&lt;% var startTime = Date.parse(theme.style.mourn.startTime.replace(/-/g, &quot;/&quot;)); %&gt;&lt;% var endTime = Date.parse(theme.style.mourn.endTime.replace(/-/g, &quot;/&quot;)); %&gt;&lt;% var currentTime = Date.now(); %&gt;&lt;% &#125; %&gt;&lt;% if (currentTime &gt; startTime &amp;&amp; currentTime &lt; endTime) &#123; %&gt; &lt;style&gt; html &#123; -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); _filter: none; &#125; &lt;/style&gt;&lt;% &#125; %&gt; 然后配置中改成: themes\\volantis\\_config.yml123456style: ... mourn: # 哀悼: 全站变灰 switch: true startTime: &#x27;2020-4-4 0:0:0&#x27; endTime: &#x27;2020/4/5 0:0:0&#x27; 这样只需要填写好开启关闭的时间, 然后打开开关switch: true即可 日期用-或者/分隔都可以, 因为ejs中有做格式化时间一定要用(英文)冒号:分隔日期和时间之间要有空格隔开个位数不要添加前缀, 比如凌晨三点要写 3:0:0, 不要写成 03:00:00 心得之前配置主题的时候小心翼翼, 生怕一不小心弄错了就头大.折腾了一段时间积攒了一些经验 一. 边预览边修改1. 可以使用命令hexo s 开启本地预览, 在浏览器输入localhost:4000开启本地预览2. 开启后cmd窗口放在一旁, 在编辑器中做修改, hexo server 一直监听着变化, 每次保存都会自动编译3. 只需要在浏览器里刷新一下就可以看到结果. 有什么编译错误cmd窗口里也会实时的显示出来.二. 学会看报错信息常见的报错信息就那么几个单词, 不懂的翻译一下, 知道错在哪里, 然后思考为什么会错误, 一步步修改, 慢慢的一点点积累就会成长.三. YAML是个好东西掌握了yaml语法以后, 就可以自由的添加自己想要的配置.就上面的修改全站变灰为例, 说白了就是找到自己想要的效果的代码, 然后在ejs里做判断, ejs和yaml配合, 就可以作出自己想要的效果了.","categories":[{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/categories/HEXO/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/tags/HEXO/"},{"name":"YAML","slug":"YAML","permalink":"https://www.boii.xyz/tags/YAML/"}]},{"title":"Electron Note","slug":"Electron/Electron-Note","date":"2020-03-21T08:55:25.000Z","updated":"2021-07-27T04:41:46.352Z","comments":true,"path":"posts/34681.html","link":"","permalink":"https://www.boii.xyz/posts/34681.html","excerpt":"Note","text":"Note Hello World在项目文件夹下新建两个文件: main.html &amp; main.js 123456789101112131415161718&lt;!--main.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id=&quot;title&quot;&gt; Hello World ! &lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819// main.jsconst electron = require(&#x27;electron&#x27;); // 引入electron模块const app = electron.app; // 创建electron引用const BrowserWindow = electron.BrowserWindow; // 创建窗口引用let mainWindow = null; // 声明要打开的主窗口app.on(&#x27;ready&#x27;, () =&gt; &#123; mainWindow = new BrowserWindow(&#123; // 设置打开的窗口大小 width: 800, heigth: 500 &#125;); mainWindow.loadFile(&#x27;main.html&#x27;); // 加载html页面 mainWindow.on(&#x27;closed&#x27;, () =&gt; &#123; // 监听窗口关闭事件 mainWindow = null // 一定要把窗口设置为null,否则会一直占内存 &#125;); // 如同C语言申请内存后一定要free释放内存&#125;); 然后打开cmd命令行, cd到项目的根目录, 执行命令 1npm init 项目根目录就会生成一个 package.json 文件 12345678910111213&#123; &quot;name&quot;: &quot;Hello-World&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;electron .&quot; // 这句要自己添加 &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 然后就可以在 cmd命令行 中执行命令来启动项目 1npm start 或者 electron . 效果如下: 也可以自己添加 main.css 编写样式, 让界面更好看. 所有命名不固定. 主进程与渲染进程主进程 Electron 运行 package.json 的 main属性 的进程被称为主进程 每个应用只有一个主进程 作用: 管理原生GUI , 典型的窗口(BrowserWindow , Tray, Dock, Menu) 创建渲染进程 控制应用生命周期 (app) 模块: **(常用): **app , BrowserWindow , ipcMain , Menu , Tray , MenuItem , dialog , Notification , webContents , autoUpdater , globalShortcut , clipboard , crashReporter SystemPreferences , TouchBar , netLog , powerMonitor , inAppPurchase , net , powerSaveBlocker , contentTracing , BrowserView , session , protocol , Screen , shell , nativelmage 渲染进程 展示web页面的进程称为渲染进程 一个应用可以有多个渲染进程 作用: 通过Node.js, Electron提供的API可以跟系统底层打交道 常用模块: **(常用): **ipcRenderer , remote , desktopCapture , clipboard , crashReporter webFrame , shell , nativelmage 进程间通信通信工具: IPC通信模块 Electron 提供了IPC通信模块, 主进程的 ipcMain 和渲染进程的 ipcRenderer ipcMain 和 ipcRenderer 都是EventEmitter 对象 从渲染进程到主进程 (render to main) Callbake写法: ipcRenderer.send( channer, …args) // 渲染进程中发送 ipcMain.on(channel, handler) // 主进程中响应 123456789101112131415// Render-process.jsconst &#123;ipcRenderer&#125; = require(&#x27;electron&#x27;);ipcRenderer.send(&#x27;通信频段名&#x27;, 0或N个参数);// Main-process.js...function handleIPC() &#123; ipcMain.on(&#x27;通信频段名&#x27;, (err, 0或N个参数) =&gt; &#123; // do something to reply &#125;);&#125;setTimeout(handleIPC, 500);... Promise写法 (Electron 7.0之后, 处理请求 + 响应模式): ipcRenderer.invoke(channel, …args) // 渲染进程中发送 ipcMain.handle(channel, handler) // 主进程中响应 从主进程到渲染进程 (main to render) ipcRenderer.on(channel, handler) // 渲染进程中响应 webContents.send(channel) // 主进程中发送 123456789101112// Main-process.js...mainWindow = new BrowserWindow(&#123;......&#125;);mainWindow.webContents.send(&#x27;通信频段名&#x27;);...// Render-process.jsconst &#123;ipcRenderer&#125; = require(&#x27;electron&#x27;);ipcRenderer.on(&#x27;通信频段名&#x27;, (err, 0或N个参数) =&gt; &#123; // do something to reply&#125;) 从渲染进程到渲染进程 (render to render) 页面间通信页面之间的通信主要做两件事情: 1. 通知事件; 2. 数据共享 通知事件 ipcRenderer.sendTo( webContentsId, channel, …args ) 1234567891011121314151617181920// Main-process.jsconst &#123;app, BrowserWindow, Notification, ipcMain&#125; = require(&#x27;electron&#x27;);let win1 = null;let win2 = null;app.on(&#x27;ready&#x27;, () =&gt; &#123; win1 = new BrowserWindow(&#123; width:500, heigth:500, webPreferences:&#123;nodeIntegration:true&#125; &#125;); win1.loadFile(&#x27;./win1.html&#x27;); win2 = new BrowserWindow(&#123; width:500, heigth:500, webPreferences:&#123;nodeIntegration:true&#125; &#125;); win2.loadFile(&#x27;./win2.html&#x27;); global.sharedObject = &#123; win2WebContentsId: win2.webContents.id &#125; //把win2的id放在全局对象中&#125;); 12345// render1-process.js// senderconst &#123;ipcRenderer, remote&#125; = require(&#x27;electron&#x27;)let win2Id = remote.getGlobal(&#x27;sharedObject&#x27;).win2WenContentsId //获取win2的idipcRenderer.sendTo(win2Id, &#x27;通信频段名&#x27;, 0或N个参数) // 与win2进行通信 123456// render2-process.js// responserconst &#123;ipcRenderer&#125; = require(&#x27;electron&#x27;)ipcRenderer.on(&#x27;通信频段名&#x27;, (err, 0或N个参数) =&gt; &#123; // 响应 // do something to reply&#125;); 数据共享 使用web技术( localStorage , sessionStorage , indexedDB ) 调试渲染进程的调试 用代码打开 Chromiun的开发者工具 12let win = new BrowserWindow();win.webContents.openDevTools(); 输入命令行 electron . 之后, 在窗口按下快捷键 Ctrl + Shift + i 主进程的调试Electron 主进程是一个 Node.js 进程。Node.js 在 8 之后引入了 --inspect 参数用于调试，同样也适用于 Electron 主进程： 1electron . --inspect 默认会监听 9229 端口，应用启动后，在 Chrome 浏览器（或其他基于 Chromium 开发的浏览器）中打开 chrome://inspect 即可看到对应的调试会话，点击会话链接即可打开 devtools 进行调试。 另外，可以在命令行参数中指定端口号，实现同时调试多个应用中的多个进程而不产生冲突： 1electron . --inspect=1234 步骤1.开启命令行开关 启动electron的时候需要带上inspect开关，并配置调试端口. 有两个开关，分别是 --inspect=[port] 和 --inspect-brk=[port]，区别在于后者会暂停在第一行js代码 这里建议在 package.json 的 script 字段添加如下内容 12345&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;electron .&quot;, &quot;debug&quot;: &quot;electron . --inspect=5858&quot; // 添加这行 &#125;, 2.设置chrome调试器 打开chrome，然后新开一个标签进入chrome://inspect ，这里我们要先配置监听的端口，不然的话，Remote Target列表里是不会出现要调试的electron程序的 &gt;_ &gt;_ 然后在项目目录下就可以直接使用命令 1npm run debug 就可以看到如下画面: &gt;_ 3.调试 点击 inspect 就可以进行调试了. 在 VSCode 中调试上述方法均会打开 devtools 界面，所有的调试操作均在 devtools 中进行。对于某些操作比如代码断点调试，可以进一步与编辑器或 IDE 相结合，提升开发体验。以下将简要介绍如何在 VSCode 进行调试。 以 Electron 官方的模板 electron-quick-start 为例，首先需要为 VSCode 安装一个扩展：Debugger for Chrome（用于调试渲染进程）。克隆代码仓库到本地并安装依赖： 123git clone https://github.com/electron/electron-quick-start.gitcd electron-quick-startnpm install 然后在仓库中添加文件 .vscode/launch.json，内容如下： 12345678910111213141516171819202122232425262728&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Main&quot;, &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;runtimeExecutable&quot;: &quot;C:\\\\Users\\\\用户名\\\\AppData\\\\Roaming\\\\npm\\\\electron&quot;, &quot;runtimeArgs&quot;: [&quot;--remote-debugging-port=9222&quot;, &quot;.&quot;], &quot;windows&quot;: &#123; &quot;runtimeExecutable&quot;: &quot;C:\\\\Users\\\\用户名\\\\AppData\\\\Roaming\\\\npm\\\\electron.cmd&quot; &#125; &#125;, &#123; &quot;name&quot;: &quot;Renderer&quot;, &quot;type&quot;: &quot;chrome&quot;, &quot;request&quot;: &quot;attach&quot;, &quot;port&quot;: 9222, &quot;webRoot&quot;: &quot;$&#123;workspaceFolder&#125;&quot; &#125; ], &quot;compounds&quot;: [ &#123; &quot;name&quot;: &quot;All&quot;, &quot;configurations&quot;: [&quot;Main&quot;, &quot;Renderer&quot;] &#125; ]&#125; 注意: Windows系统的路径分隔符要写作 “\\\\“ if 普通安装electron ​ then 把”用户名”改成”你系统的用户名”; else 自定义安装electron ​ then 找到你的 electron.cmd; ​ 复制路径; ​ 到 json中修改; if Linux用户 ​ then 系统.路径分隔符 = “/“ if (项目根目录/node_modules/.bin/electron).isExist ​ then 1234&quot;runtimeExecutable&quot;: &quot;$&#123;workspaceFolder&#125;/node_modules/.bin/electron&quot;,&quot;windows&quot;: &#123; &quot;runtimeExecutable&quot;: &quot;$&#123;workspaceFolder&#125;/node_modules/.bin/electron.cmd&quot;&#125; 然后在 VSCode 左侧选择 debug 面板，启动 All 这一项开始调试，此时就可以在 main.js 或 renderer.js 文件中添加断点了： 配置文件中的一些要点解释如下： configurations 中的两项分别对应主进程和渲染进程。compounds 中指定了一个组合会话 All，选择 All 将会同时启动这两个会话。 Renderer 配置中的 webRoot 参数直接使用了 $&#123;workspaceFolder&#125;，是因为在这个工程中，HTML 引用的静态资源位于根目录下。实际使用的时候需要更新到对应的路径才会生效。 实际开发中可能会有编译的流程，比如使用 TypeScript 配合打包工具 Webpack，最终生成的代码与源代码并不在一个路径下。这种情况下需要产出 source map 来建立映射关系。 &gt;_ 经验技巧 少用remote模块 因为每次remote会触发底层的同步IPC事件, 特别影响性能, 处理的不好容易进程卡死 不要用sync模式 一旦写的不好就会整个应用卡死 在请求+响应的通信模式下,需要自定义超时限制 在响应的时候需要设置一个时长限制, 当应用响应超时, 需要response一个异常的超时事件让业务处理, 然后去做对应的交互","categories":[{"name":"Electron","slug":"Electron","permalink":"https://www.boii.xyz/categories/Electron/"},{"name":"Note","slug":"Note","permalink":"https://www.boii.xyz/categories/Note/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"https://www.boii.xyz/tags/Electron/"},{"name":"note","slug":"note","permalink":"https://www.boii.xyz/tags/note/"}]},{"title":"Git-基本操作说明","slug":"Git/Git-基本操作说明","date":"2019-07-18T00:09:37.000Z","updated":"2021-07-19T09:02:50.840Z","comments":true,"path":"posts/42006.html","link":"","permalink":"https://www.boii.xyz/posts/42006.html","excerpt":"Git Yes!","text":"Git Yes! 经典git关系图 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 初始化刚新建一个项目的时候需要来几条初始化命令 生成本地仓库git init 把工作区的文件提交到暂存区git add .或者git add 文件名 把暂存区的文件提交到本地仓库git commit -m “描述”这里的描述就是到时候看到的下面的这些 先给你要提交的远程仓库起个别名git remote add 仓库别名 Git地址Git地址如下图所示 把本地仓库的文件提交到远程仓库（就是github上能看到的那种）git push -u 仓库别名 分支名分支就是….算了这里是傻瓜备忘不想解释 到这就可以上去github看看了。文件内容都在里面 第二次提交第二次提交的时候一般不是整个项目都有变动对吧？没事git会自动识别修改过的和没修改过的文件 可以看看git识别到哪些git status 红色的，Umerged，表示工作区有改动的文件，还没提交到暂存区git文件的四种状态 untracked 未被追踪的。就是还没添加过的 unmodified 工作区里已经被追踪了，还没修改 modified 工作区的文件修改了但还没提交到暂存区 staged 添加到了暂存区倒是还没提交到远程仓库 把它提交到暂存区去git add . 把它提交到本地仓库去git commit -m “描述” 把它提交到远程仓库去git push -u 远程仓库别名 分支名 搞定！ 拉取远程仓库的文件到本地git pull 远程仓库别名 分支名 多用户共同开发的时候，新用户可能会在本地新建一个文件夹，然后git init, 接着pull可能会出现拉取失败，因为git认为这是两个不同的项目，所以拒绝拉取合并，可以加上--allow-unrelated-histories 1git pull 仓库别名 分支名 --allow-unrelated-histories 总结要把代码写完放在github上就等于 你要从山旮旯里寄东西到北京 工作区 =&gt; 就是你项目的文件夹，你经营的这家客栈暂存区 =&gt; 就是你这个项目的git索引，你这个村里的驿站本地仓库 =&gt; 就是你电脑里的一个存储库，你市里的驿站远程仓库 =&gt; 就是github服务器上面，北京 你东西收拾好了的时候 得找村里的快递站帮你保管和寄送到市里的快递站git add .等你说commit的时候 市里的快递站 就给你 送到省里的快递站git commit -m &quot;描述&quot;等你说push的时候 省里的快递站 就给你 送到北京git push -u 远程仓库别名 分支名 &gt;_","categories":[{"name":"Git","slug":"Git","permalink":"https://www.boii.xyz/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.boii.xyz/tags/git/"},{"name":"命令","slug":"命令","permalink":"https://www.boii.xyz/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"SSM-配置文件","slug":"Java/SSM/SSM-配置文件","date":"2019-07-14T15:19:12.000Z","updated":"2021-07-19T08:58:54.399Z","comments":true,"path":"posts/25425.html","link":"","permalink":"https://www.boii.xyz/posts/25425.html","excerpt":"先把配置文件捋清楚","text":"先把配置文件捋清楚 前言SSM框架中有几个比较重要的配置文件，一开始学起来会很模糊，这里做一下整理 当一个web程序启动时，Tomcat服务器最先会读取 web.xml 文件，这个文件中会启动一些配置，还会启动Spring配置文件**applicationContext.xml** 和SpringMVC配置文件 springMVC-servlet.xml 这两个文件，在运行 applicationContext.xml 的时候会启动MyBatis的配置文件 **myBatis.xml**，并且会调用到 jdbc.properties 和 log4J.properties 两个资源属性文件里的属性。 web.xml接下来先看看最先启动的 web.xml 是都怎么配置。 在Spring配置中和在Servlet配置中，就启动了applicationContext 和 SpringMVC-servlet 两个配置文件 启动applicationContext 1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 启动SpringMVC-servlet 1234567891011&lt;!--部署Servlet分发器 DispatcherServlet--&gt;&lt;servlet&gt; &lt;servlet-name&gt;springer&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--注册DispatcherServlet的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springer-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 运行到这的时候就会调用到上述两个文件。 整个文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;!--以下配置的加载顺序:先 ServletContext &gt;&gt; context-param &gt;&gt; listener &gt;&gt; filter &gt;&gt; servlet &gt;&gt; spring--&gt; &lt;!-- ==================== 欢迎页配置 ==================== --&gt; &lt;!--配置欢迎页--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- ==================== Spring配置 ==================== --&gt; &lt;!--启动Spinrg 配置文件 applicationContext.xml--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--配置监听器，加载Spring 配置文件--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- ==================== Serlvet配置 ==================== --&gt; &lt;!--部署Servlet分发器 DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springer&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--注册DispatcherServlet的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springer-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--配置DispatcherServlet的作用范围，这里作用于整个web目录--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springer&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- ==================== 过滤器配置 ==================== --&gt; &lt;!--配置过编码滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!--编码格式：UTF-8--&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--是否全部过滤，包括符合格式的文件/请求--&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!--配置过滤器的作用范围，这里作用于整个WEB目录--&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- ==================== 错误页面配置 ==================== --&gt; &lt;!--404错误页面注册--&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/WEB-INF/jsp/404.jsp&lt;/location&gt; &lt;/error-page&gt;&lt;/web-app&gt; applicationContext.xml这个文件是第二个启动的配置文件 在这个文件里主要做了几件事情： 加载jdbc.properties资源属性文件 配置数据源 配置Mybatis工厂 指定数据源 指定Mybatis配置文件 批量配置Mapper接口 设置需要扫描的dao包 配置sqlSessionFactory对象 添加事务支持 配置事务管理器 配置通知 配置切面 扫描service包 下面一个一个解释： 1.加载jdbc.properties1&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; 把连接数据库的一些数据分离出来写在jdbc.properties这个文件中，加载了这个文件就可以使用这些属性 而在 jdbc.properties 文件中的内容如下（这里演示的是MySQL8.0）: 1234567jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/transactional?useSSL=false?serverTimezone=Hongkong?characterEncoding=utf-8?autoReconnect=truejdbc.username=rootjdbc.password=123456jdbc.maxTotal=30jdbc.maxIdle=10jdbc.initialSize=5 至于如何调用，则在下面的配置数据源中演示 2.配置数据源123456789101112&lt;bean id=&quot;dSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=&quot;maxTotal&quot; value=&quot;$&#123;jdbc.maxTotal&#125;&quot;/&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;jdbc.maxIdle&#125;&quot;/&gt; &lt;!-- 初始化连接数 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;jdbc.initialSize&#125;&quot;/&gt; &lt;/bean&gt; 在上面已经加载了jdbc.properties，所以在配置数据源的时候直接用 $&#123;属性名&#125; 就可以使用该属性。这样做的好处是，在多处调用 jdbc.properties 里的那些属性的时候，如果要该一个属性比如数据库密码，只需要修改jdbc.properties 中的 jdbc.password 的值就行了。 3.配置Mybatis工厂123456784&lt;!-- 配置MyBatis工厂，同时指定数据源，并与MyBatis完美整合 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--指定数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dSource&quot;/&gt; &lt;!-- configLocation的属性值为MyBatis的核心配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;/bean&gt; 注意指定数据源的 &lt;property&gt; 标签中的 ref 属性，要和数据源的 id 对应 在第二个 &lt;property&gt; 中指定和启动了Mybatis的配置文件 4.配置数据映射接口数据映射接口，也就是dao，通过Mybatis配置文件映射到数据库操作文件 12345&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- mybatis-spring组件的扫描器 ，必须写全dao的包名，且只能扫描一个dao包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;dao&quot;/&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt; 配置以后，Spring会自动扫描MyBatis的接口并装配（Spring将指定包中所有被@Mapper注解标注的接口自动装配为MyBatis的映射接口） 在Eclipse中的进行项目的话要写全dao 的包名，比如 com.github.java.dao 这样，而在IDEA中一般会配置好项目的source root 根目录 和 resource root 资源目录，所以写dao包名就好。 例如我的目录结构，我设置了java为source root 根目录，所以不用写全包名 5.添加事务支持12345&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;4&lt;property name=&quot;dataSource&quot; ref=&quot;dSource&quot; /&gt;&lt;/bean&gt;&lt;!-- 开启事务注解 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt; 事务支持有很多种方法，这种是基于@Transactional注解的事务管理。 还有一种是声明式事务管理 6.扫描service包1&lt;context:component-scan base-package=&quot;service&quot;/&gt; 完整文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;4 &lt;!--=================== 加载jdbc.properties ===================--&gt;4&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--======================== 配置数据源 ========================--&gt; &lt;bean id=&quot;dSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=&quot;maxTotal&quot; value=&quot;$&#123;jdbc.maxTotal&#125;&quot;/&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;jdbc.maxIdle&#125;&quot;/&gt; &lt;!-- 初始化连接数 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;jdbc.initialSize&#125;&quot;/&gt; &lt;/bean&gt; &lt;!--======================== 配置MyBatis工厂 ========================--&gt;4&lt;!-- 配置MyBatis工厂，同时指定数据源，并与MyBatis完美整合 --&gt;4&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;44&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;44&lt;!-- configLocation的属性值为MyBatis的核心配置文件 --&gt;44&lt;property name=&quot;configLocation&quot; value=&quot;classpath:com/mybatis/mybatis-config.xml&quot; /&gt;4&lt;/bean&gt; &lt;!--======================== Mapper代理 ========================--&gt; 4&lt;!--Mapper代理开发，使用Spring自动扫描MyBatis的接口并装配（Spring将指定包中所有被@Mapper注解标注的接口自动装配为MyBatis的映射接口） --&gt;4&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;44&lt;!-- mybatis-spring组件的扫描器 ，必须写全dao的包名，且只能扫描一个dao包 --&gt;44&lt;property name=&quot;basePackage&quot; value=&quot;com.dao&quot; /&gt;44&lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;4&lt;/bean&gt; 4&lt;!--======================== 扫描Service包 ========================--&gt; 4&lt;!-- dao包在mybatis-spring组件中已经扫描，这里不再需要扫描 --&gt;4&lt;context:component-scan base-package=&quot;com.service&quot; /&gt; &lt;!--======================== 配置事务支持 ========================--&gt; 4&lt;!-- 添加事务支持 --&gt;4&lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;44&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;4&lt;/bean&gt;4&lt;!-- 开启事务注解 --&gt;4&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot; /&gt;&lt;/beans&gt; SpringMVC-servlet.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;controller&quot;/&gt; &lt;context:component-scan base-package=&quot;converter&quot;/&gt; &lt;context:component-scan base-package=&quot;formatter&quot;/&gt; &lt;context:component-scan base-package=&quot;utils&quot;/&gt; &lt;context:component-scan base-package=&quot;po&quot;/&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt; &lt;mvc:resources location=&quot;/html/&quot; mapping=&quot;/html/**&quot;/&gt; &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot;/&gt; &lt;!--==================== 配置视图解析器 ====================--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!--==================== 注册类型转换器 ====================--&gt; &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;converter.GoodsConverter&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--启动类型转换器--&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt; &lt;!--==================== 注册格式化转换器 ====================--&gt; &lt;bean id=&quot;formattingConversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;formatters&quot;&gt; &lt;set&gt; &lt;bean class=&quot;formatter.GoodsFormatter&quot;/&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--启动格式化转换器--&gt; &lt;mvc:annotation-driven conversion-service=&quot;formattingConversionService&quot;/&gt; &lt;!--==================== 配置校验器 ====================--&gt; &lt;!--配置错误消息资源--&gt; &lt;bean id=&quot;msgSource&quot; class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;basenames&quot; value=&quot;errorMessages&quot;/&gt; &lt;!--资源文件编码格式--&gt; &lt;property name=&quot;fileEncodings&quot; value=&quot;utf-8&quot;/&gt; &lt;!--对资源文件内容缓存时间，单位秒--&gt; &lt;property name=&quot;cacheSeconds&quot; value=&quot;120&quot;/&gt; &lt;/bean&gt; &lt;!--注册校验器--&gt; &lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;&gt; &lt;!--hibernate校验器--&gt; &lt;property name=&quot;providerClass&quot; value=&quot;org.hibernate.validator.HibernateValidator&quot;/&gt; &lt;!--指定校验使用的资源为将，在文件中配置校验错误信息--&gt; &lt;property name=&quot;validationMessageSource&quot; ref=&quot;msgSource&quot;/&gt; &lt;/bean&gt; &lt;!--启动spring的valid校验功能--&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot; validator=&quot;validator&quot;/&gt; &lt;!--==================== 配置拦截器 ====================--&gt; &lt;mvc:interceptors&gt; &lt;!--&lt;bean class=&quot;interceptor.AllInterceptor&quot;/&gt;--&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/&quot;/&gt; &lt;bean class=&quot;interceptor.Interceptor1&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/five&quot;/&gt; &lt;bean class=&quot;interceptor.Interceptor2&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;!--==================== 配置文件上传和下载 ====================--&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot; p:defaultEncoding=&quot;UTF-8&quot; p:maxUploadSize=&quot;5400000&quot; p:uploadTempDir=&quot;fileUpload/temp&quot;&gt; &lt;/bean&gt; &lt;!--==================== 配置异常处理 ====================--&gt; &lt;!--使用@ExceptionHandler注解时注释掉，因为@ExceptionHandler注解方法不能有任何配置--&gt; &lt;!--统一异常处理，托管MyExceptionHandler--&gt; &lt;!--&lt;bean class=&quot;exception.MyExceptionHandler&quot;/&gt;--&gt; &lt;!--统一异常处理，使用SimpleMappingExceptionResolver异常处理器处理异常--&gt; &lt;!--&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;定义默认的异常处理页面，当该异常类型注册时使用&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;property name=&quot;defaultErrorView&quot; value=&quot;error&quot;/&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;定义异常处理页面用来获取异常信息的变量名，默认名为exception&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;/&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;定义需要特殊处理的异常，用类名活完全路径名为key，异常页名为值&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;property name=&quot;exceptionMappings&quot;&gt;--&gt; &lt;!--&lt;props&gt;--&gt; &lt;!--&lt;prop key=&quot;exception.MyException&quot;&gt;my-error&lt;/prop&gt;--&gt; &lt;!--&lt;prop key=&quot;java.sql.SQLException&quot;&gt;sql-error&lt;/prop&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;这里还可以继续扩展对不同异常类型的处理&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;/props&gt;--&gt; &lt;!--&lt;/property&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt;&lt;/beans&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"},{"name":"SSM","slug":"Java/SSM","permalink":"https://www.boii.xyz/categories/Java/SSM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/tags/SSM/"},{"name":"SSM配置","slug":"SSM配置","permalink":"https://www.boii.xyz/tags/SSM%E9%85%8D%E7%BD%AE/"}]},{"title":"SSM-8-Spring事务管理","slug":"Java/SSM/SSM-8-Spring事务管理","date":"2019-07-13T09:04:13.000Z","updated":"2021-07-19T08:58:54.313Z","comments":true,"path":"posts/3844.html","link":"","permalink":"https://www.boii.xyz/posts/3844.html","excerpt":"有了事务好管理","text":"有了事务好管理 前言事务：也就是一个用户操作中，需要包含哪些具体操作。这些操作集合在一起，就是事务。这些操作必须是具体的，必要的，不可分割的。要么全部完成，要么全部失败。 比如你给你朋友转账1000块的操作，分成几个步骤就是： 自己的账户扣1000块钱 对方的账户加1000块钱 把这笔转账行为记录在服务器中 这三个步骤就具备了原子性，一致性，隔离性，持久性。 原子性：要么全部完成，有一个完成不了就全部回滚。比如自己的账户扣钱成功，但是对方的账户加钱失败，那么就回滚，自己的账户的钱恢复到转账钱的余额。 一致性： 一致性代表了底层数据存储的完整性。例如你转账给朋友1000块，那你的账户要扣1000块，你朋友的账户得增加1000块，如果只增加了500块，那就是不一致。 隔离性：隔离性意味着事务必须在不干扰其他进程或事务的前提下独立执行。也就是，在事务或工作单元执行完毕之前，其所访问的数据不能受系统其他部分的影响。比如你在给朋友转账的时候，别人给你转账是转不了的。因为要确保你的账户的隔离。 持久性：持久性表示在某个事务的执行过程中，对数据所作的所有改动都必须在事务成功结束前保存至某种物理存储设备。转账后要把这次转账记录在服务器里，不管过了多久都可以查。 事务的三个主要方法：开启事务 BeginTranscation()，提交 commit() ，回滚 rollback()","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"},{"name":"SSM","slug":"Java/SSM","permalink":"https://www.boii.xyz/categories/Java/SSM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/tags/SSM/"},{"name":"事务管理","slug":"事务管理","permalink":"https://www.boii.xyz/tags/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"}]},{"title":"SSM-7-统一异常处理","slug":"Java/SSM/SSM-7-统一异常处理","date":"2019-07-11T12:55:10.000Z","updated":"2021-07-19T08:58:54.169Z","comments":true,"path":"posts/59097.html","link":"","permalink":"https://www.boii.xyz/posts/59097.html","excerpt":"遇到异常不要慌～","text":"遇到异常不要慌～ 摘要程序运行过程中总会遇到一些可预知的，不可预知的异常。如果不对这些异常进行捕捉和处理，就会导致程序崩溃、停止运行、闪退等诸多令人体验极差的现象。如果对这些异常一个一个单独处理，则代码显得很臃肿，耦合度高（独立性差），所以要用统一异常处理对所有的代码进行异常处理 SpringMVC处理异常有三种方式： 简单异常处理SimpleMappingExceptionResolver 实现HandlerExceptionResolver接口自定义异常 使用@ExceptionHandler注解实现异常处理 在程序中可能出现异常的地方进行捕捉，程序发生异常被捕捉到后，就会调用我们编写的统一异常处理类进行处理 效果图 使用步骤由于我们太完美了程序暂时没有什么异常，所以我们得自己制造点异常。 我们先做一个列表，把控制层，业务层，模型层的各种异常集中链接在这里。 1234567891011121314151617181920&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;/&gt; &lt;title&gt;Exception&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;body&quot;&gt; &lt;h3&gt;&lt;a href=&quot;db&quot;&gt;控制器中数据库异常&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href=&quot;my&quot;&gt;控制器中自定义异常&lt;/a&gt;&lt;/h3&gt; &lt;h3&gt;&lt;a href=&quot;no&quot;&gt;控制器中未知异常&lt;/a&gt;&lt;/h3&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如下图： 这些链接点击后跳转到控制层里进行处理。而程序不会无端端的就异常，所以我们得先在控制器里弄点异常：自己主动抛出一个异常 。 先主动搞个异常1throw new SQLException(&quot;控制器中数据库异常&quot;); 这句话就是主动抛出一个异常。 整体的代码如下： 123456789101112131415@Controllerpublic class ExceptionController&#123; @RequestMapping(&quot;/db&quot;) public void db() throws Exception &#123; throw new SQLException(&quot;控制器中数据库异常&quot;); &#125; @RequestMapping(&quot;/my&quot;) public void my() throws Exception &#123; throw new MyException(&quot;控制器中自定义异常&quot;); &#125; @RequestMapping(&quot;/no&quot;) public void no() throws Exception &#123; throw new Exception(&quot;控制器中未知异常&quot;); &#125;&#125; 好了制造好了异常，现在开始来处理。一共有三种方法 实现HandlerExceptionResolver接口1.编写一个类实现HandlerExceptionResolver接口异常抛出后，就会被捕捉，捕捉后就要进行处理啦。我们编写一个类，这个类要实现 HandlerExceptionResolver接口里的 resolveException() 方法。 123456789101112131415161718192021222324252627282930public class MyExceptionHandler implements HandlerExceptionResolver &#123; /** * 重写接口方法 * * @param arg0 servlet请求 * @param arg1 servlet响应 * @param obj 目标对象 * @param ex 异常 * @return 返回相应的视图 */ @Override public ModelAndView resolveException(HttpServletRequest arg0, HttpServletResponse arg1, Object obj, Exception ex) &#123; Map&lt;String, Object&gt; model = new HashMap&lt;&gt;(); model.put(&quot;ex&quot;, ex); // 根据不同错误转向不同页面（统一处理），即异常与view的对应关系 // 如果异常属于自定义异常类型 if (ex instanceof MyException) &#123; return new ModelAndView(&quot;exception/my-error&quot;, model); // 如果异常属于数据库异常类型 &#125; else if (ex instanceof SQLException) &#123; return new ModelAndView(&quot;exception/sql-error&quot;, model); // 如果异常属于未知类型 &#125; else &#123; return new ModelAndView(&quot;exception/error&quot;, model); &#125; &#125;&#125; 控制层里制造了三种不同的异常 ，这些异常被捕捉后会被送到这里进行处理。这里主要就是根据异常的不同类型返回不同的视图页面。 3. 在SpringMVC配置文件中配置1&lt;bean class=&quot;exception.MyExceptionHandler&quot;/&gt; 使用@ExceptionHandler注解实现异常处理这种是最容易的一种方式，集成简单，扩展性好。 1.创建一个BaseController类创建一个抽象类，并在类中使用@ExceptionHandler注解声明异常处理方法 12345678910111213141516171819public abstract class BaseController &#123; /** * 异常处理方法 * @param request Servlet请求 * @param ex 异常实例 * @return 返回一个视图页面的名称 */ @ExceptionHandler public String exception(HttpServletRequest request, Exception ex)&#123; request.setAttribute(&quot;ex&quot;, ex); if (ex instanceof SQLException) &#123; return &quot;404&quot;; &#125; else if ( ex instanceof MyException) &#123; return &quot;exception/my-error&quot;; &#125; else &#123; return &quot;exception/error&quot;; &#125; &#125;&#125; 2.让其他控制器继承这个类让其他需要处理异常的类继承这个BaseController类 123public class ExceptionController extends BaseController&#123; ......&#125; 3. 注意使用这种方法是配置文件中不要配置任何其他异常处理方法。注意使用这种方法是配置文件中不要配置任何其他异常处理方法！！！ 注意使用这种方法是配置文件中不要配置任何其他异常处理方法！！！ 注意使用这种方法是配置文件中不要配置任何其他异常处理方法！！！ 简单异常处理SimpleMappingExceptionResolver1234567891011121314&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;!--定义默认的异常处理页面，当该异常类型注册时使用--&gt; &lt;property name=&quot;defaultErrorView&quot; value=&quot;error&quot;/&gt; &lt;!--定义异常处理页面用来获取异常信息的变量名，默认名为exception--&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;/&gt; &lt;!--定义需要特殊处理的异常，用类名活完全路径名为key，异常页名为值--&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;exception.MyException&quot;&gt;my-error&lt;/prop&gt; &lt;prop key=&quot;java.sql.SQLException&quot;&gt;sql-error&lt;/prop&gt; &lt;!--这里还可以继续扩展对不同异常类型的处理--&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 在SpringMVC配置文件中配置 SimpleMappingExceptionResolver异常处理器 ，即可实现对异常的统一处理。 主要分默认异常处理页面，获取异常信息的变量名，还有一些需要特殊处理的异常。 总结最简单的使用@ExceptionHandler注解的方法，虽然有集成简单，可扩展性好等优点，但是该方法对已有代码存在入侵性，需要修改已有代码，是相关类继承于BaseController。 而第一种写一个HandlerExceptionResolver的实现类的方法则比较温和，不会对代码进行入侵。记得要在SpringMVC配置文件中托管这个实现类：&lt;bean class=&quot;exception.MyExceptionHandler&quot;/&gt; 最后一种其实最方便啦，配置好就OK，不用增加什么文件。","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"},{"name":"SSM","slug":"Java/SSM","permalink":"https://www.boii.xyz/categories/Java/SSM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/tags/SSM/"},{"name":"统一异常处理","slug":"统一异常处理","permalink":"https://www.boii.xyz/tags/%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}]},{"title":"SSM-6-上传和下载","slug":"Java/SSM/SSM-6-上传和下载","date":"2019-07-09T17:04:18.000Z","updated":"2021-07-19T08:58:54.054Z","comments":true,"path":"posts/4950.html","link":"","permalink":"https://www.boii.xyz/posts/4950.html","excerpt":"来了，上下都来了～","text":"来了，上下都来了～ 摘要文件上传和下载是web经常要面对的问题。 上传的方式有多种，包括： 使用文件流手工编程上传 基于commons-fileupload组件的文件上传 基于Servlet3及以上版本文件上传 下载经常有两种方式： 通过超链接实现下载，但是会暴露下载文件的真实位置，并且只能下载存放在web应用所在的目录下的文件。 利用程序编码实现下载，可以增加安全访问控制，还可以从任意位置提供下载的数据，比如数据库。 效果图上传 选择文件前 选择文件后 上传文件后 下载 可以被下载的文件列表 选择文件存储位置 使用步骤导入jar包SpringMVC框架的文件上传是基于commons-fileupload组件，所以需要commons-fileupload和commons-io的jar包。 maven项目：配置pom.xml 1234567891011&lt;!--上传下载--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 非maven项目：将下载好的 commons-fileupload 和 commons-io 的jar放到 webapps\\WEB-INF\\lib 目录下 单文件上传1. 编写领域模型文件上传后保存在服务器里是一个对象，这个对象我们得定义它的属性。文件上传的时候的文件描述（备注），文件的创建时间等等，最重要的文件本身的类型是 MultipartFile 1234567891011121314151617181920public class FileDomain &#123; private String description; private MultipartFile myFile; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125; public MultipartFile getMyFile() &#123; return myFile; &#125; public void setMyFile(MultipartFile myFile) &#123; this.myFile = myFile; &#125;&#125; 2. 编写一个提交页面12345678910111213141516171819&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;/&gt; &lt;title&gt;onFile&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;six/oneFileUpLoad&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 选择文件：&lt;input type=&quot;file&quot; name=&quot;myFile&quot;/&gt;&lt;br&gt; 文件描述：&lt;input type=&quot;text&quot; name=&quot;description&quot;/&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; input标签的type属性为file时，就变成选择文件了。 **要注意的是：表单form的enctype属性应设置为 multipart/form-data**。然后就可以把表单提交到控制器了： action=&quot;six/oneFileUpload&quot; 3. 编写控制器123456789101112131415161718192021222324252627@Controller@RequestMapping(&quot;/six&quot;)public class SixController &#123; private static final Log logger = LogFactory.getLog(SixController.class); @RequestMapping(&quot;/oneFileUpLoad&quot;) public String oneFileUpload(@ModelAttribute FileDomain fileDomain, HttpServletRequest request) &#123; // 获取存储路径 String realpath = request.getServletContext().getRealPath(&quot;fileUpload&quot;); // 获取文件名 String fileName = fileDomain.getMyFile().getOriginalFilename(); // 如果文件名不为null &amp;&amp; 目标文件夹不存在，则新建文件夹 assert fileName != null; File targetFile = new File(realpath, fileName); if (!targetFile.exists()) &#123; targetFile.mkdirs(); &#125; // 开始上传文件 try &#123; fileDomain.getMyFile().transferTo(targetFile); logger.info(&quot;成功&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return &quot;6/showOne&quot;; &#125;&#125; 表单提交到控制器后就由控制器进行处理。 先获取realPath：文件保存到服务器的哪个地方，也叫存储路径。文件上传后都是存在服务器的，所以这里说的路径是指在服务器上的存储路径。 然后获取文件的文件名 如果realPath这个目录不存在，就创建目录 然后就开始上传文件。上传的关键方法就是 transferTo() 这里上传成功就会跳转到 /WEB-INF/jsp/6/showOne 页面 &gt;_ 4. 编写结果页面也就是上面要跳转的 /WEB-INF/jsp/6/showOne 页面 12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;/&gt; &lt;title&gt;ShowOne&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;fileDomain.description&#125;&lt;br&gt;$&#123;fileDomain.myFile.originalFilename&#125;&lt;/body&gt;&lt;/html&gt; 多文件上传多文件上传和单文件的上传过程是相同的，但是他们的模型是不同的。多文件上传的模型是列表list 1.领域模型1234567891011121314151617181920public class MultiFileDomain &#123; private List&lt;String&gt; description; private List&lt;MultipartFile&gt; myFile; public List&lt;String&gt; getDescription() &#123; return description; &#125; public void setDescription(List&lt;String&gt; description) &#123; this.description = description; &#125; public List&lt;MultipartFile&gt; getMyFile() &#123; return myFile; &#125; public void setMyFile(List&lt;MultipartFile&gt; myFile) &#123; this.myFile = myFile; &#125;&#125; 跟单文件上传的类型差不多，不同在于用list去装载。 2.编写提交页面1234567891011121314151617181920212223&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;/&gt; &lt;title&gt;MultiFile&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;six/mutliFile&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 选择文件1：&lt;input type=&quot;file&quot; name=&quot;myFile&quot;/&gt; &lt;br&gt; 文件描述1：&lt;input type=&quot;text&quot; name=&quot;description&quot;/&gt;&lt;br&gt; 选择文件2：&lt;input type=&quot;file&quot; name=&quot;myFile&quot;/&gt; &lt;br&gt; 文件描述2：&lt;input type=&quot;text&quot; name=&quot;description&quot;/&gt;&lt;br&gt; 选择文件3：&lt;input type=&quot;file&quot; name=&quot;myFile&quot;/&gt; &lt;br&gt; 文件描述3：&lt;input type=&quot;text&quot; name=&quot;description&quot;/&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 同样是enctype属性要设置成 multipart/form-data ，通过action属性提交到控制器 3.控制器12345678910111213141516171819202122232425262728293031@Controller@RequestMapping(&quot;/six&quot;)public class SixController &#123; private static final Log logger = LogFactory.getLog(SixController.class); 4@RequestMapping(&quot;/mutliFile&quot;) public String multiFile(@ModelAttribute MultiFileDomain multiFileDomain, HttpServletRequest request) &#123; // 获取真实路径 String realpath = request.getServletContext().getRealPath(&quot;fileUpload&quot;); // 如果目标文件夹不存在则新建文件夹 File targetDir = new File(realpath); if (!targetDir.exists()) &#123; targetDir.mkdirs(); &#125; // 将文件放置到list中 List&lt;MultipartFile&gt; files = multiFileDomain.getMyFile(); // 将list中的文件逐个上传 for (MultipartFile file : files) &#123; String fileName = file.getOriginalFilename(); assert fileName != null; File targetFile = new File(realpath, fileName); try &#123; file.transferTo(targetFile); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; logger.info(&quot;成功&quot;); return &quot;6/showMulti&quot;; &#125;&#125; 控制器里前部分也是相同的，获取存储路径，获取文件名，检查目标目录是否存在。 区别在于：将传过来的文件放在一个新的List中 1List&lt;MultipartFile&gt; files = multiFileDomain.getMyFile(); 然后循环遍历整个List，将文件一个一个上传，然后返回 /WEB-INF/jsp/6/showMulti 页面 下载利用程序实现下载需要设置两个报头： 设置Content-Type的值为：application/x-msdownload，因为web服务器需要告诉浏览器所输出内容的类型不是普通文件文件或是HTML，而是一个要保存到本地的下载文件。 设置Content-Disposition的值为：attachment，后面还可以指定filename参数。filename参数就是那个默认保存文件名。如下图红框所示： 12response.setHeader(&quot;Content-Type&quot;, &quot;application/x-msdownload&quot;);response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + toUTF8(filename)); 1. 编写跳转页面12345678910111213141516171819202122&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;/&gt; &lt;title&gt;MultiFile&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;six/showDownFiles&quot;&gt;文件下载&lt;/a&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 整个页面只有一个a标签的链接。点击之后会跳转到 showDownFiles 控制器 2.编写列表控制器12345678910111213141516171819202122232425@Controller@RequestMapping(&quot;/six&quot;)public class SixController &#123; private static final Log logger = LogFactory.getLog(SixController.class); 4@RequestMapping(&quot;/showDownFiles&quot;) public String showDown(HttpServletRequest request, Model model) &#123; // 获取存储目录 String realpath = request.getServletContext().getRealPath(&quot;fileUpload&quot;); // 实例化为一个File对象 File dir = new File(realpath); // 将目录下的文件放到File数组中 File[] files = dir.listFiles(); // 创建一个数组列表，用于返回到前台页面 ArrayList&lt;String&gt; fileName = new ArrayList&lt;&gt;(); assert files != null; // 逐一将目录下的文件添加到数组列表中 for (File file : files) &#123; fileName.add(file.getName()); &#125; // 将数组列表返回给前台页面 model.addAttribute(&quot;files&quot;, fileName); return &quot;6/showDownFiles&quot;; &#125;&#125; 列出控制器还是比较简单的： 获取存储位置 将路径实例化成一个File对象 将存储位置里的文件放到File数组中 创建一个数组列表，然后将文件逐个添加到数组列表中 将数组列表返回给前台页面 3. 编写下载列表展示页面1234567891011121314151617181920212223&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;/&gt; &lt;title&gt;ShowDownFiles&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table&gt; &lt;tr&gt;&lt;td&gt;被下载文件名&lt;/td&gt;&lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;files&#125;&quot; var=&quot;filename&quot;&gt;&lt;%--@elvariable id=&quot;filesname&quot; type=&quot;po.six.FileDomain&quot;--%&gt; &lt;tr&gt; &lt;td&gt;&lt;a href=&quot;six/down?filename=$&#123;filename&#125;&quot;&gt;$&#123;filename&#125;&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 这里用了表单标签库中的 &lt;c:forEach&gt; 标签，将存储目录中的文件列出来，列出来的每一项都是一个超链接，链接指向 six/down 这个下载控制器。效果如下： 4.编写下载控制器1234567891011121314151617181920212223242526272829303132@Controller@RequestMapping(&quot;/six&quot;)public class SixController &#123; private static final Log logger = LogFactory.getLog(SixController.class); 4@RequestMapping(&quot;/down&quot;) public String down(@RequestParam String filename, HttpServletRequest request, HttpServletResponse response) &#123; try &#123; // 获取存储位置 String savePath = request.getServletContext().getRealPath(&quot;fileUpload&quot;); // 设置报头 response.setHeader(&quot;Content-Type&quot;, &quot;application/x-msdownload&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + toUTF8(filename)); // 读取服务器上的文件并写入到输出对象中，也就是下载 FileInputStream in = new FileInputStream(savePath + &quot;\\\\&quot; + filename); ServletOutputStream out = response.getOutputStream(); out.flush(); int aRead; byte[] b = new byte[1024]; while ((aRead = in.read(b)) != -1) &#123; out.write(b, 0, aRead); &#125; out.flush(); out.close(); in.close(); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; logger.info(&quot;下载成功&quot;); return null; &#125;&#125; 下载控制器则做了几件事情： 获取存储目录 设置报头 将目标文件从输入流读取出来，转移到Servlet输出流写入进去，完成下载这个动作 因为报头的 Content-Disposition 设置为 attachment，所以下载之前浏览器会询问保存位置。 总结上传和下载是web中很重要的一项功能，需要彻底掌握。上传的方式有多种，基于commons-fileupload的文件上传还是比较容易的，关键代码就是transferTo()方法。而下载选择用编码实现是为了不暴露文件的真实位置，还有就是可以下载任意位置的文件，所以可以将文件放在数据库中，然后让下载控制器去数据库中读取下载。虽然步骤比较麻烦，但是安全，规范。","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"},{"name":"SSM","slug":"Java/SSM","permalink":"https://www.boii.xyz/categories/Java/SSM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/tags/SSM/"},{"name":"上传下载","slug":"上传下载","permalink":"https://www.boii.xyz/tags/%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"}]},{"title":"SSM-5-拦截器","slug":"Java/SSM/SSM-5-拦截器","date":"2019-07-07T04:04:18.000Z","updated":"2021-07-19T08:58:53.895Z","comments":true,"path":"posts/46719.html","link":"","permalink":"https://www.boii.xyz/posts/46719.html","excerpt":"拦截器其实就是一种中间件","text":"拦截器其实就是一种中间件 摘要拦截器 Interceptor 主要用于在 请求到达控制器之前进行验证 ，有点类似过滤器。主要用于拦截用户请求并做出相应的处理。通常应用在权限验证，记录请求信息的日志，判断用户是否登录等功能上。 主要的实现方法有两种： 通过实现 HandlerInterceptor接口 或继承 HandlerInterceptor接口 的实现类来定义。 通过实现 WebRequestInterceptor接口 或继承WebRequestInterceptor接口 的实现类来定义。 效果图拦截器的拦截时间点在这里面分三种： 请求到达控制器之前调用，比如点击我的购物车的时候，判断用户有没有登录先 控制器调用之后，返回视图之前。 解析试图之后。比如访问了XXX的QQ空间，就在视图解析完后记录到访问记录中 &gt;_ 这里的案例只是在这些方法里打印了一些话来表示出拦截器在什么时间点做了什么 使用步骤1. 配置先在springmvc-servlet.xml中配置拦截器。 123&lt;mvc:interceptors&gt; &lt;bean class=&quot;interceptor.AllInterceptor&quot;/&gt;&lt;/mvc:interceptors&gt; 这样的配置方式默认对所有请求拦截，也就是任何请求要到达控制器之前都会经过拦截器。 这种方式的话就是拦截所有的请求，但是请求如果是到/abc这个控制器的话就例外，不拦截。 1234567&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/abc&quot;/&gt; &lt;bean class=&quot;interceptor.Interceptor1&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 这种呢就是对发送到/6这个控制器的请求，进行指定的拦截器拦截。 123456&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/6&quot;/&gt; &lt;bean class=&quot;interceptor.Interceptor2&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 2. 实现接口HandlerInterceptor接口中已经有默认的实现方法了，所以implements之后并不会提醒重写方法。 preHandle：在请求到达控制器之前进行拦截 postHandle：控制器调用之后，解析试图之前进行拦截 afterCompletion：在解析试图之后进行拦截 12345678910111213141516171819202122232425package interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class AllInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle，请求到达控制器之前&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle,控制器调用之后，解析试图之前&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion,解析视图之后&quot;); &#125;&#125; 总结拦截器是一个比较重要的东西。使用也简单，主要是两点 编写拦截器的工作，preHandle要干嘛，postHandle要干嘛，afterCompletion要干嘛。 在springmvc配置文件里编写拦截规则，是全部都拦截用一个全局拦截器？还是某个控制器用某个拦截器？","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"},{"name":"SSM","slug":"Java/SSM","permalink":"https://www.boii.xyz/categories/Java/SSM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/tags/SSM/"},{"name":"拦截器","slug":"拦截器","permalink":"https://www.boii.xyz/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"}]},{"title":"SSM-4-数据绑定","slug":"Java/SSM/SSM-4-数据绑定","date":"2019-07-07T02:04:18.000Z","updated":"2021-07-19T08:58:53.714Z","comments":true,"path":"posts/41307.html","link":"","permalink":"https://www.boii.xyz/posts/41307.html","excerpt":"先把数据绑定起来","text":"先把数据绑定起来 摘要数据绑定是将用户参数输入值绑定到领域模型（POJO）的一种特性，在SpringMVC的Controller和View参数传递数据的过程中，所有HTTP请求参数的类型均为字符串，如果模型需要绑定的类型为double或int，则需要手动进行类型转换，而有了数据绑定后： 不需要手动转型数据了。 当表单输入验证失败时，会重新生成一个HTML表单，无需重新填写已输入字段。 效果图第一次加载的样子 验证失败后重新加载的样子，前面填过的数据依然保留着 验证成功后进入这个页面 使用步骤1. 导入jar包maven项目：配置pom.xml 12345678910&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt; 非maven项目：将下载好的 taglibs 和 jstl 的jar放到 webapps\\WEB-INF\\lib 目录下 2. web.xml中配置编码过滤器12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 3. 编写领域模型定义各种属性和getter&amp;setter方法，太简单，不赘述 4. 编写控制层Controller因为视图层用的都是表单标签库，所以数据要在controller层定义 然后通过model.addAttribute()方法将数据传送出去 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Controller@RequestMapping(&quot;/four&quot;)public class FourController &#123; private static final Log logger = LogFactory.getLog(FourController.class); private final FourUserService fourUserService; @Autowired public FourController(FourUserService fourUserService) &#123; this.fourUserService = fourUserService; &#125; /** * 第一次加载表单会触发这个方法 */ @RequestMapping(&quot;/input&quot;) public String inputUser(Model model) &#123; HashMap&lt;String, String&gt; hobbys = getMap();44// 虽然是第一次加载，但是也要在model添加一个领域模型的对象，否则表单标签无法找到modelAttribute属性指定的form backing object model.addAttribute(&quot;user&quot;, new User()); model.addAttribute(&quot;hobbys&quot;, hobbys); model.addAttribute(&quot;carrers&quot;, new String[]&#123;&quot;教师&quot;, &quot;学生&quot;, &quot;码农&quot;, &quot;民工&quot;&#125;); model.addAttribute(&quot;houseRegister&quot;, new String[]&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;&#125;); return &quot;userAdd&quot;; &#125; /** * 表单提交的时候会触发这个方法 */ @RequestMapping(&quot;/save&quot;) public String addUser(@ModelAttribute User user, Model model) &#123; // 进入业务层验证业务逻辑 if (fourUserService.addUser(user)) &#123; logger.info(&quot;成功&quot;); // 重定向到本控制器里的list控制方法 return &quot;redirect:list&quot;; &#125; logger.info(&quot;失败&quot;); // 验证失败的时候就到了这里，相当于重新加载，但是会带着已经填过的数据，用户就不用再次填写已经填写过的输入，注意这里没有在model.addAttribute()中new bean()。看不懂请对比上面的input方法 HashMap&lt;String, String&gt; hobbys = getMap(); model.addAttribute(&quot;hobbys&quot;, hobbys); model.addAttribute(&quot;carrers&quot;, new String[]&#123;&quot;教师&quot;, &quot;学生&quot;, &quot;码农&quot;, &quot;民工&quot;&#125;); model.addAttribute(&quot;houseRegister&quot;, new String[]&#123;&quot;北京&quot;, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;&#125;); return &quot;userAdd&quot;; &#125; @RequestMapping(&quot;/list&quot;) public String listUsers(Model model) &#123; List&lt;User&gt; users = fourUserService.getUsers(); model.addAttribute(&quot;users&quot;, users); return &quot;userList&quot;; &#125; private HashMap&lt;String, String&gt; getMap() &#123; HashMap&lt;String, String&gt; hobbys = new HashMap&lt;&gt;(5); hobbys.put(&quot;篮球&quot;, &quot;篮球&quot;); hobbys.put(&quot;乒乓球&quot;, &quot;乒乓球&quot;); hobbys.put(&quot;电玩&quot;, &quot;电玩&quot;); hobbys.put(&quot;游泳&quot;, &quot;游泳&quot;); return hobbys; &#125;&#125; 5. 编写业务逻辑层Service业务层，业务逻辑都在这里判断 123456789101112131415161718192021222324252627282930package service.four;import org.springframework.stereotype.Service;import po.four.User;import java.util.ArrayList;/** * @author pr919 */@Servicepublic class FourUserServiceImpl implements FourUserService &#123; private static ArrayList&lt;User&gt; users = new ArrayList&lt;&gt;(); @Override public boolean addUser(User u) &#123; String magicValue = &quot;民工&quot;; if (!magicValue.equals(u.getCarrer()) &amp;&amp; !&quot;&quot;.equals(u.getUsername()))&#123; users.add(u); return true; &#125; return false; &#125; @Override public ArrayList&lt;User&gt; getUsers() &#123; return users; &#125;&#125; 6. 编写视图层View视图层的表单标签通过控制层和领域模型绑定在一起，实现了数据绑定。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;%-- userAdd.jsp --%&gt;&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: pr919 Date: 2019.6.24 Time: 14:41 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;/&gt; &lt;title&gt;dataBind&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--@elvariable id=&quot;user&quot; type=&quot;po.four.User&quot;--%&gt;&lt;form:form modelAttribute=&quot;user&quot; mothod=&quot;post&quot; action=&quot;four/save&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;添加一个用户&lt;/legend&gt; &lt;p&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;form:input path=&quot;username&quot;/&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;爱好：&lt;/label&gt; &lt;%--@elvariable id=&quot;hobbys&quot; type=&quot;java.util.List&quot;--%&gt; &lt;form:checkboxes items=&quot;$&#123;hobbys&#125;&quot; path=&quot;hobby&quot;/&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;朋友：&lt;/label&gt; &lt;form:checkbox path=&quot;friends&quot; value=&quot;张三&quot;/&gt;1 &lt;form:checkbox path=&quot;friends&quot; value=&quot;李四&quot;/&gt;2 &lt;form:checkbox path=&quot;friends&quot; value=&quot;王五&quot;/&gt;3 &lt;form:checkbox path=&quot;friends&quot; value=&quot;赵六&quot;/&gt;4 &lt;/p&gt; &lt;p&gt; &lt;label&gt;职业：&lt;/label&gt; &lt;form:select path=&quot;carrer&quot;&gt; &lt;option&gt;&lt;/option&gt; 请选择职业 &lt;%--@elvariable id=&quot;carrers&quot; type=&quot;java.util.List&quot;--%&gt; &lt;form:options items=&quot;$&#123;carrers&#125;&quot;/&gt; &lt;/form:select&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;户籍：&lt;/label&gt; &lt;form:select path=&quot;houseRegister&quot;&gt; &lt;option&gt;&lt;/option&gt; 请选择户籍 &lt;%--@elvariable id=&quot;houseRegister&quot; type=&quot;java.util.List&quot;--%&gt; &lt;form:options items=&quot;$&#123;houseRegister&#125;&quot;/&gt; &lt;/form:select&gt; &lt;/p&gt; &lt;p&gt; &lt;label&gt;个人描述：&lt;/label&gt; &lt;form:textarea path=&quot;remark&quot; rows=&quot;5&quot;/&gt; &lt;/p&gt; &lt;p id=&quot;buttons&quot;&gt; &lt;input id=&quot;reset&quot; type=&quot;reset&quot; /&gt; &lt;input id=&quot;submit&quot; type=&quot;submit&quot; value=&quot;添加&quot;&gt; &lt;/p&gt; &lt;/fieldset&gt;&lt;/form:form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;%-- userAdd.jsp --%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%-- Created by IntelliJ IDEA. User: pr919 Date: 2019.6.24 Time: 15:18 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;% String path = request.getContextPath(); String basePath = request.getScheme() + &quot;://&quot; + request.getServerName() + &quot;:&quot; + request.getServerPort() + path + &quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;/&gt; &lt;title&gt;dataList&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;用户列表&lt;/h1&gt;&lt;a href=&quot;&lt;c:url value=&quot;four/input&quot;/&gt;&quot;&gt;继续添加&lt;/a&gt;&lt;table&gt; &lt;tr&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;兴趣爱好&lt;/th&gt; &lt;th&gt;朋友&lt;/th&gt; &lt;th&gt;职业&lt;/th&gt; &lt;th&gt;户籍&lt;/th&gt; &lt;th&gt;个人描述&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;users&#125;&quot; var=&quot;user&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;user.username&#125;&lt;/td&gt; &lt;td&gt; &lt;c:forEach items=&quot;$&#123;user.hobby&#125;&quot; var=&quot;hobby&quot;&gt; $&#123;hobby&#125;&amp;nbsp; &lt;/c:forEach&gt; &lt;/td&gt; &lt;td&gt; &lt;c:forEach items=&quot;$&#123;user.friends&#125;&quot; var=&quot;friend&quot;&gt; $&#123;friend&#125;&amp;nbsp; &lt;/c:forEach&gt; &lt;/td&gt; &lt;td&gt;$&#123;user.carrer&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.houseRegister&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.remark&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 总结目前来说，除了不用手动转型之外，我还没想到这个数据绑定有什么用。如果是为了验证输入的话，用javaScript或ajax就够了。","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"},{"name":"SSM","slug":"Java/SSM","permalink":"https://www.boii.xyz/categories/Java/SSM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/tags/SSM/"},{"name":"数据绑定","slug":"数据绑定","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"}]},{"title":"C-Note","slug":"Note/C-Note","date":"2019-06-09T05:03:26.000Z","updated":"2021-07-19T09:03:15.468Z","comments":true,"path":"posts/60258.html","link":"","permalink":"https://www.boii.xyz/posts/60258.html","excerpt":"C语言笔记","text":"C语言笔记 指针定义指针：dataType * pointerName = NULL; 1int * ptr_a = NULL; 指针赋值：pointerName = &amp;varName; 12int a = 10;ptr_a = &amp;a; 对于指针，其实就是存放地址的变量 int a = 10; 这句话等于申请了一块内存，放了个值10进去，起个别命叫a 。那这个空间的地址假设是 0028FF，那ptr_a = &amp;a 这句话就是再申请一块内存，把0028FF放进去，起个别名叫ptr_a 。 &amp; 这个符号是取地址的意思 * 这个符号则是取这个指针变量中，那个地址的内存中的 值，也就是直接操作内存，修改内存里的内容 值传递 引用传递值传递：传递一份副本，传递后操作的只是副本，也就是对变量的副本进行操作，变量本身不会变化 1234567891011void change(int num)&#123; num ++;&#125;void main()&#123;4int num = 9;4change(num);4printf(&quot;num = %d&quot;, num);&#125;// 结果：9 引用传递：&amp;var， 传递的是地址，传递后操作的是该地址中的值，也就是对变量本身进行操作 1234567891011void change(int * num)&#123;4*num ++;&#125;void main()&#123;4int num = 9; change(&amp;num); printf(&quot;num = %d&quot;, num);&#125;// 结果：10 值传递就是普通操作，引用传递就是操作指针（骚操作） 变量的生存周期 存储类型说明符 存储类型 说明 auto 自动存储 只能用于块作用域中的变量，局部变量默认情况下归为自动存储类型 register 寄存器存储 只能用于块作用域中的变量，请求速度快，适用在循环次数多的循环变量/反复使用的变量。 static 静态存储 载入程序时创建对象，程序结束时对象消失。 extern 外部变量 说明符表示生命的变量定义在别处。作用域是整个程序，生存周期贯穿应用程序的开始和结束。跟static一样。 头文件123456#ifndef HEADFILENAME_H_INCLUDE#define HEADFILENAME_H_INCLUDE44// TODO#endif","categories":[{"name":"Note","slug":"Note","permalink":"https://www.boii.xyz/categories/Note/"},{"name":"C Language","slug":"C-Language","permalink":"https://www.boii.xyz/categories/C-Language/"}],"tags":[{"name":"note","slug":"note","permalink":"https://www.boii.xyz/tags/note/"},{"name":"C Language","slug":"C-Language","permalink":"https://www.boii.xyz/tags/C-Language/"}]},{"title":"Java-About-Hash","slug":"Java/Java-About-Hash","date":"2019-06-08T17:26:48.000Z","updated":"2021-07-19T08:58:56.540Z","comments":true,"path":"posts/33205.html","link":"","permalink":"https://www.boii.xyz/posts/33205.html","excerpt":"Hash 是一种很神奇的数据结构","text":"Hash 是一种很神奇的数据结构 HashTableHashTable 散列表 哈希表： 是一种数据结构，它提供快速的插入和查找操作，不管表中有多少数据，插入删除和查找的时间都接近O(1) 优点：HashTable其实是基于数组的，所以在查询方面非常的快，同时它不像普通数组那样紧密排列，在数值未满的时候所有的值其实是散部在数组中的某个位置上的，所以在插入和删除的时候不用像普通数组一样让余下的值一个个的挪。 缺点：同时也因为它的基于数组的，所以创建以后难以扩展，当HashTable被基本填满的时候，性能严重下降，而且不能顺序遍历。 一个输入传进来的时候会经过散列函数，计算出一个值，这个值就是这个输入在HashTable中的位置，称为HashCode 哈希值 散列值。 当HashTable中的值还不多的时候各种操作的效率是非常高的，但是HashTable快满的时候各种操作的效率就开始变低了 开放寻址法线性探测方法 比如一个HashTable的长度是8，现在只剩下 6 这个位置是空的 而一个输入经过散列函数计算之后得到的结果是 7 ，一看 7 上面有人占了，怎么办呢？ 往下找空位咯，7 下面是 0 ，有人了，下一个 1 ，有人了，下一个 2 ，有人了…下一个 6 ，耶没人，上去！ 这样几乎遍历了一整个数组，效率是非常低的，HashTable小的时候还能忍受，如果HashTable长度是2000呢?20000呢？ 上述的方法其实就是当散列函数计算出来的值上面已经有值的时候的解决方法之一，开放寻址法中的线性探测，往下找空位，找到进填进去。最坏的情况下就是几乎遍历整个数组。 二次探测方法另一种的思路有那么点像二分查找法，叫做二次探测方法 比如表中只有 3 是有空位的，其余都是满的 而一个输入经过散列函数计算之后得到的结果是 7，一看 7 上面有人了，怎么办呢？ CurrentCode + 0，CurrentCode + 1^2^ ，CurrentCode - 1 ^2^，CurrentCode + 2^2^，CurrentCode - 2^2^，…… 7不行就 + 1^2^ = 8，8还是不行，那就7 - 1^2^ = 6，6还是不行，那就7 - 2^2^ = 3，3可以，上去！ 因为进行试探的步长都是二次方，所以叫 二次探测方法 双重散列方法还有一种方法叫做 双重散列方法 就是使用第一个哈希函数计算的值如果被占用了，就找第二个哈希函数，直到找到空闲的存储位置 不管用那种方法，只要HashTable空位不多的时候散列冲突的概率就会大大提高，尽可能保证HashTable中有一定比例的空位。 一般用加载因子来表示空位的多少。加载因子越大表示约满，反之亦然。 链表法HashTable中每个元素对应一条链表，所有散列值相同的元素放到相同的链表中。如下图 查找的时候先通过HashCode找到位置，然后将值与链表中的值逐个使用 equals() 对比。 But但其实HashTable是元素数量不能超过总容量的一半，当HashTable太满的时候，一个选择是扩容数组，创建一个新的容量为 CurrentCapacity * 1.34 + n = 2^m 的数组，把值放到新数组，但是元素的索引没法复制，会被重新哈希化。$$CurrentCapacity * 1.34 + n = 2^m = NewCapacity$$ 举个栗子一本字典有1000页，当你要查找Link这个词的时候，肯定想去翻目录，目录显示在第666页，那么你是不是可以直接翻到666页找这个单词？也就是所Link这个单词在散列表[666]，但是第666页可能不止这一个单词哦，那你是不是要一个一个进行equals才能知道是哪个呢？因为知道在哪一条链表上，所以尽管遍历看起来很慢，但总比遍历所有链表快吧？","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"Hash","slug":"Hash","permalink":"https://www.boii.xyz/tags/Hash/"}]},{"title":"Java-反射","slug":"Java/Java-反射","date":"2019-06-08T16:58:48.000Z","updated":"2021-07-19T08:58:43.203Z","comments":true,"path":"posts/13406.html","link":"","permalink":"https://www.boii.xyz/posts/13406.html","excerpt":"Java 神器：反射","text":"Java 神器：反射 12345678910111213141516171819Person p = new Person();/**获取*/Class&lt;?&gt; clazz = p.getClass(); // 得知道类对象Class&lt;?&gt; clazz = Person.class; //得知道类名Class&lt;?&gt; clazz = Class.forName(&quot;com.tcp404.Person&quot;);//得知道类的全路径名/** 获取方法 */Method method = clazz.getDeclaredMethod(&quot;方法名&quot;, new Class()&#123;[参数类型.class, 参数类型.class, ...]&#125;);Methods[] methods = clazz.getDeclaredMethods();/** 获取属性 */Field field = clazz.getDeclaredField(&quot;属性名字&quot;);Field[] fields = clazz.getDeclaredFields();/** 获取构造器 */Constructor&lt;?&gt; con = clazz.getDeclaredConstructor(new Class()&#123;[参数类型.class, 参数类型.class, ...]&#125;);Constructor&lt;?&gt;[] cs = clazz.getDeclaredConstructors();","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"反射","slug":"反射","permalink":"https://www.boii.xyz/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"Git命令大全","slug":"Git/Git命令大全","date":"2019-05-19T07:15:19.000Z","updated":"2021-07-19T09:02:51.052Z","comments":true,"path":"posts/18012.html","link":"","permalink":"https://www.boii.xyz/posts/18012.html","excerpt":"One more thing","text":"One more thing Git 常用命令&gt;_ Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 先放上一张常用Git 命令导航图 一、新建代码库12345678在当前目录新建一个Git代码库（常用）git init新建一个目录，将其初始化为Git代码库git init [project-name]下载一个项目和它的整个代码历史（常用）git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789显示当前的Git配置git config --list编辑Git配置文件git config -e [--global]设置提交代码时的用户信息git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件123456789101112131415161718192021添加指定文件到暂存区（常用）git add [file1] [file2] ...添加指定目录到暂存区，包括子目录git add [dir]添加当前目录的所有文件到暂存区（常用）git add .添加每个变化前，都会要求确认对于同一个文件的多处变化，可以实现分次提交git add -p删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 四、代码提交123456789101112131415161718提交暂存区到仓库区（常用）git commit -m [message]提交暂存区的指定文件到仓库区（常用）git commit [file1] [file2] ... -m [message]提交工作区自上次commit之后的变化，直接到仓库区git commit -a提交时显示所有diff信息git commit -v使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839404142列出所有本地分支（常用）git branch列出所有远程分支git branch -r列出所有本地分支和远程分支（常用）git branch -a新建一个分支，但依然停留在当前分支（常用）git branch [branch-name]新建一个分支，并切换到该分支（常用）git checkout -b [branch]新建一个分支，指向指定commitgit branch [branch] [commit]新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]切换到指定分支，并更新工作区（常用）git checkout [branch-name]切换到上一个分支（常用）git checkout -建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]合并指定分支到当前分支git merge [branch]选择一个commit，合并进当前分支git cherry-pick [commit]删除分支（常用）git branch -d [branch-name]删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 六、标签1234567891011121314151617181920212223242526列出所有taggit tag新建一个tag在当前commitgit tag [tag]新建一个tag在指定commitgit tag [tag] [commit]删除本地taggit tag -d [tag]删除远程taggit push origin :refs/tags/[tagName]查看tag信息git show [tag]提交指定taggit push [remote] [tag]提交所有taggit push [remote] --tags新建一个分支，指向某个taggit checkout -b [branch] [tag] 七、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263显示有变更的文件（常用）git status显示当前分支的版本历史（常用）git log显示commit历史，以及每次commit发生变更的文件git log --stat搜索提交历史，根据关键词git log -S [keyword]显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件git log [tag] HEAD --grep feature显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]显示指定文件相关的每一次diffgit log -p [file]显示过去5次提交git log -5 --pretty --oneline显示所有提交过的用户，按提交次数排序git shortlog -sn显示指定文件是什么人在什么时间修改过git blame [file]显示暂存区和工作区的代码差异（常用）git diff显示暂存区和上一个commit的差异git diff --cached [file]显示工作区与当前分支最新commit之间的差异git diff HEAD显示两次提交之间的差异git diff [first-branch]...[second-branch]显示今天你写了多少行代码git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;显示某次提交的元数据和内容变化（常用）git show [commit]显示某次提交发生变化的文件git show --name-only [commit]显示某次提交时，某个文件的内容git show [commit]:[filename]显示当前分支的最近几次提交git reflog从本地master拉取代码更新当前分支：branch 一般为mastergit rebase [branch] 八、远程同步123456789101112131415161718192021222324git remote update --更新远程仓储（常用）下载远程仓库的所有变动git fetch [remote]显示所有远程仓库git remote -v显示某个远程仓库的信息git remote show [remote]增加一个新的远程仓库，并命名git remote add [shortname] [url]取回远程仓库的变化，并与本地分支合并（常用）git pull [remote] [branch]上传本地指定分支到远程仓库（常用）git push [remote] [branch]强行推送当前分支到远程仓库，即使有冲突git push [remote] --force推送所有分支到远程仓库git push [remote] --all 九、撤销12345678910111213141516171819202122232425262728293031恢复暂存区的指定文件到工作区git checkout [file]恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]恢复暂存区的所有文件到工作区git checkout .重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]重置暂存区与工作区，与上一次commit保持一致(取消所有修改)（常用）git reset --hard重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]暂时将未提交的变化移除，稍后再移入（常用）git stashgit stash pop 十、其他12生成一个可供发布的压缩包（常用）git archive","categories":[{"name":"Git","slug":"Git","permalink":"https://www.boii.xyz/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.boii.xyz/tags/git/"},{"name":"命令","slug":"命令","permalink":"https://www.boii.xyz/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"多端同步管理Hexo博客","slug":"Hexo/多端同步管理Hexo博客","date":"2019-05-18T03:37:35.000Z","updated":"2021-07-19T09:00:39.039Z","comments":true,"path":"posts/41079.html","link":"","permalink":"https://www.boii.xyz/posts/41079.html","excerpt":"多端管理其实很简单。","text":"多端管理其实很简单。 hexo 其实是帮我们编译好放在博客根目录\\public目录下的，然后把public目录推送到github上的，所以说github.io上面都是编译过的文件，他们是光鲜亮丽的演员，但离不开默默付出的后台人员。这些默默付出的后台人员就是除了public之外的所有的文件。 我们的博客是发布到master主分支的，那就建另一个分支，把所有文件都传上去，在别的电脑上都拉下去就可以了。 1. 首先填写忽略声明文件.gitignore12345678.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/_config.yml public 每次都会编译覆盖，所以不需要它 .deploy* 编译产生的文件，也不需要 _config.yml 配置文件里会有一些id/key的重要信息，所以不上传 2. 初始化仓库和提交之前我以为hexo就是帮我们操作git，所以不明白为什么还能再初始化git 后来才知道不是那么回事。但是hexo是怎么操作我还是没明白。这里不管 像往常一样，在根目录右键 git bash here 注意！！！大坑！！！ 如果你用的是第三方的主题theme，是使用git clone下来的话，要把主题文件夹下面把.git文件夹删除掉，不然主题无法push到远程仓库，导致你发布的博客是一片空白。所以先去检查你使用的主题有没有.git这个目录 123456git init //初始化本地仓库git add . //添加本地所有文件到仓库 git commit -m &quot;blog源文件&quot; //添加commitgit branch backup //添加本地仓库分支hexogit remote add origin &lt;server&gt; //添加远程仓库 &lt;server&gt; 是指在线仓库的地址 origin是本地分支,remote add操作会将本地仓库映射到云端git push origin backup //将本地仓库的源文件推送到远程仓库hexo分支 在另一台电脑的操作首先肯定要搭建环境啦（Node 和 Git） 完了后用这个命令 123git clone &lt;server&gt; hexo //&lt;server&gt; 是指在线仓库的地址cd hexo npm install npm install的时候会根据package.json中的插件列表自动加载相应插件。 本机的同步完成。 因为在上传博客源文件的时候忽略了配置文件（_config.yml这是站点的配置文件）的上传，也就是没有上传配置文件的，在克隆下来的时候记得把配置文件拿过来，不然会报错。主题里面的配置文件也要（themes/next/_config.yml这是主题配置文件） 这里贴一张常用Git命令 &gt;_","categories":[{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/categories/HEXO/"},{"name":"Git","slug":"Git","permalink":"https://www.boii.xyz/categories/Git/"},{"name":"Note","slug":"Note","permalink":"https://www.boii.xyz/categories/Note/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/tags/HEXO/"},{"name":"note","slug":"note","permalink":"https://www.boii.xyz/tags/note/"},{"name":"git","slug":"git","permalink":"https://www.boii.xyz/tags/git/"}]},{"title":"几句话区分并行和并发","slug":"Note/几句话区分并行和并发","date":"2019-05-15T02:04:18.000Z","updated":"2021-07-19T09:03:15.390Z","comments":true,"path":"posts/38965.html","link":"","permalink":"https://www.boii.xyz/posts/38965.html","excerpt":"吃饭和打电话你选择哪个？","text":"吃饭和打电话你选择哪个？ 举个栗子 你在吃饭，电话进来，你等到吃完了才接电话 –&gt; 你不支持【并行或者并发】 （1个CPU，队列式执行任务，这个做完了才做下一个，不允许插队） 你在吃饭，电话进来，接一下电话，吃一下饭，交替进行，说明你支持【并发】 （一个CPU，多个任务同时进行，这个做一下，那个做一下，回过来这个再做一下…，允许插队） 你在吃饭，电话进来，你继续吃饭，秘书帮你接电话，说明你支持【并行】 （多于一个CPU，多个任务同时进行，各忙各的） &gt;_ 正儿八经的胡说一下并发主要是指：同一时间 【段】 “同时”做多件事 比如一边打电话一边吃饭。人脑肯定是没法同时专注在两个事情上的，所以你的注意力会一下在电话上（听电话里说什么），一下在吃饭上（大脑下达抬手张嘴咀嚼的指令），CPU也是如此。 吃饭一个线程，接电话一个线程。分给吃饭线程一点时间片，分给接电话一点时间片，吃饭的时间片执行完了切到电话线程执行，电话线程的时间片执行完了切到吃饭线程，因为切换的快，所以感觉像同时进行。 这里时间片不懂的话就姑且理解为能量条，CPU切过来执行吃饭线程，吃饭线程的能量条就开始消耗，消耗完了CPU就走了去消耗电话线程的能量条了。与此同时吃饭线程的能量条在CPU切走的时候瞬间满了，CPU那边消耗完了又过来吃饭线程消耗这边的能量条，耗完了又走了。如此往复直到任务执行完毕。 并行只要是指：同一时间 【点】 “同时”做多件事 还是上面吃饭打电话的例子，电话来了你吃你的，电话秘书帮你接。你处理吃饭的事情，秘书处理电话的事情，所以就不用CPU切来切去的。因为有两个CPU了嘛（你 和 秘书）。 总结 一个收银员，只能排一条队伍，一个一个来，就是不支持并发并行 一个收银员，可以排多条队伍，这边忙忙那边忙忙，就是支持并发 多个收银员，可以排多条队伍，一个收银员处理一条队伍，就是支持并行 可见CPU只有一个的时候，就是假同时；多个CPU的时候，才是真正意义上的同时。","categories":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"并行与并发","slug":"并行与并发","permalink":"https://www.boii.xyz/tags/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91/"}]},{"title":"当小程序开发完成后","slug":"Other/当小程序开发完成后","date":"2019-05-13T07:35:21.000Z","updated":"2019-05-13T07:35:21.000Z","comments":true,"path":"posts/6343.html","link":"","permalink":"https://www.boii.xyz/posts/6343.html","excerpt":"开发小程序后的一点总结","text":"开发小程序后的一点总结 本来没想搞小程序的，谁知道寒假突然脑子发热，看了点视频和文章，就着现成的点子开始搞起来。 从1月20日到4月2日，平均每天投入10+小时，历经三次改版，一次阉割，无数次和UI吵架，总算把GoTE小程序做出来了。 小程序1234567小程序名：GoTE行程发布小程序样式库：ColorUI插件：WxValidate.js（表单验证）外部API：高德地图开放平台（用于获取打车费用&lt;已阉割&gt;）前端：小程序原生后端：小程序云开发环境数据库：云开发 -&gt; 云数据库 &gt;_ &gt;_ 项目最初的出发点是由于学校地处偏僻，出行不便，坐公车经常拥挤且一站到底。打车费用又十分昂贵，且独自出行来往于学校这偏僻之地具有一定危险性。校外非法黑车趁机拉帮结派，用略低于滴滴的价格拉拢学生乘坐。为了大幅盈利设置了拼车一项，一行4人35元，但是单人拼车费用要17元！ 所以我决定自己开发一个小程序供同学们发布行程信息，有相同行程的人可以互相联系一同出行，即节省了出行成本，又避免单独外出。 于是1月20日正式开动，在此后的不间断每天投入10+小时在其中，从产品定位，功能定义，开发，测试等等，历经73天最终定版，提交审核。 正当我满心欢喜的提交审核两天之后，审核团队冷冰冰的打回，再之后不管多少次修改都只有冷冰冰的这么一句话 &gt;_ 我只是一个单纯的行程发布平台，连个车字都没有哪来的涉及拼车？不管是反馈还是重新提交都只有这么冷冰冰的一句话。 此项目对我来说有非凡的意义， 第一个完整的个人项目 第一次完成想法落地实现的完整执行 第一次靠自学完成一个项目 总结在被腾讯审核团队冷冰冰的打回N次之后，开始有些心灰意冷。在这次项目中，还是有一些体会的。 在开发过程中慢慢明白了，小程序其实可以理解为一个微信内置浏览器，开发小程序的过程就跟开发网页类似。不过小程序封装了很多接口，提供了很多实现。如果是有开发经验的程序员，稍微熟悉语法就可以快速开发出一个完整的小程序，不夸张的说，一个商城，从零开始，快则半月，慢则一月。 小程序本身的局限性所致，小程序注定无法完全替代App。作为分销引流可以，要完全替代不太现实。小程序开发完全部资源包括代码不能超过2M，且运行载荷不能太大，否则会被微信的机制强制退出。如果你手机太老，还会把你的微信给强制退出（闪退）。所以承担一点分销展示的任务可以，完全搬上小程序会导致体验极其的差。参考 微信支付 -&gt; 酒店 -&gt; 同程艺龙小程序。大量的网络请求，实测 Iphone6 plus IOS 10.2 上运行体验很差. 像微信小程序，支付宝小程序，百度小程序等这种开发都是寄人篱下。用人家的平台，人家接口，享受人家封装好带来的便利，需要付出的代价就是非常严格的审核。这种情况下只能祈福于客服，出了问题或是疑问有个靠谱的客服或者回应显得尤为重要。像微信这种机器人只能说(ta)呵(ma)呵(de)了。 做成一件事情很难，特别是这种涉及很多用户，用户之间产生交流的事情，你要够专业，够团结，够投入，够拼，能力够强。GoTE是一个面向学生的，开放的平台，也就是说用户与用户之间会产生交流。在涉及到这种用户之间交流（社交）的时候就需要格外小心。比如GoTE： 第一要面临的问题就是用户身份验证。怎么确定你是学生？哪个学校的学生？目前能想到的就是利用超级课程表的方式，利用爬虫接入各学校教务系统，学生提供账号密码验证码，登录到教务系统中验证。 第二怎么保障共同出行过程的顺利？怎么尽量确保双方之间不会发生矛盾（因为路费或是任何问题）？ 看似简单的两个问题其实需要大量的工作。不过我只有一个人，很需要帮手。 此文作为第一次实际行动的总结记录 谨此","categories":[{"name":"Other","slug":"Other","permalink":"https://www.boii.xyz/categories/Other/"}],"tags":[{"name":"note","slug":"note","permalink":"https://www.boii.xyz/tags/note/"}]},{"title":"通信中的加密与解密-详细版","slug":"RSA/通信中的加密与解密-详细版","date":"2019-04-26T01:54:27.000Z","updated":"2021-07-19T09:01:55.317Z","comments":true,"path":"posts/12119.html","link":"","permalink":"https://www.boii.xyz/posts/12119.html","excerpt":"换个详细点的捋一捋","text":"换个详细点的捋一捋 首先，用户的操作系统会内置一些CA机构的CA证书 CA证书：CA机构颁发给自己的证书 组成： CA的公钥 颁发者 颁发机构 有效期 其他内容 签名（CA私钥加密过）： 对以上内容进行hash=&gt;hash值 hash的算法 这里签名是CA私钥加密过的，如果黑客用公钥解开签名，然后篡改信息再Hash，带上hash算法，就没办法加密回去，因为没CA私钥。 如果篡改成自己的公钥，再hash，带上hash算法，用自己的私钥加密（签名），这就是伪造CA证书，这样等于白干，因为操作系统会提示这个证书不可信，不过CA证书一般都是操作系统内置的，不需要网络请求，所以没机会拦截篡改。一般问题都出在CA机构内部。 那一个网站，它首先要找CA机构认证，认证完CA机构会给一张证书，这个就是网站证书了 网站证书：CA机构给网站颁发的证书 组成： 网站的公钥 颁发者（CA机构） 颁发机构（网站） 有效期 其他内容 CA签名，也就是指纹（CA私钥加密过的）： 对以上内容进行hash=&gt;hash值 hash的算法 这里的CA签名也是用CA私钥加密过的，如果黑客用CA公钥解开签名，然后篡改网站的公钥再hash，带上hash算法，就没法加密回去，因为没CA私钥。用黑客自己的私钥加密回去的话，用户拿到证书，根据颁发者（CA机构）拿出CA公钥，它解不开黑客的私钥。那就通信终止了。 场景： 首先用户请求网站给个证书看看 网站给了网站证书 用户就根据证书的颁发者去操作系统找颁发者的证书（也就是操作系统中的CA证书），去拿到CA公钥出来 然后用CA公钥解开CA签名拿到hash值1和hash算法 然后用hash算法自己计算整个证书的内容得到hash值2 对比hash值1和hash值2来验证网站证书有没有被篡改 验证通过后会生成一串随机字符串，自己保留一份，然后发一份让网站用网站的私钥加密这串随机字符串 网站把这串随机字符串用网站的私钥加密，发回给客户 用户再用证书上的网站的公钥去解，能解开，解开后对比回来的随机字符串和自己保留的那份随机字符串是不是一致 一致则说明对方就是服务器，而不是黑客瞎搞 为了服务器安全所以用户先hash一下再发，服务器加密就行了。用户解密完对比回来的hash跟自己留着的hash是不是一直就行了。hash过才能防止黑客发送一些有规律的字符串给服务器，从而寻找加密的规律。以此保护服务器私钥的安全 如果证书没问题，对方却是黑客，那字符串用黑客的私钥加密，用户用网站的公钥是解不开的。除非黑客能弄到网站的私钥，才能在这插一脚，像上面说的黑客发送有规律的字符串不过被hash解决了，接下来就要传输密钥了。 用户验证了一直，就用自己生成一串密钥，然后用网站的公钥加密，发给网站网站用网站的私钥解密，得到密钥。然后双方开始用密钥加密信息通信。 通信的时候用户的数据写完，会先把内容hash一下生成摘要，再用密钥加密网站收到之后会先用密钥解密，然后网站自己hash一下内容生成摘要，对比传过来的摘要看看是否一致是就没问题，不一致则说明黑客在中间捣乱。则断开连接 所以用密钥的时候，其实是 信息内容本身+hash出来的信息摘要，然后才加密","categories":[{"name":"RSA","slug":"RSA","permalink":"https://www.boii.xyz/categories/RSA/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://www.boii.xyz/tags/RSA/"}]},{"title":"LeetCode-笔记【No-4】0x09-回文数","slug":"LeetCode/LeetCode-笔记【No-4】0x09-回文数","date":"2019-04-25T03:30:48.000Z","updated":"2021-07-19T08:56:21.155Z","comments":true,"path":"posts/13460.html","link":"","permalink":"https://www.boii.xyz/posts/13460.html","excerpt":"LeetCode 第9题","text":"LeetCode 第9题 题目判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1:输入: 121输出: true 示例 2:输入: -121输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3:输入: 10输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶:你能不将整数转为字符串来解决这个问题吗？ 思路 首先根据题意，负数肯定是不符合要求的。那第一步先判断给进来的数是不是小于0，是直接返回出去。 要达成回文数一般都要三位数，但是0~9，11，22，33…也可以是回文数，所以小于100的数也要处理一下 现在开始解题，会有两种情况，数字长度为奇数 和 偶数 如果是偶数，只要后半段 == 前半段，return ture 如果是奇数，只要前半段 == 后半段 / 10，return ture 代码过程和计算水仙花数类似 把传进来的数x取余数k赋值给res，然后x 自除 10，第二轮res自乘10再＋取余数k res向上迭代，x向下迭代，最后进行比较。如果遇到数字位数是奇数位就比较前半段是否等于后半段÷10 代码1234567891011class Solution &#123; public boolean isPalindrome(int x) &#123; if (x &lt; 0 || x % 10 == 0 ) return false; int res = 0; while (x &gt; res)&#123; res = res * 10 + x % 10; x /= 10; &#125; return x == res || x == res / 10; &#125;&#125; 输入 1221，我们可以将数字“1221”的后半部分从“21”反转为“12”，并将其与前半部分“12”进行比较，因为二者相同，我们得知数字 1221 是回文。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.boii.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/tags/LeetCode/"}]},{"title":"LeetCode-笔记【No-3】0x0D-罗马数字转整数","slug":"LeetCode/LeetCode-笔记【No-3】0x0D-罗马数字转整数","date":"2019-04-25T03:29:48.000Z","updated":"2021-07-19T08:56:21.080Z","comments":true,"path":"posts/64290.html","link":"","permalink":"https://www.boii.xyz/posts/64290.html","excerpt":"LeetCode 第13题","text":"LeetCode 第13题 题目罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: “III” 输出: 3 示例 2: 输入: “IV” 输出: 4 示例 3: 输入: “IX” 输出: 9 示例 4: 输入: “LVIII” 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: “MCMXCIV” 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 思路 首先建立一个HashMap来映射符号和值 然后对字符串从左到右来，如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。 以此类推到最右边的数，最终得到的结果即是答案 这是LeetCode评论上的一条思路。非常简单粗暴。 代码12345678910111213141516171819202122232425262728class Solution &#123; public int romanToInt(String s) &#123; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&#x27;I&#x27;,1); map.put(&#x27;V&#x27;,5); map.put(&#x27;X&#x27;,10); map.put(&#x27;L&#x27;,50); map.put(&#x27;C&#x27;,100); map.put(&#x27;D&#x27;,500); map.put(&#x27;M&#x27;,1000); int res = 0; int size = s.length(); //最后一位不需要判断所以循环次数是size-1 for (int i = 0; i &lt; size - 1; i ++) &#123; //如果左边的数字小于右边的数字 if (map.get(s.charAt(i)) &gt;= map.get(s.charAt(i+1)))&#123; res += map.get(s.charAt(i)); &#125; else &#123; //如果左边数字小于右边的数字（也就是通常4和9的情况） res -= map.get(s.charAt(i)); &#125; &#125; //最后一位没被判断到，所以没被加上，记得加上去 res += map.get(s.charAt(size - 1)); return res; &#125;&#125; 这里的if判断先写多数的情况，也就是左边的数大于右边的数。 这样才不会把时间浪费在 先判断少数情况（左边 小于右边），再执行多数情况的运算","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.boii.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/tags/LeetCode/"}]},{"title":"LeetCode-笔记【No-2】0x07-整数反转","slug":"LeetCode/LeetCode-笔记【No-2】0x07-整数反转","date":"2019-04-25T02:44:48.000Z","updated":"2021-07-19T08:56:20.585Z","comments":true,"path":"posts/45196.html","link":"","permalink":"https://www.boii.xyz/posts/45196.html","excerpt":"LeetCode 第7题","text":"LeetCode 第7题 题目 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。示例 1: 输入: 123 输出: 321示例 2: 输入: -123 输出: -321示例 3: 输入: 120 输出: 21注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 思路一开始的思路是把数字取模然后放到int数组里，但是这样复杂又难实现，时间复杂度上也没优势 后来看到网络上的答案，思路是这样的： 首先把要判断这个数是否超范围 然后再把这个数x拿来取模，获得最后一个数并赋值给一个新的变量 然后x自除10，进入下一次循环 第二次循环的时候新变量自乘10再加取模得到的数。最后返回这个新变量 代码123456789101112131415class Solution &#123; public int reverse(int x) &#123; int rev = 0; //新变量 while (x != 0) &#123; //判断我们取得的数是否超范围 // 2^31-1 = 2147483647 | -2^31 = -2147483648 if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) return 0; if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) return 0; int pop = x % 10; //取模拿到个位数 rev = rev * 10 + pop; //自身×10空出个位，然后加上刚刚取模出来的数 x /= 10; //迭代条件。因为x是int类型，所以÷10以后小数点就被省略了 &#125; return rev; &#125;&#125; 这种思路，就不需要把数字切成一个一个再拼接。直接利用数字的特性，通过取模和乘除运算带达到效果。 时间复杂度：O(log(x))，x 中大约有 log{10}(x)位数字。 空间复杂度：O(1)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.boii.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/tags/LeetCode/"}]},{"title":"LeetCode-笔记【No-1】0x01-两数之和","slug":"LeetCode/LeetCode-笔记【No-1】0x01-两数之和","date":"2019-04-25T02:44:47.000Z","updated":"2021-07-19T08:56:20.330Z","comments":true,"path":"posts/52628.html","link":"","permalink":"https://www.boii.xyz/posts/52628.html","excerpt":"LeetCode 第1题","text":"LeetCode 第1题 题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 思路思路非常简单，就是把要找的数字target，减去第一个的差，是否等于第二个数 如果是，返回这两个数的下标，如果不是，循环继续。 代码123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length - 1; i++) &#123; for (int j = i+1; j &lt; nums.length; j ++) &#123; if (nums[j] == target - nums[i]) &#123; return new int[] &#123; i , j &#125;; &#125; &#125; &#125; return null; &#125;&#125; 第一层循环取第一个数i，然后进入第二层循环， 第二层循环从第二个数j 开始，判断要找的数-第一个数i 的差 是否等于 第二个数 j 如果不是第二层取第三个数，再进行比较。 如果第二层遍历完还没结果说明第一层的第一个数i不对，所以第一层取第二个数 再次进入第二层依次遍历。 当差等于第二层的某个数的时候，说明找到了，返回i和j的下标。 时间复杂度：O(n) 空间复杂度：O(n)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.boii.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/tags/LeetCode/"}]},{"title":"通信中的加密与解密","slug":"RSA/通信中的加密与解密","date":"2019-04-25T01:52:52.000Z","updated":"2021-07-19T09:01:55.144Z","comments":true,"path":"posts/42106.html","link":"","permalink":"https://www.boii.xyz/posts/42106.html","excerpt":"怎么和聊天才能不被人看到信息内容？","text":"怎么和聊天才能不被人看到信息内容？ 加密与解密 应用场景：通信 传统的通信场景：明文&gt;_ 如果这时候有个Hacker在中间嗅探他们的通信链路，那他们的内容就全都被看到了，甚至会被篡改 &gt;_ 加密&amp;解密明文有问题，那就加密，让中间的Hacker看不懂 凯撒密码通过约定的偏移和回正，达到A、B都看得懂，中间人看不懂的目的 加密：A发送的信息，全部右偏移3个字母 解密：B接收后左回正3个字母，就得到正确信息了。 例如：Hello world 右偏移后变成 Khnnr zrung 但是这样的加密太容易被破解了。凯撒密码是一种很古老的在战争中使用过的一种加密信件的方式，这里不说汉字，就说英文26个字母，最多进行（回正1，回正2，回正3…回正25,回正-1，回正-2…回正-25）共50次就可以破解。 对称加密A、B都将信息异或运算 如果将信息转成二进制，然后和另一个二进制(这里用E表示)，得到加密结果 那加密结果和E异或就能得到原本的信息的二进制，再转换成文字就得到了信息。 A ^ E = C C ^ E = A 例如： 加密的一方 假设 Hello world 的二进制是 0110 0101 1101 E 是： 0101 1001 1010 加密（异或）的结果就是: 0011 1100 0111 解密的一方 收到了加密的信息: 0011 1100 0111 E 是： 0101 1001 1010 解密（异或）的结果就是：0110 0101 1101 &gt;_ 这就是利用异或的特性来进行信息的加密。所以关键的E 就叫做密钥（所以拿到密钥就能破解了）。 要确保双方都有 E 这把密钥。 对称加密有3个特点： 仅做XOR（异或）运算，速度快 –优点 密钥跟数据长度相等 –缺点 双方需要提前拥有密钥 加密分片对称加密的缺点也明显，密钥长度跟数据长度相等。 解决的办法是： 把信息分组，每组对应一段密钥，分别做异或运算就可以得到密文分片，再合并到一起就得到密文（加密的信息）了。 接收的一方分别做异或运算得到明文分片，在合并到一起就得到原本的信息了。 加密分片的特点： 数据按密钥长度分组，不足的填充 可以并行计算各个分组，优化了性能 密文跟明文的序列存在规律对应关系 上面说的就是DES的ECB模式加密 不过这种简单的分组模式也是很容易发现规律 一般的改进思路是：信息第一次分组、加密、合并得到了一次密文，然后再进行第二次分组、加密、合并得到二次密文。 或者第一次分组，一次加密、二次加密、合并。 非对称加密请求方请求公钥，接收方发送公钥，请求方加密后发送，接收方用私钥解密 那密钥这么好，但是有个问题：E（密钥）怎么传输？明文还是密文？ 答案是：明文。 那密钥是明文的，被Hacker嗅探到了，那上面那些不都白费了。 所以就有了 非对称加密 &gt;_ 简单说就是：我先要个保险箱，然后把密钥放进去，关上。这个保险箱只有你开的了，所以被Hacker截获了他也开不了。 这就是非对称加密。谁都可以跟B拿保险箱，只有B自己才开得了保险箱。 12345打开状态的[保险箱] == 公钥关闭状态的[保险箱] == 密文保险箱钥匙 == 私钥 他们的特点就是： 任何人都可以请求并拿到公钥 用公钥加密明文变成密文 仅能用私钥解开密文得到明文 私钥不能丢失 RSA就是这样一个公钥（保险箱）私钥（钥匙）的算法，具体的数学应用利用了 大质数相乘难以分解，费马小定理 等数学理论，使得它难以破解（思考：所以从质数、小定理这些数学理论入手，是不是有机会破解非对称加密？）。 非对称加密需要做乘法模除等运算，性能效率比对称加密差很多。 对称加密需要做异或预算，性能效率比较高。 那么就综合起来，用非对称加密传输密钥E，然后再用对称加密传输数据。 认证找个我们都信得过的组织来保证我们不会被骗走密钥 接上面的思考，其实不用那么麻烦，硬刚刚不赢，可以曲线救国嘛~~ &gt;_ 如上，因为Hacker在中间截胡，所以他两边欺骗，然后只是做一个转发的工作。这个过程中，信息就给他看完了，而A、B都以为自己在跟对方通信，其实都被Hacker欺骗了。接下来开始传输数据的时候，Hacker前面拿到了密钥，所以他能解密任何数据，这样就绕过了非对称加密，保险箱不起作用了。 CA证书 那要怎么保证A请求B的公钥（保险箱）后，对方发过来的公钥（保险箱）就一定是B的呢？ 这里就需要一个彼此信任的组织，给每个人发身份证。就好像我们信任政府发的个人身份证（假设身份证没法伪造），所以我们看到个人身份证的时候就相信这个叫身份证上的名字。 在加密中，这个政府就是CA，身份证就是CA证书、CA数字签名。 大家都信任CA，所以检查CA证书后我们就相信B 是 B。 这个证书里面有两个重要的内容：B的公钥+CA做的数字签名 CA证书是反过来的，用私钥加密，用公钥解密。 CA用自己的私钥加密B的信息，A手里都有CA的公钥，在收到信息的时候，用CA的公钥解密，如果能解开，就证明B就是B。 换句话说，A请求B发保险箱过来，B先把保险箱给CA做个记号（CA认证加密），然后再发给A，A收到后看看记号跟CA约定的一不一样（CA的公钥解不解得开），如果Hacker发一个自己的保险箱，上面是没记号的（或者记号跟约定的不一样），那就说明这个保险箱是假的。 &gt;_ 以上就是一个简单的过程，Hacker发的假保险箱（公钥）跟CA约定的不一样（CA公钥解不开），A就停止发送密钥，Hacker欺骗失败 完整性非对称加密 和 认证 解决了保密性和真实性，但是完整性还没有一个保障。 如果Hacker等A、B非对称加密传输完密钥之后，在对称加密传输数据这个环节入手，篡改信息怎么办？ 答案是：哈希一下 单向哈希（Hash）可以把一个输入变成一个定长的输出串，它的特点就是无法从这个输入逆向还原输入内容，并且输入只要有一点改变，哪怕是那么一丢丢，输出串都会完全不同。 &gt;_ 这里哈希并不是这么简单，只需要知道哈希不可逆，一点点改变都会导致结果完全不同。 总结安全可靠的通信： B让CA用 # CA私钥 # 签名 [B的公钥]（给B的保险箱做个记号） A请求B给 [B的公钥]（打开的保险箱） B发送签名过的 [[B的公钥]]（带记号的保险箱）给A A用 ## CA的公钥 ## 校验B发来的 [[ B的公钥 ]]（检查记号） 用 [ B的公钥 ] 加密 “密钥E”（密钥放进保险箱关上门） B用【B的私钥】解密 “密钥E” A 用 “密钥E” 加密后传输数据 B 用 “密钥E” 解密数据 &gt;_","categories":[{"name":"RSA","slug":"RSA","permalink":"https://www.boii.xyz/categories/RSA/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://www.boii.xyz/tags/RSA/"}]},{"title":"RSA加密原理","slug":"RSA/RSA加密原理","date":"2019-04-25T00:09:08.000Z","updated":"2021-07-19T09:01:54.942Z","comments":true,"path":"posts/35371.html","link":"","permalink":"https://www.boii.xyz/posts/35371.html","excerpt":"数学是一种很奇妙的东西","text":"数学是一种很奇妙的东西 质数：只能被1和自身整除的数 互质数：两个数的公约数只有1，这两个为互质数 欧拉函数：OL(n)=x，x：从0到n的范围内，和n互质的数 的 个数，也就是从0到n的范围内，和n的公约数只有1的数的个数 RSA加密原理 P：质数1 Q：质数2 N：最小公倍数 OL(N)=X -&gt; X：小于N &amp; 和N互质 的数的个数 E：公钥 D：私钥 M：明文 C：密文 找出P、Q 比如：P = 3 Q=11 找公共模数（求最小公倍数） N = P * Q = 3 * 11 = 33 N=33 欧拉函数 OL(N) = (P - 1)(Q - 1) OL(33) = (3 - 1)(11 - 1) = 20 计算公钥E 1 &lt; E &lt; OL(N) = 1 &lt; (1,20) &lt; 20 E的取值范围{3，5，7，11，13，17，19} E必须是整数，E必须和**OL(N)**互质 假设E=3，3是整数，3和20互质 计算私钥D E * D % OL(N) = 1 = 3 * D % 20 = 1，得出D=7 到这我们就计算出公钥和密钥了，现在我们开始用公钥加密，然后用私钥解密 加密解密 公钥加密 比如我们加密数字2：M=2 C = ME mod N; 即 密文 = 明文公钥 % 最小公倍数 C = 23 % 33 = 8 C = 8 明文2经过RSA加密后变成密文8 私钥解密 M = Cd mod N; 即 明文 = 密文私钥 % 最小公倍数 M = 87 % 33 = 2 M = 2 密文8经过RSA解密后变成明文2","categories":[{"name":"RSA","slug":"RSA","permalink":"https://www.boii.xyz/categories/RSA/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://www.boii.xyz/tags/RSA/"}]},{"title":"Hello World","slug":"Hexo/Hello-World","date":"2018-12-31T16:00:00.000Z","updated":"2021-07-19T08:59:51.742Z","comments":true,"path":"posts/16107.html","link":"","permalink":"https://www.boii.xyz/posts/16107.html","excerpt":"Hello world !","text":"Hello world ! Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server or 1$ hexo s More info: Server Generate static files1$ hexo generate or 1$ hexo g More info: Generating Deploy to remote sites1$ hexo deploy or 1$ hexo d More info: Deployment","categories":[{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/categories/HEXO/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/tags/HEXO/"}]}],"categories":[{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/categories/Golang/"},{"name":"nil","slug":"Golang/nil","permalink":"https://www.boii.xyz/categories/Golang/nil/"},{"name":"Basic","slug":"Golang/Basic","permalink":"https://www.boii.xyz/categories/Golang/Basic/"},{"name":"Framework","slug":"Golang/Framework","permalink":"https://www.boii.xyz/categories/Golang/Framework/"},{"name":"Adavanced","slug":"Golang/Adavanced","permalink":"https://www.boii.xyz/categories/Golang/Adavanced/"},{"name":"408","slug":"408","permalink":"https://www.boii.xyz/categories/408/"},{"name":"NET","slug":"408/NET","permalink":"https://www.boii.xyz/categories/408/NET/"},{"name":"Other","slug":"Other","permalink":"https://www.boii.xyz/categories/Other/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/categories/DataStruction/"},{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/categories/HEXO/"},{"name":"Git","slug":"Git","permalink":"https://www.boii.xyz/categories/Git/"},{"name":"Note","slug":"Note","permalink":"https://www.boii.xyz/categories/Note/"},{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/categories/Python/"},{"name":"内置库","slug":"Python/内置库","permalink":"https://www.boii.xyz/categories/Python/%E5%86%85%E7%BD%AE%E5%BA%93/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"https://www.boii.xyz/categories/Python/%E7%88%AC%E8%99%AB/"},{"name":"基础","slug":"Python/爬虫/基础","permalink":"https://www.boii.xyz/categories/Python/%E7%88%AC%E8%99%AB/%E5%9F%BA%E7%A1%80/"},{"name":"基础","slug":"Python/基础","permalink":"https://www.boii.xyz/categories/Python/%E5%9F%BA%E7%A1%80/"},{"name":"高级特性","slug":"Python/高级特性","permalink":"https://www.boii.xyz/categories/Python/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"},{"name":"进阶","slug":"Python/进阶","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/"},{"name":"IO","slug":"Python/进阶/IO","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/IO/"},{"name":"进程、线程","slug":"Python/进阶/进程、线程","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/"},{"name":"OPP","slug":"Python/OPP","permalink":"https://www.boii.xyz/categories/Python/OPP/"},{"name":"错误与调试","slug":"Python/进阶/错误与调试","permalink":"https://www.boii.xyz/categories/Python/%E8%BF%9B%E9%98%B6/%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B0%83%E8%AF%95/"},{"name":"Vue","slug":"Vue","permalink":"https://www.boii.xyz/categories/Vue/"},{"name":"Electron","slug":"Electron","permalink":"https://www.boii.xyz/categories/Electron/"},{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/categories/Java/"},{"name":"SSM","slug":"Java/SSM","permalink":"https://www.boii.xyz/categories/Java/SSM/"},{"name":"C Language","slug":"C-Language","permalink":"https://www.boii.xyz/categories/C-Language/"},{"name":"RSA","slug":"RSA","permalink":"https://www.boii.xyz/categories/RSA/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/categories/LeetCode/"}],"tags":[{"name":"函数式编程","slug":"函数式编程","permalink":"https://www.boii.xyz/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"Golang","slug":"Golang","permalink":"https://www.boii.xyz/tags/Golang/"},{"name":"选项设计模式","slug":"选项设计模式","permalink":"https://www.boii.xyz/tags/%E9%80%89%E9%A1%B9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Function Option","slug":"Function-Option","permalink":"https://www.boii.xyz/tags/Function-Option/"},{"name":"生成器模式","slug":"生成器模式","permalink":"https://www.boii.xyz/tags/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"name":"Builder 模式","slug":"Builder-模式","permalink":"https://www.boii.xyz/tags/Builder-%E6%A8%A1%E5%BC%8F/"},{"name":"交叉编译","slug":"交叉编译","permalink":"https://www.boii.xyz/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"},{"name":"条件编译","slug":"条件编译","permalink":"https://www.boii.xyz/tags/%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/"},{"name":"gin","slug":"gin","permalink":"https://www.boii.xyz/tags/gin/"},{"name":"拦截器","slug":"拦截器","permalink":"https://www.boii.xyz/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"},{"name":"中间件","slug":"中间件","permalink":"https://www.boii.xyz/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"监视器","slug":"监视器","permalink":"https://www.boii.xyz/tags/%E7%9B%91%E8%A7%86%E5%99%A8/"},{"name":"上传","slug":"上传","permalink":"https://www.boii.xyz/tags/%E4%B8%8A%E4%BC%A0/"},{"name":"下载","slug":"下载","permalink":"https://www.boii.xyz/tags/%E4%B8%8B%E8%BD%BD/"},{"name":"重定向","slug":"重定向","permalink":"https://www.boii.xyz/tags/%E9%87%8D%E5%AE%9A%E5%90%91/"},{"name":"路由","slug":"路由","permalink":"https://www.boii.xyz/tags/%E8%B7%AF%E7%94%B1/"},{"name":"request","slug":"request","permalink":"https://www.boii.xyz/tags/request/"},{"name":"response","slug":"response","permalink":"https://www.boii.xyz/tags/response/"},{"name":"YAML","slug":"YAML","permalink":"https://www.boii.xyz/tags/YAML/"},{"name":"Json","slug":"Json","permalink":"https://www.boii.xyz/tags/Json/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://www.boii.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"物理层","slug":"物理层","permalink":"https://www.boii.xyz/tags/%E7%89%A9%E7%90%86%E5%B1%82/"},{"name":"七层模型","slug":"七层模型","permalink":"https://www.boii.xyz/tags/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/"},{"name":"OSI 模型","slug":"OSI-模型","permalink":"https://www.boii.xyz/tags/OSI-%E6%A8%A1%E5%9E%8B/"},{"name":"OneTiny","slug":"OneTiny","permalink":"https://www.boii.xyz/tags/OneTiny/"},{"name":"FTP","slug":"FTP","permalink":"https://www.boii.xyz/tags/FTP/"},{"name":"局域网","slug":"局域网","permalink":"https://www.boii.xyz/tags/%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"name":"独立开发","slug":"独立开发","permalink":"https://www.boii.xyz/tags/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91/"},{"name":"数据结构","slug":"数据结构","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DataStruction","slug":"DataStruction","permalink":"https://www.boii.xyz/tags/DataStruction/"},{"name":"HEXO","slug":"HEXO","permalink":"https://www.boii.xyz/tags/HEXO/"},{"name":"note","slug":"note","permalink":"https://www.boii.xyz/tags/note/"},{"name":"git","slug":"git","permalink":"https://www.boii.xyz/tags/git/"},{"name":"Python","slug":"Python","permalink":"https://www.boii.xyz/tags/Python/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://www.boii.xyz/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"json","slug":"json","permalink":"https://www.boii.xyz/tags/json/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.boii.xyz/tags/%E7%88%AC%E8%99%AB/"},{"name":"Vue","slug":"Vue","permalink":"https://www.boii.xyz/tags/Vue/"},{"name":"Electron","slug":"Electron","permalink":"https://www.boii.xyz/tags/Electron/"},{"name":"命令","slug":"命令","permalink":"https://www.boii.xyz/tags/%E5%91%BD%E4%BB%A4/"},{"name":"Java","slug":"Java","permalink":"https://www.boii.xyz/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://www.boii.xyz/tags/SSM/"},{"name":"SSM配置","slug":"SSM配置","permalink":"https://www.boii.xyz/tags/SSM%E9%85%8D%E7%BD%AE/"},{"name":"事务管理","slug":"事务管理","permalink":"https://www.boii.xyz/tags/%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"},{"name":"统一异常处理","slug":"统一异常处理","permalink":"https://www.boii.xyz/tags/%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"上传下载","slug":"上传下载","permalink":"https://www.boii.xyz/tags/%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"},{"name":"数据绑定","slug":"数据绑定","permalink":"https://www.boii.xyz/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"},{"name":"C Language","slug":"C-Language","permalink":"https://www.boii.xyz/tags/C-Language/"},{"name":"Hash","slug":"Hash","permalink":"https://www.boii.xyz/tags/Hash/"},{"name":"反射","slug":"反射","permalink":"https://www.boii.xyz/tags/%E5%8F%8D%E5%B0%84/"},{"name":"并行与并发","slug":"并行与并发","permalink":"https://www.boii.xyz/tags/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91/"},{"name":"RSA","slug":"RSA","permalink":"https://www.boii.xyz/tags/RSA/"},{"name":"算法","slug":"算法","permalink":"https://www.boii.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.boii.xyz/tags/LeetCode/"}]}