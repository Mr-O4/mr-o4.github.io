<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Mr.Boii</title><meta name=keywords content><meta name=description content="淘汰算法 将计算机简单看作一个 「计算+存储」 的工具，那么 CPU 的主要作用就是 「计算」，硬盘的主要作用就是 「存储」。
计算需要从硬盘里将数据搬运到 CPU 中，但是硬盘的速度是在太慢，从而有了折中的「内存」。即能存储一定的数据，又比硬盘速度更快些，虽然对于 CPU 而言还是太慢了。
计算机将部分数据从硬盘搬到内存中，在 CPU 需要时可以快速给到 CPU，从而提高 CPU 使用率。
但是内存是有限的，她被发明的本意就是为了加快访问。计算机不可能同时将全部的程序都放在内存中，但是我们又需要同时运行许多程序，于是操作系统就站出来负责这些工作。
一台计算机只有 4G 的内存，但是却可以运行 8G 的程序，其原因是由于程序的局部性原理，我们不需要同时运行 8G 的程序。
我们可以将程序中目前需要的部分先加载到内存中，随着程序的运行访问到某个子程序不在内存中，这个时候再去硬盘中加载到内存，这称为「内存页面置换」，也就是操作系统的内存管理的内容之一。
站在操作系统的视角，现在 A 程序运行的时候需要有个子程序 A&rsquo; ，但不在内存中，毫无疑问需要去硬盘中加载。但是加载之前有个问题需要考虑：目前内存是否有足够空间容纳子程序 A&rsquo;？
如果空间足够，那么加载进来就完事儿，如果不够怎么办？答案就是把一部分数据抱回硬盘，再把需要的子程序 A&rsquo; 抱进来内存中。
那么，把哪部分数据抱回去？也就是个淘汰谁的问题。于是诞生出许多的淘汰算法。这就是淘汰算法的由来。
!!! summary 由于资源的稀缺，我们建立一个兼顾速度和容量的中间件——内存。但是内存容量依然有限，而我们又有多程序同时运行的需求，所以操作系统站出来负责内存管理。
在进行内存管理的时候，需要将旧数据换下去，把新数据换上来，所以有了把谁换下去的问题，于是有了淘汰算法。 解决方案 淘汰算法不仅仅适用于操作系统的内存管理，同样适用其他空间不足时需要替换数据的场景中。
常见的淘汰算法有：
OPT (Optimum 最佳淘汰算法) (理想化，未来没准能实现) FIFO (First In First Out 先进先出算法) (绝对公平，但不实用) LRU (Least Recently Used 最近最少使用算法) (容易把热点数据淘汰掉) LFU (Least Frequently Used 最近最不常使用算法) (实现比较复杂) ARC (Adaptive Replacement Cache 自适应缓存替换算法) (结合了 LRU 和 LFU) 首先我们准备一个空队列，然后准备一组编号代表第几号页被访问的顺序：701203042303212"><meta name=author content="Boii"><link rel=canonical href=https://www.boii.xyz/posts/note/lru/><link crossorigin=anonymous href=/assets/css/stylesheet.min.30c0c973d02d0622251a43d6856208a4b7655389233c0e74e71274fc9f3dc8dd.css integrity="sha256-MMDJc9AtBiIlGkPWhWIIpLdlU4kjPA505xJ0/J89yN0=" rel="preload stylesheet" as=style><link rel=icon href=https://www.boii.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.boii.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.boii.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://www.boii.xyz/apple-touch-icon.png><link rel=mask-icon href=https://www.boii.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content><meta property="og:description" content="淘汰算法 将计算机简单看作一个 「计算+存储」 的工具，那么 CPU 的主要作用就是 「计算」，硬盘的主要作用就是 「存储」。
计算需要从硬盘里将数据搬运到 CPU 中，但是硬盘的速度是在太慢，从而有了折中的「内存」。即能存储一定的数据，又比硬盘速度更快些，虽然对于 CPU 而言还是太慢了。
计算机将部分数据从硬盘搬到内存中，在 CPU 需要时可以快速给到 CPU，从而提高 CPU 使用率。
但是内存是有限的，她被发明的本意就是为了加快访问。计算机不可能同时将全部的程序都放在内存中，但是我们又需要同时运行许多程序，于是操作系统就站出来负责这些工作。
一台计算机只有 4G 的内存，但是却可以运行 8G 的程序，其原因是由于程序的局部性原理，我们不需要同时运行 8G 的程序。
我们可以将程序中目前需要的部分先加载到内存中，随着程序的运行访问到某个子程序不在内存中，这个时候再去硬盘中加载到内存，这称为「内存页面置换」，也就是操作系统的内存管理的内容之一。
站在操作系统的视角，现在 A 程序运行的时候需要有个子程序 A&rsquo; ，但不在内存中，毫无疑问需要去硬盘中加载。但是加载之前有个问题需要考虑：目前内存是否有足够空间容纳子程序 A&rsquo;？
如果空间足够，那么加载进来就完事儿，如果不够怎么办？答案就是把一部分数据抱回硬盘，再把需要的子程序 A&rsquo; 抱进来内存中。
那么，把哪部分数据抱回去？也就是个淘汰谁的问题。于是诞生出许多的淘汰算法。这就是淘汰算法的由来。
!!! summary 由于资源的稀缺，我们建立一个兼顾速度和容量的中间件——内存。但是内存容量依然有限，而我们又有多程序同时运行的需求，所以操作系统站出来负责内存管理。
在进行内存管理的时候，需要将旧数据换下去，把新数据换上来，所以有了把谁换下去的问题，于是有了淘汰算法。 解决方案 淘汰算法不仅仅适用于操作系统的内存管理，同样适用其他空间不足时需要替换数据的场景中。
常见的淘汰算法有：
OPT (Optimum 最佳淘汰算法) (理想化，未来没准能实现) FIFO (First In First Out 先进先出算法) (绝对公平，但不实用) LRU (Least Recently Used 最近最少使用算法) (容易把热点数据淘汰掉) LFU (Least Frequently Used 最近最不常使用算法) (实现比较复杂) ARC (Adaptive Replacement Cache 自适应缓存替换算法) (结合了 LRU 和 LFU) 首先我们准备一个空队列，然后准备一组编号代表第几号页被访问的顺序：701203042303212"><meta property="og:type" content="article"><meta property="og:url" content="https://www.boii.xyz/posts/note/lru/"><meta property="og:image" content="https://www.boii.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="og:site_name" content="Mr.Boii"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.boii.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content><meta name=twitter:description content="淘汰算法 将计算机简单看作一个 「计算+存储」 的工具，那么 CPU 的主要作用就是 「计算」，硬盘的主要作用就是 「存储」。
计算需要从硬盘里将数据搬运到 CPU 中，但是硬盘的速度是在太慢，从而有了折中的「内存」。即能存储一定的数据，又比硬盘速度更快些，虽然对于 CPU 而言还是太慢了。
计算机将部分数据从硬盘搬到内存中，在 CPU 需要时可以快速给到 CPU，从而提高 CPU 使用率。
但是内存是有限的，她被发明的本意就是为了加快访问。计算机不可能同时将全部的程序都放在内存中，但是我们又需要同时运行许多程序，于是操作系统就站出来负责这些工作。
一台计算机只有 4G 的内存，但是却可以运行 8G 的程序，其原因是由于程序的局部性原理，我们不需要同时运行 8G 的程序。
我们可以将程序中目前需要的部分先加载到内存中，随着程序的运行访问到某个子程序不在内存中，这个时候再去硬盘中加载到内存，这称为「内存页面置换」，也就是操作系统的内存管理的内容之一。
站在操作系统的视角，现在 A 程序运行的时候需要有个子程序 A&rsquo; ，但不在内存中，毫无疑问需要去硬盘中加载。但是加载之前有个问题需要考虑：目前内存是否有足够空间容纳子程序 A&rsquo;？
如果空间足够，那么加载进来就完事儿，如果不够怎么办？答案就是把一部分数据抱回硬盘，再把需要的子程序 A&rsquo; 抱进来内存中。
那么，把哪部分数据抱回去？也就是个淘汰谁的问题。于是诞生出许多的淘汰算法。这就是淘汰算法的由来。
!!! summary 由于资源的稀缺，我们建立一个兼顾速度和容量的中间件——内存。但是内存容量依然有限，而我们又有多程序同时运行的需求，所以操作系统站出来负责内存管理。
在进行内存管理的时候，需要将旧数据换下去，把新数据换上来，所以有了把谁换下去的问题，于是有了淘汰算法。 解决方案 淘汰算法不仅仅适用于操作系统的内存管理，同样适用其他空间不足时需要替换数据的场景中。
常见的淘汰算法有：
OPT (Optimum 最佳淘汰算法) (理想化，未来没准能实现) FIFO (First In First Out 先进先出算法) (绝对公平，但不实用) LRU (Least Recently Used 最近最少使用算法) (容易把热点数据淘汰掉) LFU (Least Frequently Used 最近最不常使用算法) (实现比较复杂) ARC (Adaptive Replacement Cache 自适应缓存替换算法) (结合了 LRU 和 LFU) 首先我们准备一个空队列，然后准备一组编号代表第几号页被访问的顺序：701203042303212"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.boii.xyz/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://www.boii.xyz/posts/note/lru/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"淘汰算法 将计算机简单看作一个 「计算+存储」 的工具，那么 CPU 的主要作用就是 「计算」，硬盘的主要作用就是 「存储」。\n计算需要从硬盘里将数据搬运到 CPU 中，但是硬盘的速度是在太慢，从而有了折中的「内存」。即能存储一定的数据，又比硬盘速度更快些，虽然对于 CPU 而言还是太慢了。\n计算机将部分数据从硬盘搬到内存中，在 CPU 需要时可以快速给到 CPU，从而提高 CPU 使用率。\n但是内存是有限的，她被发明的本意就是为了加快访问。计算机不可能同时将全部的程序都放在内存中，但是我们又需要同时运行许多程序，于是操作系统就站出来负责这些工作。\n一台计算机只有 4G 的内存，但是却可以运行 8G 的程序，其原因是由于程序的局部性原理，我们不需要同时运行 8G 的程序。\n我们可以将程序中目前需要的部分先加载到内存中，随着程序的运行访问到某个子程序不在内存中，这个时候再去硬盘中加载到内存，这称为「内存页面置换」，也就是操作系统的内存管理的内容之一。\n站在操作系统的视角，现在 A 程序运行的时候需要有个子程序 A\u0026rsquo; ，但不在内存中，毫无疑问需要去硬盘中加载。但是加载之前有个问题需要考虑：目前内存是否有足够空间容纳子程序 A\u0026rsquo;？\n如果空间足够，那么加载进来就完事儿，如果不够怎么办？答案就是把一部分数据抱回硬盘，再把需要的子程序 A\u0026rsquo; 抱进来内存中。\n那么，把哪部分数据抱回去？也就是个淘汰谁的问题。于是诞生出许多的淘汰算法。这就是淘汰算法的由来。\n!!! summary 由于资源的稀缺，我们建立一个兼顾速度和容量的中间件——内存。但是内存容量依然有限，而我们又有多程序同时运行的需求，所以操作系统站出来负责内存管理。\n在进行内存管理的时候，需要将旧数据换下去，把新数据换上来，所以有了把谁换下去的问题，于是有了淘汰算法。 解决方案 淘汰算法不仅仅适用于操作系统的内存管理，同样适用其他空间不足时需要替换数据的场景中。\n常见的淘汰算法有：\nOPT (Optimum 最佳淘汰算法) (理想化，未来没准能实现) FIFO (First In First Out 先进先出算法) (绝对公平，但不实用) LRU (Least Recently Used 最近最少使用算法) (容易把热点数据淘汰掉) LFU (Least Frequently Used 最近最不常使用算法) (实现比较复杂) ARC (Adaptive Replacement Cache 自适应缓存替换算法) (结合了 LRU 和 LFU) 首先我们准备一个空队列，然后准备一组编号代表第几号页被访问的顺序：701203042303212","keywords":[],"articleBody":"淘汰算法 将计算机简单看作一个 「计算+存储」 的工具，那么 CPU 的主要作用就是 「计算」，硬盘的主要作用就是 「存储」。\n计算需要从硬盘里将数据搬运到 CPU 中，但是硬盘的速度是在太慢，从而有了折中的「内存」。即能存储一定的数据，又比硬盘速度更快些，虽然对于 CPU 而言还是太慢了。\n计算机将部分数据从硬盘搬到内存中，在 CPU 需要时可以快速给到 CPU，从而提高 CPU 使用率。\n但是内存是有限的，她被发明的本意就是为了加快访问。计算机不可能同时将全部的程序都放在内存中，但是我们又需要同时运行许多程序，于是操作系统就站出来负责这些工作。\n一台计算机只有 4G 的内存，但是却可以运行 8G 的程序，其原因是由于程序的局部性原理，我们不需要同时运行 8G 的程序。\n我们可以将程序中目前需要的部分先加载到内存中，随着程序的运行访问到某个子程序不在内存中，这个时候再去硬盘中加载到内存，这称为「内存页面置换」，也就是操作系统的内存管理的内容之一。\n站在操作系统的视角，现在 A 程序运行的时候需要有个子程序 A’ ，但不在内存中，毫无疑问需要去硬盘中加载。但是加载之前有个问题需要考虑：目前内存是否有足够空间容纳子程序 A’？\n如果空间足够，那么加载进来就完事儿，如果不够怎么办？答案就是把一部分数据抱回硬盘，再把需要的子程序 A’ 抱进来内存中。\n那么，把哪部分数据抱回去？也就是个淘汰谁的问题。于是诞生出许多的淘汰算法。这就是淘汰算法的由来。\n!!! summary 由于资源的稀缺，我们建立一个兼顾速度和容量的中间件——内存。但是内存容量依然有限，而我们又有多程序同时运行的需求，所以操作系统站出来负责内存管理。\n在进行内存管理的时候，需要将旧数据换下去，把新数据换上来，所以有了把谁换下去的问题，于是有了淘汰算法。 解决方案 淘汰算法不仅仅适用于操作系统的内存管理，同样适用其他空间不足时需要替换数据的场景中。\n常见的淘汰算法有：\nOPT (Optimum 最佳淘汰算法) (理想化，未来没准能实现) FIFO (First In First Out 先进先出算法) (绝对公平，但不实用) LRU (Least Recently Used 最近最少使用算法) (容易把热点数据淘汰掉) LFU (Least Frequently Used 最近最不常使用算法) (实现比较复杂) ARC (Adaptive Replacement Cache 自适应缓存替换算法) (结合了 LRU 和 LFU) 首先我们准备一个空队列，然后准备一组编号代表第几号页被访问的顺序：701203042303212\n每当访问一个页面的时候，我们就将其编号入队，通过观察其位置来区别不同算法的差异。\nLRU LRU 不仅记录了编号，还记录了其上次被访问至当前的时长。但是我们可以通过每次访问都将该编号放到队头，这样队尾自然演化成上次访问时间最长的那些。\n7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 备注 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 队头 7 0 1 2 0 3 0 4 2 3 0 3 2 1 7 0 1 2 2 3 0 4 2 2 0 3 3 队尾 前面三列可以看出，队列未满的时候， 7、0、1 依次入队，此时队头至队尾顺序为 107；\n接着 2 入队，这时候 7 是距离入队时间(上次访问时间)最久的，所以被淘汰，于是队列成了 210；\n然后 0 再次入队，因为 0 已经在队列中，所以把 0 调整到队头即可，此时队列成了 021；\n然后 3 入队，此时 1 是距离入队时间最久的，所以被淘汰，于是队列成了 302，后面的情况也是如此。\n这就是朴素的 LRU 算法，之所以实现简单就在于，虽然她带着一个「上次访问时间」的维度，但是这个维度可以通过将编号调整至队头，慢慢的队尾就是最久的一个。\n那么实现起来只需要一个 链队 即可搞定。访问的编号在队中，只需要执行链表结点删除、插入队头两个操作即可；访问的编号不在队中，那么将队尾结点删除，插入队头两个操作即可。由于是链表，所以插入删除的时间复杂度仅为 O(1)。\n但是要插入删除之前得先找到该结点，这样就得去遍历链表，时间复杂度是 O(n)，这个问题也简单，只需要增加一个哈希表，在插入和删除的时候维护这个哈希表即可。\n??? example\n```go package main type Node struct { Pre, Next *Node key int Data any } type LRUCache struct { length int capacity int H map[int]*Node Head *Node Tail *Node } func NewLRU(capacity int) *LRUCache { return \u0026LRUCache{ H: make(map[int]*Node, capacity), capacity: capacity, } } func (l *LRUCache) Get(idx int) *Node { node := l.H[idx] if node == nil { return nil } l.moveToHead(idx) return node } func (l *LRUCache) moveToHead(idx int) { node := l.H[idx] node.Next.Pre = node.Pre node.Pre.Next = node.Next first := l.Head first.Pre = node node.Next = first l.Head = node } func (l *LRUCache) eliminate() { if l.length \u003c l.capacity { return } last := l.Tail if last == nil { return } // 清理map delete(l.H, last.key) // 断链 l.Tail = last.Pre last.Pre.Next = nil last = nil // 长度减1 l.length-- } func (l *LRUCache) Put(idx int, data any) { node := \u0026Node{ key: idx, Data: data, } // 数据存在，就放到队头，不存在，就淘汰一个再放队头 if _, ok := l.H[idx]; ok { l.moveToHead(idx) } // 淘汰数据 l.eliminate() l.put(node) } func (l *LRUCache) put(node *Node) { if l.Head == nil { l.Head = node l.Tail = node l.length++ return } first := l.Head first.Pre = node node.Next = first l.Head = node l.H[node.key] = node l.length++ } ``` 优点 热点数据命中率高。\n缺点\n朴素的 LRU 可能会导致热点数据被淘汰下去。例如，765432176576543243218，除了 1，其他都是反复被访问的页面，然后 1 就一直排在队尾，队列长这样 2345671。\n然后访问了一下 1，变成 1234567，再访问下 8，这时候直接把 7 淘汰掉了，变成 8123456。而我们知道 7 的访问次数是比 1 高的。\n这样就造成 7 这个热点数据被淘汰，而 1 这个冷数据却留下来了。\n还有一种情况就是，当 1234567 的访问次数都很高，也就是他们都是热点数据，这时候 LRU 将失去优点。\nLFU LRU 记录了「上次访问时间」的维度，而 LFU 这是记录了「访问频率」的维度。\n","wordCount":"418","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Boii"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.boii.xyz/posts/note/lru/"},"publisher":{"@type":"Organization","name":"Mr.Boii","logo":{"@type":"ImageObject","url":"https://www.boii.xyz/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.boii.xyz/ accesskey=h title="Boii (Alt + H)"><img src=https://www.boii.xyz/apple-touch-icon.png alt=logo aria-label=logo height=35>Boii</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.boii.xyz/posts title="📚 文章"><span>📚 文章</span></a></li><li><a href=https://www.boii.xyz/archives/ title="⏱ 时间轴"><span>⏱ 时间轴</span></a></li><li><a href=https://www.boii.xyz/categories/ title="🧩 分类"><span>🧩 分类</span></a></li><li><a href=https://www.boii.xyz/tags/ title="🔖 标签"><span>🔖 标签</span></a></li><li><a href=https://www.boii.xyz/me title=me><span>me</span></a></li><li><a href=https://www.boii.xyz/search/ title="🔍 (Alt + /)" accesskey=/><span><i class="fa-solid fa-magnifying-glass"></i>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.boii.xyz/>Home</a>&nbsp;»&nbsp;<a href=https://www.boii.xyz/posts/>Posts</a></div><h1 class=post-title></h1><div class=post-meta>2 min&nbsp;·&nbsp;Boii</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%b7%98%e6%b1%b0%e7%ae%97%e6%b3%95 aria-label=淘汰算法>淘汰算法</a><ul><li><a href=#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 aria-label=解决方案>解决方案</a><ul><li><a href=#lru aria-label=LRU>LRU</a></li><li><a href=#lfu aria-label=LFU>LFU</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=淘汰算法>淘汰算法<a hidden class=anchor aria-hidden=true href=#淘汰算法>#</a></h1><p>将计算机简单看作一个 「计算+存储」 的工具，那么 CPU 的主要作用就是 「计算」，硬盘的主要作用就是 「存储」。</p><p>计算需要从硬盘里将数据搬运到 CPU 中，但是硬盘的速度是在太慢，从而有了折中的「内存」。即能存储一定的数据，又比硬盘速度更快些，虽然对于 CPU 而言还是太慢了。</p><p>计算机将部分数据从硬盘搬到内存中，在 CPU 需要时可以快速给到 CPU，从而提高 CPU 使用率。</p><p>但是内存是有限的，她被发明的本意就是为了加快访问。计算机不可能同时将全部的程序都放在内存中，但是我们又需要同时运行许多程序，于是操作系统就站出来负责这些工作。</p><p>一台计算机只有 4G 的内存，但是却可以运行 8G 的程序，其原因是由于程序的局部性原理，我们不需要同时运行 8G 的程序。</p><p>我们可以将程序中目前需要的部分先加载到内存中，随着程序的运行访问到某个子程序不在内存中，这个时候再去硬盘中加载到内存，这称为「内存页面置换」，也就是操作系统的内存管理的内容之一。</p><p>站在操作系统的视角，现在 A 程序运行的时候需要有个子程序 A&rsquo; ，但不在内存中，毫无疑问需要去硬盘中加载。但是加载之前有个问题需要考虑：目前内存是否有足够空间容纳子程序 A&rsquo;？</p><p>如果空间足够，那么加载进来就完事儿，如果不够怎么办？答案就是把一部分数据抱回硬盘，再把需要的子程序 A&rsquo; 抱进来内存中。</p><p>那么，把哪部分数据抱回去？也就是个淘汰谁的问题。于是诞生出许多的淘汰算法。这就是淘汰算法的由来。</p><p>!!! summary
由于资源的稀缺，我们建立一个兼顾速度和容量的中间件——内存。但是内存容量依然有限，而我们又有多程序同时运行的需求，所以操作系统站出来负责内存管理。</p><pre><code>在进行内存管理的时候，需要将旧数据换下去，把新数据换上来，所以有了把谁换下去的问题，于是有了淘汰算法。
</code></pre><h2 id=解决方案>解决方案<a hidden class=anchor aria-hidden=true href=#解决方案>#</a></h2><p>淘汰算法不仅仅适用于操作系统的内存管理，同样适用其他空间不足时需要替换数据的场景中。</p><p>常见的淘汰算法有：</p><ul><li>OPT (Optimum 最佳淘汰算法) (理想化，未来没准能实现)</li><li>FIFO (First In First Out 先进先出算法) (绝对公平，但不实用)</li><li>LRU (Least Recently Used 最近最少使用算法) (容易把热点数据淘汰掉)</li><li>LFU (Least Frequently Used 最近最不常使用算法) (实现比较复杂)</li><li>ARC (Adaptive Replacement Cache 自适应缓存替换算法) (结合了 LRU 和 LFU)</li></ul><p>首先我们准备一个空队列，然后准备一组编号代表第几号页被访问的顺序：701203042303212</p><p>每当访问一个页面的时候，我们就将其编号入队，通过观察其位置来区别不同算法的差异。</p><h3 id=lru>LRU<a hidden class=anchor aria-hidden=true href=#lru>#</a></h3><p>LRU 不仅记录了编号，还记录了其上次被访问至当前的时长。但是我们可以通过每次访问都将该编号放到队头，这样队尾自然演化成上次访问时间最长的那些。</p><table><thead><tr><th>7</th><th>0</th><th>1</th><th>2</th><th>0</th><th>3</th><th>0</th><th>4</th><th>2</th><th>3</th><th>0</th><th>3</th><th>2</th><th>1</th><th>2</th><th>备注</th></tr></thead><tbody><tr><td>7</td><td>0</td><td>1</td><td>2</td><td>0</td><td>3</td><td>0</td><td>4</td><td>2</td><td>3</td><td>0</td><td>3</td><td>2</td><td>1</td><td>2</td><td>队头</td></tr><tr><td></td><td>7</td><td>0</td><td>1</td><td>2</td><td>0</td><td>3</td><td>0</td><td>4</td><td>2</td><td>3</td><td>0</td><td>3</td><td>2</td><td>1</td><td></td></tr><tr><td></td><td></td><td>7</td><td>0</td><td>1</td><td>2</td><td>2</td><td>3</td><td>0</td><td>4</td><td>2</td><td>2</td><td>0</td><td>3</td><td>3</td><td>队尾</td></tr></tbody></table><p>前面三列可以看出，队列未满的时候， 7、0、1 依次入队，此时队头至队尾顺序为 107；</p><p>接着 2 入队，这时候 7 是距离入队时间(上次访问时间)最久的，所以被淘汰，于是队列成了 210；</p><p>然后 0 再次入队，因为 0 已经在队列中，所以把 0 调整到队头即可，此时队列成了 021；</p><p>然后 3 入队，此时 1 是距离入队时间最久的，所以被淘汰，于是队列成了 302，后面的情况也是如此。</p><p>这就是朴素的 LRU 算法，之所以实现简单就在于，虽然她带着一个「上次访问时间」的维度，但是这个维度可以通过将编号调整至队头，慢慢的队尾就是最久的一个。</p><p>那么实现起来只需要一个 <strong>链队</strong> 即可搞定。访问的编号在队中，只需要执行链表结点删除、插入队头两个操作即可；访问的编号不在队中，那么将队尾结点删除，插入队头两个操作即可。由于是链表，所以插入删除的时间复杂度仅为 O(1)。</p><p>但是要插入删除之前得先找到该结点，这样就得去遍历链表，时间复杂度是 O(n)，这个问题也简单，只需要增加一个哈希表，在插入和删除的时候维护这个哈希表即可。</p><p>??? example</p><pre><code>```go
package main

type Node struct {
    Pre, Next *Node
    key       int
    Data      any
}

type LRUCache struct {
    length   int
    capacity int
    H        map[int]*Node
    Head     *Node
    Tail     *Node
}

func NewLRU(capacity int) *LRUCache {
    return &amp;LRUCache{
        H:        make(map[int]*Node, capacity),
        capacity: capacity,
    }
}

func (l *LRUCache) Get(idx int) *Node {
    node := l.H[idx]
    if node == nil {
        return nil
    }
    l.moveToHead(idx)
    return node
}

func (l *LRUCache) moveToHead(idx int) {
    node := l.H[idx]
    node.Next.Pre = node.Pre
    node.Pre.Next = node.Next
    first := l.Head
    first.Pre = node
    node.Next = first
    l.Head = node
}

func (l *LRUCache) eliminate() {
    if l.length &lt; l.capacity {
        return
    }
    last := l.Tail
    if last == nil {
        return
    }
    // 清理map
    delete(l.H, last.key)
    // 断链
    l.Tail = last.Pre
    last.Pre.Next = nil
    last = nil
    // 长度减1
    l.length--
}

func (l *LRUCache) Put(idx int, data any) {
    node := &amp;Node{
        key:  idx,
        Data: data,
    }
    // 数据存在，就放到队头，不存在，就淘汰一个再放队头
    if _, ok := l.H[idx]; ok {
        l.moveToHead(idx)
    }
    // 淘汰数据
    l.eliminate()
    l.put(node)
}

func (l *LRUCache) put(node *Node) {
    if l.Head == nil {
        l.Head = node
        l.Tail = node
        l.length++
        return
    }
    first := l.Head
    first.Pre = node
    node.Next = first
    l.Head = node
    l.H[node.key] = node
    l.length++
}
```
</code></pre><ul><li><p>优点
热点数据命中率高。</p></li><li><p>缺点</p></li></ul><p>朴素的 LRU 可能会导致热点数据被淘汰下去。例如，765432176576543243218，除了 1，其他都是反复被访问的页面，然后 1 就一直排在队尾，队列长这样 2345671。</p><p>然后访问了一下 1，变成 1234567，再访问下 8，这时候直接把 7 淘汰掉了，变成 8123456。而我们知道 7 的访问次数是比 1 高的。</p><p>这样就造成 7 这个热点数据被淘汰，而 1 这个冷数据却留下来了。</p><p>还有一种情况就是，当 1234567 的访问次数都很高，也就是他们都是热点数据，这时候 LRU 将失去优点。</p><h3 id=lfu>LFU<a hidden class=anchor aria-hidden=true href=#lfu>#</a></h3><p>LRU 记录了「上次访问时间」的维度，而 LFU 这是记录了「访问频率」的维度。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://www.boii.xyz/posts/manjaro/manjaro/><span class=title>« Prev Page</span><br><span></span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share  on twitter" href="https://twitter.com/intent/tweet/?text=&url=https%3a%2f%2fwww.boii.xyz%2fposts%2fnote%2flru%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share  on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.boii.xyz%2fposts%2fnote%2flru%2f&title=&summary=&source=https%3a%2f%2fwww.boii.xyz%2fposts%2fnote%2flru%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share  on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.boii.xyz%2fposts%2fnote%2flru%2f&title="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share  on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.boii.xyz%2fposts%2fnote%2flru%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share  on whatsapp" href="https://api.whatsapp.com/send?text=%20-%20https%3a%2f%2fwww.boii.xyz%2fposts%2fnote%2flru%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share  on telegram" href="https://telegram.me/share/url?text=&url=https%3a%2f%2fwww.boii.xyz%2fposts%2fnote%2flru%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.boii.xyz/>Mr.Boii</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>