<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang [深入理解] 2-slice 实现原理 | Mr.Boii</title><meta name=keywords content="Golang,底层原理"><meta name=description content="关于你可能知道的 slice"><meta name=author content="Boii"><link rel=canonical href=https://www.boii.xyz/posts/go/golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-2-slice-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/><link crossorigin=anonymous href=/assets/css/stylesheet.min.30c0c973d02d0622251a43d6856208a4b7655389233c0e74e71274fc9f3dc8dd.css integrity="sha256-MMDJc9AtBiIlGkPWhWIIpLdlU4kjPA505xJ0/J89yN0=" rel="preload stylesheet" as=style><link rel=icon href=https://www.boii.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.boii.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.boii.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://www.boii.xyz/apple-touch-icon.png><link rel=mask-icon href=https://www.boii.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Golang [深入理解] 2-slice 实现原理"><meta property="og:description" content="关于你可能知道的 slice"><meta property="og:type" content="article"><meta property="og:url" content="https://www.boii.xyz/posts/go/golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-2-slice-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"><meta property="og:image" content="https://www.boii.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-14T15:07:18+00:00"><meta property="article:modified_time" content="2021-09-14T15:07:18+00:00"><meta property="og:site_name" content="Mr.Boii"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.boii.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Golang [深入理解] 2-slice 实现原理"><meta name=twitter:description content="关于你可能知道的 slice"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.boii.xyz/posts/"},{"@type":"ListItem","position":2,"name":"Golang [深入理解] 2-slice 实现原理","item":"https://www.boii.xyz/posts/go/golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-2-slice-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang [深入理解] 2-slice 实现原理","name":"Golang [深入理解] 2-slice 实现原理","description":"关于你可能知道的 slice\n","keywords":["Golang","底层原理"],"articleBody":"关于你可能知道的 slice\nslice 实现原理 slice 是一段底层数组的描述。\n 在 golang spec 是这么说的：\nA slice is a descriptor for a contiguous segment of an underlying array and provides access to a numbered sequence of elements from that array. A slice type denotes the set of all slices of arrays of its element type. The number of elements is called the length of the slice and is never negative. The value of an uninitialized slice is nil.\n切片是底层数组的连续段的描述符，提供对该数组中编号的元素序列的访问。切片类型表示其元素类型的数组的所有切片的集合。元素的数量称为切片的长度，并且永远不会为负。未初始化切片的值为nil。\n slice 结构 在源码包中 src/runtime/slice.go:slice 对 Slice 定义如下：\n1 2 3 4 5  type slice struct { array unsafe.Pointer len int cap int }   通过这个结构体可以更清晰看出，切片是基于一个底层数组的（即 array 字段，其为一个指针，指向一个数组），并且带有两个字段：长度 len 和 容量 cap。\n  容量，指的是切片的底层数组的元素最大个数。\n  长度，指的是切片的底层数组的元素目前个数。\n  创建切片共有 3 种方式：\n  通过字面量直接创建\n  基于已有 数组/slice 创建\n  通过 make() 创建\n1 2 3 4 5  arr := [8]int{1, 2, 3, 4, 5, 6, 7, 8} s1 := []int{11, 22, 33}\t// 1. 通过字面量直接创建 s2 := arr[2:6]\t// 2. 通过下标基于数组或切片创建 s3 := make([]int, 10, 20)\t// 3. 通过关键字 make 创建     [:] re-slice [:] 语法在 golang spec 称为 Slice Expression，也有称作 re-slice，是 golang 中很常用的一种获得切片的方法。但在使用时有一些地方需要注意。\n[:] 语法有两种基本形式：\n [low : high] [low : high : max]  第一种基本形式中，low 和 high 都允许使用字面常量或变量，都允许忽略不写，所以有以下几种形式：\n [2:5]、[2:]、[:5]、[:]  第二种基本形式中，low、high、max 都允许使用字面常量或变量，但只允许 low 忽略不写，所以只有 2 种形式：\n [2:5:6]、[:5:6]  在忽略不写的情况下：\n  low的默认值为 0，即基础数组的第一个元素开始算起\n  high的默认值为 len(基础数组/切片)，即基础数组/切片的最后一个\n  max 的默认值为 len(底层数组)，即底层数组的最后一个元素（包含最后一个元素）\n  举个栗子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  b := make([]int, 0, 10)\t// 切片 b，b 的基础数组和底层数组都是某个匿名数组  for i := 0; i  8; i++ { b = append(b, i+1) } fmt.Println(\"b:\", b)\t// b: [1 2 3 4 5 6 7 8] fmt.Println(len(b), cap(b))\t// 8 10  j := b[2:7]\t// 切片 j，基础数组是 b，底层数组是某个匿名数组 fmt.Println(\"j:\", j)\t// j: [3 4 5 6 7] fmt.Println(len(j), cap(j))\t// 5 8  k := j[2:]\t// 切片 k，基础数组是 j，底层数组是某个匿名数组 fmt.Println(\"k:\", k)\t// k: [5 6 7] fmt.Println(len(k), cap(k))\t// 3 6  l := j[1:4:6]\t// 切片 l，基础数组是 j, 底层数组是某个匿名数组 fmt.Println(\"l:\", l)\t// l: [4 5 6] fmt.Println(len(l), cap(l))\t// 3 5   此外 low、high、max 的默认值也有一些要求，但概括起来就是： $$ 0 \\le low \\le len(s) \\le high \\le max \\le cap(s) $$ 即：low 不能超过 high、high 不能超过 max、max 不能超过 cap(s)；反之，max 不能小于 high、high 不能小于 low、low 不能小于 0。\n low 的取值在 [0, high] high 的取值在 [low, max] max 的取值在 [high, cap(s)]  扩容策略 Slice 是基于底层数组的一种动态数组，相对于长度固定的数组，Slice 更灵活，且体现在：当底层数组容量不足时，Slice 会自动扩容。既然会自动扩容，那么就一定有扩容策略。\n扩容关注点：容量 扩容时机：len(s) == cap(s) 扩容触发场景：len(s) == cap(s) 时继续使用 append() 追加元素 扩容策略：\n  扩容后能容纳要追加的元素：\n if oldCap  if oldCap = 1024 { newCap = oldCap * 1.25}    扩容后不能容纳要追加的元素：\n newCap = 预估的容量    复制问题 在复制 Slice 时，如果仅仅使用等于号 s1 = s2，这样只是拷贝了一个地址。\n要实现完全的复制，需要使用 golang 提供的 copy() 函数。\n使用 copy() 拷贝时，会将源切片的元素逐个拷贝到目的切片指向的数组中，拷贝的数量取两个切片长度的最小值。例如上图中，s1 长度为 8，s2 长度为 5，则共拷贝 5 个元素，即 copy() 不会发生扩容。\n 注意，copy() 是覆盖行为。原有数据将会被覆盖。\n 比较问题 在 Slice 的比较中，因为 Slice 不是可比较类型，直接用恒等号 == 比较是无法通过编译的，如果取地址比较也是行不通的，因为 Slice 是结构体，取地址比较的是两个结构体，自然是 false。\n1 2 3 4 5  s1 := []int{1, 2, 3, 4, 5} s2 := s1 s1 == s2 // 无法通过编译 \u0026s1 == \u0026s2\t// false   所以，Slice 比较肯定不是那么肤浅的。\nSlice 的比较在网上盛传的有两种：使用 reflect.DeepEqual() 和 手写比较函数。\n因为 reflect.DeepEqual() 效率较低，所以才有手写比较函数。下面简单展示下 DeepEqual()，然后讲解手写比较函数。\nreflect.DeepEqual() 1 2 3  func compare(a, b []rune) bool { return reflect.DeepEqual(a, b) }   手写比较函数 其实比较两个 Slice 的思路也简单：\n 先看看长度是否相等； 再看看是不是都为 nil 或 都不为 nil，是就 true，否就下一步（都为 nil 也是相等）； 遍历随便哪一个，在遍历中两两比较，一旦不等就返回 false（如果是用在安全方面要预防计时攻击）  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func compare(a, b []rune) bool { if len(a) != len(b) {\t// 比较长度，长度都不同肯定不相等  return false } if (a==nil) != (b==nil) {\t// 看看是否都为 nil 或 都不为 nil  return false } for i := range a {\t// 遍历，逐个比较  if a[i] != b[i] { return false } } return true }   在遍历之前还可以加入 BCE 优化，不过第一步比较长度时，编译器已经获取了 a 和 b 的长度了，在遍历时应该不会再次检查边界了。\n性能陷阱 问题 golang 具有垃圾回收功能，而一个切片的底层数组，有可能被多个切片引用（即有多个 Slice 指向同一个底层数组），例如 [:] re-slice 就是对底层数组的再一次引用。\n这样的机制就有可能带来一个问题：\n 有一个结构体切片 a 有100 个元素，每个结构体的大小是 1 MB，也就是 a 的大小是 100 MB；\n然后另一个切片 b 引用了 切片 a 最后两个元素，即 b := a[len(a)-2:]。当 a 使用完后 GC 是没法回收这个 100 MB 的底层数组的，因为还有 b 在引用着。\n于是就会出现这种 用到只有 2 MB，但却无法回收剩下 98 MB 的空间。这就是我想说的性能陷阱。\n 1 2 3 4 5 6  type BigStruct struct { ... } a := []BigStruct { ... 100 个} b := a[len(a)-2:]   解决方法 比较推荐的做法是，采用 copy() 的方法替代 re-slice，因为 copy(b, a) 后 a 和 b 引用的不是同一个底层数组。这样 a 使用完以后，底层数组那 100 MB 的空间也能被 GC 回收。\n1 2 3 4 5 6 7 8  type BigStruct struct { ... } a := []BigStruct { ... 100 个} b := make([]BigStruct, 2) copy(b, a)   BCE 优化 边界检查\n总结  每个 Slice 都指向一个底层数组 每个 Slice 都保存了当前 Slice 的长度、底层数组的可用容量 因为 Slice 本身是结构体，带有 len 和 cap 字段，所以计算长度和容量都是 O(1) 因为 Slice 本身是结构体，所以通过函数传递时不会拷贝整个切片，属于引用传递 因为 Slice 本身是结构体，其中 array 字段为指针类型，所以在函数内对 Slice 的修改会影响到外部。 使用 append() 追加元素时有可能触发扩容，扩容后将生成新的切片 使用 copy() 复制 Slice 时，目的 Slice 原有的内容会被覆盖 创建切片时尽可能根据实际需要预分配容量，尽量避免追加过程中扩容操作，有利于提升性能 拷贝时需要判断实际拷贝的个数 谨慎使用多个切片操作同一个数组，以防读写冲突 ","wordCount":"731","inLanguage":"en","datePublished":"2021-09-14T15:07:18Z","dateModified":"2021-09-14T15:07:18Z","author":{"@type":"Person","name":"Boii"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.boii.xyz/posts/go/golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-2-slice-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},"publisher":{"@type":"Organization","name":"Mr.Boii","logo":{"@type":"ImageObject","url":"https://www.boii.xyz/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.boii.xyz/ accesskey=h title="Boii (Alt + H)"><img src=https://www.boii.xyz/apple-touch-icon.png alt=logo aria-label=logo height=35>Boii</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.boii.xyz/posts title="📚 文章"><span>📚 文章</span></a></li><li><a href=https://www.boii.xyz/archives/ title="⏱ 时间轴"><span>⏱ 时间轴</span></a></li><li><a href=https://www.boii.xyz/categories/ title="🧩 分类"><span>🧩 分类</span></a></li><li><a href=https://www.boii.xyz/tags/ title="🔖 标签"><span>🔖 标签</span></a></li><li><a href=https://www.boii.xyz/me title=me><span>me</span></a></li><li><a href=https://www.boii.xyz/search/ title="🔍 (Alt + /)" accesskey=/><span><i class="fa-solid fa-magnifying-glass"></i>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.boii.xyz/>Home</a>&nbsp;»&nbsp;<a href=https://www.boii.xyz/posts/>Posts</a></div><h1 class=post-title>Golang [深入理解] 2-slice 实现原理</h1><div class=post-meta><span title="2021-09-14 15:07:18 +0000 UTC">September 14, 2021</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Boii</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#slice-%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86 aria-label="slice 实现原理">slice 实现原理</a><ul><li><a href=#slice-%e7%bb%93%e6%9e%84 aria-label="slice 结构">slice 结构</a></li><li><a href=#-re-slice aria-label="[:] re-slice"><code>[:]</code> re-slice</a></li><li><a href=#%e6%89%a9%e5%ae%b9%e7%ad%96%e7%95%a5 aria-label=扩容策略>扩容策略</a></li><li><a href=#%e5%a4%8d%e5%88%b6%e9%97%ae%e9%a2%98 aria-label=复制问题>复制问题</a></li><li><a href=#%e6%af%94%e8%be%83%e9%97%ae%e9%a2%98 aria-label=比较问题>比较问题</a><ul><li><a href=#reflectdeepequal aria-label=reflect.DeepEqual()>reflect.DeepEqual()</a></li><li><a href=#%e6%89%8b%e5%86%99%e6%af%94%e8%be%83%e5%87%bd%e6%95%b0 aria-label=手写比较函数>手写比较函数</a></li></ul></li><li><a href=#%e6%80%a7%e8%83%bd%e9%99%b7%e9%98%b1 aria-label=性能陷阱>性能陷阱</a><ul><li><a href=#%e9%97%ae%e9%a2%98 aria-label=问题>问题</a></li><li><a href=#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95 aria-label=解决方法>解决方法</a></li></ul></li><li><a href=#bce-%e4%bc%98%e5%8c%96 aria-label="BCE 优化">BCE 优化</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></li></ul></div></details></div><div class=post-content><p>关于你可能知道的 slice</p><h1 id=slice-实现原理>slice 实现原理<a hidden class=anchor aria-hidden=true href=#slice-实现原理>#</a></h1><p>slice 是一段底层数组的描述。</p><blockquote><p>在 <a href=https://golang.org/ref/spec#Slice_types>golang spec</a> 是这么说的：</p><p>A slice is a descriptor for a contiguous segment of an <em>underlying array</em> and provides access to a numbered sequence of elements from that array. A slice type denotes the set of all slices of arrays of its element type. The number of elements is called the length of the slice and is never negative. The value of an uninitialized slice is <code>nil</code>.</p><p>切片是底层数组的连续段的描述符，提供对该数组中编号的元素序列的访问。切片类型表示其元素类型的数组的所有切片的集合。元素的数量称为切片的长度，并且永远不会为负。未初始化切片的值为<code>nil</code>。</p></blockquote><h2 id=slice-结构>slice 结构<a hidden class=anchor aria-hidden=true href=#slice-结构>#</a></h2><p>在源码包中 <code>src/runtime/slice.go:slice</code> 对 Slice 定义如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>slice</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>array</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
</span></span><span class=line><span class=cl>    <span class=nx>len</span>   <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>cap</span>   <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>通过这个结构体可以更清晰看出，切片是基于一个底层数组的（即 array 字段，其为一个指针，指向一个数组），并且带有两个字段：<code>长度 len</code> 和 <code>容量 cap</code>。</p><ul><li><p>容量，指的是切片的底层数组的元素最大个数。</p></li><li><p>长度，指的是切片的底层数组的元素目前个数。</p></li></ul><p><img loading=lazy src=https://blogpicure.oss-cn-shenzhen.aliyuncs.com/blog/illustration-pic/Go/IMG/IMG20210820132115.png alt></p><p>创建切片共有 3 种方式：</p><ol><li><p>通过字面量直接创建</p></li><li><p>基于已有 数组/slice 创建</p></li><li><p>通过 make() 创建</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>arr</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>8</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>s1</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>11</span><span class=p>,</span> <span class=mi>22</span><span class=p>,</span> <span class=mi>33</span><span class=p>}</span>		<span class=c1>// 1. 通过字面量直接创建
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>s2</span> <span class=o>:=</span> <span class=nx>arr</span><span class=p>[</span><span class=mi>2</span><span class=p>:</span><span class=mi>6</span><span class=p>]</span>				<span class=c1>// 2. 通过下标基于数组或切片创建
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>s3</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>)</span>	<span class=c1>// 3. 通过关键字 make 创建
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h2 id=-re-slice><code>[:]</code> re-slice<a hidden class=anchor aria-hidden=true href=#-re-slice>#</a></h2><p><code>[:]</code> 语法在 <a href=https://golang.org/ref/spec#Slice_types>golang spec</a> 称为 <code>Slice Expression</code>，也有称作 <code>re-slice</code>，是 golang 中很常用的一种获得切片的方法。但在使用时有一些地方需要注意。</p><p><code>[:]</code> 语法有两种基本形式：</p><ol><li><code>[low : high]</code></li><li><code>[low : high : max]</code></li></ol><p>第一种基本形式中，low 和 high 都<strong>允许使用字面常量或变量</strong>，都<strong>允许忽略不写</strong>，所以有以下几种形式：</p><ul><li><code>[2:5]</code>、<code>[2:]</code>、<code>[:5]</code>、<code>[:]</code></li></ul><p>第二种基本形式中，low、high、max 都<strong>允许使用字面常量或变量</strong>，但只允许 low 忽略不写，所以只有 2 种形式：</p><ul><li><code>[2:5:6]</code>、<code>[:5:6]</code></li></ul><p>在忽略不写的情况下：</p><ul><li><p>low的默认值为 <code>0</code>，即基础数组的第一个元素开始算起</p></li><li><p>high的默认值为 <code>len(基础数组/切片)</code>，即基础数组/切片的最后一个</p></li><li><p>max 的默认值为 <code>len(底层数组)</code>，即底层数组的最后一个元素（包含最后一个元素）</p></li></ul><p>举个栗子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>b</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>		    <span class=c1>// 切片 b，b 的基础数组和底层数组都是某个匿名数组
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>8</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>b</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;b:&#34;</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span>			<span class=c1>// b: [1 2 3 4 5 6 7 8] 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>b</span><span class=p>),</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>b</span><span class=p>))</span>		<span class=c1>// 8 10
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>j</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>[</span><span class=mi>2</span><span class=p>:</span><span class=mi>7</span><span class=p>]</span>						<span class=c1>// 切片 j，基础数组是 b，底层数组是某个匿名数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;j:&#34;</span><span class=p>,</span> <span class=nx>j</span><span class=p>)</span>			<span class=c1>// j: [3 4 5 6 7]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>j</span><span class=p>),</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>j</span><span class=p>))</span>		<span class=c1>// 5 8
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>k</span> <span class=o>:=</span> <span class=nx>j</span><span class=p>[</span><span class=mi>2</span><span class=p>:]</span>						<span class=c1>// 切片 k，基础数组是 j，底层数组是某个匿名数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;k:&#34;</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span>			<span class=c1>// k: [5 6 7]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>k</span><span class=p>),</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>k</span><span class=p>))</span>		<span class=c1>// 3 6
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>l</span> <span class=o>:=</span> <span class=nx>j</span><span class=p>[</span><span class=mi>1</span><span class=p>:</span><span class=mi>4</span><span class=p>:</span><span class=mi>6</span><span class=p>]</span>					<span class=c1>// 切片 l，基础数组是 j, 底层数组是某个匿名数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;l:&#34;</span><span class=p>,</span> <span class=nx>l</span><span class=p>)</span>			<span class=c1>// l: [4 5 6]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>l</span><span class=p>),</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>l</span><span class=p>))</span>		<span class=c1>// 3 5
</span></span></span></code></pre></td></tr></table></div></div><p><img loading=lazy src=https://blogpicure.oss-cn-shenzhen.aliyuncs.com/blog/illustration-pic/Go/IMG/image-20210820161028818.png alt></p><p>此外 low、high、max 的默认值也有一些要求，但概括起来就是：
$$
0 \le low \le len(s) \le high \le max \le cap(s)
$$
即：low 不能超过 high、high 不能超过 max、max 不能超过 cap(s)；反之，max 不能小于 high、high 不能小于 low、low 不能小于 0。</p><ul><li>low 的取值在 <code>[0, high]</code></li><li>high 的取值在 <code>[low, max]</code></li><li>max 的取值在 <code>[high, cap(s)]</code></li></ul><h2 id=扩容策略>扩容策略<a hidden class=anchor aria-hidden=true href=#扩容策略>#</a></h2><p>Slice 是基于底层数组的一种动态数组，相对于长度固定的数组，Slice 更灵活，且体现在：当底层数组容量不足时，Slice 会自动扩容。既然会自动扩容，那么就一定有扩容策略。</p><p>扩容关注点：容量
扩容时机：<code>len(s) == cap(s)</code>
扩容触发场景：<code>len(s) == cap(s)</code> 时继续使用 <code>append()</code> 追加元素
扩容策略：</p><ul><li><p>扩容后能容纳要追加的元素：</p><ul><li><code>if oldCap &lt; 1024 { newCap = oldCap * 2}</code></li><li><code>if oldCap >= 1024 { newCap = oldCap * 1.25}</code></li></ul></li><li><p>扩容后不能容纳要追加的元素：</p><ul><li>newCap = 预估的容量</li></ul></li></ul><h2 id=复制问题>复制问题<a hidden class=anchor aria-hidden=true href=#复制问题>#</a></h2><p>在复制 Slice 时，如果仅仅使用等于号 <code>s1 = s2</code>，这样只是拷贝了一个地址。</p><p>要实现完全的复制，需要使用 golang 提供的 <code>copy()</code> 函数。</p><p><img loading=lazy src=https://blogpicure.oss-cn-shenzhen.aliyuncs.com/blog/illustration-pic/Go/IMG/IMG20210820183847.png alt></p><p>使用 <code>copy()</code> 拷贝时，会将源切片的元素逐个拷贝到目的切片指向的数组中，拷贝的数量取两个切片长度的最小值。例如上图中，s1 长度为 8，s2 长度为 5，则共拷贝 5 个元素，即 <code>copy()</code> 不会发生扩容。</p><blockquote><p>注意，<code>copy()</code> 是覆盖行为。原有数据将会被覆盖。</p></blockquote><h2 id=比较问题>比较问题<a hidden class=anchor aria-hidden=true href=#比较问题>#</a></h2><p>在 Slice 的比较中，因为 Slice 不是<code>可比较类型</code>，直接用恒等号 <code>==</code> 比较是无法通过编译的，如果取地址比较也是行不通的，因为 Slice 是结构体，取地址比较的是两个结构体，自然是 false。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>s1</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>s2</span> <span class=o>:=</span> <span class=nx>s1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>s1</span> <span class=o>==</span> <span class=nx>s2</span> 	<span class=c1>// 无法通过编译
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&amp;</span><span class=nx>s1</span> <span class=o>==</span> <span class=o>&amp;</span><span class=nx>s2</span>	<span class=c1>// false
</span></span></span></code></pre></td></tr></table></div></div><p>所以，Slice 比较肯定不是那么肤浅的。</p><p>Slice 的比较在网上盛传的有两种：<code>使用 reflect.DeepEqual()</code> 和 <code>手写比较函数</code>。</p><p>因为 <code>reflect.DeepEqual()</code> 效率较低，所以才有手写比较函数。下面简单展示下 <code>DeepEqual()</code>，然后讲解手写比较函数。</p><h3 id=reflectdeepequal>reflect.DeepEqual()<a hidden class=anchor aria-hidden=true href=#reflectdeepequal>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>compare</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=p>[]</span><span class=kt>rune</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>DeepEqual</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=手写比较函数>手写比较函数<a hidden class=anchor aria-hidden=true href=#手写比较函数>#</a></h3><p>其实比较两个 Slice 的思路也简单：</p><ol><li>先看看长度是否相等；</li><li>再看看是不是<strong>都为 nil</strong> 或 <strong>都不为 nil</strong>，是就 true，否就下一步（都为 nil 也是相等）；</li><li>遍历随便哪一个，在遍历中两两比较，一旦不等就返回 false（如果是用在安全方面要预防计时攻击）</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>compare</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=p>[]</span><span class=kt>rune</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span> <span class=o>!=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span> <span class=p>{</span>	<span class=c1>// 比较长度，长度都不同肯定不相等
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>a</span><span class=o>==</span><span class=kc>nil</span><span class=p>)</span> <span class=o>!=</span> <span class=p>(</span><span class=nx>b</span><span class=o>==</span><span class=kc>nil</span><span class=p>)</span> <span class=p>{</span>	<span class=c1>// 看看是否都为 nil 或 都不为 nil
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>a</span> <span class=p>{</span>			<span class=c1>// 遍历，逐个比较
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>!=</span> <span class=nx>b</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在遍历之前还可以加入 BCE 优化，不过第一步比较长度时，编译器已经获取了 a 和 b 的长度了，在遍历时应该不会再次检查边界了。</p><h2 id=性能陷阱>性能陷阱<a hidden class=anchor aria-hidden=true href=#性能陷阱>#</a></h2><h3 id=问题>问题<a hidden class=anchor aria-hidden=true href=#问题>#</a></h3><p>golang 具有垃圾回收功能，而一个切片的底层数组，有可能被多个切片引用（即有多个 Slice 指向同一个底层数组），例如 <code>[:] re-slice</code> 就是对底层数组的再一次引用。</p><p>这样的机制就有可能带来一个问题：</p><blockquote><p>有一个结构体切片 a 有100 个元素，每个结构体的大小是 1 MB，也就是 a 的大小是 100 MB；</p><p>然后另一个切片 b 引用了 切片 a 最后两个元素，即 <code>b := a[len(a)-2:]</code>。当 a 使用完后 GC 是没法回收这个 100 MB 的底层数组的，因为还有 b 在引用着。</p><p>于是就会出现这种 用到只有 2 MB，但却无法回收剩下 98 MB 的空间。这就是我想说的性能陷阱。</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>BigStruct</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=o>:=</span> <span class=p>[]</span><span class=nx>BigStruct</span> <span class=p>{</span> <span class=o>...</span> <span class=mi>100</span> <span class=nx>个</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>b</span> <span class=o>:=</span> <span class=nx>a</span><span class=p>[</span><span class=nb>len</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span><span class=o>-</span><span class=mi>2</span><span class=p>:]</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=解决方法>解决方法<a hidden class=anchor aria-hidden=true href=#解决方法>#</a></h3><p>比较推荐的做法是，采用 <code>copy()</code> 的方法替代 <code>re-slice</code>，因为 <code>copy(b, a)</code> 后 a 和 b 引用的不是同一个底层数组。这样 a 使用完以后，底层数组那 100 MB 的空间也能被 GC 回收。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>BigStruct</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=o>:=</span> <span class=p>[]</span><span class=nx>BigStruct</span> <span class=p>{</span> <span class=o>...</span> <span class=mi>100</span> <span class=nx>个</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>b</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=nx>BigStruct</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>copy</span><span class=p>(</span><span class=nx>b</span><span class=p>,</span> <span class=nx>a</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=bce-优化>BCE 优化<a hidden class=anchor aria-hidden=true href=#bce-优化>#</a></h2><p>边界检查</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><ol><li>每个 Slice 都指向一个底层数组</li><li>每个 Slice 都保存了当前 Slice 的长度、底层数组的可用容量</li><li>因为 Slice 本身是结构体，带有 <code>len</code> 和 <code>cap</code> 字段，所以计算长度和容量都是 <code>O(1)</code></li><li>因为 Slice 本身是结构体，所以通过函数传递时不会拷贝整个切片，属于引用传递</li><li>因为 Slice 本身是结构体，其中 array 字段为指针类型，所以在函数内对 Slice 的修改会影响到外部。</li><li>使用 append() 追加元素时有可能触发扩容，扩容后将生成新的切片</li><li>使用 copy() 复制 Slice 时，目的 Slice 原有的内容会被覆盖</li><li>创建切片时尽可能根据实际需要预分配容量，尽量避免追加过程中扩容操作，有利于提升性能</li><li>拷贝时需要判断实际拷贝的个数</li><li>谨慎使用多个切片操作同一个数组，以防读写冲突</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.boii.xyz/tags/golang/>Golang</a></li><li><a href=https://www.boii.xyz/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/>底层原理</a></li></ul><nav class=paginav><a class=prev href=https://www.boii.xyz/posts/go/golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-4-string-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/><span class=title>« Prev Page</span><br><span>Golang [深入理解] 4-string 实现原理</span></a>
<a class=next href=https://www.boii.xyz/posts/go/golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-1-for-range/><span class=title>Next Page »</span><br><span>Golang [深入理解] 1-for & range</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Golang [深入理解] 2-slice 实现原理 on twitter" href="https://twitter.com/intent/tweet/?text=Golang%20%5b%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%5d%202-slice%20%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86&url=https%3a%2f%2fwww.boii.xyz%2fposts%2fgo%2fgolang-%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3-2-slice-%25E5%25AE%259E%25E7%258E%25B0%25E5%258E%259F%25E7%2590%2586%2f&hashtags=Golang%2c%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Golang [深入理解] 2-slice 实现原理 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.boii.xyz%2fposts%2fgo%2fgolang-%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3-2-slice-%25E5%25AE%259E%25E7%258E%25B0%25E5%258E%259F%25E7%2590%2586%2f&title=Golang%20%5b%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%5d%202-slice%20%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86&summary=Golang%20%5b%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%5d%202-slice%20%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86&source=https%3a%2f%2fwww.boii.xyz%2fposts%2fgo%2fgolang-%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3-2-slice-%25E5%25AE%259E%25E7%258E%25B0%25E5%258E%259F%25E7%2590%2586%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Golang [深入理解] 2-slice 实现原理 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.boii.xyz%2fposts%2fgo%2fgolang-%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3-2-slice-%25E5%25AE%259E%25E7%258E%25B0%25E5%258E%259F%25E7%2590%2586%2f&title=Golang%20%5b%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%5d%202-slice%20%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Golang [深入理解] 2-slice 实现原理 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.boii.xyz%2fposts%2fgo%2fgolang-%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3-2-slice-%25E5%25AE%259E%25E7%258E%25B0%25E5%258E%259F%25E7%2590%2586%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Golang [深入理解] 2-slice 实现原理 on whatsapp" href="https://api.whatsapp.com/send?text=Golang%20%5b%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%5d%202-slice%20%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%20-%20https%3a%2f%2fwww.boii.xyz%2fposts%2fgo%2fgolang-%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3-2-slice-%25E5%25AE%259E%25E7%258E%25B0%25E5%258E%259F%25E7%2590%2586%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Golang [深入理解] 2-slice 实现原理 on telegram" href="https://telegram.me/share/url?text=Golang%20%5b%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%5d%202-slice%20%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86&url=https%3a%2f%2fwww.boii.xyz%2fposts%2fgo%2fgolang-%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3-2-slice-%25E5%25AE%259E%25E7%258E%25B0%25E5%258E%259F%25E7%2590%2586%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.boii.xyz/>Mr.Boii</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>