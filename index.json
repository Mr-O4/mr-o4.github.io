[{"content":"使用链表进行批量执行操作 最近在项目中学到一种挺有意思的编程技巧。这里记录一下\n场景 在创建一个抽奖的时候，前端会携带许许多多的数据过来，这些数据有抽奖本身的、抽奖配置的、奖项信息的、参与方式的、助力方式的、创建人信息的、创建人联系方式的等等。\n这里面每一种都需要校验，有些条件还是互斥的，有些条件的判定依赖与其他条件的结果，所以无法只靠结构体 tag 去使用 gValid 库校验，并且在验证的时候还需要考虑验证的顺序。\n解决方案 通过阅读项目的源码以后，发现是实现了一个链表，这个链表有 3 个方法：\nAddToChainHead( Handler ): 添加结点到链表的表头 AddToChainTail( Handler ): 添加结点到链表的表尾 Iterator( Param Structure ): 遍历链表 结点的数据域是一个 Handler，这个结构体必须实现 Handler 接口，在遍历链表时需要调用其校验方法。\nHandler 接口中只有一个 Handle( Param Structure ) error 校验方法。\n在创建抽奖的时候，初始化这个链表，将校验器逐个加入链表，最后遍历链表，在链表中调用结点的中的校验器的 Handle 校验方法执行。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package chain // Handler 接口，参数放在 req 这个结构体中 type Handler interface { Handle(*Req) error } type node struct { Data Handler // 数据域 Next *Node // 指针域 } type chain struct { HeadNode *Node // 头结点 TailNode *Node // 尾结点 } // 创建链表 type NewChain() *chain { return \u0026amp;chain{} } // 添加结点到链表头部 func (c *chain) AddToHead(h Handler) { node := \u0026amp;node{ Data: h, Next: nil, } if c.HeadNode == nil { c.HeadNode = node c.TailNode = node return } node.Next = c.HeadNode c.HeadNode = node } // 添加链表到尾部 func (c *chain) AddToTail(h Handler) { node := \u0026amp;node{ Data: h, Next: nil, } if c.HeadNode == nil || c.TailNode == nil { c.HeadNode = node c.TailNode = node return } c.TailNode.Next = node } func (c *chain) Iterator(req *Req) error { curr := c.HeadNode for curr != nil { // 遍历链表 err := curr.Data.Handle(req); // 执行 Handle 方法 if err != nil { return err } curr = curr.Next } return nil } 这样链表的定义好了。使用者在使用的时候，需要实现 Handle 方法、添加到链表、调用 Iterator 即可。\n下面创建一个结构体去实现 Handle 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package create import ( \u0026#34;errors\u0026#34; \u0026#34;time\u0026#34; \u0026#34;verify\u0026#34; ) // 实例化一个验证器 var InfoVerifier = \u0026amp;infoVerifier{} type infoVerfier struct {} // 实现 Handle 方法 func (l *infoVerifier) Handle(req *Req) error { if req.Info.CreateTime \u0026lt; time.Now().Unix() { return errors.New(\u0026#34;创建时间错误\u0026#34;) } if req.Info.Uid \u0026lt; 1 { return errors.New(\u0026#34;创建人id错误\u0026#34;) } if req.Info.ManagerId \u0026lt; 1 { return errors.New(\u0026#34;管理员id错误\u0026#34;) } if !verify.IsBadMan(req.Info.Uid) { return errors.New(\u0026#34;请稍后再试\u0026#34;) } return nil } 在创建抽奖的时候，初始化链表、添加到链表、调用 Iterator\n1 2 3 4 5 6 7 8 9 10 11 package create func CreateLottery(req *Req) { c := chain.NewChain() // 初始化链表 c.AddToHead(InfoVerifier) // 添加验证器到链表 err := c.Iterator(req) // 遍历所有验证器 if err != nil { response.JsonExitError(400, error) } ... } 总结 这样的方法实现了非常好的扩展性。编写链表结构的人不需要考虑后面使用者的参数多么复杂，反正都统一放在 Param Structure 中，只要求使用者一定要实现 Handle 方法。然后在遍历方法 Iterator 中遍历链表并调用 Handle 就行。\n使用者只需要创建一个结构体，实现 Handle 方法使结构体成为一个校验器，然后使用 AddToXXX 加入链表，调用 Iterator 方法即可。\n","permalink":"https://www.boii.xyz/posts/skill/%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8%E5%A4%84%E7%90%86%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C/","summary":"使用链表进行批量执行操作 最近在项目中学到一种挺有意思的编程技巧。这里记录一下\n场景 在创建一个抽奖的时候，前端会携带许许多多的数据过来，这些数据有抽奖本身的、抽奖配置的、奖项信息的、参与方式的、助力方式的、创建人信息的、创建人联系方式的等等。\n这里面每一种都需要校验，有些条件还是互斥的，有些条件的判定依赖与其他条件的结果，所以无法只靠结构体 tag 去使用 gValid 库校验，并且在验证的时候还需要考虑验证的顺序。\n解决方案 通过阅读项目的源码以后，发现是实现了一个链表，这个链表有 3 个方法：\nAddToChainHead( Handler ): 添加结点到链表的表头 AddToChainTail( Handler ): 添加结点到链表的表尾 Iterator( Param Structure ): 遍历链表 结点的数据域是一个 Handler，这个结构体必须实现 Handler 接口，在遍历链表时需要调用其校验方法。\nHandler 接口中只有一个 Handle( Param Structure ) error 校验方法。\n在创建抽奖的时候，初始化这个链表，将校验器逐个加入链表，最后遍历链表，在链表中调用结点的中的校验器的 Handle 校验方法执行。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package chain // Handler 接口，参数放在 req 这个结构体中 type Handler interface { Handle(*Req) error } type node struct { Data Handler // 数据域 Next *Node // 指针域 } type chain struct { HeadNode *Node // 头结点 TailNode *Node // 尾结点 } // 创建链表 type NewChain() *chain { return \u0026amp;chain{} } // 添加结点到链表头部 func (c *chain) AddToHead(h Handler) { node := \u0026amp;node{ Data: h, Next: nil, } if c.","title":"使用链表进行批量执行操作"},{"content":"Hello Hugo! Hello Hugo.\n","permalink":"https://www.boii.xyz/hello/","summary":"Hello Hugo! Hello Hugo.","title":"Hello"},{"content":"安全地执行不安全的函数\n场景 在日常开发中，可能会遇到一种场景：\n开启一个事务去执行某个任务，这个任务的其中一个子任务有可能失败，但是你又不想这个失败影响整个事务，只想打印一下日志。这种场景就可以用上安全函数 SaveFunc。\n举个栗子，在修改简历时，我希望能发送一条通知给关注了这份简历的人，而发送通知有可能失败，甚至引发 panic。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func UpdateResume(rid Resume, data ResumeData) bool { if data == nil { return false } // 启动一个事务更新简历 err := newTransaction(func(){ rid.SetData(data) SendNotice() // 可能因这个函数 panic 而导致整个 UpdateResume 事务失败 }) if err != nil { log.Printf(\u0026#34;transaction fail. Cause: \u0026#34;, err) return false } log.Printf(\u0026#34;transaction success.\u0026#34;) return true } func SendNotice() { if Search(ctx) == nil { panic(\u0026#34;can not get resume.\u0026#34;) } notice := new(Notice) if !notice.Send() { log.Println(\u0026#34;sent notice fail.\u0026#34;) } log.Println(\u0026#34;sent notice success.\u0026#34;) } 在发送通知的函数 SendNotice() 如果 Search 不到资源则会直接 panic，这样会影响到整个事务失败回滚，从而 UpdateResume() 也失败。\n这样显然不合理，总不能因为你发送通知失败就不让我更新简历吧？所以对于这样的场景，我们要对 SendNotice() 做安全处理。\nSaveFunc 那么就轮到主角 SaveFunc() 登场了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 import \u0026#34;github.com/pkg/errors\u0026#34; type UnsaveFunc func () error func SaveFunc(fn UnsaveFunc) (err error) { defer func() { if r := recover(); r != nil { err = errors.Wrap(r) } }() return fn() } SaveFunc() 其实非常简单，函数名你可以换成你自己喜欢的名字。\n它仅仅做一件非常普通的事情，把不安全的函数 fn 传递进来，在这里面执行，即使 fn 发生 panic 也会被 defer 中捕获，然后 recover，使得程序不会被中断。\n这样加了一层用于兜底，就不怕不安全的函数会影响外层事务的执行了。\n具体使用如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 type UnsaveFunc func () error func SaveFunc(fn UnsaveFunc) (err error) { defer func() { if r := recover(); r != nil { err = errors.Wrap(r) } }() return fn() } func UpdateResume(rid Resume, data ResumeData) bool { if data == nil { return false } // 启动一个事务更新简历 err := newTransaction(func(){ rid.SetData(data) if e := SaveFunc(SendNotice()); e != nil { log.Println(e) } }) if err != nil { log.Printf(\u0026#34;transaction fail. Cause: \u0026#34;, err) return false } log.Printf(\u0026#34;transaction success.\u0026#34;) return true } // 给不安全函数增加一个返回值 error 以符合 UnsaveFunc 定义 func SendNotice() error { if Search(ctx) == nil { panic(\u0026#34;can not get context.\u0026#34;) } notice := new(Notice) if !notice.Send() { return errors.New(\u0026#34;sent notice fail.\u0026#34;) } return nil } 上面的代码将原本的例子中不安全的函数 SendNotice() 增加了一个返回值 error 以符合 UnsaveFunc 的定义。\n然后在调用的地方 UpdateResume() 用 SaveFunc(SendNotice) 将函数传递进去。这样即使 SendNotice() 发生 panic 也会被 SaveFunc 处理掉，不会影响 UpdateResume()。\n但这样有三个不好的地方：\n它破坏了原本的 SendNotice()，是一种侵入性的改造； 它限定了不安全函数 SendNotice() 不能携带参数； 它限定了不安全函数 SendNotice() 不能返回结果。 这对这几个问题，我们可以用闭包来解决。\n使用闭包替代侵入性改造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 func SendNotice() { if Search(ctx) == nil { panic(\u0026#34;can not get context.\u0026#34;) } notice := new(Notice) if !notice.Send() { log.Println(\u0026#34;sent notice fail.\u0026#34;) } log.Println(\u0026#34;sent notice success.\u0026#34;) } func ClosureSendNotice() UnsaveFunc { return func () error { SendNotice() return nil } } func UpdateResume(rid Resume, data ResumeData) bool { if data == nil { return false } // 启动一个事务更新简历 err := newTransaction(func(){ rid.SetData(data) if e := SaveFunc(ClosureSendNotice()); e != nil { log.Println(e) } }) if err != nil { log.Printf(\u0026#34;transaction fail. Cause: \u0026#34;, err) return false } log.Printf(\u0026#34;transaction success.\u0026#34;) return true } 我们使用一个闭包返回一个 UnsaveFunc，将不安全的函数 SendNotice() 放在里面，这样就不会造成侵入性改造，也不需要更改 UnsaveFunc 的定义了。\n这样就解决第一个问题。\n使用闭包解决参数问题 为了说明这个问题，我们先让 SendNotice() 需要接收一个参数。\n1 2 3 4 5 6 7 8 9 10 11 12 func SendNotice(rid Resume) { if Search(ctx) == nil { panic(\u0026#34;can not get context.\u0026#34;) } notice := new(Notice) notice.rid = rid if !notice.Send() { log.Println(\u0026#34;sent notice fail.\u0026#34;) } log.Println(\u0026#34;sent notice success.\u0026#34;) } 这里其实也很简单\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func SendNotice(rid Resume) { if Search(ctx) == nil { panic(\u0026#34;can not get context.\u0026#34;) } notice := new(Notice) notice.rid = rid if !notice.Send() { log.Println(\u0026#34;sent notice fail.\u0026#34;) } log.Println(\u0026#34;sent notice success.\u0026#34;) } func ClosureSendNotice(rid Resume) UnsaveFunc { return func () error { SendNotice(rid) return nil } } func UpdateResume(rid Resume, data ResumeData) bool { if data == nil { return false } // 启动一个事务更新简历 err := newTransaction(func(){ rid.SetData(data) if e := SaveFunc(ClosureSendNotice(rid)); e != nil { log.Println(e) } }) if err != nil { log.Printf(\u0026#34;transaction fail. Cause: \u0026#34;, err) return false } log.Printf(\u0026#34;transaction success.\u0026#34;) return true } 这里其实也很简单，只需要给闭包函数写上 SendNotice() 需要的参数，然后闭包中的 SendNotice() 直接调用就行。\n参数会栈逃逸到堆上，这点不需要担心作用域的问题。\n使用闭包解决返回值问题 这个问题好像跟最初的场景相悖了。\n如果不安全函数 SendNotice() 有返回值，那么在 UpdateResume() 中的事务有两种情况：\n事务中 不需要 用到 SendNotice() 的返回值 事务中 需要 用到 SendNotice() 的返回值 1 2 3 4 5 6 7 8 9 10 11 12 func UpdateResume(rid Resume, data ResumeData) bool { ...... err := newTransaction(func(){ rid.SetData(data) if e := SaveFunc(ClosureSendNotice(rid)); err != nil { log.Println(e) } }) ...... } 如果不需要用到，那么就不需要考虑返回值的事情了。\n如果需要用到，说明事务中依赖 SendNotice() 的返回值，这样的话，SendNotice() 失败不就意味着整个事务失败了吗。那还费劲心机搞个 SaveFunc 干嘛？\n所以返回值这点，可以不处理。\n照目前这个场景是这种结论，我还没想出其他场景。\n如果非要处理返回值这个问题也不是没有办法，但是要连同 SaveFunc 一起改造，也很不正确。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 type UnsaveFunc func () (interface{}, error) func SaveFunc(fn UnsaveFunc) (arg interface{}, err error) { defer func() { if r := recover(); r != nil { err = errors.Wrap(r) } }() return fn() } func SendNotice() bool { if Search(ctx) == nil { panic(\u0026#34;can not get resume.\u0026#34;) } notice := new(Notice) if !notice.Send() { log.Println(\u0026#34;sent notice fail.\u0026#34;) return false } log.Println(\u0026#34;sent notice success.\u0026#34;) return true } func ClosureSendNotice() UnsaveFunc { return func () (interface{}, error) { res := SendNotice() if !res { return res, errors.New(\u0026#34;fail.\u0026#34;) } return res, nil } } func UpdateResume(rid Resume, data ResumeData) bool { if data == nil { return false } // 启动一个事务更新简历 err := newTransaction(func(){ rid.SetData(data) res, e := SaveFunc(ClosureSendNotice(rid)) if e != nil { log.Println(e) } log.Println(res) }) if err != nil { log.Printf(\u0026#34;transaction fail. Cause: \u0026#34;, err) return false } log.Printf(\u0026#34;transaction success.\u0026#34;) return true } ","permalink":"https://www.boii.xyz/posts/go/golang-%E6%8A%80%E6%9C%AF%E5%90%AF%E5%8F%91-savefunc/","summary":"\u003cp\u003e安全地执行不安全的函数\u003c/p\u003e","title":"Golang [技术启发] 安全函数 SaveFunc"},{"content":"commit message 不要乱写\n提交信息规范 我们对项目的 git 提交信息格式进行统一格式约定，这将提升项目日志的可读性。\n共包含三个部分：\nHeader（必须） Body（可省略） Footer（可省略） 1 2 3 4 5 \u0026lt;type\u0026gt;[scope]: \u0026lt;subject\u0026gt; // 空一行 \u0026lt;body\u0026gt; // 空一行 \u0026lt;footer\u0026gt; 其中，Header 是必需的，Body 和 Footer 可以省略(默认忽略)，一般我们在 git commit 提交时指定的 -m 参数，就相当于默认指定 Header。\n不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。\nHeader Header 部分只有一行，包括三个字段：type（必需）、scope（可选）和 subject（必需），可以用如下格式表示它的结构：\n1 \u0026lt;type\u0026gt;[scope]: \u0026lt;subject\u0026gt; type 用于表述此次提交信息的意义，首写字母大写，包括但不局限于如下类型：\n功能相关 Feat：新功能（feature） Fix：Bug 修复 Test：增加测试 文档相关 Docs：文档内容变化（documentation） Style：格式（不影响代码运行的变动） 优化相关 Perf：性能优化 Refactor：重构（即不是新增功能，也不是修改 Bug 的代码变动） 版本相关 Revert：代码回滚 Release：版本发布 构建相关 Chore：构建过程或辅助工具的变动 Build：基础构建系统或依赖库的变化 Ci：CI 构建系统及其脚本变化 scope scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视仓库不同而不同\nsubject subject是 commit 目的的简短描述，用于简要描述修改变更的内容，不超过50个字符。如 Update code highlighting in readme.md。\n句尾不要使用符号。 使用第一人称、现在时、祈使句语气。 以动词开头，比如change，而不是changed或changes 第一个字母小写 Body Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。\nMore detailed explanatory text, if necessary. Wrap it to about 72 characters or so. Further paragraphs come after blank lines.- Bullet points are okay, too- Use a hanging indent\n有两个注意点。\n使用第一人称现在时，比如使用change而不是changed或changes。 应该说明代码变动的动机，以及与以前行为的对比。 Footer Footer 部分只用于两种情况。\n1、不兼容变动 如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: { myAttr: \u0026#39;attribute\u0026#39;, } After: scope: { myAttr: \u0026#39;@\u0026#39;, } The removed `inject` wasn\u0026#39;t generaly useful for directives so there should be no code using it. 2、关闭 Issue 如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。\nCloses #234\n也可以一次关闭多个 issue 。\nCloses #123, #245, #992\nRevert 还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。\nrevert: feat(pencil): add \u0026lsquo;graphiteWidth\u0026rsquo; option\nThis reverts commit 667ecc1654a317a13331b17617d973392f415f02.\nBody部分的格式是固定的，必须写成This reverts commit .，其中的hash是被撤销 commit 的 SHA 标识符。\n如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。\n标签规范 为了方便维护人员和用户能够快速找到他们想要查看的问题，我们使用“标签”功能对 Pull requests 和 Issues 进行分类。\n如果您不确定某个标签的含义，或者不知道将哪些标签应用于 PR 或 issue，千万别错过这个。\nIssue 的标签：\n类型 Bug: 检测到需要进行确认的 Bug Feature Request: 提出了新功能请求的 Issue Question: 提出疑问的 Issue Meta: 表明使用条款变更的 Issue Support: 被标记为支持请求的 Issue Polls: 发起投票的 Issue 结果 Duplicate: 重复提及的 Issue Irrelevant: 与 NexT 主题无关的 Issue Expected Behavior: 与预期行为相符的 Issue Need More Info: 需要更多信息的 Issue Need Verify: 需要开发人员或用户确认 Bug 或解决方法的 Issue Verified: 已经被确认的 Issue Can't Reproduce: 无法复现的 Issue Solved: 已经解决的 Issue Stale: 由于长期无人回应被封存的 Issue Pull Request 的标签：\nBreaking Change: 产生重大变动的 Pull Request Bug Fix: 修复相关 Bug 的 Pull Request New Feature: 添加了新功能的 Pull Request Feature: 为现有功能提供选项或加成的 Pull Request i18n: 更新了翻译的 Pull Request Work in Progress: 仍在进行改动和完善的 Pull Request Skip Release: 无需在 Release Note 中展现的 Pull Request 两者兼有：\nRoadmap: 与 NexT 主题发展相关的 Issue 或者 Pull Request Help Wanted: 需要帮助的 Issue 或者 Pull Request Discussion: 需要进行讨论的 Issue 或者 Pull Request Improvement: 需要改进的 Issue 或者改进了 NexT 主题的 Pull Request Performance: 提出性能问题的 Issue 或者提高了 NexT 主题性能的 Pull Request Hexo: 与 Hexo 和 Hexo 插件相关的 Issue 或者 Pull Request Template Engine: 与模版引擎相关的 Issue 或者 Pull Request CSS: 与 NexT 主题 CSS 文件相关的 Issue 或者 Pull Request Fonts: 与 NexT 主题字体相关的 Issue 或者 Pull Request PJAX: 与 PJAX 相关的 Issue 或者 Pull Request 3rd Party Plugin: 与第三方插件和服务相关的 Issue 或者 Pull Request Docs: 与文档说明相关的 Issue 或者 Pull Request Configurations: 与 NexT 主题设置相关的 Issue 或者 Pull Request ","permalink":"https://www.boii.xyz/posts/git/git-commit-message-%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97/","summary":"\u003cp\u003ecommit message 不要乱写\u003c/p\u003e","title":"Git-commit message 编写指南"},{"content":"虽然不推荐，但免不了要用到。\n实现抽象类 最近在仿写一个程序的代码，那个程序使用的是「TypeScript」，一种面向对象的、动态的、强类型的语言，而 Golang 是静态的、强类型的、并且没有明确表明是面向对象的一种语言。\nGolang 官方对于 Go 是否是面向对象语言的回答是：Yes and no。官方的态度就是我没说我是面向对象，但是你可以按照面向对象的范式去编写程序。\n基本上面向对象的“封装、继承、多态、抽象”，在 Go 语言层面都有一定的实现，例如：\n使用 struct 进行封装 在 struct 中使用匿名字段进行继承和多态 使用接口实现抽象 但是对于其他一些概念上如：静态、抽象类等则没有直接的语法和机制进行实现。但是还是有一些方法可以实现，今天只讨论怎么实现，不讨论这样实现是否违背 Golang 的设计哲学。编程的范式有很多种，最常见的无非面向过程、面向对象、函数式这三种，三者各有优劣，咱们不作无畏之争。\n为什么需要抽象类：抽象类本质 类 在面向对象中，将所有的事物按照其属性和行为分门别类，也就是面向对象的基本单位之一 —— 类 Class。\n例如学校里的同学都是学生， 他们有共同的属性是学号、班级、姓名、年龄， 他们有共同的行为是上课、实训、吃饭、睡觉， 所以可以将属性和行为作为基本元素，组成一个 学生类。\n再例如学校里的大人都是教职工， 他们有共同的属性是工号、科室、姓名、年龄， 他们有共同的行为是授课、带实训、吃饭、睡觉， 所以可以将属性和行为作为基本元素，组成一个 教师类。\n继承 多个类之间的属性、行为会有重复，将这些重复提取出来，提升一层，就成了父类，原本的那些类就称作子类，它们去继承这个父类，就能继续拥有这些重复的属性和行为。这就是继承 extends\n例如学生类和教师类都有重复属性：姓名、年龄；重复行为：吃饭、睡觉。\n学生和老师共同点是他们都是人，所以将姓名、年龄、吃饭、睡觉提取出来，组成一个新的类 —— 人类。\n然后学生类和教师类继承人类，就能拥有这四个重复的属性和行为。\n抽象 有时候重复的行为虽然做的事情是一样的，但是具体怎么做是不同的。\n那么这时这个行为就是一种抽象的行为。那你在定义这个行为的时候就不能将内容写死。于是就需要声明这个行为是一种抽象行为，给它定义为一个抽象方法。\n例如老师的授课行为，都是授课，但是英语老师的授课方式是听说读写、化学老师的授课方式是燃烧爆炸、语文老师的授课方式是之乎者也。\n所以我们要把授课声明为一个抽象方法。\n你也许会觉得我照样可以写死啊，然后语文老师类继承教师类，然后重写授课这个方法，化学老师类继承教师类，然后也重写授课这个方法，这样也行啊。\n是的，这样的确可以，不过教师类中写死的那部分就成了一种“默认行为”。当子类重写的时候，执行重写的行为，没有重写则执行这种“默认行为”。\n不过，当你站在顶层设计的时候，还要为一种抽象行为设置默认，会不会优点顾此失彼哦？\n其实当你站在上帝视角设计时，你应该不太愿意陷入细节里，而更愿意把握好大局。我设计一个教师类，我指定它有这些行为，具体怎么实现，谁继承谁负责。就像架构师在设计系统时关注这里用什么技术、那里用什么结构才能让系统更稳定、性能更好，而不是设计到一半陷入到“这个判断这样写是否效率更高”的细节里。所以当有这些抽象行为时，将他们定义为抽象方法更好。\n而从另一个角度来说，任何人，只要他有具体的授课内容，即使他没有工号、没有科室，但他也是教书育人、为人师表不是么？例如孔子，他没有工号、没有科室，但是他教书育人，弟子三千圣贤七十二，不也被尊为至圣先师嘛。\n所以这也是一个稍微哲学的问题，它从更加开放的角度去评判，一个人是否是老师，不是看他有没有教师资格证，有没有工号，有没有科室，只要他实现具体的授课方式，他就是一个老师。\n到这里我想你应该能理解 Golang 中，一个结构体 S 只要实现了接口 I 中的所有方法，就表示 S 实现了 I，A 是一个 I 类型。\n一个司机结构体 Driver，只要实现了教师接口 Teacher 中的授课方法 teach()， 那么 Driver 就是一个 Teacher，他就是一个教练， Driver 就是一个 Teacher 类型。\n接口 所以在设计中，我们总会倾向于去定义一些规则，也就是这些抽象行为，然后让实现者自己来实现。这就是接口——interface。\n在 Golang 和 面向对象的典型代表 Java 中都有对接口的支持。在 Java 中一个类实现某个接口时要显式的使用 implements 关键字，在 Golang 中则是某个接口体具有接口中的所有方法的具体实现即可。一种是侵入式的，一种是非侵入式的。\n抽象类 有时候我就是想在设计某个类型的时候，它有的行为是抽象的，我不指定它的默认行为；而有的行为我就给它个默认行为。\n那么这种时候可以使用抽象类。接口是绝对抽象的，类是绝对具象的，而抽象类则是在绝对抽象和绝对具象之间。\n就像第一句话说的，有些行为我就想给它个默认行为，有些则不想。而接口不会有具体实现，类必须有具体实现，而抽象类则是可以有具体实现，也可以没有具体实现。\n例如教师类有授课、打卡上班两种行为。授课方式多种多样，打卡上班方式也多种多样。那我现在只声明授课是一种抽象行为，谁继承谁自行实现，再给打卡上班指定一种默认行为方式 —— 指纹打卡。\n如此当 语文老师类 继承了 教师类 以后，必须实现授课的具体行为，也就是实现抽象方法；至于打卡上班行为，可以重写个人脸识别打卡，也可以不重写，那就默认指纹打卡。\n所以抽象类更像一种中庸之道。取绝对抽象和绝对具象的折中，增加了程序的灵活性。\n小结 在设计时，将一类事物的共有的属性和行为提取出来，定义为一类。\n将多个类中重复的部分剥离出来，定义为父类，让子类去继承。\n为一类事物定性时可以不关注具体其具体行为，只关注其有没有这个行为即可。这些行为称为抽象行为，即抽象方法。将这些抽象行为封装起来，就是一个接口。\n为一类事物定性时，想要给一些抽象行为设置默认行为，就改用抽象类。\nGolang 实现抽象类 Golang 中的接口是非侵入式的，接口中的方法是没有具体实现的，抽象类是可以有具体实现的，于是将接口和结构体结合起来，实现抽象类。\n抽象类分两种情况：具有默认行为的抽象方法使用到 this 的 和 没使用到的。\n没使用到 this 的情况 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 定义抽象类 type IAbsClass interface {\t// 使用接口定义抽象行为 abs()\t// 抽象方法，需要子类实现 } type AbsClass struct {}\t// 定义抽象类结构体 func (this AbsClass) common() {\t// 具有默认行为的抽象方法，没使用到 this fmt.Println(\u0026#34;AbsClass common()\u0026#34;) } // --------------------------- 分割线 ----------------------------- // 子类1继承抽象类 type SubClass1 struct { AbsClass name string } func (this SubClass1) abs() {\t// 子类实现抽象方法 fmt.Println(\u0026#34;SubClass1 implement abs().\u0026#34;) } func NewSubClass1(name string) *SubClass1 {\t// 子类构造方法 s := new(SubClass1) s.name = name return s } // 子类2继承抽象类 type SubClass2 struct { AbsClass name string } func (this SubClass2) abs() {\t// 子类实现抽象方法 fmt.Println(\u0026#34;SubClass2 implement abs().\u0026#34;) } func (this SubClass2) common() {\t// 子类重写抽象方法 fmt.Println(\u0026#34;SubClass2 overwrite common().\u0026#34;) } func NewSubClass2(name string) *SubClass2 {\t// 子类构造方法 s := new(SubClass) s.name = name return s } 通过接口 IAbsClass 定义抽象方法 abs()，然后定义一个配对的结构体 AbsClass，结构体实现那些具有默认行为的抽象方法 common()。\n然后子类 SubClass1 和 SubClass2 继承抽象类，也就是嵌入匿名字段 AbsClass，然后自己实现抽象方法 abs() 。\n而且 SubClass2 还对有默认行为的 common() 不满意，自己进行了重写。\n使用方法如下：\n1 2 3 4 5 6 7 8 9 10 func main() { sub1 := NewSubClass1(\u0026#34;Boii\u0026#34;) sub2 := NewSubClass2(\u0026#34;Eva\u0026#34;) sub1.abs()\t// \u0026#34;SubClass1 implement abs().\u0026#34; sub2.abs()\t// \u0026#34;SubClass2 implement abs().\u0026#34; sub1.common()\t// \u0026#34;AbsClass common()\u0026#34; sub2.common()\t// \u0026#34;SubClass2 overwrite common().\u0026#34; } 因为 SubClass2 对具有默认行为的抽象方法 common() 进行了重写，所以调用时调的是重写的方法。\n使用到 this 的情况 Golang 中本身并不是明确支持继承，所以如果我们为抽象方法定义默认行为是需要使用到 this 的话，Golang 不会做自动转换，它会认为这个 this 就是 AbsClass 本身，而不是 SubClass1 或 SubClass2。\n基于这种情况，我们需要 3 步：\n在 AbsClass 中加入一个接口字段 i IAbsClass 在使用 this 的时候换成 this.i 由于 i 是个接口类型，子类 SubClass1、SubClass2 在实例化时得将自己注册进去。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // 抽象类 type IAbsClass interface { abs() } type AbsClass struct { i IAbsClass\t// == 增加一个接口字段 == } func (this AbsClass) common1() {\t// 具有默认行为的抽象方法，没使用到 this fmt.Println(\u0026#34;AbsClass common()\u0026#34;) } func (this AbsClass) common2() {\t// 具有默认行为的抽象方法，使用到了 this this.i.abs()\t// == 不能直接 this，要用 this.i == } // --------------------------- 分割线 ----------------------------- // 子类1继承抽象类 type SubClass1 struct { AbsClass name string } func (this SubClass1) abs() {\t// 子类实现抽象方法 fmt.Println(\u0026#34;SubClass1 implement abs().\u0026#34;) } func NewSubClass1(name string) *SubClass1 {\t// 子类构造方法 s := new(SubClass1) s.AbsClass.i = s\t// == 将自己注册进去 == s.name = name return s } // 子类2继承抽象类 type SubClass2 struct { AbsClass name string } func (this SubClass2) abs() {// 子类实现抽象方法 fmt.Println(\u0026#34;SubClass2 implement abs().\u0026#34;) } func NewSubClass2(name string) *SubClass2 {\t// 子类构造方法 s := new(SubClass) s.name = name s.AbsClass.i = s\t// == 将自己注册进去 == return s } 这样通过子类 SubClass1、SubClass2 调用 common() 时才能正确的执行。\n1 2 3 4 5 6 7 func main() { sub1 := NewSubClass1(\u0026#34;Boii\u0026#34;) sub2 := NewSubClass2(\u0026#34;Eva\u0026#34;) sub1.common2()\t// \u0026#34;SubClass1 implement abs().\u0026#34; sub2.common2()\t// \u0026#34;SubClass2 implement abs().\u0026#34; } 总结 通过有无这种行为去定性一个类，而不是通过如何实现这种行为去定性，这就是面向接口编程。\n将一些行为聚合在一起，不实现它们，就是一个接口。如果要给这些行为一个默认行为，那就用抽象类。\nJava 中的抽象类和接口都支持成员变量，但在 Golang 中实现抽象类时，无法兼顾成员变量，因为接口不可以有变量。虽然可以把抽象类的成员变量放在抽象类结构体中，也可以在子类中访问到，但是无法做到泛化：\n1 2 3 4 5 6 7 8 9 10 11 func test(ia IAstClass) { fmt.Println(ia.name)\t// 编译失败，接口中没有变量 } func test(a AstClass) { fmt.Println(a.name)\t// 编译失败，无法将子类传进来 test(sub1) } func test(ia IAstClass) { fmt.Println(ia.(AstClass).name)\t// 编译失败，test(sub1) 会报错说断言失败 } 当然可以在抽象类接口中，为抽象类结构体增加 getter、setter 方法，然后抽象类结构体实现 getter、setter 方法，但其实也不是好。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 抽象类 type IAbsClass interface { abs() getAbsName() string } type AbsClass struct { i IAbsClass\t// == 增加一个接口字段 == absName string } func (a AbsClass) getAbsName() string { return a.absName } // --------------------------- 分割线 ----------------------------- func test(ia IAstClass) { fmt.Println(ia.getAstName()) } 属性多了可以将所有的 getter、setter 放在一个接口 IGetAstAttr 中，然后 IAstClass 中嵌入这个 IGetAstAttr，或者更进一步使用选项设计模式管理所有 getter、setter。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 抽象类 type IAbsClass interface { IGetAstAttr abs() } type IGetAstAttr interface { getAbsName() string getAbsAge() int getAbsEmail() string setAbsName() string setAbsAge() int setAbsEmail() string } type AbsClass struct { i IAbsClass\t// == 增加一个接口字段 == // 抽象类的成员变量 absName string absAge int absEmail string } func (a AbsClass) getAbsName() string { return a.absName } // --------------------------- 分割线 ----------------------------- func test(ia IAstClass) { fmt.Println(ia.getAstName()) } 但是我总觉得这样违背了 Golang 的设计哲学。我也不喜欢这种脱离本质的东西。如果已经到了这种程度，倒不如重新设计，看看如何通过组合替代继承。\n","permalink":"https://www.boii.xyz/posts/go/golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-10-%E5%AE%9E%E7%8E%B0%E6%8A%BD%E8%B1%A1%E7%B1%BB/","summary":"\u003cp\u003e虽然不推荐，但免不了要用到。\u003c/p\u003e","title":"Golang [深入理解] 10-实现抽象类"},{"content":"都是实现，有啥区别？\n值实现 VS 指针实现 值接收者方法（Value receiver method）和指针接收者方法（Pointer receiver method），都可以被结构体变量（struct variable）或结构体指针（struct pointer）调用。\n值接收者方法中，对接收者的修改，不会影响调用者。 指针接收者方法中，对接收者的修改，会影响调用者。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 type S struct { age int } func (s S) read() {\t// 值实现，值接收者方法 s.age = 50 } func (s *S) write(n int) {\t// 指针实现，指针接收者方法 s.age = n } func main() { sV := A{age: 10}\t// 结构体变量 sP := \u0026amp;A{age: 10}\t// 结构体指针 sV.read()\t// 结构体变量可以调用值实现的方法 fmt.Println(sV.age)\t// 10 sV.write(15)\t// 结构体变量可以调用指针实现的方法 fmt.Println(sV.age)\t// 15 sP.read()\t// 结构体指针可以调用值实现的方法 fmt.Println(sP.age)\t// 10 sP.write(18)\t// 结构体指针可以调用指针实现的方法 fmt.Println(sP.age)\t// 18 } 在上述栗子中，\nsP 是结构体指针，在 sP 调用值方法 sP.read() 时，编译器会自动转换为 (*sP).read()；\nsV 是结构体变量，在 sV 调用指针方法 sV.write() 时，编译器会自动转换为 (\u0026amp;sV).write(15)。\n值接收者方法 指针接收者方法 结构体变量调用者 可以调用，类似于传值 可以调用，相当于 (\u0026amp;sV).write(15) 结构体指针调用者 可以调用，相当于 (*sP).read() 可以调用，类似与传指针，所以会影响调用者 修改 不影响调用者 影响调用者 如何选择 要看类型的本质。如果一个结构体类型的实例，应该是独一份的，那么就应该用指针接收者方法。\n例如，文件结构体。每个文件都是独一份的，对应地，文件结构体返回一个文件对象，这个对象应该唯一的代表这个文件，所以文件结构体的方法应该使用指针接收者方法。\n涉及接口 在不涉及接口的情况下，值实现和指针实现，结构体变量和结构体指针都调用。\n但是在涉及接口的情况下，这两种实现还是有区别的。\n使用值实现接口方法时，等于 “值实现 + 指针实现”； 使用指针实现接口方法时，仅等于 “指针实现”。 值实现 = 值实现 + 指针实现\n指针实现 = 指针实现\n调用的时候依然是结构体变量和结构体指针都能调值实现方法和指针实现方法，这一点没变。\n区别的地方在于，当你要把结构体传递给接口变量时，会有区分。\n举个栗子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 type Ier interface { print() } type Sa struct {} type Sb struct {} func (a Sa) print() {}\t// Sa 使用值实现 func (b *Sb) print() {}\t// Sb 使用指针实现 func main() { sav := Sa{}\t// 结构体变量，Sa 使用值实现了 Ier sap := \u0026amp;Sa{}\t// 结构体指针，Sa 使用值实现了 Ier sbv := Sb{}\t// 结构体变量，Sb 使用指针实现了 Ier sbp := \u0026amp;Sb{}\t// 结构体变量，Sb 使用指针实现了 Ier sav.print()\t// 结构体变量 可以调用 值实现方法 sap.print()\t// 结构体指针 可以调用 值实现方法 sbv.print()\t// 结构体变量 可以调用 指针实现方法 sbp.print()\t// 结构体指针 可以调用 指针实现方法 var ier1 Ier ier1 = sav\t// 值实现者 的 结构体变量 可以传递给 接口变量 ier1 = sap\t// 值实现者 的 结构体指针 可以传递给 接口变量 // 指针实现者 的 结构体变量 不能传给 接口变量 ier1 = sbv\t// cannot use sbv (type Sb) as type Ier in assignment: Sb does not implement Ier (print method has pointer receiver) ier1 = sbp\t// 指针实现者 的 结构体指针 可以传递给 接口变量 } ","permalink":"https://www.boii.xyz/posts/go/golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-9-%E5%80%BC%E5%AE%9E%E7%8E%B0-vs-%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0/","summary":"\u003cp\u003e都是实现，有啥区别？\u003c/p\u003e","title":"Golang [深入理解] 9-值实现 VS 指针实现"},{"content":"关于你可能知道的 nil 的使用\n关于 nil nil 是啥？golang 中的 nil 相当于其他语言中的 NULL。\n但 nil 的本质是啥？到底是一种类型？还是一种变量？还是一个关键字？\n按照博主 奇伢云存储 的介绍，nil 是一个特殊变量，也是一种触发机制。\n1 2 3 4 5 6 7 8 // nil is a predeclared identifier representing the zero value for a // pointer, channel, func, interface, map, or slice type. var nil Type // Type must be a pointer, channel, func, interface, map, or slice type // Type is here for the purposes of documentation only. It is a stand-in // for any Go type, but represents the same type for any given function // invocation. type Type int 在编译器层面，nil 是使用一个变量来表示。\nnil 其实是语言层面给出的：在编译器中，nil 是一个 Type 型变量，Type 类型 是以 int 为基础的自定义类型。\n但这不代表我们使用语言编程程序时能把 nil 当作一个变量。比如你把 nil 赋值给一个 byte 型变量，是不可以的，因为编译器不让。这是编译器的特权，你可没有！\n这里明确一点，能够赋值 nil 的类型只有 “引用六兄弟 SMCIFP”：\nslice map chan interface func pointer 这就是编译器给你这位语言使用者的权限。在上面的源码中 var nil Type 后面的注释就有写。\n所以除了这 6 兄弟之外，别的类型都不可以赋值 nil，或者和 nil 比较。\n你可以把这 “引用六兄弟 SMCIFP” 理解为一种 nilable 的类型。\n所谓 nilable，就是可以赋值为 nil（able to assign with nil），可以和 nil 比较（able to compare to nil）。\n如果用 go 提案中用泛型表示，即：\n1 2 3 4 5 6 7 8 9 10 11 type nilable interface { type []int, map[int]int, chan int, interface{}, unsafe.Pointer, func } func compare[T nilable] (a T) bool { return a == nil } func assign[T nilable] (a T) { a = nil } 并不严谨，仅仅用于表达 nilable 这个意思而已。\n于是在编译器编译你的代码的时候，如果它看到你写出 a == nil 或 a = nil 这样的代码时，它要确认 a 是 nilable 的（是引用六兄弟 SMCIFP）。所以说 nil 是一种触发机制。\n那么这六兄弟有什么特殊呢？\n我们将 go 中的类型分为值类型和引用类型 两类。\n值类型就是 int 系列、uint 系列等； 引用类型就是 “引用六兄弟 SMCIFP”。 在 golang 中，使用变量前需要先声明变量。声明变量的本质是分配一块内存。\nClang（golang 的前辈）在声明变量是分配内存，但也只是分配内存，并不管这块内存里是不是干净的，所以会出现野指针此类问题。\n我写 Clang 的时候就会有一个习惯，在声明变量的时候顺带初始化一个零值。\n1 2 3 int sum = 0; double price = 0.0; int* p = NULL; 这样的习惯可以有效的预防一些意料之外的情况。\n但是 golang 是二十一世纪的语言，它的变量声明在分配内存时是「置 0 分配」，也就是说 golang 可以保证你声明的变量分配的那块内存是干净的，你可以放心的使用。\n所以在 golang 中声明一个变量但没有初始化，这个变量的值是其类型的零值，即：\n1 2 3 var sum int // sum == 0 var str string // str == \u0026#34;\u0026#34; var p *int // p == nil SMCIFP 先声明一点：这六兄弟中，slice、map、chan、interface 是一种复合结构，pointer 和 func 是一个指针。\n其实上面引用中的这句话已经能大概的看出答案了，因为他们是指针，所以是 nilable。我们可以看看编译器中这“六兄弟”的结构。\nslice\n1 2 3 4 5 type slice struct { array unsafe.Pointer // 管理的内存块首地址 len int // 动态数组实际使用大小 cap int // 动态数组内存大小 } map\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // A header for a Go map. type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler\u0026#39;s definition. count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields } chan\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type hchan struct { qcount uint // total data in the queue dataqsiz uint // size of the circular queue buf unsafe.Pointer // points to an array of dataqsiz elements elemsize uint16 closed uint32 elemtype *_type // element type sendx uint // send index recvx uint // receive index recvq waitq // list of recv waiters sendq waitq // list of send waiters // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G\u0026#39;s status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. lock mutex } interface\n1 2 3 4 5 6 7 8 9 type iface struct { tab *itab data unsafe.Pointer } type eface struct { _type *_type data unsafe.Pointer } func 和 pointer 本身就是一个指针。\n可以看出，map 和 chan 两个都是比较大的结构体，而当你声明一个 map 或 chan 时，你必须通过 make() 才能使用。为什么？\n因为这两个结构体比较大，为了提高性能，你声明的时候 var c chan int 的时候，c 是个指针，当你 make() 的时候才会分配内存，也就是初始化 hchan。map 也是同样的道理。\n像图中那样，slice、map、chan、interface 不管他们有多大，例如 slice 有 1000 个元素，map 有 10万对键值对，chan 缓存中有 100万 个数据，那都是他们背后的数组的大小；他们本身的大小，只有一个结构体那么大。\n所以编译器在判断 nil 的时候其实非常快，因为这几个类型本身是指针，编译器只需要像如下判断即可：\n对于 slice 的时候，判断 s 中的 array 字段是不是零值； 对于 map、chan 的时候，判断 m、c 自身是不是零值； 对于 interface 的时候，判断 i 自身是不是零值； 对于 pointer、func 的时候，判断 p、f 自身是不是零值； 同样，在赋值 nil 的时候，也是把他们自身赋值为 nil 即可。\n除了 slice，因为它的结构比较小，总共就 24Byte（32位机中 12B），所以声明的时候直接初始化了一个 slice 结构，对 array 字段进行维护。\n具体细节，推荐仔细阅读 https://mp.weixin.qq.com/s/sHLYy_4XA6254-vLmlu0IA，这篇文章讲的非常通俗和详细。\n总结 nil 只能用于引用六兄弟 SMCIFP； 变量只是一个指向一块内存的指针 slice 结构较小，所以声明的时候就直接分配内存了，map 和 chan 需要 make() 才分配内存。 除了 pointer 和 func，其他都是使用对应结构体来管理 对 MCIFP 的判断 nil 和 赋值 nil，都是对变量本身进行操作，而 Slice 是对 array 字段进行操作。 再次强烈推荐阅读 https://mp.weixin.qq.com/s/sHLYy_4XA6254-vLmlu0IA。\n","permalink":"https://www.boii.xyz/posts/go/golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-7-%E5%85%B3%E4%BA%8E-nil/","summary":"\u003cp\u003e关于你可能知道的 nil 的使用\u003c/p\u003e","title":"Golang [深入理解] 7-关于 nil"},{"content":"关于你可能知道的 string\nstring 实现原理 UTF-8 在计算机中，一切都是数字「0」和「1」，确切点说应该是「低电平」和「高电平」。\n从理论角度来说，「数」是客观存在的，是真理般的存在，而「进制」是主观存在的，是人类掌握「数」的一种工具。\n一个数，可以用二进制、八进制、十进制、十六进制、二十六进制、三十八进制等各种进制来表示。不同进制之间可以按照一定规则进行转换，0 和 1 两个数字，可以组成二进制的最基本单位，所以可以通过 101 表示十进制 5，110 表示十进制 6。\n于是，在计算机中，不管我们要表示任何数，只要转换成二进制，并替换成计算机中的高低电平，既可以在计算机中确切的表示一个数。\n但是人类世界不仅有数，还有文字。文字由一个一个字符组成，正如英文由字母组成，汉字由笔画组成。在计算机中无法直接表示文字，于是计算机先驱们想出了使用“编号约定”的办法，为每一个字符编一个数字编号，这样就使得文字和数字之间有了映射关系，进而可以在计算机中表示文字。\n最初的“编号约定”是 ASCII 码表，由于计算机发展于西方，西文的基本单位 26 个字母，大小写一共 52 个，加上一些符号、控制字符，组成了 ASCII 码表。\n基础 ASCII 码表只有 127 个字符，使用 7 个比特（7 位二进制数）即可表示，而在计算机中 8 个比特组成 1 个字节，所以基础 ASCII 码表也好，扩展 ASCII 码表也好，用 1 个字节足矣。\n但是人类语言不止英文一种，还有中文、俄文、日文等等，每种语言一个编码表又使得相互之间会导致码值冲突，混乱不堪。所以 Unicode 通用学术学会便制定了一个通用字符集 UTF，国内也称作“万国码”，由此促进了文字在每一台计算机上的兼容性，防止两台计算机采用不同的编码方式导致 A 计算机的文字到 B 计算机上变成乱码。\nUTF 采用的是变长编码（有兴趣的同学自行了解为什么不是定长编码 Golang string ），小编号的字符占少字节，大编号占多字节。每一个字符的编码中的每一个字节都有几个位来用作“前缀”，通过前缀识别出该字节属于哪一个区间。具体如下：\n编号 编码模版 0~127 0xxx xxxx 128~2047 110x xxxx 10xx xxxx 2048~65535 1110 xxxx 10xx xxxx 10xx xxxx 例如，英文字符 c 的编号为 99，在 0 到 127 的区间，于是采用 0xxx xxxx 的模板，十进制 99 转为二进制为 1100011，替换到 xxx xxxx，最终编码结果为 0110 0011。\n再比如，中文字符 世 的编号为 19990，在 2048 到 65535 的区间，于是采用 1110 xxxx 10xx xxxx 10xx xxxx 的模板，十进制的 19990 转为二进制为 0100 1110 0001 0110 ，替换到模板中，最终编码结果为 1110 0100 1011 1000 1001 0110。\n再比如，当计算机看到 1110 0111 10 010101 10 001100 时，第一个字节的前缀 1110 使得计算机明白，这个字符一共占用 3 个字节，除了读取完当前这个字节，还要往后读取 2 个字节。于是从第一个字节中抽取 0111，第二和第三个字节剥离前缀 10 后得到 010101 和 001100，将这三部分拼接得到 0111 010101 001100，十进制为 30028，对应中文字符 界 字。\nstring 结构 说回 string 结构。在 C 语言中，字符串是一个字符数组指针，指向一个字符数组，这样便知道了字符串的开始，使用 \\0 表示字符串结束。这样的设计存在的问题是，字符串中无法表示 \\0 本身。\ngolang 在这个基础上进行了改进，没有采用 \\0 表示，而是增加了一个 len 字段用于记录字节数组 str 的长度，这样即可以在字符串中使用 \\0，而且求字符串长度时直接返回 len 的值即可，时间复杂度仅为 O(1)。\n在源码包中 src/runtime/stirng.go:stringStruct 对 字符串 定义如下：\n1 2 3 4 type stringStruct struct { str unsafe.Pointer\t// 指向字节数组的指针 len int\t// 字节数组的长度，即字节个数 } 要注意的是，len 表示的是 str 这个字节数组的长度，不是字符的长度。因为有的字符的长度为 2，有的为 3，有的为 1。例如一个中英混合的字符串 \u0026quot;abc世界\u0026quot;，它的 len 为 9，abc 占用 3 字节，世 占用 3 字节，界 占用 3 字节。\n复制问题 字符串的复制有 2 种方法：\n直接赋值 = re-slice 语法 1 2 3 4 hello1 := \u0026#34;hello\u0026#34; hello2 := hello1\t// hello hello3 := hello1[1:4]\t// ell 采用这两种方法时，两个字符串共享同一个底层字节数组，也就是说，是一种浅复制。\n因为 Golang 中字符串一旦定义就不可更改，对字符串中字符的修改较为麻烦，且修改完后会返回一个新的修改好的字节数组，已经不是一开始那个字节数组了，所以可以放心的使用浅复制。\n类型转换问题 一个字符串的值可以显式地转换成一个字节切片 []byte，反过来也可以。字节 byte 是 uint8 的别名，所以 []byte 等于 []uint8。\n一个字符串的值可以显式地转换成一个码点切片 []rune，反过来也可以。码点 rune 是 uint32 的别名，所以 []rune 等于 []uint32。\n所以转换问题的主角就是 string、[]byte、[]rune 三者。\n[]rune -\u0026gt; string 在一个从码点切片 []rune 到字符串 string 的转换中，码点切片中的每个码点值 rune 将被 UTF-8 编码为一到四个字节至结果字符串中。\n如果一个码点值是一个不合法的Unicode码点值，则它将被视为「Unicode替换字符值（Unicode replacement character）0xFFFD」。\n替换字符值0xFFFD将被 UTF-8 编码为三个字节0xef 0xbf 0xbd。\nstring -\u0026gt; []rune 当一个字符串 string 被转换为一个码点切片 []rune 时，此字符串中存储的字节序列将被解读为一个一个码点的 UTF-8 编码序列。\n非法的UTF-8编码字节序列将被转化为Unicode替换字符值0xFFFD。\nstring -\u0026gt; []byte 当一个字符串 string 被转换为一个字节切片 []byte 时，结果切片中的底层字节序列是此字符串中存储的字节序列的一份深复制。\n即Go运行时将为结果切片开辟一块足够大的内存来容纳被复制过来的所有字节。当此字符串的长度较长时，此转换开销是比较大的。\n[]byte -\u0026gt; string 当一个字节切片 []byte 被转换为一个字符串 string 时，此字节切片中的字节序列也将被深复制到结果字符串中。 当此字节切片的长度较长时，此转换开销同样是比较大的。\n在这两种转换（string -\u0026gt; []byte、[]byte -\u0026gt; string）中，必须使用深复制的原因是：\n[]byte 字节切片中的字节元素是可修改的，但是字符串中的字节是不可修改的；\n所以一个 []byte 和一个字符串 string 是不能共享底层字节序列的。\n请注意，在字符串和字节切片之间的转换中，\n非法的UTF-8编码字节序列将被保持原样不变。 标准编译器做了一些优化，从而使得这些转换在某些情形下将不用深复制。 这样的情形将在下一节中介绍。 []byte \u0026lt;-!-\u0026gt; []rune Go并不支持字节切片和码点切片之间的直接转换。我们可以用下面列出的方法来实现这样的转换：\n利用字符串做为中间过渡。这种方法相对方便但效率较低，因为需要做两次深复制。 使用unicode/utf8标准库包中的函数来实现这些转换。 这种方法效率较高，但使用起来不太方便。 使用bytes标准库包中的Runes函数来将一个字节切片转换为码点切片（[]byte -\u0026gt; []rune：bytes.Runes()）。 但此包中没有将码点切片转换为字节切片的函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package main import ( \u0026#34;bytes\u0026#34; \u0026#34;unicode/utf8\u0026#34; ) func main() { s := \u0026#34;颜色感染是一个有趣的游戏。\u0026#34; bs := []byte(s) // string -\u0026gt; []byte s = string(bs) // []byte -\u0026gt; string rs := []rune(s) // string -\u0026gt; []rune s = string(rs) // []rune -\u0026gt; string rs = bytes.Runes(bs) // []byte -\u0026gt; []rune bs = Runes2Bytes(rs) // []rune -\u0026gt; []byte } func Runes2Bytes(rs []rune) []byte { n := 0 for _, r := range rs { n += utf8.RuneLen(r) } n, bs := 0, make([]byte, n) for _, r := range rs { n += utf8.EncodeRune(bs[n:], r) } return bs } 本小节摘自 《Go 101》字符串相关的类型转换\n比较问题 字符串类型都是可比较类型，因为底层是字节数组，和字符 byte、rune 一样，他们背后的基础类型是 uint8 和 uint32 。\n所以两个字符串 string 或 两个字符 byte、rune 之间可以使用等于、不等、大于、大于等于、小于、小于等于的比较：string == string、string != string、string \u0026gt; string、rune \u0026gt;= rune、byte \u0026lt; byte、byte \u0026lt;= byte。\n1 2 3 4 5 6 7 8 9 hello := \u0026#34;hello\u0026#34; world := \u0026#34;world\u0026#34; fmt.Println(hello == world)\t// false fmt.Println(hello != world)\t// true fmt.Println(hello \u0026gt; world)\t// false fmt.Println(hello \u0026gt;= world)\t// false fmt.Println(hello \u0026lt; world)\t// true fmt.Println(hello \u0026lt;= world)\t// true 当比较两个字符串值的时候，它们的底层字节将逐一进行比较。\n如果一个字符串 a 是另一个字符串 b 的前缀，并且另一个字符串 b 较长; 则另一个字符串 b 为两者中的较大者。\n1 2 3 4 5 6 7 8 hello := \u0026#34;hello\u0026#34; world := \u0026#34;world\u0026#34; helloworld := hello + world fmt.Println(hello \u0026gt; helloworld)\t// false fmt.Println(hello \u0026gt;= helloworld) // false fmt.Println(hello \u0026lt; helloworld)\t// true fmt.Println(hello \u0026lt;= helloworld) // true 字符串相等比较 对于两个字符串相等或不等的比较，Go编译器会先比较他们的 len 字段：\n如果两个 len 的值不相等，则两个字符串肯定不相等； 如果两个 len 的值相等，则比较两个字符串底层的字节数组指针 str 是否相等，也就是看看是不是引用了同一个底层字节数组。如果是则相等，如果不是则逐个比较每一个字节。 ","permalink":"https://www.boii.xyz/posts/go/golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-4-string-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","summary":"\u003cp\u003e关于你可能知道的 string\u003c/p\u003e","title":"Golang [深入理解] 4-string 实现原理"},{"content":"关于你可能知道的 slice\nslice 实现原理 slice 是一段底层数组的描述。\n在 golang spec 是这么说的：\nA slice is a descriptor for a contiguous segment of an underlying array and provides access to a numbered sequence of elements from that array. A slice type denotes the set of all slices of arrays of its element type. The number of elements is called the length of the slice and is never negative. The value of an uninitialized slice is nil.\n切片是底层数组的连续段的描述符，提供对该数组中编号的元素序列的访问。切片类型表示其元素类型的数组的所有切片的集合。元素的数量称为切片的长度，并且永远不会为负。未初始化切片的值为nil。\nslice 结构 在源码包中 src/runtime/slice.go:slice 对 Slice 定义如下：\n1 2 3 4 5 type slice struct { array unsafe.Pointer len int cap int } 通过这个结构体可以更清晰看出，切片是基于一个底层数组的（即 array 字段，其为一个指针，指向一个数组），并且带有两个字段：长度 len 和 容量 cap。\n容量，指的是切片的底层数组的元素最大个数。\n长度，指的是切片的底层数组的元素目前个数。\n创建切片共有 3 种方式：\n通过字面量直接创建\n基于已有 数组/slice 创建\n通过 make() 创建\n1 2 3 4 5 arr := [8]int{1, 2, 3, 4, 5, 6, 7, 8} s1 := []int{11, 22, 33}\t// 1. 通过字面量直接创建 s2 := arr[2:6]\t// 2. 通过下标基于数组或切片创建 s3 := make([]int, 10, 20)\t// 3. 通过关键字 make 创建 [:] re-slice [:] 语法在 golang spec 称为 Slice Expression，也有称作 re-slice，是 golang 中很常用的一种获得切片的方法。但在使用时有一些地方需要注意。\n[:] 语法有两种基本形式：\n[low : high] [low : high : max] 第一种基本形式中，low 和 high 都允许使用字面常量或变量，都允许忽略不写，所以有以下几种形式：\n[2:5]、[2:]、[:5]、[:] 第二种基本形式中，low、high、max 都允许使用字面常量或变量，但只允许 low 忽略不写，所以只有 2 种形式：\n[2:5:6]、[:5:6] 在忽略不写的情况下：\nlow的默认值为 0，即基础数组的第一个元素开始算起\nhigh的默认值为 len(基础数组/切片)，即基础数组/切片的最后一个\nmax 的默认值为 len(底层数组)，即底层数组的最后一个元素（包含最后一个元素）\n举个栗子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 b := make([]int, 0, 10)\t// 切片 b，b 的基础数组和底层数组都是某个匿名数组 for i := 0; i \u0026lt; 8; i++ { b = append(b, i+1) } fmt.Println(\u0026#34;b:\u0026#34;, b)\t// b: [1 2 3 4 5 6 7 8] fmt.Println(len(b), cap(b))\t// 8 10 j := b[2:7]\t// 切片 j，基础数组是 b，底层数组是某个匿名数组 fmt.Println(\u0026#34;j:\u0026#34;, j)\t// j: [3 4 5 6 7] fmt.Println(len(j), cap(j))\t// 5 8 k := j[2:]\t// 切片 k，基础数组是 j，底层数组是某个匿名数组 fmt.Println(\u0026#34;k:\u0026#34;, k)\t// k: [5 6 7] fmt.Println(len(k), cap(k))\t// 3 6 l := j[1:4:6]\t// 切片 l，基础数组是 j, 底层数组是某个匿名数组 fmt.Println(\u0026#34;l:\u0026#34;, l)\t// l: [4 5 6] fmt.Println(len(l), cap(l))\t// 3 5 此外 low、high、max 的默认值也有一些要求，但概括起来就是： $$ 0 \\le low \\le len(s) \\le high \\le max \\le cap(s) $$ 即：low 不能超过 high、high 不能超过 max、max 不能超过 cap(s)；反之，max 不能小于 high、high 不能小于 low、low 不能小于 0。\nlow 的取值在 [0, high] high 的取值在 [low, max] max 的取值在 [high, cap(s)] 扩容策略 Slice 是基于底层数组的一种动态数组，相对于长度固定的数组，Slice 更灵活，且体现在：当底层数组容量不足时，Slice 会自动扩容。既然会自动扩容，那么就一定有扩容策略。\n扩容关注点：容量 扩容时机：len(s) == cap(s) 扩容触发场景：len(s) == cap(s) 时继续使用 append() 追加元素 扩容策略：\n扩容后能容纳要追加的元素：\nif oldCap \u0026lt; 1024 { newCap = oldCap * 2} if oldCap \u0026gt;= 1024 { newCap = oldCap * 1.25} 扩容后不能容纳要追加的元素：\nnewCap = 预估的容量 复制问题 在复制 Slice 时，如果仅仅使用等于号 s1 = s2，这样只是拷贝了一个地址。\n要实现完全的复制，需要使用 golang 提供的 copy() 函数。\n使用 copy() 拷贝时，会将源切片的元素逐个拷贝到目的切片指向的数组中，拷贝的数量取两个切片长度的最小值。例如上图中，s1 长度为 8，s2 长度为 5，则共拷贝 5 个元素，即 copy() 不会发生扩容。\n注意，copy() 是覆盖行为。原有数据将会被覆盖。\n比较问题 在 Slice 的比较中，因为 Slice 不是可比较类型，直接用恒等号 == 比较是无法通过编译的，如果取地址比较也是行不通的，因为 Slice 是结构体，取地址比较的是两个结构体，自然是 false。\n1 2 3 4 5 s1 := []int{1, 2, 3, 4, 5} s2 := s1 s1 == s2 // 无法通过编译 \u0026amp;s1 == \u0026amp;s2\t// false 所以，Slice 比较肯定不是那么肤浅的。\nSlice 的比较在网上盛传的有两种：使用 reflect.DeepEqual() 和 手写比较函数。\n因为 reflect.DeepEqual() 效率较低，所以才有手写比较函数。下面简单展示下 DeepEqual()，然后讲解手写比较函数。\nreflect.DeepEqual() 1 2 3 func compare(a, b []rune) bool { return reflect.DeepEqual(a, b) } 手写比较函数 其实比较两个 Slice 的思路也简单：\n先看看长度是否相等； 再看看是不是都为 nil 或 都不为 nil，是就 true，否就下一步（都为 nil 也是相等）； 遍历随便哪一个，在遍历中两两比较，一旦不等就返回 false（如果是用在安全方面要预防计时攻击） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func compare(a, b []rune) bool { if len(a) != len(b) {\t// 比较长度，长度都不同肯定不相等 return false } if (a==nil) != (b==nil) {\t// 看看是否都为 nil 或 都不为 nil return false } for i := range a {\t// 遍历，逐个比较 if a[i] != b[i] { return false } } return true } 在遍历之前还可以加入 BCE 优化，不过第一步比较长度时，编译器已经获取了 a 和 b 的长度了，在遍历时应该不会再次检查边界了。\n性能陷阱 问题 golang 具有垃圾回收功能，而一个切片的底层数组，有可能被多个切片引用（即有多个 Slice 指向同一个底层数组），例如 [:] re-slice 就是对底层数组的再一次引用。\n这样的机制就有可能带来一个问题：\n有一个结构体切片 a 有100 个元素，每个结构体的大小是 1 MB，也就是 a 的大小是 100 MB；\n然后另一个切片 b 引用了 切片 a 最后两个元素，即 b := a[len(a)-2:]。当 a 使用完后 GC 是没法回收这个 100 MB 的底层数组的，因为还有 b 在引用着。\n于是就会出现这种 用到只有 2 MB，但却无法回收剩下 98 MB 的空间。这就是我想说的性能陷阱。\n1 2 3 4 5 6 type BigStruct struct { ... } a := []BigStruct { ... 100 个} b := a[len(a)-2:] 解决方法 比较推荐的做法是，采用 copy() 的方法替代 re-slice，因为 copy(b, a) 后 a 和 b 引用的不是同一个底层数组。这样 a 使用完以后，底层数组那 100 MB 的空间也能被 GC 回收。\n1 2 3 4 5 6 7 8 type BigStruct struct { ... } a := []BigStruct { ... 100 个} b := make([]BigStruct, 2) copy(b, a) BCE 优化 边界检查\n总结 每个 Slice 都指向一个底层数组 每个 Slice 都保存了当前 Slice 的长度、底层数组的可用容量 因为 Slice 本身是结构体，带有 len 和 cap 字段，所以计算长度和容量都是 O(1) 因为 Slice 本身是结构体，所以通过函数传递时不会拷贝整个切片，属于引用传递 因为 Slice 本身是结构体，其中 array 字段为指针类型，所以在函数内对 Slice 的修改会影响到外部。 使用 append() 追加元素时有可能触发扩容，扩容后将生成新的切片 使用 copy() 复制 Slice 时，目的 Slice 原有的内容会被覆盖 创建切片时尽可能根据实际需要预分配容量，尽量避免追加过程中扩容操作，有利于提升性能 拷贝时需要判断实际拷贝的个数 谨慎使用多个切片操作同一个数组，以防读写冲突 ","permalink":"https://www.boii.xyz/posts/go/golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-2-slice-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","summary":"\u003cp\u003e关于你可能知道的 slice\u003c/p\u003e","title":"Golang [深入理解] 2-slice 实现原理"},{"content":"两种遍历方式的使用与区别\nfor 和 range 区别 range 可以用来遍历 “引用六兄弟” 中的三个：slice、map、chan，加上数组 array。\n对于数组和 slice，还可以用 for 来遍历。\n基本使用 slice/array 对于 range 循环，循环次数会在循环开始前计算好，在循环过程中修改切片长度并不会改变本次循环的次数。 对于空切片，循环次数为 0。 1 2 3 4 5 6 7 8 9 10 11 s := []int{11, 99, 16, 55} for i, v := range s { fmt.Println(i, v) } // Output: 0 11 1 99 2 16 3 55 这种方式中，v 是 s 中元素的一份拷贝，对 v 的修改并不会影响 s 中原本的元素。\n1 2 3 4 5 6 7 8 9 10 s := []int{11, 99, 16, 55} for i, v := range s { v += 10\t// v 只是一份拷贝，并不会影响 s 里的元素 } fmt.Println(s) // Output: [11 99 16 55] 除非 s 中的元素是指针，则对 v 的修改会影响 s，下面将会讲到。\n此外采用下面两种方式也可以修改 s 中的元素。\n1 2 3 4 5 6 7 8 9 10 s := []int{11, 99, 16, 55} for i := 0; i \u0026lt; len(s); i++ { s[i] += 10 } fmt.Println(s) // Output: [21 109 26 65] 1 2 3 4 5 6 7 8 9 10 s := []int{11, 99, 16, 55} for i := range s { s[i] += 10 } fmt.Println(s) // Output: [21 109 26 65] map 迭代过程中，删除还没遍历到的键值对，则该键值对不会被遍历。\n迭代过程中，如果创建新的键值对，则新的键值对有可能被遍历，也有可能不会被遍历。\n对于空字典，遍历次数为 0。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 m := map[byte]int{ 11: 10, 22: 20, 33: 30, 44: 40, } for k, v := range m { v += 5\t// 仅仅是对拷贝的修改，不会影响 m fmt.Println(k, v) } fmt.Println(m) // Output： 22 25 33 35 44 45 11 15 map[11:10 22:20 33:30 44:40] 同样这种方式对 v 进行修改是不会影响 m 的。\n下面这种就可以\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 m := map[byte]int{ 11: 10, 22: 20, 33: 30, 44: 40, } for k := range m { m[k] += 1\t// 这种方式就会修改到 m 的元素 fmt.Println(k, m[k]) } fmt.Println(m) // Output: 11 11 22 21 33 31 44 41 map[11:11 22:21 33:31 44:41] chan 发送给信道的值，可以通过 range 遍历，直到信道被关闭，才会退出循环。\n如果是未分配内存的 nil 信道，循环将永远阻塞。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ch := make(chan byte) go func() { ch \u0026lt;- \u0026#39;b\u0026#39; ch \u0026lt;- \u0026#39;o\u0026#39; ch \u0026lt;- \u0026#39;i\u0026#39; ch \u0026lt;- \u0026#39;i\u0026#39; close(ch) }() for c := range ch { fmt.Println(string(c)) } // Output: b o i i 性能比较 接下来我们主要针对基本类型和结构体类型，比较他们使用 for 和 range 的性能。\n只有 slice 和 array 才有办法 for 和 range 都使用，所以接下来的比对如下：\nfor range 基本类型 for + []int range + []int 结构体 for + []struct range + []struct for + []int VS range + []int 主要方式有 3 种：\nfor i:=0; i \u0026lt; len(s); i++ for i := range s for i, v := range s 先说结论：\n遍历 []int ，三种方式并没太大差别。\n[]int 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // 生成切片 func geneI(n int) []int { nums := make([]int, 0, n) rand.Seed(time.Now().Unix()) for z := 0; z \u0026lt; n; z++ { nums = append(nums, rand.Int()) } return nums } // for 遍历 func I_For(nums []int) { n := len(nums) for i := 0; i \u0026lt; n; i++ { _ = nums[i] } } // range i 遍历 func I_RangeI(nums []int) { for i := range nums { _ = nums[i] } } // range iv 遍历 func I_RangeIV(nums []int) { for i, v := range nums { _, _ = i, v } } func BenchmarkI_For(b *testing.B) { nums := geneI(1 \u0026lt;\u0026lt; 20) for i := 0; i \u0026lt; b.N; i++ { I_For(nums) } } func BenchmarkI_RangeI(b *testing.B) { nums := geneI(1 \u0026lt;\u0026lt; 20) for i := 0; i \u0026lt; b.N; i++ { I_RangeI(nums) } } func BenchmarkI_RangeIV(b *testing.B) { nums := geneI(1 \u0026lt;\u0026lt; 20) for i := 0; i \u0026lt; b.N; i++ { I_RangeIV(nums) } } 执行后的结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 $ go version go1.16.6 linux/amd64 $ go test . -bench=I_ -benchmem goos: linux goarch: amd64 cpu: Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHz BenchmarkI_For-4 2685 431122 ns/op 3124 B/op 0 allocs/op BenchmarkI_RangeI-4 2686 431759 ns/op 3123 B/op 0 allocs/op BenchmarkI_RangeIV-4 2688 432650 ns/op 3120 B/op 0 allocs/op PASS ok 3.586s 从结果可以看出，在遍历基本类型切片时，不管是时间上（ns/op），还是空间上（B/op），还是系统调用上（allocs/op），都没啥差别。\n现在是 2021-8-19，以上是 go 1.16.6 版本测试的结果，并没有太大差别，不像网上说的 for 比 range 快。\n[]struct 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 const N = 1 \u0026lt;\u0026lt; 20 type Per struct { ins [2048]byte age int } func geneS(n int) []Per { persons := make([]Per, 0, n) rand.Seed(time.Now().Unix()) for i := 0; i \u0026lt; n; i++ { persons = append(persons, Per{age: rand.Int(), ins: [2048]byte{\u0026#39;a\u0026#39;}}) } return persons } func S_For(persons []Per) { n := len(persons) for i := 0; i \u0026lt; n; i++ { _ = persons[i].age } } func S_RangeI(persons []Per) { for i := range persons { _ = persons[i].age } } func S_RangeIV(persons []Per) { for i, v := range persons { _, _ = i, v.age } } func BenchmarkS_For(b *testing.B) { persons := geneS(N) b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { S_For(persons) } } func BenchmarkS_RangeI(b *testing.B) { persons := geneS(N) b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { S_RangeI(persons) } } func BenchmarkS_RangeIV(b *testing.B) { persons := geneS(N) b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { S_RangeIV(persons) } } 运行结果\n1 2 3 4 5 6 7 8 9 $ go test . -bench=S_ -benchmem goos: linux goarch: amd64 cpu: Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHz BenchmarkS_For-4 2850 421009 ns/op 0 B/op 0 allocs/op BenchmarkS_RangeI-4 2850 420993 ns/op 0 B/op 0 allocs/op BenchmarkS_RangeIV-4 2848 421131 ns/op 0 B/op 0 allocs/op PASS ok 7.330s 可以看到基本也没太大区别。\n[]*struct 结论：即使是结构体指针切片，跑出来的结果几乎相差无几\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 func PS_For(persons []*Per) { n := len(persons) for i := 0; i \u0026lt; n; i++ { _ = persons[i].age } } func PS_RangeI(persons []*Per) { for i := range persons { _ = persons[i].age } } func PS_RangeIV(persons []*Per) { for i, v := range persons { _, _ = i, v.age } } func BenchmarkPS_For(b *testing.B) { persons := genePS(N) b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { PS_For(persons) } } func BenchmarkPS_RangeI(b *testing.B) { persons := genePS(N) b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { PS_RangeI(persons) } } func BenchmarkPS_RangeIV(b *testing.B) { persons := genePS(N) b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { PS_RangeIV(persons) } } 运行结果：\n1 2 3 4 5 6 7 8 9 10 11 12 $ go test . -bench=S_ -benchmem goos: linux goarch: amd64 cpu: Intel(R) Core(TM) i5-7300HQ CPU @ 2.50GHz BenchmarkS_For-4 83856697 14.13 ns/op 0 B/op 0 allocs/op BenchmarkS_RangeI-4 66149228 17.66 ns/op 0 B/op 0 allocs/op BenchmarkS_RangeIV-4 72271676 16.61 ns/op 0 B/op 0 allocs/op BenchmarkPS_For-4 71399964 21.43 ns/op 0 B/op 0 allocs/op BenchmarkPS_RangeI-4 63293829 18.62 ns/op 0 B/op 0 allocs/op BenchmarkPS_RangeIV-4 63576286 18.57 ns/op 0 B/op 0 allocs/op PASS ok 7.565s 能修改元素的遍历 前面说 for i, v := range s 这种方式，v 是一份拷贝，对 v 的修改不会影响 s 中的元素。\n但是如果 v 是个指针，对 v 的修改还是会影响的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 a := 10 b := 20 c := 30 s := []*int{\u0026amp;a, \u0026amp;b, \u0026amp;c} fmt.Println(a, b, c) for _, v := range s { *v += 1 } fmt.Println(a, b, c) // Output： 10 20 30 11 21 31 再举个结构体的栗子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type Person struct { name string age int } persons := make([]*Person, 0, 3) persons = append(persons, \u0026amp;Person{age: 15}, \u0026amp;Person{age: 25}, \u0026amp;Person{age: 35}) fmt.Println(persons[0], persons[1], persons[2]) for _, v := range persons { v.age += 1 } fmt.Println(persons[0], persons[1], persons[2]) // Output: \u0026amp;{ 15} \u0026amp;{ 25} \u0026amp;{ 35} \u0026amp;{ 16} \u0026amp;{ 26} \u0026amp;{ 36} 总结 遍历总共有 3 种方式：\nfor：for i:=0; i\u0026lt;n; i++ rangeI：for i := range items rangeIV：for i, v := range items 三种方式都各有所长。其中 rangeIV 中 v 是 items 中元素的一份拷贝，如果 v 不是指针，那么对于 v 的修改并不会影响 items 里面的元素，如果 v 是指针，则能够影响。\n正是因为 v 是一份拷贝，所以在一些旧版本中可能会因此降低了性能，但在新版本（至少 go 1.16.6 ，我并没有去求证）中，从基准测试来看是没有什么区别，可能在新版本中做了优化。\n","permalink":"https://www.boii.xyz/posts/go/golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-1-for-range/","summary":"\u003cp\u003e两种遍历方式的使用与区别\u003c/p\u003e","title":"Golang [深入理解] 1-for \u0026 range"},{"content":"基础不牢，地动山摇\n接受配置文件 这段时间又换系统了。一开始想使用 ArchLinux ，但是对于网络那块的问题还是有些不稳定，虽然 ArchLinux 并不难操作，但是真的是太太太太太简洁了！基本上要啥没啥，都得自己去找去安装。尽管教程很多但是除非很喜欢折腾，不然 ArchLinux 并不是适合大部分动手能力强的人。\n最后还是选择 Manjaro + i3 的配置方案。Manjaro 配置了一些基本需要用到的软件，比如网络管理、蓝牙管理、电池管理等等一系列刚需软件。如果不喜欢，卸载了换个别的，一样是定制度很高。\n在使用新系统的时候，频繁的需要接触配置文件，很多东西都可以通过自己修改配置文件达到自己想要的效果。渐渐的，之前不希望 OneTiny 有任何配置文件的想法逐渐改变。在使用 i3 的时候，很多小而美的软件也有配置文件。独立一个可执行程序虽好，但少了用户自定义的自由，整个软件的可玩性也就不高了。\n整改 接受了这个观念，一下子很多问题迎刃而解。例如我想要配置好 9012 端口，下次直接使用 onetiny 命令就运行在 9012 端口，而不用每次运行的时候都得手动指定端口号。\n此外有了配置文件和配置目录，更新功能在下载新版本时的临时目录也有地方了，断点续传的临时文件也有地方放了，还有很多配置项都可以在配置文件中写好。\n但是未来我还是会开辟一个分支，仅保留核心部分功能，也就是最初的样子，v0.1 那一版的样子，但是会有并发下载、断点续传这些与核心业务相关的功能，而没有什么密码访问、自动更新这些无关核心问题的功能。而 master 分支继续开发新功能。\n整改起来也方便。使用 os.UserConfigDir() 就可以获取用户的配置目录路径，在其下创建一个 tiny/ 目录和一个 config.yml 文件即可。\n这里采用的是 YAML 格式的配置文件，虽然网上很多说 TOML 是最好的配置文件格式啥的，但\u0026hellip;我真没觉得好到想这些布道师说的一样。虽然我也喜欢拥抱新事物，但是项目中配置项很少，YAML 也不复杂。\n这里感谢 spf13/viper 这个库，非常好用，功能丰富，使用也不难。配置问题很容易就解决了。\n同时为了支持子命令，我换成 urfave/cli 这个库，之前看没看太懂，觉得很繁琐，现在用了之后觉得还不错。\n最后是对项目结构小小的重构了一下。根据命令将整个项目分为 core 部分、config 部分、update 部分。\ncore 部分是核心业务，使用 gin 框架支持，做起来其实和做一个 web 应用相差无几。 config 部分对应子命令 onetiny config，用于设置一些配置。设置生效后会写入文件。 update 部分对应子命令 onetiny update，用于检查更新，自动更新等。\n目前的结构就是使用 cli 管理这些命令，每个命令都有不同的职责，所以分成不同的模块，使用不同的库。\n新功能 这次还新增了一个访问登录功能。如果开启服务的人指定了访问者需要登录的话，访问者需要输入帐号密码才能看到共享目录，才能下载。\n一开始开发这个程序的时候是为了解决自己的场景，就是自己有多台设备，设备之间互传文件的一个问题，是一种单用户的场景。但是慢慢的越做越像一个局域网内的 NSA ，像一台文件服务器，场景中也假设了多用户，而不是一开始的单用户。\n不过没关系，反正自己写着玩，自己的程序就是自己喜欢写成啥样就啥样（因为到现在还没人给我提 issue 哈哈哈）。\n写这个功能的时候其实就跟写 web 项目时做保持登录一样。 注册方式是通过命令 onetiny sec -u 帐号 -p 密码 来注册，也就是写进配置文件。 访问时会经过中间件 checkLogin() 检查 cookie ，没有 cookie 或者 cookie 对不上就转回去登录。\n掉坑 在做登录功能的时候才发现我对 web 其实很不了解，一个完整的登录流程都了解不透彻后来慢慢摸索才明白。\n通常的登录流程是这样的： 客户端访问 A 页面，服务端验证是否登录过，也就是有没有 session 或者 cookie 或者 token 之类的； 有就响应，没有就重定向到登录页； 客户端这边收到登录页后需要输入账号密码，通过表单提交到服务端； 这个时候客户端还是停留在登录页的，然后使用 Ajax 监听服务器发来的响应； 根据响应的内容判断是提示密码错误，还是收下 cookie，重新提交访问 A 页面的请求 重新提交访问 A 页面的请求后就就可以等待响应，正常显示了。 在这里踩了两个坑，都是因为基础不牢的原因。\n第一个是不了解前端，在后端那研究怎么让浏览器自动重新提交访问请求。其实如果之前不要那么排斥前端，多了解下就会知道 Ajax，且现在大多网站都用 Ajax 来做这一步。Ajax 有原生的，如 XMLHttpRequest，也有 jquery 封装好的等等。\n第二个是不了解 HTTP 响应状态码，重定向分很多种情况，瞎用个 301 永久移动 就上去了，结果就是程序都对，但就是登录完还跳回登录页。因为浏览器在访问一个页面时收到 301 的话，它会将这个页面和新的页面做一个绑定，缓存起来。这样下次用户再访问时直接展示那个新的页面。\n正确的做法应该是使用 307 临时重定向。\n最后还是在浏览器调试器里分析出来的，也算是个不大不小的坑。 以前只知道重定向，没关注过不同的重定向的区别。基础不牢，地动山摇。\n最后 虽然经验不足的我搞这么一个小功能搞了一天两夜，但也还是收获了一些东西，发现自己一些问题，要抓紧时间补上。而且在写这篇日记的时候发现 gitee 上有人 star 了我的项目，还有三个 watch，一下子觉得这两天掉的头发值了。\n","permalink":"https://www.boii.xyz/posts/other/onetiny-%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B04-2021-8-16/","summary":"\u003cp\u003e基础不牢，地动山摇\u003c/p\u003e","title":"OneTiny 开发日记4-2021-8-16"},{"content":"新增访问层级限制\n更新功能没写成，还是没想好怎么处理整个流程。\n摆在面前有两个问题：\n下载下来的新版本（可执行文件）放在哪 如何关闭自己然后启动新版本 所以暂时搁置，转头去实现访问层级限制功能。\n使用中间件 这次把中间件用上了，还把之前对浏览器的默认行为：请求 favicon.ico 进行拦截的部分放在单独的中间件里，并且应用到全局。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Start 函数负责启动 gin 实例，开始提供 HTTP 服务 func Start() { gin.SetMode(gin.ReleaseMode) r := gin.New() r.Use(gin.LoggerWithWriter(config.Output),gin.Recovery()) // 中间件 r.Use(middleware.InterceptICO) r.Use(middleware.CheckLevel) r.NoRoute(controller.NotFound) r.GET(\u0026#34;/*filename\u0026#34;, controller.Handler) r.POST(\u0026#34;/upload\u0026#34;, controller.Upload) printInfo() err := r.Run(\u0026#34;:\u0026#34; + config.Port) if _, ok := err.(*net.OpError); ok { log.Fatal(color.RedString(\u0026#34;指定的 %s 端口已被占用，请换一个端口号。\u0026#34;, config.Port)) } } 拦截浏览器默认请求行为的中间件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package middleware import ( \u0026#34;net/http\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; ) // InterceptICO 拦截浏览器默认请求 favicon.ico 的行为 func InterceptICO(c *gin.Context) { if strings.HasSuffix(c.Param(\u0026#34;filename\u0026#34;), \u0026#34;.ico\u0026#34;) { c.Status(http.StatusOK) c.Abort() } } gin 的封装真的让 web 开发变得很方便，中间件也让代码更加清晰，耦合度降低。Nice！\n新增参数 -x 这次新增一个访问层级限制的功能，使用参数 -x 或者 --max 可以指定。\n例如：\n用户指定共享目录为：/a/b , 最大层级为 2，则访问者最深可以访问到 /a/b/c/d 、/a/b/c/d/file 。\n{% checkbox green checked, /a/b %} {% checkbox green checked, /a/b/file %} {% checkbox green checked, /a/b/c %} {% checkbox green checked, /a/b/c/file %} {% checkbox green checked, /a/b/c/d %} {% checkbox green checked, /a/b/c/d/file %} {% checkbox times red checked, /a/b/c/d/e %} {% checkbox times red checked, /a/b/c/d/e/file %}\n其实这个功能有点鸡肋，真实场景下限制访问层级可能不常用，只有一个场景会很常见。\n即：共享者只是想开放共享目录那一层给人访问，你可以看到这一层有什么子目录和文件，你可以下载这一层的所有文件，但不能深入访问子目录。\n所以我把参数的默认值设置为 0。即只能访问共享目录那一层，如果要开放子目录给人访问，就自己设置 -x 参数。\n最核心的就是这个函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 检查当前访问的路径是否超过限定层级 func isOverLevel(relPath string, isFile bool) bool { rel, _ := filepath.Rel(config.RootPath, filepath.Join(config.RootPath, relPath)) i := strings.Split(rel, config.SEPARATORS) level := len(i) if i[0] == \u0026#34;.\u0026#34; { level = 0 } if isFile { level-- } return level \u0026gt; int(config.MaxLevel) } 通过 filepath.Rel 把当前访问路径切出来，按照路径分隔符 config.SEPARATORS 切割，判断切割出来的个数是否超过设定的最大访问层级。\n如果访问的是共享目录，filepath.Rel 会返回一个单元素切片 [\u0026quot;.\u0026quot;]，应该把 level 修正为 0 。 如果访问的是文件，会超出 1 级，应该把 level 自减 1 。\n例如 filepath.Rel(\u0026quot;/a/b\u0026quot;, \u0026quot;/a/b/c/file\u0026quot;) 会得到 /c/file，切割得到切片为 [\u0026quot;c\u0026quot; \u0026quot;file\u0026quot;]，level 为 2 。但这个 file 实际上是 c 目录下的一个文件，应该是与 c 同一层级 1，所以做一次自减来修正。\n最后 今晚想了想，这好像是个 FTP 工具，却用 HTTP 来实现，总感觉怪怪的。有时间研究研究 FTP 协议，看看能不能用 FTP 协议实现吧。\n","permalink":"https://www.boii.xyz/posts/other/onetiny-%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B03-2021-6-29/","summary":"新增访问层级限制\n更新功能没写成，还是没想好怎么处理整个流程。\n摆在面前有两个问题：\n下载下来的新版本（可执行文件）放在哪 如何关闭自己然后启动新版本 所以暂时搁置，转头去实现访问层级限制功能。\n使用中间件 这次把中间件用上了，还把之前对浏览器的默认行为：请求 favicon.ico 进行拦截的部分放在单独的中间件里，并且应用到全局。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Start 函数负责启动 gin 实例，开始提供 HTTP 服务 func Start() { gin.SetMode(gin.ReleaseMode) r := gin.New() r.Use(gin.LoggerWithWriter(config.Output),gin.Recovery()) // 中间件 r.Use(middleware.InterceptICO) r.Use(middleware.CheckLevel) r.NoRoute(controller.NotFound) r.GET(\u0026#34;/*filename\u0026#34;, controller.Handler) r.POST(\u0026#34;/upload\u0026#34;, controller.Upload) printInfo() err := r.Run(\u0026#34;:\u0026#34; + config.Port) if _, ok := err.(*net.OpError); ok { log.Fatal(color.RedString(\u0026#34;指定的 %s 端口已被占用，请换一个端口号。\u0026#34;, config.","title":"OneTiny 开发日记3-2021-6-29"},{"content":"第一次修改别人的东西哈哈\n今天开始给 OneTiny 增加更新的功能，本来想做一个跟 oh-my-zsh 一样的效果，就是会突然跳出来问你是不是要更新，是的话就给你下载最新版然后重启一下终端。\n但是写着写着渐渐面临一个问题，下载后放哪？如果是类 Unix 系统怎么把文件放到 /usr/bin 目录下？放完怎么让他自己启动？\n慢慢的又修改思路，换成不自动检查更新或隔一段时间检查，通过 onetiny update 命令可以主动更新。\n在写的时候新引入了两个库，一个时负责下载时显示进度的 progressbar，一个是解析命令参数的 flaggy。\n{% ghcard schollz/progressbar, theme=algolia%} {% ghcard integrii/flaggy, theme=algolia%} 修改 progressbar 库 修改内容：修复了多了很多空行的情况 在使用 progressbar 时，跑了官方给出的示例但是没得到官方的效果。\n官网给出的例子：\n1 2 3 4 5 6 7 func main() { bar := progressbar.Default(100) for i := 0; i \u0026lt; 100; i++ { bar.Add(1) time.Sleep(40 * time.Millisecond) } } 官方演示的效果： 实际跑出来的效果：\n1 2 3 4 5 6 7 8 9 10 $ go run main.go 100% |█████████████████████████████████████| (100/100, 25bit/s) 有很多的空行。 应用到 OneTiny 里也是一样，官方并没有给出太多答案。 不过进度条的核心就在于 \\r 字符串，于是顺着代码一步步找下去，最后在库的源文件 progressbar.go 中找到了一个函数 clearProgressBar():\n{% folding cyan, 点击查看 clearProgressBar() %}\n1 2 3 4 5 6 7 8 9 10 11 12 13 func clearProgressBar(c config, s state) error { if c.useANSICodes { // write the \u0026#34;clear current line\u0026#34; ANSI escape sequence return writeString(c, \u0026#34;\\033[2K\\r\u0026#34;) } // fill the empty content // to overwrite the progress bar and jump // back to the beginning of the line str := fmt.Sprintf(\u0026#34;\\r%s\\r\u0026#34;, strings.Repeat(\u0026#34; \u0026#34;, s.maxLineWidth)) return writeString(c, str) // the following does not show correctly if the previous line is longer than subsequent line // return writeString(c, \u0026#34;\\r\u0026#34;) } {% endfolding %}\n看到最下面的注释，虽然我不知道上面 return 了下，但是最后一句注释让我觉得有戏。 于是我把上面的 return 注释掉，取消了最后一行 return 的注释。\n{% folding cyan, 点击查看修改后的 clearProgressBar() %}\n1 2 3 4 5 6 7 8 9 10 11 12 13 func clearProgressBar(c config, s state) error { if c.useANSICodes { // write the \u0026#34;clear current line\u0026#34; ANSI escape sequence return writeString(c, \u0026#34;\\033[2K\\r\u0026#34;) } // fill the empty content // to overwrite the progress bar and jump // back to the beginning of the line - str := fmt.Sprintf(\u0026#34;\\r%s\\r\u0026#34;, strings.Repeat(\u0026#34; \u0026#34;, s.maxLineWidth)) - return writeString(c, str) // the following does not show correctly if the previous line is longer than subsequent line + return writeString(c, \u0026#34;\\r\u0026#34;) } {% endfolding %}\n结果居然正常了\u0026hellip;正常了\u0026hellip;常了\u0026hellip;了\u0026hellip;\n好吧没时间管那么多，提交了个 issue 给官方就走了。\n修改 flaggy 库 修改点：增加了修改 --help 和 --version 的描述信息的接口，增加了打印版本信息的简写 -v 之前使用的是 flag 包解析命令行参数，但这包对子命令不友好。\n增加修改 SetHelpFlagDescription 和 SetVersionFlagDescription 我准备把原本的命令改成：\n1 2 3 4 5 6 7 8 tiny ├── -a --allow 指定是否允许访问者上传。 ├── -r --road 指定对外开放的目录的绝对路径。 (default: /home/boii/...) ├── -p --port 指定开放的端口 (default: 9090) ├── -h --help 打印帮助信息。 + ├── -v --version 打印版本信息。当前版本: v0.2.1 + └── update 更新到最新版本 + └── -l --list 列出当前最新版本和更新内容 增加了打印版本信息、update 子命令； update 子命令不带参数时执行更新。\n用 flag 包太麻烦了，找了一会儿 github 之后终于找到一个比较适合的库 flaggy。使用方式和 flag 大体相似，支持子命令等更丰富的功能。\n但是在打印 help 信息时，它把 --help 和 --version 的描述写死了，还不提供接口给人修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 tiny - 一个用于局域网内共享文件的FTP程序。 Usage: tiny [update] Subcommands: update (u) update 可以帮你进行版本升级 Flags: --version Displays the program version string. -h --help Displays help with available flag, subcommand, and positional value parameters. -r --road 指定对外开放的目录的绝对路径。 (default: /home/boii/...) -p --port 指定开放的端口 (default: 9090) -a --allow 指定是否允许访问者上传。 中英混杂，看着就别扭。\n文档中给出的示例也只有一点点，让我猜了好久最后找到了。\n{% folding cyan, 点击查看修改步骤 %} {% tabs tab-id %}\n在 main.go 中增加两个函数，开发者可以通过这两个函数修改默认的描述信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // SetName sets the name of the default package command parser func SetName(name string) { DefaultParser.Name = name } + // SetHelpFlagDescription sets the help flag description of the default package command parser + func SetHelpFlagDescription(description string) { + DefaultParser.HelpFlagDescription = description + } + + // SetVersionFlagDescription sets the version flag description of + the default package command parser + func SetVersionFlagDescription(description string) { + DefaultParser.VersionFlagDescription = description + } // ShowHelpAndExit shows parser help and exits with status code 2 func ShowHelpAndExit(message string) { ... 当然，原本的默认描述还是要保留的\n1 2 3 4 5 6 7 8 9 // defaultVersion is applied to parsers when they are created const defaultVersion = \u0026#34;0.0.0\u0026#34; + var defaultHelpFlagDescription = \u0026#34;Displays help with available flag, subcommand, and positional value parameters.\u0026#34; + var defaultVersionFlagDescription = \u0026#34;Displays the program version string.\u0026#34; // DebugMode indicates that debug output should be enabled var DebugMode bool 在 helpValues.go 中修改两处地方：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // if the built-in version flag is enabled, then add it as a help flag if p.ShowVersionWithVersionFlag { defaultVersionFlag := HelpFlag{ ShortName: \u0026#34;\u0026#34;, LongName: versionFlagLongName, - Description: \u0026#34;Displays the program version string.\u0026#34;, + Description: DefaultParser.VersionFlagDescription, DefaultValue: \u0026#34;\u0026#34;, Spacer: makeSpacer(versionFlagLongName, maxLength), } h.Flags = append(h.Flags, defaultVersionFlag) } // if the built-in help flag exists, then add it as a help flag if p.ShowHelpWithHFlag { defaultHelpFlag := HelpFlag{ ShortName: helpFlagShortName, LongName: helpFlagLongName, - Description: \u0026#34;Displays help with available flag, subcommand, and positional value parameters.\u0026#34;, + Description: DefaultParser.HelpFlagDescription, DefaultValue: \u0026#34;\u0026#34;, Spacer: makeSpacer(helpFlagLongName, maxLength), } h.Flags = append(h.Flags, defaultHelpFlag) } 修改 subCommand.go 中的结构体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type Subcommand struct { Name string ShortName string Description string + HelpFlagDescription string // the help flag description + VersionFlagDescription string // the version flag description Position int // the position of this subcommand, not including flags Subcommands []*Subcommand Flags []*Flag PositionalFlags []*PositionalValue ParsedValues []parsedValue // a list of values and positionals parsed AdditionalHelpPrepend string // additional prepended message when Help is displayed AdditionalHelpAppend string // additional appended message when Help is displayed Used bool // indicates this subcommand was found and parsed Hidden bool // indicates this subcommand should be hidden from help } 我也想不明白为啥 DefaultParser 声明是个 *Parser，但是在 VSCODE 中点击跳转会跳到 SubCommand。\n最后，修改一下 parser.go 中的结构体。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 type Parser struct { Subcommand Version string // the optional version of the parser. + HelpFlagDescription string // the help flag description + VersionFlagDescription string // the version flag description ShowHelpWithHFlag bool // display help when -h or --help passed ShowVersionWithVersionFlag bool // display the version when --version passed ShowHelpOnUnexpected bool // display help when an unexpected flag or subcommand is passed TrailingArguments []string // everything after a -- is placed here HelpTemplate *template.Template // template for Help output trailingArgumentsExtracted bool // indicates that trailing args have been parsed and should not be appended again parsed bool // indicates this parser has parsed subcommandContext *Subcommand // points to the most specific subcommand being used } // NewParser creates a new ArgumentParser ready to parse inputs func NewParser(name string) *Parser { // this can not be done inline because of struct embedding p := \u0026amp;Parser{} p.Name = name p.Version = defaultVersion + p.HelpFlagDescription = defaultHelpFlagDescription + p.VersionFlagDescription = defaultVersionFlagDescription p.ShowHelpOnUnexpected = true p.ShowHelpWithHFlag = true p.ShowVersionWithVersionFlag = true p.SetHelpTemplate(DefaultHelpTemplate) p.subcommandContext = \u0026amp;Subcommand{} return p } 1 2 3 4 5 6 7 8 9 10 flaggy.SetName(\u0026#34;tiny\u0026#34;) flaggy.SetVersion(VERSION) flaggy.SetDescription(\u0026#34;一个用于局域网内共享文件的FTP程序。\u0026#34;) + flaggy.SetHelpFlagDescription(\u0026#34;打印帮助信息。\u0026#34;) + flaggy.SetVersionFlagDescription(\u0026#34;打印版本信息。当前版本: \u0026#34; + VERSION) flaggy.String(\u0026amp;RootPath, \u0026#34;r\u0026#34;, \u0026#34;road\u0026#34;, \u0026#34;指定对外开放的目录的绝对路径。\u0026#34;) flaggy.String(\u0026amp;Port, \u0026#34;p\u0026#34;, \u0026#34;port\u0026#34;, \u0026#34;指定开放的端口\u0026#34;) flaggy.Bool(\u0026amp;IsAllowUpload, \u0026#34;a\u0026#34;, \u0026#34;allow\u0026#34;, \u0026#34;指定是否允许访问者上传。\u0026#34;) ... flaggy.Parse() {% endtabs %}\n{% endfolding %}\n增加打印版本信息的 -v 原本的打印信息有两种方式：\n1 2 3 4 5 6 7 # 第一种 $ cmd --version 0.0.1 # 第二种 $ cmd version 0.0.1 可能是为了把 -v 留给使用者定义成 --verbose 之类的，所以源码中只有几个默认的值：\n1 2 3 4 // strings used for builtin help and version flags both short and long const versionFlagLongName = \u0026#34;version\u0026#34; const helpFlagLongName = \u0026#34;help\u0026#34; const helpFlagShortName = \u0026#34;h\u0026#34; 不过我暂时用不到，我希望能有第三种方式：\n1 2 3 # 第三种 $ cmd -v 0.0.1 所以进行了以下修改：\n{% tabs tab-id %}\nmain.go 添加 versionFlagShortName\n1 2 3 4 5 // strings used for builtin help and version flags both short and long const versionFlagLongName = \u0026#34;version\u0026#34; + const versionFlagShortName = \u0026#34;v\u0026#34; const helpFlagLongName = \u0026#34;help\u0026#34; const helpFlagShortName = \u0026#34;h\u0026#34; helpValues.go 修改一下，这样打印帮助信息的时候才会显示出来 -v\n1 2 3 4 5 6 7 8 9 10 11 12 // if the built-in version flag is enabled, then add it as a help flag if p.ShowVersionWithVersionFlag { defaultVersionFlag := HelpFlag{ - ShortName: \u0026#34;\u0026#34;, + ShortName: versionFlagShortName, LongName: versionFlagLongName, Description: DefaultParser.VersionFlagDescription, DefaultValue: \u0026#34;\u0026#34;, Spacer: makeSpacer(versionFlagLongName, maxLength), } h.Flags = append(h.Flags, defaultVersionFlag) } subCommand.go 修改一下，这里主要是让 -v 生效\n1 2 3 4 5 6 7 8 // if the flag being passed is version or v and the option to display // version with version flags, then display version if p.ShowVersionWithVersionFlag { - if flagName == versionFlagLongName { + if flagName == versionFlagLongName || flagName == versionFlagShortName { p.ShowVersionAndExit() } } 同样在 subCommand.go 修改一下，这里主要是检查使用者是不是定义了 -v 或者 \u0026ndash;version\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // ensureNoConflictWithBuiltinVersion ensures that the flags on this subcommand do // not conflict with the builtin version flag (-v/--version). Exits the program // if a conflict is found. func (sc *Subcommand) ensureNoConflictWithBuiltinVersion() { for _, f := range sc.Flags { if f.LongName == versionFlagLongName { sc.exitBecauseOfVersionFlagConflict(f.LongName) } - if f.ShortName == versionFlagLongName { + if f.ShortName == versionFlagShortName { sc.exitBecauseOfVersionFlagConflict(f.ShortName) } } } {% endtabs %}\n","permalink":"https://www.boii.xyz/posts/other/onetiny-%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B02-2021-6-25/","summary":"\u003cp\u003e第一次修改别人的东西哈哈\u003c/p\u003e","title":"OneTiny 开发日记2-2021-6-25"},{"content":"开发 OneTiny 时的一点思路\n需求 下载链接 自从买了台二手 Surface 二合一电脑以后，的确效率上去了，可以手写真香，手终于能跟上脑子了。 一开始拿来当出门用的备用机，轻便，但是使用久了以后，渐渐开始有和主力机之间传输文件的需求。 最简单的就是拿个 U 盘拷过来拷过去，一次两次还好，多了就烦了。\n于是经过搜索我发现了 Python 可以通过在命令行输入 python -m http.server 8000 来暂时开启一个共享目录，同一局域网内的主机就可以访问到这个目录的内容。 但是这条命令在 Linux 中可以，在 Windows 下不能执行。\n想想这玩意本质就是开启一个 HTTP 服务，指定当前目录为 HTTP 服务的根目录。刚好学了 Gin 框架，而 Golang 又可以编译独立的可执行文件，还可以交叉编译，于是说干就干开始干活。\n思路 开启一个 HTTP 服务以后，当有人访问时，需要返回目录下的内容。 返回的页面采用最简单的效果，基本没有 CSS 。\nv0.1 版非常简单，程序启动的时候通过 -r 指定目录，没有的话默认当前目录；通过 -p 可以指定程序运行的端口。\n当有人访问时，也就是程序接收到请求，读取目录下所有文件包括目录，交给 HTML 生成器 generateHTML 生成 HTML 内容，然后返回给访问者。\n如果用户点击的是目录，则遍历该目录、生成 HTML，返回； 如果用户点击的是文件，则触发下载行为，将文件传输给访问者。\nv0.1.1 版时重构了 获取IP 函数，解决了 Windows 下给出的无效 IP 的问题，并修复了下载文件异常的问题。\n到这里 OneTiny 作为一个局域网 FTP 工具已经可以提供稳定的服务了。\n但是只能单向下载文件还不够，如果能上传就好了，有来有回。\n于是 v0.2 版新增了上传功能，并且在 HTML 部分增加了显示文件大小、返回上一级目录的链接。\n这一版在新增功能的时候做了一部分重构。由于 0.1 版直接获取请求路径中的参数导致代码耦合度非常高，所以创建了一个 FileStruction 的模型，用于存储文件的绝对路径、相对路径、文件大小等信息。\nv0.2.1 版的时候觉得，有时候开放一个目录供人下载文件，但不希望对方上传文件上来，所以需要一个开关来设置是否允许上传。于是增加了 -a 的参数，默认不可以上传，除非加上 -a 参数才会在客户端展示的时候展示出上传框。\nv0.2.2 版对整个程序做了较大幅度的重构，将一些全局的变量移动到 config 包，然后把启动 Gin 实例的部分移动到 start 包，并做了对 -p 、-r 参数的校验，避免用户指定系统预留的端口，或者输入一个不存在的目录作为访问根目录。还另外增加了 color 包用于控制台彩色打印（windows 除外）。\n后记 这是我的第一个规范使用 Git 维护的独立项目，源自自身实际需求。 虽然市面上有许多现成的好看的功能更强大的 FTP 工具，但是我觉得那些太复杂，且需要安装等等。 我更愿意使用一个简简单单的只负责在局域网内的设备间传输文件的工具，除了必要的功能不添加太多复杂的功能，所以连界面也采用最简单的 “裸 HTML” 。 （我也不喜欢把时间花在写出华丽的界面上，而更愿意把时间拿来完善和增强本身的功能）\n简单、专注、无需安装，这些是 OneTiny 的特点，也是 OneTiny 的局限。 我希望除了图形界面版本，OneTiny 能一直保持这种大道至简的风格，专注与局域网 FTP 这个职责即可。\nДавай!\nTodo 上传功能 自动检查更新功能 密码验证功能（防止局域网内监听） 增加图形界面（使用 fyne） 限定访问层级 限定允许上传位置 大文件多线程下载 断点续传 版本历史 2021-06-16 0.2.1 -\u0026gt; 0.2.2 Refactor: 对gin实例启动部分进行重构，移动至 start 包内；新增 config 包 Style：控制台增加彩色打印（windows除外） Fix: 增加 flag 参数的验证 2021-06-16 v0.2 -\u0026gt; v0.2.1 Feat: 新增 允许上传 flag -a 2021-06-11 v0.1.1 -\u0026gt; v0.2 Feat: 新增上传功能 Style: 文件列表增加 文件大小，增加返回上一级目录链接 2021-06-11 v0.1 -\u0026gt; v0.1.1 Fix: 修复了下载文件异常 Refactor: 重构了获取IP函数 2021-06-11 nil -\u0026gt; v0.1 首个版本，具有局域网内单向共享文件的功能，未具有上传功能。 可通过 -p 指定端口，通过 -r 指定目录 ","permalink":"https://www.boii.xyz/posts/other/onetiny-%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B01-2021-6-22/","summary":"\u003cp\u003e开发 OneTiny 时的一点思路\u003c/p\u003e","title":"OneTiny 开发日记1-2021-6-22"},{"content":"So easy~\n操作方法 效果：点击下载\n在source目录下，新建download目录，和_posts、About、tags、categories等目录并列 将你需要分享的文件或者需要展示的图片之类，统一放到该download下 在写文章时，通过诸如 [点击下载](/download/xx.exe) 这样的链接，直接写入。其他，照旧 在 {% btn volantis主题, https://volantis.js.org/ %}下，可以这样写 {% btn 点击下载, /download/xx.exe, fas fa-download %} 注意：\n全半角不要搞错。 必须是压缩文件（.exe | .zip | .rar | 7z |\u0026hellip;），否则跳过去直接给你展示了不会触发下载的。 ","permalink":"https://www.boii.xyz/posts/hexo/hexo-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD/","summary":"\u003cp\u003eSo easy~\u003c/p\u003e","title":"Hexo-文件下载功能"},{"content":"Vue 的细节是真的多.\nv-text 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{{msg}}\u0026lt;/span\u0026gt; 等价于 \u0026lt;span v-text=\u0026#34;msg\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { msg: \u0026#39;Hello World !\u0026#39;, } }); \u0026lt;/script\u0026gt; // 显示结果 ==\u0026raquo;\nHello World 等价于 Hello World.\nv-once 形式: v-once\n值: 无\n作用: 限定所在元素只被渲染一次, 完成后即使值更新了也不再渲染\n不管是用 v-text = \u0026ldquo;msg\u0026rdquo; 还是用 {{msg}} 都会实时的更新,也就是当msg 的值改变的时候, 显示的结果也会改变.\n如果只想渲染一次, 可以加上v-once\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{{msg}}\u0026lt;/span\u0026gt; 不等价于 \u0026lt;span v-text=\u0026#34;msg\u0026#34; v-once\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { msg: \u0026#39;Hello World !\u0026#39;, } }); app.msg = \u0026#34;Hello\u0026#34; \u0026lt;/script\u0026gt; 显示结果 ==\u0026raquo;\nHello World 不等价于 Hello\nv-html 形式: v-html = \u0026ldquo;variable\u0026rdquo;\n值: variable -\u0026gt; string, 取自于data{} 里的属性\n! WARN: 容易导致XSS攻击. 所以, 只在可信内容上使用. 永不用在用户提交的内容上。\n作用: 更新元素的innerHTML. 内容按普通的HTML插入, 不会被编译\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;span v-html=\u0026#34;dodo\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { dodo: \u0026#39;\u0026lt;h2\u0026gt;Hello\u0026lt;/h2\u0026gt;\u0026#39; } }); \u0026lt;/script\u0026gt; \u0026lt;!-- 渲染结果 =\u0026gt;\u0026gt; --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;span v-html=\u0026#34;dodo\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;Hello\u0026lt;/h2\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!--显示结果 ==\u0026gt;\u0026gt; --\u0026gt; Hello v-on 形式： v-on:event[.qualifier] = \u0026ldquo;Function | Inline statements | Object\u0026rdquo;\n缩写： @event[.qualifier] = \u0026ldquo;Function | Inline statements | Object\u0026rdquo;\n值：\nevent -\u0026gt; 要监听的事件， 如click， keyup等 qualifier -\u0026gt; 修饰符，监听事件做一些限定 methods -\u0026gt; 当所监听的事件触发时的响应方法 Inline statements -\u0026gt; 内联语句 Object -\u0026gt; [2.4.0]新增，使用键值对对象作为响应事件，但是不支持任何修饰器 作用： 绑定监听事件。事件类型由event参数指定，\n修饰符：\n.stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .capture - 添加事件侦听器时使用 capture 模式。 .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。 .native - 监听组件根元素的原生事件。 .once - 只触发一次回调。 .left - (2.2.0) 只当点击鼠标左键时触发。 .right - (2.2.0) 只当点击鼠标右键时触发。 .middle - (2.2.0) 只当点击鼠标中键时触发。 .passive - (2.3.0) 以 { passive: true } 模式添加侦听器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!--方法处理器--\u0026gt; \u0026lt;button v-on:click=\u0026#34;Function1\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;!-- 动态事件（2.6.0+） --\u0026gt; \u0026lt;button v-on:[event]=\u0026#34;dosth\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;!-- 内联语句 --\u0026gt; \u0026lt;button v-on:click=\u0026#34;dosth(\u0026#39;hello\u0026#39;, $event)\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;!-- 缩写 --\u0026gt; \u0026lt;button @click=\u0026#34;dosth\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;!-- 停止冒泡 --\u0026gt; \u0026lt;button @click.stop=\u0026#34;dosth\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;!-- 阻止默认行为 --\u0026gt; \u0026lt;button @click.prevent=\u0026#34;dosth\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;!-- 没有表达式的阻止默认行为 --\u0026gt; \u0026lt;form @click.prevent\u0026gt;\u0026lt;/form\u0026gt; \u0026lt;!-- 串联修饰符 --\u0026gt; \u0026lt;button @click.stop.prevent=\u0026#34;dosth\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;!-- 键修饰符.键名 --\u0026gt; \u0026lt;button @keyup.enter=\u0026#34;onEnter\u0026#34;\u0026gt; \u0026lt;!-- 键修饰符.键码 --\u0026gt; \u0026lt;button @keyup.13=\u0026#34;onEnter\u0026#34;\u0026gt; \u0026lt;!-- 点击回调只触发一次 --\u0026gt; \u0026lt;button @click.once=\u0026#34;dosth\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;!-- 对象语法（2.4.0+） --\u0026gt; \u0026lt;button v-on=\u0026#34;{keyup: dosthA, keydown: dosthB\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; v-bind 形式： v-bind:AttributeOrProperty[.qualifier] = \u0026ldquo;value\u0026rdquo;\n缩写： :AttributeOrProperty=\u0026ldquo;value\u0026rdquo;\n值：\nAttributeOrProperty -\u0026gt; 标签的原生属性或特性 value -\u0026gt; 标签原生属性所对应的值 作用：将属性或特性与变量绑定在一起，实现动态修改\n修饰符：\n.prop - 作为一个 DOM property 绑定而不是作为 attribute 绑定。(差别在哪里？) .camel - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。(从 2.1.0 开始支持) .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;!-- 绑定一个属性 --\u0026gt; \u0026lt;img v-bind:src=\u0026#34;imageSrc\u0026#34;\u0026gt; \u0026lt;!-- 动态 attribute 名 (2.6.0+) --\u0026gt; \u0026lt;button v-bind:[key]=\u0026#34;value\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;!-- 缩写 --\u0026gt; \u0026lt;img :src=\u0026#34;imageSrc\u0026#34;\u0026gt; \u0026lt;!-- 动态 attribute 名缩写 (2.6.0+) --\u0026gt; \u0026lt;button :[key]=\u0026#34;value\u0026#34;\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;!-- 内联字符串拼接 --\u0026gt; \u0026lt;img :src=\u0026#34;\u0026#39;/path/to/images/\u0026#39; + fileName\u0026#34;\u0026gt; \u0026lt;!-- class 绑定 --\u0026gt; \u0026lt;div :class=\u0026#34;{ red: isRed }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div :class=\u0026#34;[classA, classB]\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div :class=\u0026#34;[classA, { classB: isB, classC: isC }]\u0026#34;\u0026gt; \u0026lt;!-- style 绑定 --\u0026gt; \u0026lt;div :style=\u0026#34;{ fontSize: size + \u0026#39;px\u0026#39; }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div :style=\u0026#34;[styleObjectA, styleObjectB]\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 绑定一个有属性的对象 --\u0026gt; \u0026lt;div v-bind=\u0026#34;{ id: someProp, \u0026#39;other-attr\u0026#39;: otherProp }\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 通过 prop 修饰符绑定 DOM 属性 --\u0026gt; \u0026lt;div v-bind:text-content.prop=\u0026#34;text\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--\u0026gt; \u0026lt;my-component :prop=\u0026#34;someThing\u0026#34;\u0026gt;\u0026lt;/my-component\u0026gt; \u0026lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --\u0026gt; \u0026lt;child-component v-bind=\u0026#34;$props\u0026#34;\u0026gt;\u0026lt;/child-component\u0026gt; \u0026lt;!-- XLink --\u0026gt; \u0026lt;svg\u0026gt;\u0026lt;a :xlink:special=\u0026#34;foo\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/svg\u0026gt; v-model 形式： v-model[.qualifier] = \u0026ldquo;variable\u0026rdquo;\n值：variable -\u0026gt; 双向数据绑定的变量，通过这个变量实现数据与视图之间的绑定\n! WARN: 只能在 \u0026lt;input\u0026gt;、\u0026lt;select\u0026gt;、\u0026lt;textarea\u0026gt; 和组件上使用\n作用： 实现双向数据绑定\n修饰符：\n.lazy - 取代 input 监听 change 事件, 懒加载，会等到失焦才更新 .number - 输入字符串转为有效的数字，限制只有数字有效， 但是如果先输入字符串则该修饰符无效 .trim - 输入首尾空格过滤 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;p\u0026gt;{{msg}}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;v-model.lazy\u0026lt;input type=\u0026#34;text\u0026#34; v-model.lazy=\u0026#34;msg\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { msg: \u0026#39;Hello World !\u0026#39; } }); \u0026lt;/script\u0026gt; 加了lazy修饰符， 所以会等到input输入框失去焦点才渲染更新\n","permalink":"https://www.boii.xyz/posts/vue/vue-note-day2/","summary":"\u003cp\u003eVue 的细节是真的多.\u003c/p\u003e","title":"VUE-note-day2"},{"content":"疫情在家真的无聊 T_T，学点Vue吧\nv-if \u0026amp; v-else-if \u0026amp; v-else v-if 形式: v-if = \u0026ldquo;express | variable\u0026rdquo;\n值: true -\u0026gt; 渲染1 | false -\u0026gt; 不渲染\n作用: vue的一个内部指令, 用在html标签中, 作为标签的一个属性. 用来判断是否渲染所在的标签.\n其作用相当于C语言中的 if判断语句\n1 2 3 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div v-if=\u0026#34;isLogin\u0026#34;\u0026gt;欢迎来到XXX.\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 1 2 3 4 5 6 7 8 \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { isLogin: true } }); \u0026lt;/script\u0026gt; v-else-if [2.1.0新增] 形式: v-else-if = \u0026ldquo;express | variable\u0026rdquo;\n值: true -\u0026gt; 渲染 | false -\u0026gt; 不渲染\n! WARN: 必须紧跟在 v-if 或 v-else-if后面, 否则将不被识别.\n作用: 其作用相当于C语言中的 else if 判断语句.\nv-else 形式: v-else\n值: 无\n作用: 同 v-if 一样, vue的一个内部指令, 用在html标签中.\n! WARN: 必须紧跟在 v-if 或 v-else-if后面, 否则将不被识别.\n综合示例 1 2 3 4 5 6 7 \u0026lt;div v-if=\u0026#34;type === \u0026#39;A\u0026#39;\u0026#34;\u0026gt; A \u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;type === \u0026#39;B\u0026#39;\u0026#34;\u0026gt; B \u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;type === \u0026#39;C\u0026#39;\u0026#34;\u0026gt; C \u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt; Not A/B/C \u0026lt;/div\u0026gt; key 管理可复用元素 形式: key = \u0026ldquo;unique-value\u0026rdquo;\n值: 不固定, 只要是全局唯一即可\n作用: vue为了高效渲染使得加载速度变快, 会复用已有元素, 有时候有的元素虽然相同但是我们不想被复用, 可以在元素中添加key属性来避免被vue复用. 使用了key属性的元素会被重新渲染而不是复用\n官网示例 1 2 3 4 5 6 7 8 \u0026lt;template v-if=\u0026#34;loginType === \u0026#39;username\u0026#39;\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input placeholder=\u0026#34;Enter your username\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-else\u0026gt; \u0026lt;label\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;input placeholder=\u0026#34;Enter your email address\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; 这个例子, 如果input 输入框内有内容, 在切换的时候不会被清空, 因为被vue复用了.\n1 2 3 4 5 6 7 8 \u0026lt;template v-if=\u0026#34;loginType === \u0026#39;username\u0026#39;\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Username\u0026lt;/label\u0026gt; \u0026lt;input placeholder=\u0026#34;Enter your username\u0026#34; key=\u0026#34;username-input\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-else\u0026gt; \u0026lt;label\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;input placeholder=\u0026#34;Enter your email address\u0026#34; key=\u0026#34;email-input\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; 而这个例子, 如果\u0026lt;input\u0026gt;输入框内有内容, 在切换时会被清空, 因为不会被复用而是重新渲染. 但是 \u0026lt;label\u0026gt;依然会被高效复用, 因为没有key属性.\nkey属性作用: 避免被复用, 使之重新渲染\nv-show 形式: v-show = \u0026ldquo;express | variable\u0026rdquo;\n值: true -\u0026gt; 显示2 | false -\u0026gt; 不显示\n作用: vue的一个内部指令, 用在html标签中, 用于判断所在标签是否显示, 而不是是否渲染\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1 v-show=\u0026#34;right\u0026#34;\u0026gt;Hello!\u0026lt;/h1\u0026gt; \u0026lt;!--当right为true时, 该标签会被显示, 为false时不显示--\u0026gt; \u0026lt;h2 v-show=\u0026#34;status === 1\u0026#34;\u0026gt; 当status为1时显示 \u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data:{ right: true, status: 2 } }); \u0026lt;/script\u0026gt; 渲染后的结果: \u0026lt;h1 style=\u0026#34;display:block;\u0026#34;\u0026gt;Hello!\u0026lt;/h1\u0026gt; \u0026lt;h2 style=\u0026#34;display:none;\u0026#34;\u0026gt; 当status为1时显示 \u0026lt;/h2\u0026gt; v-if VS v-show 渲染:\nv-if 是**“真正”的条件渲染**，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\nv-show只是简单地基于 CSS 进行切换。\n渲染时机:\nv-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。\nv-show 就简单得多——不管初始条件是什么，元素总是会被渲染，\n开销:\nv-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。 因此:\n如果需要非常频繁地切换，则使用 v-show 较好；\n如果在运行时条件很少改变，则使用 v-if 较好。\nv-for 数组作为数据源 形式: 渲染一个数组\nv-for = \u0026ldquo;alias in source\u0026rdquo; 或 v-for = \u0026ldquo;alias of source\u0026rdquo; v-for = \u0026ldquo;(alias, index) in source\u0026rdquo; 值:\nsource -\u0026gt; 数据源, 是一个数组 alias -\u0026gt; 别名, 遍历时的临时变量 index -\u0026gt; 索引(下标), 默认的, 可以取别的名, 但是约定俗成是 index ! WARN:\n别名和索引的位置不能换. 即使换了解释器也默认按照 第一个参数是临时变量, 第二个参数是索引, in 后面的参数是数据源 的规则来解释 哪个元素要被循环渲染就写在哪个元素里作为它的属性. 作用: 将数组里的每一个值渲染到标签的插值3中.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;age in DemoArray\u0026#34;\u0026gt;{{age}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { DemoArray: [20, 30, 44, 10, 33] } }); \u0026lt;/script\u0026gt; // 渲染结果=\u0026gt;\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;20\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;30\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;44\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;10\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;33\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; // 显示结果 ==\u0026raquo;\n20 30 44 10 33 排序 计算的工作都在computed里完成\n排序实现在vue对象中的computed, 但是computed里的键名不能和data里的键名相同. 而我们要按排序后的数组渲染, 所以 html 里要改成 v-for = \u0026ldquo;age in sortArray\u0026rdquo;\n1 2 3 4 5 6 7 8 9 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;age in DemoArray\u0026#34;\u0026gt;{{age}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; ... \u0026lt;/script\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { DemoArray: [20, 30, 44, 10, 33] }, computed: { /** 错误写法. 键名重复 DemoArray: function(){ return this.DemoArray.sort((a, b) =\u0026gt; a - b); } */ sortItems: function(){ return this.DemoArray.sort((a, b) =\u0026gt; a - b); } } }); \u0026lt;/script\u0026gt; 因为 javascript 自带的 bug, 对数组排序 DemoArray.sort()是把每个数组元素的最前面的一位4, 所以排序出来是有问题的.\n导致这个 bug 的原因我猜想是因为 js 是弱类型语言, 解释器也不知道你这个数组里到底是字符串还是数字还是什么, 又得给你排序, 所以干脆统统按 给字符串排序 的方法处理.\n修复方法就是自己实现一个函数. 上述代码中用了箭头函数使得更加简洁. 关键代码即 (a, b) =\u0026gt; a - b\n数组更新 会修改原数组的方法: 变异方法 push() pop() shift() unshift() splice() sort() reverse() 通过这些方法修改数组, 会触发视图的更新.\n不会修改原数组的方法: 非变异方法 filter() concat() slice() 它们不会改变原始数组，而返回一个新数组。\n当使用非变异方法时，可以用新数组替换旧数组：\n1 2 3 4 5 6 7 8 9 10 11 var app = new Vue ({ el: \u0026#39;#app\u0026#39;, data:{ items: [ {msg: \u0026#34;m1\u0026#34;}, {msg: \u0026#34;m2\u0026#34;} ] } }); // 替换 app.items = app.items.filter( item =\u0026gt; item.items.match(/mmm/) ) ; ? 这里不清楚怎么实现的, 但是官网的说法是: 并非丢弃现有DOM而重新渲染整个列表, 因为Vue里有些智能的方法, 所以, 数组在改动不大的情况下去替换原有数组的非常高效的, 不必担心.\n至于怎么个智能法没说, 有待深挖.\n数组更新的注意事项 问题: 由于不靠谱的JavaScript的限制, 以下两种方法的更新Vue是无法检测到的\n利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 修改数组的长度时，例如：vm.items.length = newLength 1 2 3 4 5 6 7 8 var app = new Vue({ ... data: { array: [0,1,2,3,4,5,6,7,8] } }); app.array[3] = 10\t//Vue 检测不到更新, 也不会触发视图更新 app.array.length = 8\t//Vue 检测不到更新\t解决: 问题1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Vue.set(vm.items, indexOfItem, newValue), // 例如: Vue.set(app.array, 2, 10) // ==\u0026gt;\u0026gt; [0,1,10,3,4,5,6,7,8] 或 vm.items.splice(indexOfItem, 1, newValue), // 例如: app.array.splice(3, 1, 50) // ==\u0026gt;\u0026gt; [0,1,2,50,4,5,6,7,8] // 关于这个1,可以是任何数, // 0则不吃掉任何元素, // 1则吃掉array[indexOfItem]那个元素, // 2则吃掉array[indexOfItem] 和 array[indexOfItem + 1]两个元素 // 以此类推 // 例如: app.array.splice(2,2,30) // ==\u0026gt;\u0026gt; [0,1,30,5,6,7,8] 或 vm.$set(vm.items, indexOfItem, newValue) // 例如: app.$set(app.array, 2, 10) // ==\u0026gt;\u0026gt; [0,1,10,3,4,5,6,7,8] 解决: 问题2 1 app.array.splice(新长度值) 对象作为数据源 形式: 渲染一个对象\nv-for = \u0026ldquo;value in object\u0026rdquo; v-for = \u0026ldquo;(value, key) in object\u0026rdquo; v-for = \u0026ldquo;(value, key, index) in object\u0026rdquo; 值:\nobject -\u0026gt; 数据源, 是一个对象, 要遍历的是它的所有属性 value -\u0026gt; 别名, 遍历时的临时变量, 输出的是每一个属性的值 key -\u0026gt; 索引(键名), 默认的, 可以取别的名, 但是约定俗成是 key, 输出的是每一个属性(键值对)的键名 index -\u0026gt; 索引(下标), 默认的, 可以取别的名, 约定俗成是index, 输出的是每一个属性的下标5. ! WARN:\n和遍历数组一样, 键名索引和下标索引的位置不要换. 即使换了解释器也是按照 第一个参数是临时变量,第二个参数是键名索引, 第三个参数是下标索引, in 后面是数据源的规则解释. 哪个元素要被循环渲染就写在哪个元素里作为它的属性. 作用: 将对象里的每一个属性(键值对)的值渲染到标签的插值3中.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li v-for=\u0026#34;(val, key, idx) in obj\u0026#34;\u0026gt;{{idx}}-{{key}}-{{val}}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { obj:{ prop1: \u0026#39;key1\u0026#39;, prop2: 20, prop3: true } } }); \u0026lt;/script\u0026gt; // 渲染结果 =\u0026gt;\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;0-prop1-key1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;1-prop2-20\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;2-prop3-true\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; // 显示结果 ==\u0026raquo;\n0-prop1-key1 1-prop2-20 2-prop3-true 对象更新的注意事项 问题: 由于不靠谱的JavaScript的限制, 对象属性的添加或删除 Vue是检测不到的\n1 2 3 4 5 6 7 8 var app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { a: 1 } }); app.b = 2 // Vue检测不到, 不会更新视图 解决方法 app.a app.b 这里a和b叫做根级别响应式属性, 是不允许动态添加的, 但是根级别属性的属性是可以动态添加的.\n1 2 3 4 5 6 7 8 var app = new Vue({ el: \u0026#39;#app\u0026#39;, data: { root:{ child: 1 } } }); // app.root 不允许动态添加, app.root.child允许动态添加 添加单个属性的方法\n1 2 3 4 5 6 7 8 Vue.set(rootAttribute, childKey, childValue) // 例如: Vue.set(app.root, \u0026#39;age\u0026#39;, 10) // ==\u0026gt;\u0026gt; data: { //\troot: { child: 1, age: 10} //\t} 或 vm.$set(rootAttribute, childKey, childValue) // 例如: app.$set(app.root, \u0026#39;age\u0026#39;, 10) 添加多个属性的方法: 使用 Object.assign() 或 _.extend()\n1 app.root = Object.assign({}, app.root, { age: 27, favoriteColor: \u0026#39;Vue Green\u0026#39; }) 数组对象作为数据源的排序 计算处理同样是在computed中.\n重新定义一个函数, 并作出处理\n在v-for调用时 把数据源换成刚刚定义的函数名\n1 2 3 4 5 6 7 8 computed: { ... //数组对象方法排序: sortStudents: function () { var key = \u0026#34;age\u0026#34;; return this.students.sort((a, b) =\u0026gt; a[key] \u0026lt; b[key] ? -1 : (a[key] \u0026gt; b[key] ? 1 : 0)) } } 范围作为数据源 形式: 渲染一个对象\nv-for = \u0026ldquo;value in object\u0026rdquo; v-for = \u0026ldquo;(value, key) in object\u0026rdquo; v-for = \u0026ldquo;(value, key, index) in object\u0026rdquo; 值:\nobject -\u0026gt; 数据源, 是一个对象, 要遍历的是它的所有属性 value -\u0026gt; 别名, 遍历时的临时变量, 输出的是每一个属性的值 key -\u0026gt; 索引(键名), 默认的, 可以取别的名, 但是约定俗成是 key, 输出的是每一个属性(键值对)的键名 index -\u0026gt; 索引(下标), 默认的, 可以取别的名, 约定俗成是index, 输出的是每一个属性的下标5. ! WARN:\n和遍历数组一样, 键名索引和下标索引的位置不要换. 即使换了解释器也是按照 第一个参数是临时变量,第二个参数是键名索引, 第三个参数是下标索引, in 后面是数据源的规则解释. 哪个元素要被循环渲染就写在哪个元素里作为它的属性. 作用: 将对象里的每一个属性(键值对)的值渲染到标签的插值3中.\n形式: v-for=\u0026quot; n in range\u0026quot;\n值:\nn -\u0026gt; 别名, 遍历时的临时变量 range -\u0026gt; 数据源, 遍历的范围 1 2 3 \u0026lt;div\u0026gt; \u0026lt;span v-for=\u0026#34;n in 10\u0026#34;\u0026gt;{{ n }} \u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 显示结果 ==\u0026raquo;\n1 2 3 4 5 6 7 8 9 10\nv-for 和 v-if 一起用时 尽量不要把v-for 和 v-if 放在同一个标签里\n但他们处在同一个标签内时, v-for 的优先级比 v-if 高\n1 2 3 4 \u0026lt;!--尽量不要--\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34; v-if=\u0026#34;!todo.isComplete\u0026#34;\u0026gt; {{ todo }} \u0026lt;/li\u0026gt; 1 2 3 4 5 6 7 \u0026lt;!--上面是特殊情况下的写法, 下面是正常情况下的规范写法--\u0026gt; \u0026lt;ul v-if=\u0026#34;todos.length\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;todo in todos\u0026#34;\u0026gt; {{ todo }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;p v-else\u0026gt;No todos left!\u0026lt;/p\u0026gt; 渲染, 加载完DOM树之后就开始在页面上加载, 这个过程叫做渲染\u0026#160;\u0026#x21a9;\u0026#xfe0e;\ndisplay: block\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n插值, HTML标签中间用 {{ 插值 }} 包起来的地方\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n如果是字符串就,第一位就是第一个字符; 如果是数字,第一位就是最大位的那个数字, 比如39的第一位是3\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n对象中的属性都是键值对, 属性的下标从0开始, 先定义的属性(键值对)下标就靠前\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDOM树, 全部html标签的树状结构\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://www.boii.xyz/posts/vue/vue-note-day1/","summary":"\u003cp\u003e疫情在家真的无聊 T_T，学点Vue吧\u003c/p\u003e","title":"VUE-note-day1"},{"content":"哀悼日-全站变灰的实现 前言 作为一个关心家国大事的青年，在国家有难时因争相出手付出举手之劳，虽然现在时和平年代，但是也会经历 918公祭日、哀悼日等。\n每到这些日子，警报响彻神州, 江水呜咽，山川悲鸣; 大江南北，长城内外，国家以最高的祭奠向英雄哀悼，人民以最深的怀念为英雄送行。\n除了现场祭奠，线上我们也想表达自己对那些烈士、英雄和逝世同胞的深切哀悼，那么可以通过全站变灰的方式，遮去往日绚烂的色彩，跳脱的动效为他们沉寂。\n下面将介绍如何让全站变灰。\n青铜操作 作为 铂金CV工程师\n{% note green, 先来一顿 青铜段 操作: %}\n用最广告的引擎搜索: 全站变灰 点进广告最多的论坛, 将关键代码进行数据读取: Ctrl + C 来到自己的站点启动全站检测: F12 找到html标签, 在style面板中进行数据写入: Ctrl + V 完美~\n白银操作 {% note gray, 接下来就要进行 白银段 操作了: %}\n这里我用的是Volantis这个主题, 你要找到你自己主题里生成 \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt;标签的那个文件.\n进入网站根目录, 找到 themes\\volantis\\layout_partial\\head.ejs 在 \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; 标签内添加 {% codeblock themes\\volantis\\layout_partial\\head.ejs lang:css %} {% endcodeblock %}\n保存,推送: hexo g -d 做到这里其实就够了. 但是你也可以进阶一下\n黄金操作 {% note yellow, 再来顿 黄金段 操作: %}\n在刚刚添加 \u0026lt;style\u0026gt;...\u0026lt;/style\u0026gt; 标签外面再套上一句ejs的判断语句 {% codeblock themes\\volantis\\layout_partial\\head.ejs lang:css mark:1,12 %} \u0026lt;% if (theme.style.mourn) { %\u0026gt; \u0026lt;% } %\u0026gt; {% endcodeblock %}\n在你的主题目录的配置文件 themes\\volantis\\_config.yml 中, 添加 mourn: true {% codeblock themes\\volantis_config.yml lang:yaml mark:3 %} style: \u0026hellip; mourn: true # 哀悼: 全站变灰 {% endcodeblock %} 保存,推送: hexo g -d 这样当你要关掉的时候就不用再跑去head.ejs中删除了, 直接在主题配置文件中把mourn: false 就行了.\n{% span green, 开启 -\u0026gt; mourn: true %}\n{% span red, 关闭 -\u0026gt; mourn: false %}\n也可以把mourn放到最外层, 只要让 mourn字段 前面没有空格就行, 相应的 \u0026lt;% if (theme.style.mourn) { %\u0026gt; 要改成 \u0026lt;% if (theme.mourn) { %\u0026gt;\n这是yaml的语法, 不懂的出门左转\n铂金操作 {% note cyan, 最后是 铂金段 操作 %}\n推送毕竟需要时间, 如果我们想要实现准时准点时间一到自动全站变灰,那就要升级下操作了. 只需要把刚刚的代码修改一下.\n{% codeblock themes\\volantis\\layout_partial\\head.ejs lang:css mark:1,2,3,4,5,6,7 %} \u0026lt;% if (theme.style.mourn.switch){ %\u0026gt; \u0026lt;% var startTime = Date.parse(theme.style.mourn.startTime.replace(/-/g, \u0026ldquo;/\u0026rdquo;)); %\u0026gt; \u0026lt;% var endTime = Date.parse(theme.style.mourn.endTime.replace(/-/g, \u0026ldquo;/\u0026rdquo;)); %\u0026gt; \u0026lt;% var currentTime = Date.now(); %\u0026gt; \u0026lt;% } %\u0026gt; \u0026lt;% if (currentTime \u0026gt; startTime \u0026amp;\u0026amp; currentTime \u0026lt; endTime) { %\u0026gt; \u0026lt;% } %\u0026gt; {% endcodeblock %}\n然后配置中改成: {% codeblock themes\\volantis_config.yml lang:yaml mark:4,5,6 %} style: \u0026hellip; mourn: # 哀悼: 全站变灰 switch: true startTime: \u0026lsquo;2020-4-4 0:0:0\u0026rsquo; endTime: \u0026lsquo;2020/4/5 0:0:0\u0026rsquo; {% endcodeblock %} 这样只需要填写好开启关闭的时间, 然后打开开关{% span green, switch: true %}即可\n{% noteblock guide red %}\n日期用-或者/分隔都可以, 因为ejs中有做格式化 时间一定要用(英文)冒号:分隔 日期和时间之间要有空格隔开 个位数不要添加前缀, 比如凌晨三点要写 3:0:0, 不要写成 03:00:00 {% endnoteblock %} 心得 之前配置主题的时候小心翼翼, 生怕一不小心弄错了就头大. 折腾了一段时间积攒了一些经验\n{% noteblock guide blue%}\n{% p subtitle, 一. 边预览边修改 %}\n可以使用命令{% span blue, hexo s %} 开启本地预览, 在浏览器输入{% span cyan, localhost:4000 %}开启本地预览 开启后cmd窗口放在一旁, 在编辑器中做修改, hexo server 一直监听着变化, 每次保存都会自动编译 只需要在浏览器里刷新一下就可以看到结果. 有什么编译错误cmd窗口里也会实时的显示出来. {% p subtitle, 二. 学会看报错信息 %}\n常见的报错信息就那么几个单词, 不懂的翻译一下, 知道错在哪里, 然后思考为什么会错误, 一步步修改, 慢慢的一点点积累就会成长.\n{% p subtitle, 三. YAML是个好东西 %} 掌握了yaml语法以后, 就可以自由的添加自己想要的配置. 就上面的修改全站变灰为例, 说白了就是找到自己想要的效果的代码, 然后在ejs里做判断, ejs和yaml配合, 就可以作出自己想要的效果了.\n{% endnoteblock %}\n","permalink":"https://www.boii.xyz/posts/hexo/%E5%85%A8%E7%AB%99%E5%8F%98%E7%81%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/","summary":"\u003ch1 id=\"哀悼日-全站变灰的实现\"\u003e哀悼日-全站变灰的实现\u003c/h1\u003e","title":"全站变灰的实现"},{"content":"Note\nHello World 在项目文件夹下新建两个文件: main.html \u0026amp; main.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;!--main.html--\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello World\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1 id=\u0026#34;title\u0026#34;\u0026gt; Hello World ! \u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // main.js const electron = require(\u0026#39;electron\u0026#39;); // 引入electron模块 const app = electron.app; // 创建electron引用 const BrowserWindow = electron.BrowserWindow; // 创建窗口引用 let mainWindow = null; // 声明要打开的主窗口 app.on(\u0026#39;ready\u0026#39;, () =\u0026gt; { mainWindow = new BrowserWindow({ // 设置打开的窗口大小 width: 800, heigth: 500 }); mainWindow.loadFile(\u0026#39;main.html\u0026#39;); // 加载html页面 mainWindow.on(\u0026#39;closed\u0026#39;, () =\u0026gt; {\t// 监听窗口关闭事件 mainWindow = null\t// 一定要把窗口设置为null,否则会一直占内存 });\t// 如同C语言申请内存后一定要free释放内存 }); 然后打开cmd命令行, cd到项目的根目录, 执行命令\n1 npm init 项目根目录就会生成一个 package.json 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;name\u0026#34;: \u0026#34;Hello-World\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;main.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;electron .\u0026#34;\t// 这句要自己添加 }, \u0026#34;keywords\u0026#34;: [], \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34; } 然后就可以在 cmd命令行 中执行命令来启动项目\n1 npm start 或者 electron . 效果如下:\n也可以自己添加 main.css 编写样式, 让界面更好看.\n所有命名不固定.\n主进程与渲染进程 主进程 Electron 运行 package.json 的 main属性 的进程被称为主进程\n每个应用只有一个主进程\n作用:\n管理原生GUI , 典型的窗口(BrowserWindow , Tray, Dock, Menu) 创建渲染进程 控制应用生命周期 (app) 模块:\n**(常用): **app , BrowserWindow , ipcMain , Menu , Tray , MenuItem , dialog , Notification , webContents , autoUpdater , globalShortcut , clipboard , crashReporter SystemPreferences , TouchBar , netLog , powerMonitor , inAppPurchase , net , powerSaveBlocker , contentTracing , BrowserView , session , protocol , Screen , shell , nativelmage 渲染进程 展示web页面的进程称为渲染进程 一个应用可以有多个渲染进程 作用: 通过Node.js, Electron提供的API可以跟系统底层打交道 常用模块: **(常用): **ipcRenderer , remote , desktopCapture , clipboard , crashReporter webFrame , shell , nativelmage 进程间通信 通信工具: IPC通信模块\nElectron 提供了IPC通信模块, 主进程的 ipcMain 和渲染进程的 ipcRenderer ipcMain 和 ipcRenderer 都是EventEmitter 对象 从渲染进程到主进程 (render to main) Callbake写法: ipcRenderer.send( channer, \u0026hellip;args) // 渲染进程中发送 ipcMain.on(channel, handler) // 主进程中响应 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Render-process.js const {ipcRenderer} = require(\u0026#39;electron\u0026#39;); ipcRenderer.send(\u0026#39;通信频段名\u0026#39;, 0或N个参数); // Main-process.js ... function handleIPC() { ipcMain.on(\u0026#39;通信频段名\u0026#39;, (err, 0或N个参数) =\u0026gt; { // do something to reply }); } setTimeout(handleIPC, 500); ... Promise写法 (Electron 7.0之后, 处理请求 + 响应模式): ipcRenderer.invoke(channel, \u0026hellip;args) // 渲染进程中发送 ipcMain.handle(channel, handler) // 主进程中响应 从主进程到渲染进程 (main to render) ipcRenderer.on(channel, handler) // 渲染进程中响应 webContents.send(channel) // 主进程中发送 1 2 3 4 5 6 7 8 9 10 11 12 // Main-process.js ... mainWindow = new BrowserWindow({......}); mainWindow.webContents.send(\u0026#39;通信频段名\u0026#39;); ... // Render-process.js const {ipcRenderer} = require(\u0026#39;electron\u0026#39;); ipcRenderer.on(\u0026#39;通信频段名\u0026#39;, (err, 0或N个参数) =\u0026gt; { // do something to reply }) 从渲染进程到渲染进程 (render to render) 页面间通信 页面之间的通信主要做两件事情: 1. 通知事件; 2. 数据共享\n通知事件 ipcRenderer.sendTo( webContentsId, channel, \u0026hellip;args ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // Main-process.js const {app, BrowserWindow, Notification, ipcMain} = require(\u0026#39;electron\u0026#39;); let win1 = null; let win2 = null; app.on(\u0026#39;ready\u0026#39;, () =\u0026gt; { win1 = new BrowserWindow({ width:500, heigth:500, webPreferences:{nodeIntegration:true} }); win1.loadFile(\u0026#39;./win1.html\u0026#39;); win2 = new BrowserWindow({ width:500, heigth:500, webPreferences:{nodeIntegration:true} }); win2.loadFile(\u0026#39;./win2.html\u0026#39;); global.sharedObject = { win2WebContentsId: win2.webContents.id }\t//把win2的id放在全局对象中 }); 1 2 3 4 5 // render1-process.js // sender const {ipcRenderer, remote} = require(\u0026#39;electron\u0026#39;) let win2Id = remote.getGlobal(\u0026#39;sharedObject\u0026#39;).win2WenContentsId\t//获取win2的id ipcRenderer.sendTo(win2Id, \u0026#39;通信频段名\u0026#39;, 0或N个参数)\t// 与win2进行通信 1 2 3 4 5 6 // render2-process.js // responser const {ipcRenderer} = require(\u0026#39;electron\u0026#39;) ipcRenderer.on(\u0026#39;通信频段名\u0026#39;, (err, 0或N个参数) =\u0026gt; {\t// 响应 // do something to reply }); 数据共享 使用web技术( localStorage , sessionStorage , indexedDB ) 调试 渲染进程的调试 用代码打开 Chromiun的开发者工具 1 2 let win = new BrowserWindow(); win.webContents.openDevTools(); 输入命令行 electron . 之后, 在窗口按下快捷键 Ctrl + Shift + i 主进程的调试 Electron 主进程是一个 Node.js 进程。Node.js 在 8 之后引入了 --inspect 参数用于调试，同样也适用于 Electron 主进程：\n1 electron . --inspect 默认会监听 9229 端口，应用启动后，在 Chrome 浏览器（或其他基于 Chromium 开发的浏览器）中打开 chrome://inspect 即可看到对应的调试会话，点击会话链接即可打开 devtools 进行调试。\n另外，可以在命令行参数中指定端口号，实现同时调试多个应用中的多个进程而不产生冲突：\n1 electron . --inspect=1234 步骤 1.开启命令行开关\n启动electron的时候需要带上inspect开关，并配置调试端口.\n有两个开关，分别是 --inspect=[port] 和 --inspect-brk=[port]，区别在于后者会暂停在第一行js代码\n这里建议在 package.json 的 script 字段添加如下内容\n1 2 3 4 5 \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;electron .\u0026#34;, \u0026#34;debug\u0026#34;: \u0026#34;electron . --inspect=5858\u0026#34; // 添加这行 }, 2.设置chrome调试器\n打开chrome，然后新开一个标签进入chrome://inspect ，这里我们要先配置监听的端口，不然的话，Remote Target列表里是不会出现要调试的electron程序的\n\u0026gt;_\n\u0026gt;_\n然后在项目目录下就可以直接使用命令\n1 npm run debug 就可以看到如下画面:\n\u0026gt;_\n3.调试\n点击 inspect 就可以进行调试了.\n在 VSCode 中调试 上述方法均会打开 devtools 界面，所有的调试操作均在 devtools 中进行。对于某些操作比如代码断点调试，可以进一步与编辑器或 IDE 相结合，提升开发体验。以下将简要介绍如何在 VSCode 进行调试。\n以 Electron 官方的模板 electron-quick-start 为例，首先需要为 VSCode 安装一个扩展：Debugger for Chrome（用于调试渲染进程）。克隆代码仓库到本地并安装依赖：\n1 2 3 git clone https://github.com/electron/electron-quick-start.git cd electron-quick-start npm install 然后在仓库中添加文件 .vscode/launch.json，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Main\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;runtimeExecutable\u0026#34;: \u0026#34;C:\\\\Users\\\\用户名\\\\AppData\\\\Roaming\\\\npm\\\\electron\u0026#34;, \u0026#34;runtimeArgs\u0026#34;: [\u0026#34;--remote-debugging-port=9222\u0026#34;, \u0026#34;.\u0026#34;], \u0026#34;windows\u0026#34;: { \u0026#34;runtimeExecutable\u0026#34;: \u0026#34;C:\\\\Users\\\\用户名\\\\AppData\\\\Roaming\\\\npm\\\\electron.cmd\u0026#34; } }, { \u0026#34;name\u0026#34;: \u0026#34;Renderer\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;chrome\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;attach\u0026#34;, \u0026#34;port\u0026#34;: 9222, \u0026#34;webRoot\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34; } ], \u0026#34;compounds\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;All\u0026#34;, \u0026#34;configurations\u0026#34;: [\u0026#34;Main\u0026#34;, \u0026#34;Renderer\u0026#34;] } ] } 注意: Windows系统的路径分隔符要写作 \u0026ldquo;\\\\\u0026rdquo;\nif 普通安装electron\n​\tthen 把\u0026quot;用户名\u0026quot;改成\u0026quot;你系统的用户名\u0026quot;;\nelse 自定义安装electron\n​\tthen 找到你的 electron.cmd;\n​\t复制路径;\n​\t到 json中修改;\nif Linux用户\n​\tthen 系统.路径分隔符 = \u0026ldquo;/\u0026rdquo;\nif (项目根目录/node_modules/.bin/electron).isExist\n​\tthen\n1 2 3 4 \u0026#34;runtimeExecutable\u0026#34;: \u0026#34;${workspaceFolder}/node_modules/.bin/electron\u0026#34;, \u0026#34;windows\u0026#34;: { \u0026#34;runtimeExecutable\u0026#34;: \u0026#34;${workspaceFolder}/node_modules/.bin/electron.cmd\u0026#34; } 然后在 VSCode 左侧选择 debug 面板，启动 All 这一项开始调试，此时就可以在 main.js 或 renderer.js 文件中添加断点了：\n配置文件中的一些要点解释如下：\nconfigurations 中的两项分别对应主进程和渲染进程。compounds 中指定了一个组合会话 All，选择 All 将会同时启动这两个会话。 Renderer 配置中的 webRoot 参数直接使用了 ${workspaceFolder}，是因为在这个工程中，HTML 引用的静态资源位于根目录下。实际使用的时候需要更新到对应的路径才会生效。 实际开发中可能会有编译的流程，比如使用 TypeScript 配合打包工具 Webpack，最终生成的代码与源代码并不在一个路径下。这种情况下需要产出 source map 来建立映射关系。 \u0026gt;_\n经验技巧 少用remote模块\n因为每次remote会触发底层的同步IPC事件, 特别影响性能, 处理的不好容易进程卡死\n不要用sync模式\n一旦写的不好就会整个应用卡死\n在请求+响应的通信模式下,需要自定义超时限制\n在响应的时候需要设置一个时长限制, 当应用响应超时, 需要response一个异常的超时事件让业务处理, 然后去做对应的交互\n","permalink":"https://www.boii.xyz/posts/electron/electron-note/","summary":"\u003cp\u003eNote\u003c/p\u003e","title":"Electron Note"},{"content":"Git Yes!\n经典git关系图\nWorkspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 初始化 刚新建一个项目的时候需要来几条初始化命令\n生成本地仓库 git init\n把工作区的文件提交到暂存区 git add . 或者 git add 文件名\n把暂存区的文件提交到本地仓库 git commit -m \u0026ldquo;描述\u0026rdquo; 这里的描述就是到时候看到的下面的这些\n先给你要提交的远程仓库起个别名 git remote add 仓库别名 Git地址 Git地址如下图所示\n把本地仓库的文件提交到远程仓库（就是github上能看到的那种） git push -u 仓库别名 分支名 分支就是\u0026hellip;.算了这里是傻瓜备忘不想解释\n到这就可以上去github看看了。文件内容都在里面\n第二次提交 第二次提交的时候一般不是整个项目都有变动对吧？ 没事git会自动识别修改过的和没修改过的文件\n可以看看git识别到哪些 git status\n红色的，Umerged，表示工作区有改动的文件，还没提交到暂存区 git文件的四种状态\nuntracked 未被追踪的。就是还没添加过的 unmodified 工作区里已经被追踪了，还没修改 modified 工作区的文件修改了但还没提交到暂存区 staged 添加到了暂存区倒是还没提交到远程仓库 把它提交到暂存区去 git add .\n把它提交到本地仓库去 git commit -m \u0026ldquo;描述\u0026rdquo;\n把它提交到远程仓库去 git push -u 远程仓库别名 分支名\n搞定！\n拉取远程仓库的文件到本地 git pull 远程仓库别名 分支名\n多用户共同开发的时候，新用户可能会在本地新建一个文件夹，然后git init, 接着pull 可能会出现拉取失败，因为git认为这是两个不同的项目，所以拒绝拉取合并，可以加上--allow-unrelated-histories\n1 git pull 仓库别名 分支名 --allow-unrelated-histories 总结 要把代码写完放在github上就等于 你要从山旮旯里寄东西到北京\n工作区 =\u0026gt; 就是你项目的文件夹，你经营的这家客栈 暂存区 =\u0026gt; 就是你这个项目的git索引，你这个村里的驿站 本地仓库 =\u0026gt; 就是你电脑里的一个存储库，你市里的驿站 远程仓库 =\u0026gt; 就是github服务器上面，北京\n你东西收拾好了的时候 得找村里的快递站帮你保管和寄送到市里的快递站 git add . 等你说commit的时候 市里的快递站 就给你 送到省里的快递站 git commit -m \u0026quot;描述\u0026quot; 等你说push的时候 省里的快递站 就给你 送到北京 git push -u 远程仓库别名 分支名\n\u0026gt;_\n","permalink":"https://www.boii.xyz/posts/git/git-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E8%AF%B4%E6%98%8E/","summary":"\u003cp\u003eGit Yes!\u003c/p\u003e","title":"Git-基本操作说明"},{"content":"先把配置文件捋清楚\n前言 SSM框架中有几个比较重要的配置文件，一开始学起来会很模糊，这里做一下整理\n当一个web程序启动时，Tomcat服务器最先会读取 web.xml 文件，这个文件中会启动一些配置，还会启动Spring配置文件**applicationContext.xml** 和SpringMVC配置文件 springMVC-servlet.xml 这两个文件，在运行 applicationContext.xml 的时候会启动MyBatis的配置文件 myBatis.xml，并且会调用到 jdbc.properties 和 log4J.properties 两个资源属性文件里的属性。\nweb.xml 接下来先看看最先启动的 web.xml 是都怎么配置。\n在Spring配置中和在Servlet配置中，就启动了applicationContext 和 SpringMVC-servlet 两个配置文件\n启动applicationContext 1 2 3 4 \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; 启动SpringMVC-servlet 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--部署Servlet分发器 DispatcherServlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springer\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--注册DispatcherServlet的配置文件--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springer-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; 运行到这的时候就会调用到上述两个文件。\n整个文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\u0026#34; id=\u0026#34;WebApp_ID\u0026#34; version=\u0026#34;3.1\u0026#34;\u0026gt; \u0026lt;!--以下配置的加载顺序:先 ServletContext \u0026gt;\u0026gt; context-param \u0026gt;\u0026gt; listener \u0026gt;\u0026gt; filter \u0026gt;\u0026gt; servlet \u0026gt;\u0026gt; spring--\u0026gt; \u0026lt;!-- ==================== 欢迎页配置 ==================== --\u0026gt; \u0026lt;!--配置欢迎页--\u0026gt; \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;index.jsp\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt; \u0026lt;!-- ==================== Spring配置 ==================== --\u0026gt; \u0026lt;!--启动Spinrg 配置文件 applicationContext.xml--\u0026gt; \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \u0026lt;!--配置监听器，加载Spring 配置文件--\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;org.springframework.web.context.ContextLoaderListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; \u0026lt;!-- ==================== Serlvet配置 ==================== --\u0026gt; \u0026lt;!--部署Servlet分发器 DispatcherServlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springer\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--注册DispatcherServlet的配置文件--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springer-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;!--配置DispatcherServlet的作用范围，这里作用于整个web目录--\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springer\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;!-- ==================== 过滤器配置 ==================== --\u0026gt; \u0026lt;!--配置过编码滤器--\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;characterEncodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;!--编码格式：UTF-8--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;UTF-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--是否全部过滤，包括符合格式的文件/请求--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;forceEncoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;true\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;!--配置过滤器的作用范围，这里作用于整个WEB目录--\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;characterEncodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;!-- ==================== 错误页面配置 ==================== --\u0026gt; \u0026lt;!--404错误页面注册--\u0026gt; \u0026lt;error-page\u0026gt; \u0026lt;error-code\u0026gt;404\u0026lt;/error-code\u0026gt; \u0026lt;location\u0026gt;/WEB-INF/jsp/404.jsp\u0026lt;/location\u0026gt; \u0026lt;/error-page\u0026gt; \u0026lt;/web-app\u0026gt; applicationContext.xml 这个文件是第二个启动的配置文件\n在这个文件里主要做了几件事情：\n加载jdbc.properties资源属性文件 配置数据源 配置Mybatis工厂 指定数据源 指定Mybatis配置文件 批量配置Mapper接口 设置需要扫描的dao包 配置sqlSessionFactory对象 添加事务支持 配置事务管理器 配置通知 配置切面 扫描service包 下面一个一个解释：\n1.加载jdbc.properties 1 \u0026lt;context:property-placeholder location=\u0026#34;classpath:jdbc.properties\u0026#34; /\u0026gt; 把连接数据库的一些数据分离出来写在jdbc.properties这个文件中，加载了这个文件就可以使用这些属性\n而在 jdbc.properties 文件中的内容如下（这里演示的是MySQL8.0）:\n1 2 3 4 5 6 7 jdbc.driver=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/transactional?useSSL=false?serverTimezone=Hongkong?characterEncoding=utf-8?autoReconnect=true jdbc.username=root jdbc.password=123456 jdbc.maxTotal=30 jdbc.maxIdle=10 jdbc.initialSize=5 至于如何调用，则在下面的配置数据源中演示\n2.配置数据源 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;bean id=\u0026#34;dSource\u0026#34; class=\u0026#34;org.apache.commons.dbcp2.BasicDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;!-- 最大连接数 --\u0026gt; \u0026lt;property name=\u0026#34;maxTotal\u0026#34; value=\u0026#34;${jdbc.maxTotal}\u0026#34;/\u0026gt; \u0026lt;!-- 最大空闲连接数 --\u0026gt; \u0026lt;property name=\u0026#34;maxIdle\u0026#34; value=\u0026#34;${jdbc.maxIdle}\u0026#34;/\u0026gt; \u0026lt;!-- 初始化连接数 --\u0026gt; \u0026lt;property name=\u0026#34;initialSize\u0026#34; value=\u0026#34;${jdbc.initialSize}\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 在上面已经加载了jdbc.properties，所以在配置数据源的时候直接用 ${属性名} 就可以使用该属性。这样做的好处是，在多处调用 jdbc.properties 里的那些属性的时候，如果要该一个属性比如数据库密码，只需要修改jdbc.properties 中的 jdbc.password 的值就行了。\n3.配置Mybatis工厂 1 2 3 4 5 6 7 8 \u0026lt;!-- 配置MyBatis工厂，同时指定数据源，并与MyBatis完美整合 --\u0026gt; \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;!--指定数据源--\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dSource\u0026#34;/\u0026gt; \u0026lt;!-- configLocation的属性值为MyBatis的核心配置文件 --\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 注意指定数据源的 \u0026lt;property\u0026gt; 标签中的 ref 属性，要和数据源的 id 对应\n在第二个 \u0026lt;property\u0026gt; 中指定和启动了Mybatis的配置文件\n4.配置数据映射接口 数据映射接口，也就是dao，通过Mybatis配置文件映射到数据库操作文件\n1 2 3 4 5 \u0026lt;bean class=\u0026#34;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026#34;\u0026gt; \u0026lt;!-- mybatis-spring组件的扫描器 ，必须写全dao的包名，且只能扫描一个dao包 --\u0026gt; \u0026lt;property name=\u0026#34;basePackage\u0026#34; value=\u0026#34;dao\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;sqlSessionFactoryBeanName\u0026#34; value=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 配置以后，Spring会自动扫描MyBatis的接口并装配（Spring将指定包中所有被@Mapper注解标注的接口自动装配为MyBatis的映射接口）\n在Eclipse中的进行项目的话要写全dao 的包名，比如 com.github.java.dao 这样，而在IDEA中一般会配置好项目的source root 根目录 和 resource root 资源目录，所以写dao包名就好。\n例如我的目录结构，我设置了java为source root 根目录，所以不用写全包名\n5.添加事务支持 1 2 3 4 5 \u0026lt;bean id=\u0026#34;txManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dSource\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 开启事务注解 --\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026#34;txManager\u0026#34; /\u0026gt; 事务支持有很多种方法，这种是基于@Transactional注解的事务管理。\n还有一种是声明式事务管理\n6.扫描service包 1 \u0026lt;context:component-scan base-package=\u0026#34;service\u0026#34;/\u0026gt; 完整文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\u0026#34;\u0026gt; \u0026lt;!--=================== 加载jdbc.properties ===================--\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:jdbc.properties\u0026#34;/\u0026gt; \u0026lt;!--======================== 配置数据源 ========================--\u0026gt; \u0026lt;bean id=\u0026#34;dSource\u0026#34; class=\u0026#34;org.apache.commons.dbcp2.BasicDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;!-- 最大连接数 --\u0026gt; \u0026lt;property name=\u0026#34;maxTotal\u0026#34; value=\u0026#34;${jdbc.maxTotal}\u0026#34;/\u0026gt; \u0026lt;!-- 最大空闲连接数 --\u0026gt; \u0026lt;property name=\u0026#34;maxIdle\u0026#34; value=\u0026#34;${jdbc.maxIdle}\u0026#34;/\u0026gt; \u0026lt;!-- 初始化连接数 --\u0026gt; \u0026lt;property name=\u0026#34;initialSize\u0026#34; value=\u0026#34;${jdbc.initialSize}\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--======================== 配置MyBatis工厂 ========================--\u0026gt; \u0026lt;!-- 配置MyBatis工厂，同时指定数据源，并与MyBatis完美整合 --\u0026gt; \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;!-- configLocation的属性值为MyBatis的核心配置文件 --\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:com/mybatis/mybatis-config.xml\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--======================== Mapper代理 ========================--\u0026gt; \u0026lt;!--Mapper代理开发，使用Spring自动扫描MyBatis的接口并装配（Spring将指定包中所有被@Mapper注解标注的接口自动装配为MyBatis的映射接口） --\u0026gt; \u0026lt;bean class=\u0026#34;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026#34;\u0026gt; \u0026lt;!-- mybatis-spring组件的扫描器 ，必须写全dao的包名，且只能扫描一个dao包 --\u0026gt; \u0026lt;property name=\u0026#34;basePackage\u0026#34; value=\u0026#34;com.dao\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;sqlSessionFactoryBeanName\u0026#34; value=\u0026#34;sqlSessionFactory\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--======================== 扫描Service包 ========================--\u0026gt; \u0026lt;!-- dao包在mybatis-spring组件中已经扫描，这里不再需要扫描 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.service\u0026#34; /\u0026gt; \u0026lt;!--======================== 配置事务支持 ========================--\u0026gt; \u0026lt;!-- 添加事务支持 --\u0026gt; \u0026lt;bean id=\u0026#34;txManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 开启事务注解 --\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026#34;txManager\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt; SpringMVC-servlet.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;controller\u0026#34;/\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;converter\u0026#34;/\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;formatter\u0026#34;/\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;utils\u0026#34;/\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;po\u0026#34;/\u0026gt; \u0026lt;mvc:annotation-driven/\u0026gt; \u0026lt;mvc:resources location=\u0026#34;/css/\u0026#34; mapping=\u0026#34;/css/**\u0026#34;/\u0026gt; \u0026lt;mvc:resources location=\u0026#34;/html/\u0026#34; mapping=\u0026#34;/html/**\u0026#34;/\u0026gt; \u0026lt;mvc:resources location=\u0026#34;/images/\u0026#34; mapping=\u0026#34;/images/**\u0026#34;/\u0026gt; \u0026lt;!--==================== 配置视图解析器 ====================--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34; id=\u0026#34;internalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--==================== 注册类型转换器 ====================--\u0026gt; \u0026lt;bean id=\u0026#34;conversionService\u0026#34; class=\u0026#34;org.springframework.context.support.ConversionServiceFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;converters\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;bean class=\u0026#34;converter.GoodsConverter\u0026#34;/\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--启动类型转换器--\u0026gt; \u0026lt;mvc:annotation-driven conversion-service=\u0026#34;conversionService\u0026#34;/\u0026gt; \u0026lt;!--==================== 注册格式化转换器 ====================--\u0026gt; \u0026lt;bean id=\u0026#34;formattingConversionService\u0026#34; class=\u0026#34;org.springframework.format.support.FormattingConversionServiceFactoryBean\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;formatters\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;bean class=\u0026#34;formatter.GoodsFormatter\u0026#34;/\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--启动格式化转换器--\u0026gt; \u0026lt;mvc:annotation-driven conversion-service=\u0026#34;formattingConversionService\u0026#34;/\u0026gt; \u0026lt;!--==================== 配置校验器 ====================--\u0026gt; \u0026lt;!--配置错误消息资源--\u0026gt; \u0026lt;bean id=\u0026#34;msgSource\u0026#34; class=\u0026#34;org.springframework.context.support.ReloadableResourceBundleMessageSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;basenames\u0026#34; value=\u0026#34;errorMessages\u0026#34;/\u0026gt; \u0026lt;!--资源文件编码格式--\u0026gt; \u0026lt;property name=\u0026#34;fileEncodings\u0026#34; value=\u0026#34;utf-8\u0026#34;/\u0026gt; \u0026lt;!--对资源文件内容缓存时间，单位秒--\u0026gt; \u0026lt;property name=\u0026#34;cacheSeconds\u0026#34; value=\u0026#34;120\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--注册校验器--\u0026gt; \u0026lt;bean id=\u0026#34;validator\u0026#34; class=\u0026#34;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\u0026#34;\u0026gt; \u0026lt;!--hibernate校验器--\u0026gt; \u0026lt;property name=\u0026#34;providerClass\u0026#34; value=\u0026#34;org.hibernate.validator.HibernateValidator\u0026#34;/\u0026gt; \u0026lt;!--指定校验使用的资源为将，在文件中配置校验错误信息--\u0026gt; \u0026lt;property name=\u0026#34;validationMessageSource\u0026#34; ref=\u0026#34;msgSource\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--启动spring的valid校验功能--\u0026gt; \u0026lt;mvc:annotation-driven conversion-service=\u0026#34;conversionService\u0026#34; validator=\u0026#34;validator\u0026#34;/\u0026gt; \u0026lt;!--==================== 配置拦截器 ====================--\u0026gt; \u0026lt;mvc:interceptors\u0026gt; \u0026lt;!--\u0026lt;bean class=\u0026#34;interceptor.AllInterceptor\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt; \u0026lt;mvc:exclude-mapping path=\u0026#34;/\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;interceptor.Interceptor1\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/five\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;interceptor.Interceptor2\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt; \u0026lt;!--==================== 配置文件上传和下载 ====================--\u0026gt; \u0026lt;bean id=\u0026#34;multipartResolver\u0026#34; class=\u0026#34;org.springframework.web.multipart.commons.CommonsMultipartResolver\u0026#34; p:defaultEncoding=\u0026#34;UTF-8\u0026#34; p:maxUploadSize=\u0026#34;5400000\u0026#34; p:uploadTempDir=\u0026#34;fileUpload/temp\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--==================== 配置异常处理 ====================--\u0026gt; \u0026lt;!--使用@ExceptionHandler注解时注释掉，因为@ExceptionHandler注解方法不能有任何配置--\u0026gt; \u0026lt;!--统一异常处理，托管MyExceptionHandler--\u0026gt; \u0026lt;!--\u0026lt;bean class=\u0026#34;exception.MyExceptionHandler\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!--统一异常处理，使用SimpleMappingExceptionResolver异常处理器处理异常--\u0026gt; \u0026lt;!--\u0026lt;bean class=\u0026#34;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\u0026#34;\u0026gt;--\u0026gt; \u0026lt;!--\u0026amp;lt;!\u0026amp;ndash;定义默认的异常处理页面，当该异常类型注册时使用\u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026#34;defaultErrorView\u0026#34; value=\u0026#34;error\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!--\u0026amp;lt;!\u0026amp;ndash;定义异常处理页面用来获取异常信息的变量名，默认名为exception\u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026#34;exceptionAttribute\u0026#34; value=\u0026#34;ex\u0026#34;/\u0026gt;--\u0026gt; \u0026lt;!--\u0026amp;lt;!\u0026amp;ndash;定义需要特殊处理的异常，用类名活完全路径名为key，异常页名为值\u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;property name=\u0026#34;exceptionMappings\u0026#34;\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;props\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;prop key=\u0026#34;exception.MyException\u0026#34;\u0026gt;my-error\u0026lt;/prop\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;prop key=\u0026#34;java.sql.SQLException\u0026#34;\u0026gt;sql-error\u0026lt;/prop\u0026gt;--\u0026gt; \u0026lt;!--\u0026amp;lt;!\u0026amp;ndash;这里还可以继续扩展对不同异常类型的处理\u0026amp;ndash;\u0026amp;gt;--\u0026gt; \u0026lt;!--\u0026lt;/props\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/property\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/bean\u0026gt;--\u0026gt; \u0026lt;/beans\u0026gt; ","permalink":"https://www.boii.xyz/posts/java/ssm/ssm-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","summary":"先把配置文件捋清楚\n前言 SSM框架中有几个比较重要的配置文件，一开始学起来会很模糊，这里做一下整理\n当一个web程序启动时，Tomcat服务器最先会读取 web.xml 文件，这个文件中会启动一些配置，还会启动Spring配置文件**applicationContext.xml** 和SpringMVC配置文件 springMVC-servlet.xml 这两个文件，在运行 applicationContext.xml 的时候会启动MyBatis的配置文件 myBatis.xml，并且会调用到 jdbc.properties 和 log4J.properties 两个资源属性文件里的属性。\nweb.xml 接下来先看看最先启动的 web.xml 是都怎么配置。\n在Spring配置中和在Servlet配置中，就启动了applicationContext 和 SpringMVC-servlet 两个配置文件\n启动applicationContext 1 2 3 4 \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; 启动SpringMVC-servlet 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--部署Servlet分发器 DispatcherServlet--\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springer\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--注册DispatcherServlet的配置文件--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springer-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; 运行到这的时候就会调用到上述两个文件。\n整个文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 \u0026lt;?","title":"SSM-配置文件"},{"content":"有了事务好管理\n前言 事务：也就是一个用户操作中，需要包含哪些具体操作。这些操作集合在一起，就是事务。这些操作必须是具体的，必要的，不可分割的。要么全部完成，要么全部失败。\n比如你给你朋友转账1000块的操作，分成几个步骤就是：\n自己的账户扣1000块钱 对方的账户加1000块钱 把这笔转账行为记录在服务器中 这三个步骤就具备了原子性，一致性，隔离性，持久性。\n原子性：**要么全部完成，有一个完成不了就全部回滚。**比如自己的账户扣钱成功，但是对方的账户加钱失败，那么就回滚，自己的账户的钱恢复到转账钱的余额。\n一致性： **一致性代表了底层数据存储的完整性。**例如你转账给朋友1000块，那你的账户要扣1000块，你朋友的账户得增加1000块，如果只增加了500块，那就是不一致。\n隔离性：**隔离性意味着事务必须在不干扰其他进程或事务的前提下独立执行。**也就是，在事务或工作单元执行完毕之前，其所访问的数据不能受系统其他部分的影响。比如你在给朋友转账的时候，别人给你转账是转不了的。因为要确保你的账户的隔离。\n持久性：**持久性表示在某个事务的执行过程中，对数据所作的所有改动都必须在事务成功结束前保存至某种物理存储设备。**转账后要把这次转账记录在服务器里，不管过了多久都可以查。\n事务的三个主要方法：开启事务 BeginTranscation()，提交 commit() ，回滚 rollback()\n","permalink":"https://www.boii.xyz/posts/java/ssm/ssm-8-spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/","summary":"有了事务好管理\n前言 事务：也就是一个用户操作中，需要包含哪些具体操作。这些操作集合在一起，就是事务。这些操作必须是具体的，必要的，不可分割的。要么全部完成，要么全部失败。\n比如你给你朋友转账1000块的操作，分成几个步骤就是：\n自己的账户扣1000块钱 对方的账户加1000块钱 把这笔转账行为记录在服务器中 这三个步骤就具备了原子性，一致性，隔离性，持久性。\n原子性：**要么全部完成，有一个完成不了就全部回滚。**比如自己的账户扣钱成功，但是对方的账户加钱失败，那么就回滚，自己的账户的钱恢复到转账钱的余额。\n一致性： **一致性代表了底层数据存储的完整性。**例如你转账给朋友1000块，那你的账户要扣1000块，你朋友的账户得增加1000块，如果只增加了500块，那就是不一致。\n隔离性：**隔离性意味着事务必须在不干扰其他进程或事务的前提下独立执行。**也就是，在事务或工作单元执行完毕之前，其所访问的数据不能受系统其他部分的影响。比如你在给朋友转账的时候，别人给你转账是转不了的。因为要确保你的账户的隔离。\n持久性：**持久性表示在某个事务的执行过程中，对数据所作的所有改动都必须在事务成功结束前保存至某种物理存储设备。**转账后要把这次转账记录在服务器里，不管过了多久都可以查。\n事务的三个主要方法：开启事务 BeginTranscation()，提交 commit() ，回滚 rollback()","title":"SSM-8-Spring事务管理"},{"content":"遇到异常不要慌～\n摘要 程序运行过程中总会遇到一些可预知的，不可预知的异常。如果不对这些异常进行捕捉和处理，就会导致程序崩溃、停止运行、闪退等诸多令人体验极差的现象。如果对这些异常一个一个单独处理，则代码显得很臃肿，耦合度高（独立性差），所以要用统一异常处理对所有的代码进行异常处理\nSpringMVC处理异常有三种方式：\n简单异常处理SimpleMappingExceptionResolver 实现HandlerExceptionResolver接口自定义异常 使用@ExceptionHandler注解实现异常处理 在程序中可能出现异常的地方进行捕捉，程序发生异常被捕捉到后，就会调用我们编写的统一异常处理类进行处理\n效果图 使用步骤 由于我们太完美了程序暂时没有什么异常，所以我们得自己制造点异常。\n我们先做一个列表，把控制层，业务层，模型层的各种异常集中链接在这里。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; %\u0026gt; \u0026lt;%@ page isELIgnored=\u0026#34;false\u0026#34; %\u0026gt; \u0026lt;% String path = request.getContextPath(); String basePath = request.getScheme() + \u0026#34;://\u0026#34; + request.getServerName() + \u0026#34;:\u0026#34; + request.getServerPort() + path + \u0026#34;/\u0026#34;; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base href=\u0026#34;\u0026lt;%=basePath%\u0026gt;\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;Exception\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;\u0026lt;a href=\u0026#34;db\u0026#34;\u0026gt;控制器中数据库异常\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;\u0026lt;a href=\u0026#34;my\u0026#34;\u0026gt;控制器中自定义异常\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;\u0026lt;a href=\u0026#34;no\u0026#34;\u0026gt;控制器中未知异常\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如下图：\n这些链接点击后跳转到控制层里进行处理。而程序不会无端端的就异常，所以我们得先在控制器里弄点异常：自己主动抛出一个异常 。\n先主动搞个异常 1 throw new SQLException(\u0026#34;控制器中数据库异常\u0026#34;); 这句话就是主动抛出一个异常。\n整体的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Controller public class ExceptionController{ @RequestMapping(\u0026#34;/db\u0026#34;) public void db() throws Exception { throw new SQLException(\u0026#34;控制器中数据库异常\u0026#34;); } @RequestMapping(\u0026#34;/my\u0026#34;) public void my() throws Exception { throw new MyException(\u0026#34;控制器中自定义异常\u0026#34;); } @RequestMapping(\u0026#34;/no\u0026#34;) public void no() throws Exception { throw new Exception(\u0026#34;控制器中未知异常\u0026#34;); } } 好了制造好了异常，现在开始来处理。一共有三种方法\n实现HandlerExceptionResolver接口 1.编写一个类实现HandlerExceptionResolver接口 异常抛出后，就会被捕捉，捕捉后就要进行处理啦。我们编写一个类，这个类要实现 HandlerExceptionResolver接口里的 resolveException() 方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class MyExceptionHandler implements HandlerExceptionResolver { /** * 重写接口方法 * * @param arg0 servlet请求 * @param arg1 servlet响应 * @param obj 目标对象 * @param ex 异常 * @return 返回相应的视图 */ @Override public ModelAndView resolveException(HttpServletRequest arg0, HttpServletResponse arg1, Object obj, Exception ex) { Map\u0026lt;String, Object\u0026gt; model = new HashMap\u0026lt;\u0026gt;(); model.put(\u0026#34;ex\u0026#34;, ex); // 根据不同错误转向不同页面（统一处理），即异常与view的对应关系 // 如果异常属于自定义异常类型 if (ex instanceof MyException) { return new ModelAndView(\u0026#34;exception/my-error\u0026#34;, model); // 如果异常属于数据库异常类型 } else if (ex instanceof SQLException) { return new ModelAndView(\u0026#34;exception/sql-error\u0026#34;, model); // 如果异常属于未知类型 } else { return new ModelAndView(\u0026#34;exception/error\u0026#34;, model); } } } 控制层里制造了三种不同的异常 ，这些异常被捕捉后会被送到这里进行处理。这里主要就是根据异常的不同类型返回不同的视图页面。\n3. 在SpringMVC配置文件中配置 1 \u0026lt;bean class=\u0026#34;exception.MyExceptionHandler\u0026#34;/\u0026gt; 使用@ExceptionHandler注解实现异常处理 这种是最容易的一种方式，集成简单，扩展性好。\n1.创建一个BaseController类 创建一个抽象类，并在类中使用@ExceptionHandler注解声明异常处理方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public abstract class BaseController { /** * 异常处理方法 * @param request Servlet请求 * @param ex 异常实例 * @return 返回一个视图页面的名称 */ @ExceptionHandler public String exception(HttpServletRequest request, Exception ex){ request.setAttribute(\u0026#34;ex\u0026#34;, ex); if (ex instanceof SQLException) { return \u0026#34;404\u0026#34;; } else if ( ex instanceof MyException) { return \u0026#34;exception/my-error\u0026#34;; } else { return \u0026#34;exception/error\u0026#34;; } } } 2.让其他控制器继承这个类 让其他需要处理异常的类继承这个BaseController类\n1 2 3 public class ExceptionController extends BaseController{ ...... } 3. 注意使用这种方法是配置文件中不要配置任何其他异常处理方法。 注意使用这种方法是配置文件中不要配置任何其他异常处理方法！！！\n注意使用这种方法是配置文件中不要配置任何其他异常处理方法！！！\n注意使用这种方法是配置文件中不要配置任何其他异常处理方法！！！\n简单异常处理SimpleMappingExceptionResolver 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\u0026#34;\u0026gt; \u0026lt;!--定义默认的异常处理页面，当该异常类型注册时使用--\u0026gt; \u0026lt;property name=\u0026#34;defaultErrorView\u0026#34; value=\u0026#34;error\u0026#34;/\u0026gt; \u0026lt;!--定义异常处理页面用来获取异常信息的变量名，默认名为exception--\u0026gt; \u0026lt;property name=\u0026#34;exceptionAttribute\u0026#34; value=\u0026#34;ex\u0026#34;/\u0026gt; \u0026lt;!--定义需要特殊处理的异常，用类名活完全路径名为key，异常页名为值--\u0026gt; \u0026lt;property name=\u0026#34;exceptionMappings\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026#34;exception.MyException\u0026#34;\u0026gt;my-error\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026#34;java.sql.SQLException\u0026#34;\u0026gt;sql-error\u0026lt;/prop\u0026gt; \u0026lt;!--这里还可以继续扩展对不同异常类型的处理--\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 在SpringMVC配置文件中配置 SimpleMappingExceptionResolver异常处理器 ，即可实现对异常的统一处理。\n主要分默认异常处理页面，获取异常信息的变量名，还有一些需要特殊处理的异常。\n总结 最简单的使用@ExceptionHandler注解的方法，虽然有集成简单，可扩展性好等优点，但是该方法对已有代码存在入侵性，需要修改已有代码，是相关类继承于BaseController。\n而第一种写一个HandlerExceptionResolver的实现类的方法则比较温和，不会对代码进行入侵。记得要在SpringMVC配置文件中托管这个实现类：\u0026lt;bean class=\u0026quot;exception.MyExceptionHandler\u0026quot;/\u0026gt;\n最后一种其实最方便啦，配置好就OK，不用增加什么文件。\n","permalink":"https://www.boii.xyz/posts/java/ssm/ssm-7-%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","summary":"遇到异常不要慌～\n摘要 程序运行过程中总会遇到一些可预知的，不可预知的异常。如果不对这些异常进行捕捉和处理，就会导致程序崩溃、停止运行、闪退等诸多令人体验极差的现象。如果对这些异常一个一个单独处理，则代码显得很臃肿，耦合度高（独立性差），所以要用统一异常处理对所有的代码进行异常处理\nSpringMVC处理异常有三种方式：\n简单异常处理SimpleMappingExceptionResolver 实现HandlerExceptionResolver接口自定义异常 使用@ExceptionHandler注解实现异常处理 在程序中可能出现异常的地方进行捕捉，程序发生异常被捕捉到后，就会调用我们编写的统一异常处理类进行处理\n效果图 使用步骤 由于我们太完美了程序暂时没有什么异常，所以我们得自己制造点异常。\n我们先做一个列表，把控制层，业务层，模型层的各种异常集中链接在这里。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; %\u0026gt; \u0026lt;%@ page isELIgnored=\u0026#34;false\u0026#34; %\u0026gt; \u0026lt;% String path = request.getContextPath(); String basePath = request.getScheme() + \u0026#34;://\u0026#34; + request.getServerName() + \u0026#34;:\u0026#34; + request.getServerPort() + path + \u0026#34;/\u0026#34;; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base href=\u0026#34;\u0026lt;%=basePath%\u0026gt;\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;Exception\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;body\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;\u0026lt;a href=\u0026#34;db\u0026#34;\u0026gt;控制器中数据库异常\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;\u0026lt;a href=\u0026#34;my\u0026#34;\u0026gt;控制器中自定义异常\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt;\u0026lt;a href=\u0026#34;no\u0026#34;\u0026gt;控制器中未知异常\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如下图：","title":"SSM-7-统一异常处理"},{"content":"来了，上下都来了～\n摘要 文件上传和下载是web经常要面对的问题。\n上传的方式有多种，包括：\n使用文件流手工编程上传 基于commons-fileupload组件的文件上传 基于Servlet3及以上版本文件上传 下载经常有两种方式：\n通过超链接实现下载，但是会暴露下载文件的真实位置，并且只能下载存放在web应用所在的目录下的文件。 利用程序编码实现下载，可以增加安全访问控制，还可以从任意位置提供下载的数据，比如数据库。 效果图 上传 选择文件前\n选择文件后\n上传文件后\n下载 可以被下载的文件列表\n选择文件存储位置\n使用步骤 导入jar包 SpringMVC框架的文件上传是基于commons-fileupload组件，所以需要commons-fileupload和commons-io的jar包。\nmaven项目：配置pom.xml\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--上传下载--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-fileupload\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-fileupload\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-io\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-io\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 非maven项目：将下载好的 commons-fileupload 和 commons-io 的jar放到 webapps\\WEB-INF\\lib 目录下\n单文件上传 1. 编写领域模型 文件上传后保存在服务器里是一个对象，这个对象我们得定义它的属性。文件上传的时候的文件描述（备注），文件的创建时间等等，最重要的文件本身的类型是 MultipartFile\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class FileDomain { private String description; private MultipartFile myFile; public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public MultipartFile getMyFile() { return myFile; } public void setMyFile(MultipartFile myFile) { this.myFile = myFile; } } 2. 编写一个提交页面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; %\u0026gt; \u0026lt;%@ page isELIgnored=\u0026#34;false\u0026#34; %\u0026gt; \u0026lt;% String path = request.getContextPath(); String basePath = request.getScheme() + \u0026#34;://\u0026#34; + request.getServerName() + \u0026#34;:\u0026#34; + request.getServerPort() + path + \u0026#34;/\u0026#34;; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base href=\u0026#34;\u0026lt;%=basePath%\u0026gt;\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;onFile\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;six/oneFileUpLoad\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; 选择文件：\u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;myFile\u0026#34;/\u0026gt;\u0026lt;br\u0026gt; 文件描述：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;description\u0026#34;/\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; input标签的type属性为file时，就变成选择文件了。\n要注意的是：表单form的enctype属性应设置为 multipart/form-data。然后就可以把表单提交到控制器了： action=\u0026quot;six/oneFileUpload\u0026quot;\n3. 编写控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Controller @RequestMapping(\u0026#34;/six\u0026#34;) public class SixController { private static final Log logger = LogFactory.getLog(SixController.class); @RequestMapping(\u0026#34;/oneFileUpLoad\u0026#34;) public String oneFileUpload(@ModelAttribute FileDomain fileDomain, HttpServletRequest request) { // 获取存储路径 String realpath = request.getServletContext().getRealPath(\u0026#34;fileUpload\u0026#34;); // 获取文件名 String fileName = fileDomain.getMyFile().getOriginalFilename(); // 如果文件名不为null \u0026amp;\u0026amp; 目标文件夹不存在，则新建文件夹 assert fileName != null; File targetFile = new File(realpath, fileName); if (!targetFile.exists()) { targetFile.mkdirs(); } // 开始上传文件 try { fileDomain.getMyFile().transferTo(targetFile); logger.info(\u0026#34;成功\u0026#34;); } catch (IOException e) { e.printStackTrace(); } return \u0026#34;6/showOne\u0026#34;; } } 表单提交到控制器后就由控制器进行处理。\n先获取realPath：文件保存到服务器的哪个地方，也叫存储路径。文件上传后都是存在服务器的，所以这里说的路径是指在服务器上的存储路径。 然后获取文件的文件名 如果realPath这个目录不存在，就创建目录 然后就开始上传文件。上传的关键方法就是 transferTo() 这里上传成功就会跳转到 /WEB-INF/jsp/6/showOne 页面\n\u0026gt;_\n4. 编写结果页面 也就是上面要跳转的 /WEB-INF/jsp/6/showOne 页面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; %\u0026gt; \u0026lt;%@ page isELIgnored=\u0026#34;false\u0026#34; %\u0026gt; \u0026lt;% String path = request.getContextPath(); String basePath = request.getScheme() + \u0026#34;://\u0026#34; + request.getServerName() + \u0026#34;:\u0026#34; + request.getServerPort() + path + \u0026#34;/\u0026#34;; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base href=\u0026#34;\u0026lt;%=basePath%\u0026gt;\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;ShowOne\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; ${fileDomain.description}\u0026lt;br\u0026gt; ${fileDomain.myFile.originalFilename} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 多文件上传 多文件上传和单文件的上传过程是相同的，但是他们的模型是不同的。多文件上传的模型是列表list\n1.领域模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class MultiFileDomain { private List\u0026lt;String\u0026gt; description; private List\u0026lt;MultipartFile\u0026gt; myFile; public List\u0026lt;String\u0026gt; getDescription() { return description; } public void setDescription(List\u0026lt;String\u0026gt; description) { this.description = description; } public List\u0026lt;MultipartFile\u0026gt; getMyFile() { return myFile; } public void setMyFile(List\u0026lt;MultipartFile\u0026gt; myFile) { this.myFile = myFile; } } 跟单文件上传的类型差不多，不同在于用list去装载。\n2.编写提交页面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; %\u0026gt; \u0026lt;%@ page isELIgnored=\u0026#34;false\u0026#34; %\u0026gt; \u0026lt;% String path = request.getContextPath(); String basePath = request.getScheme() + \u0026#34;://\u0026#34; + request.getServerName() + \u0026#34;:\u0026#34; + request.getServerPort() + path + \u0026#34;/\u0026#34;; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base href=\u0026#34;\u0026lt;%=basePath%\u0026gt;\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;MultiFile\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;six/mutliFile\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; 选择文件1：\u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;myFile\u0026#34;/\u0026gt; \u0026lt;br\u0026gt; 文件描述1：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;description\u0026#34;/\u0026gt;\u0026lt;br\u0026gt; 选择文件2：\u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;myFile\u0026#34;/\u0026gt; \u0026lt;br\u0026gt; 文件描述2：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;description\u0026#34;/\u0026gt;\u0026lt;br\u0026gt; 选择文件3：\u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;myFile\u0026#34;/\u0026gt; \u0026lt;br\u0026gt; 文件描述3：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;description\u0026#34;/\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;/\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 同样是enctype属性要设置成 multipart/form-data ，通过action属性提交到控制器\n3.控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Controller @RequestMapping(\u0026#34;/six\u0026#34;) public class SixController { private static final Log logger = LogFactory.getLog(SixController.class); @RequestMapping(\u0026#34;/mutliFile\u0026#34;) public String multiFile(@ModelAttribute MultiFileDomain multiFileDomain, HttpServletRequest request) { // 获取真实路径 String realpath = request.getServletContext().getRealPath(\u0026#34;fileUpload\u0026#34;); // 如果目标文件夹不存在则新建文件夹 File targetDir = new File(realpath); if (!targetDir.exists()) { targetDir.mkdirs(); } // 将文件放置到list中 List\u0026lt;MultipartFile\u0026gt; files = multiFileDomain.getMyFile(); // 将list中的文件逐个上传 for (MultipartFile file : files) { String fileName = file.getOriginalFilename(); assert fileName != null; File targetFile = new File(realpath, fileName); try { file.transferTo(targetFile); } catch (IOException e) { e.printStackTrace(); } } logger.info(\u0026#34;成功\u0026#34;); return \u0026#34;6/showMulti\u0026#34;; } } 控制器里前部分也是相同的，获取存储路径，获取文件名，检查目标目录是否存在。\n区别在于：将传过来的文件放在一个新的List中\n1 List\u0026lt;MultipartFile\u0026gt; files = multiFileDomain.getMyFile(); 然后循环遍历整个List，将文件一个一个上传，然后返回 /WEB-INF/jsp/6/showMulti 页面\n下载 利用程序实现下载需要设置两个报头：\n设置Content-Type的值为：application/x-msdownload，因为web服务器需要告诉浏览器所输出内容的类型不是普通文件文件或是HTML，而是一个要保存到本地的下载文件。 设置Content-Disposition的值为：attachment，后面还可以指定filename参数。filename参数就是那个默认保存文件名。如下图红框所示： 1 2 response.setHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/x-msdownload\u0026#34;); response.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;filename=\u0026#34; + toUTF8(filename)); 1. 编写跳转页面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; %\u0026gt; \u0026lt;%@ page isELIgnored=\u0026#34;false\u0026#34; %\u0026gt; \u0026lt;% String path = request.getContextPath(); String basePath = request.getScheme() + \u0026#34;://\u0026#34; + request.getServerName() + \u0026#34;:\u0026#34; + request.getServerPort() + path + \u0026#34;/\u0026#34;; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base href=\u0026#34;\u0026lt;%=basePath%\u0026gt;\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;MultiFile\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;a href=\u0026#34;six/showDownFiles\u0026#34;\u0026gt;文件下载\u0026lt;/a\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 整个页面只有一个a标签的链接。点击之后会跳转到 showDownFiles 控制器\n2.编写列表控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Controller @RequestMapping(\u0026#34;/six\u0026#34;) public class SixController { private static final Log logger = LogFactory.getLog(SixController.class); @RequestMapping(\u0026#34;/showDownFiles\u0026#34;) public String showDown(HttpServletRequest request, Model model) { // 获取存储目录 String realpath = request.getServletContext().getRealPath(\u0026#34;fileUpload\u0026#34;); // 实例化为一个File对象 File dir = new File(realpath); // 将目录下的文件放到File数组中 File[] files = dir.listFiles(); // 创建一个数组列表，用于返回到前台页面 ArrayList\u0026lt;String\u0026gt; fileName = new ArrayList\u0026lt;\u0026gt;(); assert files != null; // 逐一将目录下的文件添加到数组列表中 for (File file : files) { fileName.add(file.getName()); } // 将数组列表返回给前台页面 model.addAttribute(\u0026#34;files\u0026#34;, fileName); return \u0026#34;6/showDownFiles\u0026#34;; } } 列出控制器还是比较简单的：\n获取存储位置 将路径实例化成一个File对象 将存储位置里的文件放到File数组中 创建一个数组列表，然后将文件逐个添加到数组列表中 将数组列表返回给前台页面 3. 编写下载列表展示页面 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;%@ taglib prefix=\u0026#34;c\u0026#34; uri=\u0026#34;http://java.sun.com/jsp/jstl/core\u0026#34; %\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; %\u0026gt; \u0026lt;%@ page isELIgnored=\u0026#34;false\u0026#34; %\u0026gt; \u0026lt;% String path = request.getContextPath(); String basePath = request.getScheme() + \u0026#34;://\u0026#34; + request.getServerName() + \u0026#34;:\u0026#34; + request.getServerPort() + path + \u0026#34;/\u0026#34;; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base href=\u0026#34;\u0026lt;%=basePath%\u0026gt;\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;ShowDownFiles\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;被下载文件名\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;c:forEach items=\u0026#34;${files}\u0026#34; var=\u0026#34;filename\u0026#34;\u0026gt;\u0026lt;%--@elvariable id=\u0026#34;filesname\u0026#34; type=\u0026#34;po.six.FileDomain\u0026#34;--%\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href=\u0026#34;six/down?filename=${filename}\u0026#34;\u0026gt;${filename}\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/c:forEach\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这里用了表单标签库中的 \u0026lt;c:forEach\u0026gt; 标签，将存储目录中的文件列出来，列出来的每一项都是一个超链接，链接指向 six/down 这个下载控制器。效果如下：\n4.编写下载控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Controller @RequestMapping(\u0026#34;/six\u0026#34;) public class SixController { private static final Log logger = LogFactory.getLog(SixController.class); @RequestMapping(\u0026#34;/down\u0026#34;) public String down(@RequestParam String filename, HttpServletRequest request, HttpServletResponse response) { try { // 获取存储位置 String savePath = request.getServletContext().getRealPath(\u0026#34;fileUpload\u0026#34;); // 设置报头 response.setHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/x-msdownload\u0026#34;); response.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;filename=\u0026#34; + toUTF8(filename)); // 读取服务器上的文件并写入到输出对象中，也就是下载 FileInputStream in = new FileInputStream(savePath + \u0026#34;\\\\\u0026#34; + filename); ServletOutputStream out = response.getOutputStream(); out.flush(); int aRead; byte[] b = new byte[1024]; while ((aRead = in.read(b)) != -1) { out.write(b, 0, aRead); } out.flush(); out.close(); in.close(); } catch (Throwable e) { e.printStackTrace(); } logger.info(\u0026#34;下载成功\u0026#34;); return null; } } 下载控制器则做了几件事情：\n获取存储目录 设置报头 将目标文件从输入流读取出来，转移到Servlet输出流写入进去，完成下载这个动作 因为报头的 Content-Disposition 设置为 attachment，所以下载之前浏览器会询问保存位置。\n总结 上传和下载是web中很重要的一项功能，需要彻底掌握。上传的方式有多种，基于commons-fileupload的文件上传还是比较容易的，关键代码就是transferTo()方法。而下载选择用编码实现是为了不暴露文件的真实位置，还有就是可以下载任意位置的文件，所以可以将文件放在数据库中，然后让下载控制器去数据库中读取下载。虽然步骤比较麻烦，但是安全，规范。\n","permalink":"https://www.boii.xyz/posts/java/ssm/ssm-6-%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/","summary":"来了，上下都来了～\n摘要 文件上传和下载是web经常要面对的问题。\n上传的方式有多种，包括：\n使用文件流手工编程上传 基于commons-fileupload组件的文件上传 基于Servlet3及以上版本文件上传 下载经常有两种方式：\n通过超链接实现下载，但是会暴露下载文件的真实位置，并且只能下载存放在web应用所在的目录下的文件。 利用程序编码实现下载，可以增加安全访问控制，还可以从任意位置提供下载的数据，比如数据库。 效果图 上传 选择文件前\n选择文件后\n上传文件后\n下载 可以被下载的文件列表\n选择文件存储位置\n使用步骤 导入jar包 SpringMVC框架的文件上传是基于commons-fileupload组件，所以需要commons-fileupload和commons-io的jar包。\nmaven项目：配置pom.xml\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--上传下载--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-fileupload\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-fileupload\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-io\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-io\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 非maven项目：将下载好的 commons-fileupload 和 commons-io 的jar放到 webapps\\WEB-INF\\lib 目录下\n单文件上传 1. 编写领域模型 文件上传后保存在服务器里是一个对象，这个对象我们得定义它的属性。文件上传的时候的文件描述（备注），文件的创建时间等等，最重要的文件本身的类型是 MultipartFile\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class FileDomain { private String description; private MultipartFile myFile; public String getDescription() { return description; } public void setDescription(String description) { this.","title":"SSM-6-上传和下载"},{"content":"拦截器其实就是一种中间件\n摘要 拦截器 Interceptor 主要用于在 请求到达控制器之前进行验证 ，有点类似过滤器。主要用于拦截用户请求并做出相应的处理。通常应用在权限验证，记录请求信息的日志，判断用户是否登录等功能上。\n主要的实现方法有两种：\n通过实现 HandlerInterceptor接口 或继承 HandlerInterceptor接口 的实现类来定义。 通过实现 WebRequestInterceptor接口 或继承WebRequestInterceptor接口 的实现类来定义。 效果图 拦截器的拦截时间点在这里面分三种：\n请求到达控制器之前调用，比如点击我的购物车的时候，判断用户有没有登录先 控制器调用之后，返回视图之前。 解析试图之后。比如访问了XXX的QQ空间，就在视图解析完后记录到访问记录中 \u0026gt;_\n这里的案例只是在这些方法里打印了一些话来表示出拦截器在什么时间点做了什么\n使用步骤 1. 配置 先在springmvc-servlet.xml中配置拦截器。\n1 2 3 \u0026lt;mvc:interceptors\u0026gt; \u0026lt;bean class=\u0026#34;interceptor.AllInterceptor\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptors\u0026gt; 这样的配置方式默认对所有请求拦截，也就是任何请求要到达控制器之前都会经过拦截器。\n这种方式的话就是拦截所有的请求，但是请求如果是到/abc这个控制器的话就例外，不拦截。\n1 2 3 4 5 6 7 \u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt; \u0026lt;mvc:exclude-mapping path=\u0026#34;/abc\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;interceptor.Interceptor1\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt; 这种呢就是对发送到/6这个控制器的请求，进行指定的拦截器拦截。\n1 2 3 4 5 6 \u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/6\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;interceptor.Interceptor2\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt; 2. 实现接口 HandlerInterceptor接口中已经有默认的实现方法了，所以implements之后并不会提醒重写方法。\npreHandle：在请求到达控制器之前进行拦截\npostHandle：控制器调用之后，解析试图之前进行拦截\nafterCompletion：在解析试图之后进行拦截\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class AllInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026#34;preHandle，请求到达控制器之前\u0026#34;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;postHandle,控制器调用之后，解析试图之前\u0026#34;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;afterCompletion,解析视图之后\u0026#34;); } } 总结 拦截器是一个比较重要的东西。使用也简单，主要是两点\n编写拦截器的工作，preHandle要干嘛，postHandle要干嘛，afterCompletion要干嘛。 在springmvc配置文件里编写拦截规则，是全部都拦截用一个全局拦截器？还是某个控制器用某个拦截器？ ","permalink":"https://www.boii.xyz/posts/java/ssm/ssm-5-%E6%8B%A6%E6%88%AA%E5%99%A8/","summary":"拦截器其实就是一种中间件\n摘要 拦截器 Interceptor 主要用于在 请求到达控制器之前进行验证 ，有点类似过滤器。主要用于拦截用户请求并做出相应的处理。通常应用在权限验证，记录请求信息的日志，判断用户是否登录等功能上。\n主要的实现方法有两种：\n通过实现 HandlerInterceptor接口 或继承 HandlerInterceptor接口 的实现类来定义。 通过实现 WebRequestInterceptor接口 或继承WebRequestInterceptor接口 的实现类来定义。 效果图 拦截器的拦截时间点在这里面分三种：\n请求到达控制器之前调用，比如点击我的购物车的时候，判断用户有没有登录先 控制器调用之后，返回视图之前。 解析试图之后。比如访问了XXX的QQ空间，就在视图解析完后记录到访问记录中 \u0026gt;_\n这里的案例只是在这些方法里打印了一些话来表示出拦截器在什么时间点做了什么\n使用步骤 1. 配置 先在springmvc-servlet.xml中配置拦截器。\n1 2 3 \u0026lt;mvc:interceptors\u0026gt; \u0026lt;bean class=\u0026#34;interceptor.AllInterceptor\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptors\u0026gt; 这样的配置方式默认对所有请求拦截，也就是任何请求要到达控制器之前都会经过拦截器。\n这种方式的话就是拦截所有的请求，但是请求如果是到/abc这个控制器的话就例外，不拦截。\n1 2 3 4 5 6 7 \u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt; \u0026lt;mvc:exclude-mapping path=\u0026#34;/abc\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;interceptor.Interceptor1\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt; 这种呢就是对发送到/6这个控制器的请求，进行指定的拦截器拦截。\n1 2 3 4 5 6 \u0026lt;mvc:interceptors\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/6\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;interceptor.Interceptor2\u0026#34;/\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;/mvc:interceptors\u0026gt; 2. 实现接口 HandlerInterceptor接口中已经有默认的实现方法了，所以implements之后并不会提醒重写方法。","title":"SSM-5-拦截器"},{"content":"先把数据绑定起来\n摘要 数据绑定是将用户参数输入值绑定到领域模型（POJO）的一种特性，在SpringMVC的Controller和View参数传递数据的过程中，所有HTTP请求参数的类型均为字符串，如果模型需要绑定的类型为double或int，则需要手动进行类型转换，而有了数据绑定后：\n不需要手动转型数据了。 当表单输入验证失败时，会重新生成一个HTML表单，无需重新填写已输入字段。 效果图 第一次加载的样子\n验证失败后重新加载的样子，前面填过的数据依然保留着\n验证成功后进入这个页面\n使用步骤 1. 导入jar包 maven项目：配置pom.xml\n1 2 3 4 5 6 7 8 9 10 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;jstl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;taglibs\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;standard\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 非maven项目：将下载好的 taglibs 和 jstl 的jar放到 webapps\\WEB-INF\\lib 目录下\n2. web.xml中配置编码过滤器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;characterEncodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;UTF-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;forceEncoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;true\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;characterEncodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 3. 编写领域模型 定义各种属性和getter\u0026amp;setter方法，太简单，不赘述\n4. 编写控制层Controller 因为视图层用的都是表单标签库，所以数据要在controller层定义\n然后通过model.addAttribute()方法将数据传送出去\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @Controller @RequestMapping(\u0026#34;/four\u0026#34;) public class FourController { private static final Log logger = LogFactory.getLog(FourController.class); private final FourUserService fourUserService; @Autowired public FourController(FourUserService fourUserService) { this.fourUserService = fourUserService; } /** * 第一次加载表单会触发这个方法 */ @RequestMapping(\u0026#34;/input\u0026#34;) public String inputUser(Model model) { HashMap\u0026lt;String, String\u0026gt; hobbys = getMap(); // 虽然是第一次加载，但是也要在model添加一个领域模型的对象，否则表单标签无法找到modelAttribute属性指定的form backing object model.addAttribute(\u0026#34;user\u0026#34;, new User()); model.addAttribute(\u0026#34;hobbys\u0026#34;, hobbys); model.addAttribute(\u0026#34;carrers\u0026#34;, new String[]{\u0026#34;教师\u0026#34;, \u0026#34;学生\u0026#34;, \u0026#34;码农\u0026#34;, \u0026#34;民工\u0026#34;}); model.addAttribute(\u0026#34;houseRegister\u0026#34;, new String[]{\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;广州\u0026#34;, \u0026#34;深圳\u0026#34;}); return \u0026#34;userAdd\u0026#34;; } /** * 表单提交的时候会触发这个方法 */ @RequestMapping(\u0026#34;/save\u0026#34;) public String addUser(@ModelAttribute User user, Model model) { // 进入业务层验证业务逻辑 if (fourUserService.addUser(user)) { logger.info(\u0026#34;成功\u0026#34;); // 重定向到本控制器里的list控制方法 return \u0026#34;redirect:list\u0026#34;; } logger.info(\u0026#34;失败\u0026#34;); // 验证失败的时候就到了这里，相当于重新加载，但是会带着已经填过的数据，用户就不用再次填写已经填写过的输入，注意这里没有在model.addAttribute()中new bean()。看不懂请对比上面的input方法 HashMap\u0026lt;String, String\u0026gt; hobbys = getMap(); model.addAttribute(\u0026#34;hobbys\u0026#34;, hobbys); model.addAttribute(\u0026#34;carrers\u0026#34;, new String[]{\u0026#34;教师\u0026#34;, \u0026#34;学生\u0026#34;, \u0026#34;码农\u0026#34;, \u0026#34;民工\u0026#34;}); model.addAttribute(\u0026#34;houseRegister\u0026#34;, new String[]{\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;广州\u0026#34;, \u0026#34;深圳\u0026#34;}); return \u0026#34;userAdd\u0026#34;; } @RequestMapping(\u0026#34;/list\u0026#34;) public String listUsers(Model model) { List\u0026lt;User\u0026gt; users = fourUserService.getUsers(); model.addAttribute(\u0026#34;users\u0026#34;, users); return \u0026#34;userList\u0026#34;; } private HashMap\u0026lt;String, String\u0026gt; getMap() { HashMap\u0026lt;String, String\u0026gt; hobbys = new HashMap\u0026lt;\u0026gt;(5); hobbys.put(\u0026#34;篮球\u0026#34;, \u0026#34;篮球\u0026#34;); hobbys.put(\u0026#34;乒乓球\u0026#34;, \u0026#34;乒乓球\u0026#34;); hobbys.put(\u0026#34;电玩\u0026#34;, \u0026#34;电玩\u0026#34;); hobbys.put(\u0026#34;游泳\u0026#34;, \u0026#34;游泳\u0026#34;); return hobbys; } } 5. 编写业务逻辑层Service 业务层，业务逻辑都在这里判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package service.four; import org.springframework.stereotype.Service; import po.four.User; import java.util.ArrayList; /** * @author pr919 */ @Service public class FourUserServiceImpl implements FourUserService { private static ArrayList\u0026lt;User\u0026gt; users = new ArrayList\u0026lt;\u0026gt;(); @Override public boolean addUser(User u) { String magicValue = \u0026#34;民工\u0026#34;; if (!magicValue.equals(u.getCarrer()) \u0026amp;\u0026amp; !\u0026#34;\u0026#34;.equals(u.getUsername())){ users.add(u); return true; } return false; } @Override public ArrayList\u0026lt;User\u0026gt; getUsers() { return users; } } 6. 编写视图层View 视图层的表单标签通过控制层和领域模型绑定在一起，实现了数据绑定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 \u0026lt;%-- userAdd.jsp --%\u0026gt; \u0026lt;%@ taglib prefix=\u0026#34;form\u0026#34; uri=\u0026#34;http://www.springframework.org/tags/form\u0026#34; %\u0026gt; \u0026lt;%-- Created by IntelliJ IDEA. User: pr919 Date: 2019.6.24 Time: 14:41 To change this template use File | Settings | File Templates. --%\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; %\u0026gt; \u0026lt;%@ page isELIgnored=\u0026#34;false\u0026#34; %\u0026gt; \u0026lt;% String path = request.getContextPath(); String basePath = request.getScheme() + \u0026#34;://\u0026#34; + request.getServerName() + \u0026#34;:\u0026#34; + request.getServerPort() + path + \u0026#34;/\u0026#34;; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base href=\u0026#34;\u0026lt;%=basePath%\u0026gt;\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;dataBind\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;%--@elvariable id=\u0026#34;user\u0026#34; type=\u0026#34;po.four.User\u0026#34;--%\u0026gt; \u0026lt;form:form modelAttribute=\u0026#34;user\u0026#34; mothod=\u0026#34;post\u0026#34; action=\u0026#34;four/save\u0026#34;\u0026gt; \u0026lt;fieldset\u0026gt; \u0026lt;legend\u0026gt;添加一个用户\u0026lt;/legend\u0026gt; \u0026lt;p\u0026gt; \u0026lt;label\u0026gt;用户名：\u0026lt;/label\u0026gt; \u0026lt;form:input path=\u0026#34;username\u0026#34;/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;label\u0026gt;爱好：\u0026lt;/label\u0026gt; \u0026lt;%--@elvariable id=\u0026#34;hobbys\u0026#34; type=\u0026#34;java.util.List\u0026#34;--%\u0026gt; \u0026lt;form:checkboxes items=\u0026#34;${hobbys}\u0026#34; path=\u0026#34;hobby\u0026#34;/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;label\u0026gt;朋友：\u0026lt;/label\u0026gt; \u0026lt;form:checkbox path=\u0026#34;friends\u0026#34; value=\u0026#34;张三\u0026#34;/\u0026gt;1 \u0026lt;form:checkbox path=\u0026#34;friends\u0026#34; value=\u0026#34;李四\u0026#34;/\u0026gt;2 \u0026lt;form:checkbox path=\u0026#34;friends\u0026#34; value=\u0026#34;王五\u0026#34;/\u0026gt;3 \u0026lt;form:checkbox path=\u0026#34;friends\u0026#34; value=\u0026#34;赵六\u0026#34;/\u0026gt;4 \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;label\u0026gt;职业：\u0026lt;/label\u0026gt; \u0026lt;form:select path=\u0026#34;carrer\u0026#34;\u0026gt; \u0026lt;option\u0026gt;\u0026lt;/option\u0026gt; 请选择职业 \u0026lt;%--@elvariable id=\u0026#34;carrers\u0026#34; type=\u0026#34;java.util.List\u0026#34;--%\u0026gt; \u0026lt;form:options items=\u0026#34;${carrers}\u0026#34;/\u0026gt; \u0026lt;/form:select\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;label\u0026gt;户籍：\u0026lt;/label\u0026gt; \u0026lt;form:select path=\u0026#34;houseRegister\u0026#34;\u0026gt; \u0026lt;option\u0026gt;\u0026lt;/option\u0026gt; 请选择户籍 \u0026lt;%--@elvariable id=\u0026#34;houseRegister\u0026#34; type=\u0026#34;java.util.List\u0026#34;--%\u0026gt; \u0026lt;form:options items=\u0026#34;${houseRegister}\u0026#34;/\u0026gt; \u0026lt;/form:select\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;label\u0026gt;个人描述：\u0026lt;/label\u0026gt; \u0026lt;form:textarea path=\u0026#34;remark\u0026#34; rows=\u0026#34;5\u0026#34;/\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p id=\u0026#34;buttons\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;reset\u0026#34; type=\u0026#34;reset\u0026#34; /\u0026gt; \u0026lt;input id=\u0026#34;submit\u0026#34; type=\u0026#34;submit\u0026#34; value=\u0026#34;添加\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;/form:form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 \u0026lt;%-- userAdd.jsp --%\u0026gt; \u0026lt;%@ taglib prefix=\u0026#34;c\u0026#34; uri=\u0026#34;http://java.sun.com/jsp/jstl/core\u0026#34; %\u0026gt; \u0026lt;%-- Created by IntelliJ IDEA. User: pr919 Date: 2019.6.24 Time: 15:18 To change this template use File | Settings | File Templates. --%\u0026gt; \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; %\u0026gt; \u0026lt;%@ page isELIgnored=\u0026#34;false\u0026#34; %\u0026gt; \u0026lt;% String path = request.getContextPath(); String basePath = request.getScheme() + \u0026#34;://\u0026#34; + request.getServerName() + \u0026#34;:\u0026#34; + request.getServerPort() + path + \u0026#34;/\u0026#34;; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base href=\u0026#34;\u0026lt;%=basePath%\u0026gt;\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;dataList\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;用户列表\u0026lt;/h1\u0026gt; \u0026lt;a href=\u0026#34;\u0026lt;c:url value=\u0026#34;four/input\u0026#34;/\u0026gt;\u0026#34;\u0026gt;继续添加\u0026lt;/a\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;用户名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;兴趣爱好\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;朋友\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;职业\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;户籍\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;个人描述\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;c:forEach items=\u0026#34;${users}\u0026#34; var=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;${user.username}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;c:forEach items=\u0026#34;${user.hobby}\u0026#34; var=\u0026#34;hobby\u0026#34;\u0026gt; ${hobby}\u0026amp;nbsp; \u0026lt;/c:forEach\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;c:forEach items=\u0026#34;${user.friends}\u0026#34; var=\u0026#34;friend\u0026#34;\u0026gt; ${friend}\u0026amp;nbsp; \u0026lt;/c:forEach\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${user.carrer}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${user.houseRegister}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${user.remark}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/c:forEach\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 总结 目前来说，除了不用手动转型之外，我还没想到这个数据绑定有什么用。如果是为了验证输入的话，用javaScript或ajax就够了。\n","permalink":"https://www.boii.xyz/posts/java/ssm/ssm-4-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","summary":"\u003cp\u003e先把数据绑定起来\u003c/p\u003e","title":"SSM-4-数据绑定"},{"content":"C语言笔记\n指针 定义指针：dataType * pointerName = NULL;\n1 int * ptr_a = NULL; 指针赋值：pointerName = \u0026amp;varName;\n1 2 int a = 10; ptr_a = \u0026amp;a; 对于指针，其实就是存放地址的变量\nint a = 10; 这句话等于申请了一块内存，放了个值10进去，起个别命叫a 。那这个空间的地址假设是 0028FF，那ptr_a = \u0026amp;a 这句话就是再申请一块内存，把0028FF放进去，起个别名叫ptr_a 。\n\u0026amp; 这个符号是取地址的意思\n* 这个符号则是取这个指针变量中，那个地址的内存中的 值，也就是直接操作内存，修改内存里的内容\n值传递 引用传递 值传递：传递一份副本，传递后操作的只是副本，也就是对变量的副本进行操作，变量本身不会变化\n1 2 3 4 5 6 7 8 9 10 11 void change(int num) { num ++; } void main() { int num = 9; change(num); printf(\u0026#34;num = %d\u0026#34;, num); } // 结果：9 引用传递：\u0026amp;var， 传递的是地址，传递后操作的是该地址中的值，也就是对变量本身进行操作\n1 2 3 4 5 6 7 8 9 10 11 void change(int * num) { *num ++; } void main() { int num = 9; change(\u0026amp;num); printf(\u0026#34;num = %d\u0026#34;, num); } // 结果：10 值传递就是普通操作，引用传递就是操作指针（骚操作）\n变量的生存周期 存储类型说明符 存储类型 说明 auto 自动存储 只能用于块作用域中的变量，局部变量默认情况下归为自动存储类型 register 寄存器存储 只能用于块作用域中的变量，请求速度快，适用在循环次数多的循环变量/反复使用的变量。 static 静态存储 载入程序时创建对象，程序结束时对象消失。 extern 外部变量 说明符表示生命的变量定义在别处。作用域是整个程序，生存周期贯穿应用程序的开始和结束。跟static一样。 头文件 1 2 3 4 5 6 #ifndef HEADFILENAME_H_INCLUDE #define HEADFILENAME_H_INCLUDE // TODO #endif ","permalink":"https://www.boii.xyz/posts/note/c-note/","summary":"\u003cp\u003eC语言笔记\u003c/p\u003e","title":"C-Note"},{"content":"Hash 是一种很神奇的数据结构\nHashTable HashTable 散列表 哈希表： 是一种数据结构，它提供快速的插入和查找操作，不管表中有多少数据，插入删除和查找的时间都接近O(1)\n**优点：**HashTable其实是基于数组的，所以在查询方面非常的快，同时它不像普通数组那样紧密排列，在数值未满的时候所有的值其实是散部在数组中的某个位置上的，所以在插入和删除的时候不用像普通数组一样让余下的值一个个的挪。\n**缺点：**同时也因为它的基于数组的，所以创建以后难以扩展，当HashTable被基本填满的时候，性能严重下降，而且不能顺序遍历。\n一个输入传进来的时候会经过散列函数，计算出一个值，这个值就是这个输入在HashTable中的位置，称为HashCode 哈希值 散列值。\n当HashTable中的值还不多的时候各种操作的效率是非常高的，但是HashTable快满的时候各种操作的效率就开始变低了\n开放寻址法 线性探测方法 比如一个HashTable的长度是8，现在只剩下 ~6~ 这个位置是空的\n而一个输入经过散列函数计算之后得到的结果是 ~7~ ，一看 ~7~ 上面有人占了，怎么办呢？\n往下找空位咯，~7~ 下面是 ~0~ ，有人了，下一个 ~1~ ，有人了，下一个 ~2~ ，有人了\u0026hellip;下一个 ~6~ ，耶没人，上去！\n这样几乎遍历了一整个数组，效率是非常低的，HashTable小的时候还能忍受，如果HashTable长度是2000呢?20000呢？\n上述的方法其实就是当散列函数计算出来的值上面已经有值的时候的解决方法之一，开放寻址法中的线性探测，往下找空位，找到进填进去。最坏的情况下就是几乎遍历整个数组。\n二次探测方法 另一种的思路有那么点像二分查找法，叫做二次探测方法\n比如表中只有 ~3~ 是有空位的，其余都是满的\n而一个输入经过散列函数计算之后得到的结果是 ~7~，一看 ~7~ 上面有人了，怎么办呢？\nCurrentCode + 0，CurrentCode + 1^2^ ，CurrentCode - 1 ^2^，CurrentCode + 2^2^，CurrentCode - 2^2^，……\n7不行就 + 1^2^ = 8，8还是不行，那就7 - 1^2^ = 6，6还是不行，那就7 - 2^2^ = 3，3可以，上去！\n因为进行试探的步长都是二次方，所以叫 二次探测方法\n双重散列方法 还有一种方法叫做 双重散列方法\n就是使用第一个哈希函数计算的值如果被占用了，就找第二个哈希函数，直到找到空闲的存储位置\n不管用那种方法，只要HashTable空位不多的时候散列冲突的概率就会大大提高，尽可能保证HashTable中有一定比例的空位。\n一般用加载因子来表示空位的多少。加载因子越大表示约满，反之亦然。\n链表法 HashTable中每个元素对应一条链表，所有散列值相同的元素放到相同的链表中。如下图\n查找的时候先通过HashCode找到位置，然后将值与链表中的值逐个使用 equals() 对比。\nBut 但其实HashTable是元素数量不能超过总容量的一半，当HashTable太满的时候，一个选择是扩容数组，创建一个新的容量为 CurrentCapacity * 1.34 + n = 2^m 的数组，把值放到新数组，但是元素的索引没法复制，会被重新哈希化。 $$ CurrentCapacity * 1.34 + n = 2^m = NewCapacity $$\n举个栗子 一本字典有1000页，当你要查找Link这个词的时候，肯定想去翻目录，目录显示在第666页，那么你是不是可以直接翻到666页找这个单词？也就是所Link这个单词在散列表[666]，但是第666页可能不止这一个单词哦，那你是不是要一个一个进行equals才能知道是哪个呢？因为知道在哪一条链表上，所以尽管遍历看起来很慢，但总比遍历所有链表快吧？\n","permalink":"https://www.boii.xyz/posts/java/java-about-hash/","summary":"Hash 是一种很神奇的数据结构\nHashTable HashTable 散列表 哈希表： 是一种数据结构，它提供快速的插入和查找操作，不管表中有多少数据，插入删除和查找的时间都接近O(1)\n**优点：**HashTable其实是基于数组的，所以在查询方面非常的快，同时它不像普通数组那样紧密排列，在数值未满的时候所有的值其实是散部在数组中的某个位置上的，所以在插入和删除的时候不用像普通数组一样让余下的值一个个的挪。\n**缺点：**同时也因为它的基于数组的，所以创建以后难以扩展，当HashTable被基本填满的时候，性能严重下降，而且不能顺序遍历。\n一个输入传进来的时候会经过散列函数，计算出一个值，这个值就是这个输入在HashTable中的位置，称为HashCode 哈希值 散列值。\n当HashTable中的值还不多的时候各种操作的效率是非常高的，但是HashTable快满的时候各种操作的效率就开始变低了\n开放寻址法 线性探测方法 比如一个HashTable的长度是8，现在只剩下 ~6~ 这个位置是空的\n而一个输入经过散列函数计算之后得到的结果是 ~7~ ，一看 ~7~ 上面有人占了，怎么办呢？\n往下找空位咯，~7~ 下面是 ~0~ ，有人了，下一个 ~1~ ，有人了，下一个 ~2~ ，有人了\u0026hellip;下一个 ~6~ ，耶没人，上去！\n这样几乎遍历了一整个数组，效率是非常低的，HashTable小的时候还能忍受，如果HashTable长度是2000呢?20000呢？\n上述的方法其实就是当散列函数计算出来的值上面已经有值的时候的解决方法之一，开放寻址法中的线性探测，往下找空位，找到进填进去。最坏的情况下就是几乎遍历整个数组。\n二次探测方法 另一种的思路有那么点像二分查找法，叫做二次探测方法\n比如表中只有 ~3~ 是有空位的，其余都是满的\n而一个输入经过散列函数计算之后得到的结果是 ~7~，一看 ~7~ 上面有人了，怎么办呢？\nCurrentCode + 0，CurrentCode + 1^2^ ，CurrentCode - 1 ^2^，CurrentCode + 2^2^，CurrentCode - 2^2^，……\n7不行就 + 1^2^ = 8，8还是不行，那就7 - 1^2^ = 6，6还是不行，那就7 - 2^2^ = 3，3可以，上去！","title":"Java-About-Hash"},{"content":"Java 神器：反射\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Person p = new Person(); /**获取*/ Class\u0026lt;?\u0026gt; clazz = p.getClass(); // 得知道类对象 Class\u0026lt;?\u0026gt; clazz = Person.class;\t//得知道类名 Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;com.tcp404.Person\u0026#34;);//得知道类的全路径名 /** 获取方法 */ Method method = clazz.getDeclaredMethod(\u0026#34;方法名\u0026#34;, new Class(){[参数类型.class, 参数类型.class, ...]}); Methods[] methods = clazz.getDeclaredMethods(); /** 获取属性 */ Field field = clazz.getDeclaredField(\u0026#34;属性名字\u0026#34;); Field[] fields = clazz.getDeclaredFields(); /** 获取构造器 */ Constructor\u0026lt;?\u0026gt; con = clazz.getDeclaredConstructor(new Class(){[参数类型.class, 参数类型.class, ...]}); Constructor\u0026lt;?\u0026gt;[] cs = clazz.getDeclaredConstructors(); ","permalink":"https://www.boii.xyz/posts/java/java-%E5%8F%8D%E5%B0%84/","summary":"Java 神器：反射\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Person p = new Person(); /**获取*/ Class\u0026lt;?\u0026gt; clazz = p.getClass(); // 得知道类对象 Class\u0026lt;?\u0026gt; clazz = Person.class;\t//得知道类名 Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;com.tcp404.Person\u0026#34;);//得知道类的全路径名 /** 获取方法 */ Method method = clazz.getDeclaredMethod(\u0026#34;方法名\u0026#34;, new Class(){[参数类型.class, 参数类型.class, ...]}); Methods[] methods = clazz.getDeclaredMethods(); /** 获取属性 */ Field field = clazz.getDeclaredField(\u0026#34;属性名字\u0026#34;); Field[] fields = clazz.getDeclaredFields(); /** 获取构造器 */ Constructor\u0026lt;?","title":"Java-反射"},{"content":"One more thing\nGit 常用命令 \u0026gt;_\nWorkspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 先放上一张常用Git 命令导航图\n一、新建代码库 1 2 3 4 5 6 7 8 在当前目录新建一个Git代码库（常用） git init 新建一个目录，将其初始化为Git代码库 git init [project-name] 下载一个项目和它的整个代码历史（常用） git clone [url] 二、配置 Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n1 2 3 4 5 6 7 8 9 显示当前的Git配置 git config --list 编辑Git配置文件 git config -e [--global] 设置提交代码时的用户信息 git config [--global] user.name \u0026#34;[name]\u0026#34; git config [--global] user.email \u0026#34;[email address]\u0026#34; 三、增加/删除文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 添加指定文件到暂存区（常用） git add [file1] [file2] ... 添加指定目录到暂存区，包括子目录 git add [dir] 添加当前目录的所有文件到暂存区（常用） git add . 添加每个变化前，都会要求确认 对于同一个文件的多处变化，可以实现分次提交 git add -p 删除工作区文件，并且将这次删除放入暂存区 git rm [file1] [file2] ... 停止追踪指定文件，但该文件会保留在工作区 git rm --cached [file] 改名文件，并且将这个改名放入暂存区 git mv [file-original] [file-renamed] 四、代码提交 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 提交暂存区到仓库区（常用） git commit -m [message] 提交暂存区的指定文件到仓库区（常用） git commit [file1] [file2] ... -m [message] 提交工作区自上次commit之后的变化，直接到仓库区 git commit -a 提交时显示所有diff信息 git commit -v 使用一次新的commit，替代上一次提交 如果代码没有任何新变化，则用来改写上一次commit的提交信息 git commit --amend -m [message] 重做上一次commit，并包括指定文件的新变化 git commit --amend [file1] [file2] ... 五、分支 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 列出所有本地分支（常用） git branch 列出所有远程分支 git branch -r 列出所有本地分支和远程分支（常用） git branch -a 新建一个分支，但依然停留在当前分支（常用） git branch [branch-name] 新建一个分支，并切换到该分支（常用） git checkout -b [branch] 新建一个分支，指向指定commit git branch [branch] [commit] 新建一个分支，与指定的远程分支建立追踪关系 git branch --track [branch] [remote-branch] 切换到指定分支，并更新工作区（常用） git checkout [branch-name] 切换到上一个分支（常用） git checkout - 建立追踪关系，在现有分支与指定的远程分支之间 git branch --set-upstream [branch] [remote-branch] 合并指定分支到当前分支 git merge [branch] 选择一个commit，合并进当前分支 git cherry-pick [commit] 删除分支（常用） git branch -d [branch-name] 删除远程分支 git push origin --delete [branch-name] git branch -dr [remote/branch] 六、标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 列出所有tag git tag 新建一个tag在当前commit git tag [tag] 新建一个tag在指定commit git tag [tag] [commit] 删除本地tag git tag -d [tag] 删除远程tag git push origin :refs/tags/[tagName] 查看tag信息 git show [tag] 提交指定tag git push [remote] [tag] 提交所有tag git push [remote] --tags 新建一个分支，指向某个tag git checkout -b [branch] [tag] 七、查看信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 显示有变更的文件（常用） git status 显示当前分支的版本历史（常用） git log 显示commit历史，以及每次commit发生变更的文件 git log --stat 搜索提交历史，根据关键词 git log -S [keyword] 显示某个commit之后的所有变动，每个commit占据一行 git log [tag] HEAD --pretty=format:%s 显示某个commit之后的所有变动，其\u0026#34;提交说明\u0026#34;必须符合搜索条件 git log [tag] HEAD --grep feature 显示某个文件的版本历史，包括文件改名 git log --follow [file] git whatchanged [file] 显示指定文件相关的每一次diff git log -p [file] 显示过去5次提交 git log -5 --pretty --oneline 显示所有提交过的用户，按提交次数排序 git shortlog -sn 显示指定文件是什么人在什么时间修改过 git blame [file] 显示暂存区和工作区的代码差异（常用） git diff 显示暂存区和上一个commit的差异 git diff --cached [file] 显示工作区与当前分支最新commit之间的差异 git diff HEAD 显示两次提交之间的差异 git diff [first-branch]...[second-branch] 显示今天你写了多少行代码 git diff --shortstat \u0026#34;@{0 day ago}\u0026#34; 显示某次提交的元数据和内容变化（常用） git show [commit] 显示某次提交发生变化的文件 git show --name-only [commit] 显示某次提交时，某个文件的内容 git show [commit]:[filename] 显示当前分支的最近几次提交 git reflog 从本地master拉取代码更新当前分支：branch 一般为master git rebase [branch] 八、远程同步 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 git remote update --更新远程仓储（常用） 下载远程仓库的所有变动 git fetch [remote] 显示所有远程仓库 git remote -v 显示某个远程仓库的信息 git remote show [remote] 增加一个新的远程仓库，并命名 git remote add [shortname] [url] 取回远程仓库的变化，并与本地分支合并（常用） git pull [remote] [branch] 上传本地指定分支到远程仓库（常用） git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突 git push [remote] --force 推送所有分支到远程仓库 git push [remote] --all 九、撤销 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 恢复暂存区的指定文件到工作区 git checkout [file] 恢复某个commit的指定文件到暂存区和工作区 git checkout [commit] [file] 恢复暂存区的所有文件到工作区 git checkout . 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 git reset [file] 重置暂存区与工作区，与上一次commit保持一致(取消所有修改)（常用） git reset --hard 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 git reset [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 git reset --hard [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变 git reset --keep [commit] 新建一个commit，用来撤销指定commit 后者的所有变化都将被前者抵消，并且应用到当前分支 git revert [commit] 暂时将未提交的变化移除，稍后再移入（常用） git stash git stash pop 十、其他 1 2 生成一个可供发布的压缩包（常用） git archive ","permalink":"https://www.boii.xyz/posts/git/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","summary":"\u003cp\u003eOne more thing\u003c/p\u003e","title":"Git命令大全"},{"content":"多端管理其实很简单。\nhexo 其实是帮我们编译好放在博客根目录\\public目录下的，然后把public目录推送到github上的，所以说github.io上面都是编译过的文件，他们是光鲜亮丽的演员，但离不开默默付出的后台人员。这些默默付出的后台人员就是除了public之外的所有的文件。\n我们的博客是发布到master主分支的，那就建另一个分支，把所有文件都传上去，在别的电脑上都拉下去就可以了。\n1. 首先填写忽略声明文件.gitignore 1 2 3 4 5 6 7 8 .DS_Store Thumbs.db db.json *.log node_modules/ public/ .deploy*/ _config.yml public 每次都会编译覆盖，所以不需要它 .deploy* 编译产生的文件，也不需要 _config.yml 配置文件里会有一些id/key的重要信息，所以不上传 2. 初始化仓库和提交 之前我以为hexo就是帮我们操作git，所以不明白为什么还能再初始化git\n后来才知道不是那么回事。但是hexo是怎么操作我还是没明白。这里不管\n像往常一样，在根目录右键 git bash here\n注意！！！大坑！！！\n如果你用的是第三方的主题theme，是使用git clone下来的话，要把主题文件夹下面把.git文件夹删除掉，不然主题无法push到远程仓库，导致你发布的博客是一片空白。所以先去检查你使用的主题有没有.git这个目录\n1 2 3 4 5 6 git init //初始化本地仓库 git add . //添加本地所有文件到仓库 git commit -m \u0026#34;blog源文件\u0026#34; //添加commit git branch backup //添加本地仓库分支hexo git remote add origin \u0026lt;server\u0026gt; //添加远程仓库 \u0026lt;server\u0026gt; 是指在线仓库的地址 origin是本地分支,remote add操作会将本地仓库映射到云端 git push origin backup //将本地仓库的源文件推送到远程仓库hexo分支 在另一台电脑的操作 首先肯定要搭建环境啦（Node 和 Git）\n完了后用这个命令\n1 2 3 git clone \u0026lt;server\u0026gt; hexo //\u0026lt;server\u0026gt; 是指在线仓库的地址 cd hexo npm install npm install的时候会根据package.json中的插件列表自动加载相应插件。 本机的同步完成。\n因为在上传博客源文件的时候忽略了配置文件（_config.yml这是站点的配置文件）的上传，也就是没有上传配置文件的，在克隆下来的时候记得把配置文件拿过来，不然会报错。主题里面的配置文件也要（themes/next/_config.yml这是主题配置文件）\n这里贴一张常用Git命令\n\u0026gt;_\n","permalink":"https://www.boii.xyz/posts/hexo/%E5%A4%9A%E7%AB%AF%E5%90%8C%E6%AD%A5%E7%AE%A1%E7%90%86hexo%E5%8D%9A%E5%AE%A2/","summary":"\u003cp\u003e多端管理其实很简单。\u003c/p\u003e","title":"多端同步管理Hexo博客"},{"content":"吃饭和打电话你选择哪个？\n举个栗子 你在吃饭，电话进来，你等到吃完了才接电话 \u0026ndash;\u0026gt; 你不支持【并行或者并发】 （1个CPU，队列式执行任务，这个做完了才做下一个，不允许插队）\n你在吃饭，电话进来，接一下电话，吃一下饭，交替进行，说明你支持【并发】 （一个CPU，多个任务同时进行，这个做一下，那个做一下，回过来这个再做一下\u0026hellip;，允许插队）\n你在吃饭，电话进来，你继续吃饭，秘书帮你接电话，说明你支持【并行】 （多于一个CPU，多个任务同时进行，各忙各的）\n\u0026gt;_\n正儿八经的胡说一下 并发主要是指：同一时间 【段】 \u0026ldquo;同时\u0026quot;做多件事\n比如一边打电话一边吃饭。人脑肯定是没法同时专注在两个事情上的，所以你的注意力会一下在电话上（听电话里说什么），一下在吃饭上（大脑下达抬手张嘴咀嚼的指令），CPU也是如此。\n吃饭一个线程，接电话一个线程。分给吃饭线程一点时间片，分给接电话一点时间片，吃饭的时间片执行完了切到电话线程执行，电话线程的时间片执行完了切到吃饭线程，因为切换的快，所以感觉像同时进行。\n这里时间片不懂的话就姑且理解为能量条，CPU切过来执行吃饭线程，吃饭线程的能量条就开始消耗，消耗完了CPU就走了去消耗电话线程的能量条了。与此同时吃饭线程的能量条在CPU切走的时候瞬间满了，CPU那边消耗完了又过来吃饭线程消耗这边的能量条，耗完了又走了。如此往复直到任务执行完毕。\n并行只要是指：同一时间 【点】 \u0026ldquo;同时\u0026quot;做多件事\n还是上面吃饭打电话的例子，电话来了你吃你的，电话秘书帮你接。你处理吃饭的事情，秘书处理电话的事情，所以就不用CPU切来切去的。因为有两个CPU了嘛（你 和 秘书）。\n总结 一个收银员，只能排一条队伍，一个一个来，就是不支持并发并行\n一个收银员，可以排多条队伍，这边忙忙那边忙忙，就是支持并发\n多个收银员，可以排多条队伍，一个收银员处理一条队伍，就是支持并行\n可见CPU只有一个的时候，就是假同时；多个CPU的时候，才是真正意义上的同时。\n","permalink":"https://www.boii.xyz/posts/note/%E5%87%A0%E5%8F%A5%E8%AF%9D%E5%8C%BA%E5%88%86%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91/","summary":"\u003cp\u003e吃饭和打电话你选择哪个？\u003c/p\u003e","title":"几句话区分并行和并发"},{"content":"开发小程序后的一点总结\n本来没想搞小程序的，谁知道寒假突然脑子发热，看了点视频和文章，就着现成的点子开始搞起来。\n从1月20日到4月2日，平均每天投入10+小时，历经三次改版，一次阉割，无数次和UI吵架，总算把GoTE小程序做出来了。\n小程序 1 2 3 4 5 6 7 小程序名：GoTE行程发布小程序 样式库：ColorUI 插件：WxValidate.js（表单验证） 外部API：高德地图开放平台（用于获取打车费用\u0026lt;已阉割\u0026gt;） 前端：小程序原生 后端：小程序云开发环境 数据库：云开发 -\u0026gt; 云数据库 \u0026gt;_\n\u0026gt;_\n项目最初的出发点是由于学校地处偏僻，出行不便，坐公车经常拥挤且一站到底。打车费用又十分昂贵，且独自出行来往于学校这偏僻之地具有一定危险性。校外非法黑车趁机拉帮结派，用略低于滴滴的价格拉拢学生乘坐。为了大幅盈利设置了拼车一项，一行4人35元，但是单人拼车费用要17元！\n所以我决定自己开发一个小程序供同学们发布行程信息，有相同行程的人可以互相联系一同出行，即节省了出行成本，又避免单独外出。\n于是1月20日正式开动，在此后的不间断每天投入10+小时在其中，从产品定位，功能定义，开发，测试等等，历经73天最终定版，提交审核。\n正当我满心欢喜的提交审核两天之后，审核团队冷冰冰的打回，再之后不管多少次修改都只有冷冰冰的这么一句话\n\u0026gt;_\n我只是一个单纯的行程发布平台，连个车字都没有哪来的涉及拼车？不管是反馈还是重新提交都只有这么冷冰冰的一句话。\n此项目对我来说有非凡的意义，\n第一个完整的个人项目 第一次完成想法落地实现的完整执行 第一次靠自学完成一个项目 总结 在被腾讯审核团队冷冰冰的打回N次之后，开始有些心灰意冷。在这次项目中，还是有一些体会的。\n在开发过程中慢慢明白了，小程序其实可以理解为一个微信内置浏览器，开发小程序的过程就跟开发网页类似。不过小程序封装了很多接口，提供了很多实现。如果是有开发经验的程序员，稍微熟悉语法就可以快速开发出一个完整的小程序，不夸张的说，一个商城，从零开始，快则半月，慢则一月。\n小程序本身的局限性所致，小程序注定无法完全替代App。作为分销引流可以，要完全替代不太现实。小程序开发完全部资源包括代码不能超过2M，且运行载荷不能太大，否则会被微信的机制强制退出。如果你手机太老，还会把你的微信给强制退出（闪退）。所以承担一点分销展示的任务可以，完全搬上小程序会导致体验极其的差。参考 微信支付 -\u0026gt; 酒店 -\u0026gt; 同程艺龙小程序。大量的网络请求，实测 Iphone6 plus IOS 10.2 上运行体验很差.\n像微信小程序，支付宝小程序，百度小程序等这种开发都是寄人篱下。用人家的平台，人家接口，享受人家封装好带来的便利，需要付出的代价就是非常严格的审核。这种情况下只能祈福于客服，出了问题或是疑问有个靠谱的客服或者回应显得尤为重要。像微信这种机器人只能说(ta)呵(ma)呵(de)了。\n做成一件事情很难，特别是这种涉及很多用户，用户之间产生交流的事情，你要够专业，够团结，够投入，够拼，能力够强。GoTE是一个面向学生的，开放的平台，也就是说用户与用户之间会产生交流。在涉及到这种用户之间交流（社交）的时候就需要格外小心。比如GoTE：\n第一要面临的问题就是用户身份验证。怎么确定你是学生？哪个学校的学生？目前能想到的就是利用超级课程表的方式，利用爬虫接入各学校教务系统，学生提供账号密码验证码，登录到教务系统中验证。 第二怎么保障共同出行过程的顺利？怎么尽量确保双方之间不会发生矛盾（因为路费或是任何问题）？ 看似简单的两个问题其实需要大量的工作。不过我只有一个人，很需要帮手。\n此文作为第一次实际行动的总结记录\n谨此\n","permalink":"https://www.boii.xyz/posts/other/%E5%BD%93%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E5%AE%8C%E6%88%90%E5%90%8E/","summary":"\u003cp\u003e开发小程序后的一点总结\u003c/p\u003e","title":"当小程序开发完成后"},{"content":"换个详细点的捋一捋\n首先，用户的操作系统会内置一些CA机构的CA证书\nCA证书：CA机构颁发给自己的证书\n组成：\nCA的公钥 颁发者 颁发机构 有效期 其他内容 签名（CA私钥加密过）： 对以上内容进行hash=\u0026gt;hash值 hash的算法 这里签名是CA私钥加密过的，如果黑客用公钥解开签名，然后篡改信息再Hash，带上hash算法，就没办法加密回去，因为没CA私钥。\n如果篡改成自己的公钥，再hash，带上hash算法，用自己的私钥加密（签名），这就是伪造CA证书，这样等于白干，因为操作系统会提示这个证书不可信，不过CA证书一般都是操作系统内置的，不需要网络请求，所以没机会拦截篡改。一般问题都出在CA机构内部。\n那一个网站，它首先要找CA机构认证，认证完CA机构会给一张证书，这个就是网站证书了\n网站证书：CA机构给网站颁发的证书\n组成：\n网站的公钥 颁发者（CA机构） 颁发机构（网站） 有效期 其他内容 CA签名，也就是指纹（CA私钥加密过的）： 对以上内容进行hash=\u0026gt;hash值 hash的算法 这里的CA签名也是用CA私钥加密过的，如果黑客用CA公钥解开签名，然后篡改网站的公钥再hash，带上hash算法，就没法加密回去，因为没CA私钥。用黑客自己的私钥加密回去的话，用户拿到证书，根据颁发者（CA机构）拿出CA公钥，它解不开黑客的私钥。那就通信终止了。\n场景： 首先用户请求网站给个证书看看 网站给了网站证书 用户就根据证书的颁发者去操作系统找颁发者的证书（也就是操作系统中的CA证书），去拿到CA公钥出来 然后用CA公钥解开CA签名拿到hash值1和hash算法 然后用hash算法自己计算整个证书的内容得到hash值2 对比hash值1和hash值2来验证网站证书有没有被篡改 验证通过后会生成一串随机字符串，自己保留一份，然后发一份让网站用网站的私钥加密这串随机字符串 网站把这串随机字符串用网站的私钥加密，发回给客户 用户再用证书上的网站的公钥去解，能解开，解开后对比回来的随机字符串和自己保留的那份随机字符串是不是一致 一致则说明对方就是服务器，而不是黑客瞎搞 为了服务器安全所以用户先hash一下再发，服务器加密就行了。用户解密完对比回来的hash跟自己留着的hash是不是一直就行了。hash过才能防止黑客发送一些有规律的字符串给服务器，从而寻找加密的规律。以此保护服务器私钥的安全\n如果证书没问题，对方却是黑客，那字符串用黑客的私钥加密，用户用网站的公钥是解不开的。 除非黑客能弄到网站的私钥，才能在这插一脚，像上面说的黑客发送有规律的字符串 不过被hash解决了，接下来就要传输密钥了。\n用户验证了一直，就用自己生成一串密钥，然后用网站的公钥加密，发给网站 网站用网站的私钥解密，得到密钥。 然后双方开始用密钥加密信息通信。\n通信的时候用户的数据写完，会先把内容hash一下生成摘要，再用密钥加密 网站收到之后会先用密钥解密，然后网站自己hash一下内容生成摘要，对比传过来的摘要看看是否一致 是就没问题，不一致则说明黑客在中间捣乱。则断开连接\n所以用密钥的时候，其实是 信息内容本身+hash出来的信息摘要，然后才加密\n","permalink":"https://www.boii.xyz/posts/rsa/%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-%E8%AF%A6%E7%BB%86%E7%89%88/","summary":"\u003cp\u003e换个详细点的捋一捋\u003c/p\u003e","title":"通信中的加密与解密-详细版"},{"content":"LeetCode 第9题\n题目 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n示例 1: 输入: 121 输出: true\n示例 2: 输入: -121 输出: false\n解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n示例 3: 输入: 10 输出: false\n解释: 从右向左读, 为 01 。因此它不是一个回文数。\n进阶: 你能不将整数转为字符串来解决这个问题吗？\n思路 首先根据题意，负数肯定是不符合要求的。那第一步先判断给进来的数是不是小于0，是直接返回出去。 要达成回文数一般都要三位数，但是0~9，11，22，33\u0026hellip;也可以是回文数，所以小于100的数也要处理一下 现在开始解题，会有两种情况，数字长度为奇数 和 偶数 如果是偶数，只要后半段 == 前半段，return ture 如果是奇数，只要前半段 == 后半段 / 10，return ture 代码过程和计算水仙花数类似\n把传进来的数x取余数k赋值给res，然后x 自除 10，第二轮res自乘10再＋取余数k\nres向上迭代，x向下迭代，最后进行比较。如果遇到数字位数是奇数位就比较前半段是否等于后半段÷10\n代码 1 2 3 4 5 6 7 8 9 10 11 class Solution { public boolean isPalindrome(int x) { if (x \u0026lt; 0 || x % 10 == 0 ) return false; int res = 0; while (x \u0026gt; res){ res = res * 10 + x % 10; x /= 10; } return x == res || x == res / 10; } } 输入 1221，我们可以将数字“1221”的后半部分从“21”反转为“12”，并将其与前半部分“12”进行比较，因为二者相同，我们得知数字 1221 是回文。\n","permalink":"https://www.boii.xyz/posts/leetcode/leetcode-%E7%AC%94%E8%AE%B0no-40x09-%E5%9B%9E%E6%96%87%E6%95%B0/","summary":"\u003cp\u003eLeetCode 第9题\u003c/p\u003e","title":"LeetCode-笔记【No-4】0x09-回文数"},{"content":"LeetCode 第13题\n题目 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n示例 1:\n输入: \u0026ldquo;III\u0026rdquo;\n输出: 3\n示例 2:\n输入: \u0026ldquo;IV\u0026rdquo;\n输出: 4\n示例 3:\n输入: \u0026ldquo;IX\u0026rdquo;\n输出: 9\n示例 4:\n输入: \u0026ldquo;LVIII\u0026rdquo;\n输出: 58\n解释: L = 50, V= 5, III = 3.\n示例 5:\n输入: \u0026ldquo;MCMXCIV\u0026rdquo;\n输出: 1994\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\n思路 首先建立一个HashMap来映射符号和值 然后对字符串从左到右来，如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。 以此类推到最右边的数，最终得到的结果即是答案 这是LeetCode评论上的一条思路。非常简单粗暴。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int romanToInt(String s) { Map\u0026lt;Character,Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#39;I\u0026#39;,1); map.put(\u0026#39;V\u0026#39;,5); map.put(\u0026#39;X\u0026#39;,10); map.put(\u0026#39;L\u0026#39;,50); map.put(\u0026#39;C\u0026#39;,100); map.put(\u0026#39;D\u0026#39;,500); map.put(\u0026#39;M\u0026#39;,1000); int res = 0; int size = s.length(); //最后一位不需要判断所以循环次数是size-1 for (int i = 0; i \u0026lt; size - 1; i ++) { //如果左边的数字小于右边的数字 if (map.get(s.charAt(i)) \u0026gt;= map.get(s.charAt(i+1))){ res += map.get(s.charAt(i)); } else { //如果左边数字小于右边的数字（也就是通常4和9的情况） res -= map.get(s.charAt(i)); } } //最后一位没被判断到，所以没被加上，记得加上去 res += map.get(s.charAt(size - 1)); return res; } } 这里的if判断先写多数的情况，也就是左边的数大于右边的数。\n这样才不会把时间浪费在 先判断少数情况（左边 小于右边），再执行多数情况的运算\n","permalink":"https://www.boii.xyz/posts/leetcode/leetcode-%E7%AC%94%E8%AE%B0no-30x0d-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/","summary":"\u003cp\u003eLeetCode 第13题\u003c/p\u003e","title":"LeetCode-笔记【No-3】0x0D-罗马数字转整数"},{"content":"LeetCode 第7题\n题目 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。\n思路 一开始的思路是把数字取模然后放到int数组里，但是这样复杂又难实现，时间复杂度上也没优势\n后来看到网络上的答案，思路是这样的： 首先把要判断这个数是否超范围 然后再把这个数x拿来取模，获得最后一个数并赋值给一个新的变量 然后x自除10，进入下一次循环 第二次循环的时候新变量自乘10再加取模得到的数。最后返回这个新变量\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int reverse(int x) { int rev = 0; //新变量 while (x != 0) { //判断我们取得的数是否超范围 // 2^31-1 = 2147483647 | -2^31 = -2147483648 if (rev \u0026gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 \u0026amp;\u0026amp; pop \u0026gt; 7)) return 0; if (rev \u0026lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 \u0026amp;\u0026amp; pop \u0026lt; -8)) return 0; int pop = x % 10; //取模拿到个位数 rev = rev * 10 + pop; //自身×10空出个位，然后加上刚刚取模出来的数 x /= 10; //迭代条件。因为x是int类型，所以÷10以后小数点就被省略了 } return rev; } } 这种思路，就不需要把数字切成一个一个再拼接。直接利用数字的特性，通过取模和乘除运算带达到效果。\n时间复杂度：O(log(x))，x 中大约有 log{10}(x)位数字。 空间复杂度：O(1) ","permalink":"https://www.boii.xyz/posts/leetcode/leetcode-%E7%AC%94%E8%AE%B0no-20x07-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","summary":"\u003cp\u003eLeetCode 第7题\u003c/p\u003e","title":"LeetCode-笔记【No-2】0x07-整数反转"},{"content":"LeetCode 第1题\n题目 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n示例 给定 nums = [2, 7, 11, 15], target = 9\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n思路 思路非常简单，就是把要找的数字target，减去第一个的差，是否等于第二个数\n如果是，返回这两个数的下标，如果不是，循环继续。\n代码 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int[] twoSum(int[] nums, int target) { for (int i = 0; i \u0026lt; nums.length - 1; i++) { for (int j = i+1; j \u0026lt; nums.length; j ++) { if (nums[j] == target - nums[i]) { return new int[] { i , j }; } } } return null; } } 第一层循环取第一个数i，然后进入第二层循环，\n第二层循环从第二个数j 开始，判断要找的数-第一个数i 的差 是否等于 第二个数 j\n如果不是第二层取第三个数，再进行比较。\n如果第二层遍历完还没结果说明第一层的第一个数i不对，所以第一层取第二个数\n再次进入第二层依次遍历。\n当差等于第二层的某个数的时候，说明找到了，返回i和j的下标。\n时间复杂度：O(n)\n空间复杂度：O(n)\n","permalink":"https://www.boii.xyz/posts/leetcode/leetcode-%E7%AC%94%E8%AE%B0no-10x01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"\u003cp\u003eLeetCode 第1题\u003c/p\u003e","title":"LeetCode-笔记【No-1】0x01-两数之和"},{"content":"怎么和聊天才能不被人看到信息内容？\n加密与解密 应用场景：通信\n传统的通信场景：明文 \u0026gt;_\n如果这时候有个Hacker在中间嗅探他们的通信链路，那他们的内容就全都被看到了，甚至会被篡改\n\u0026gt;_\n加密\u0026amp;解密 明文有问题，那就加密，让中间的Hacker看不懂\n凯撒密码 通过约定的偏移和回正，达到A、B都看得懂，中间人看不懂的目的\n加密：A发送的信息，全部右偏移3个字母\n解密：B接收后左回正3个字母，就得到正确信息了。\n例如：Hello world\n右偏移后变成 Khnnr zrung\n但是这样的加密太容易被破解了。凯撒密码是一种很古老的在战争中使用过的一种加密信件的方式，这里不说汉字，就说英文26个字母，最多进行（回正1，回正2，回正3\u0026hellip;回正25,回正-1，回正-2\u0026hellip;回正-25）共50次就可以破解。\n对称加密 A、B都将信息异或运算\n如果将信息转成二进制，然后和另一个二进制(这里用E表示)，得到加密结果\n那加密结果和E异或就能得到原本的信息的二进制，再转换成文字就得到了信息。\nA ^ E = C\tC ^ E = A\n例如：\n加密的一方\n假设 Hello world 的二进制是 0110 0101 1101\nE 是：\t0101 1001 1010\n加密（异或）的结果就是:\t0011 1100 0111\n解密的一方\n收到了加密的信息:\t0011 1100 0111\nE 是：\t0101 1001 1010\n解密（异或）的结果就是：0110 0101 1101\n\u0026gt;_\n这就是利用异或的特性来进行信息的加密。所以关键的E 就叫做密钥（所以拿到密钥就能破解了）。\n要确保双方都有 E 这把密钥。\n对称加密有3个特点：\n仅做XOR（异或）运算，速度快\t\u0026ndash;优点 密钥跟数据长度相等 \u0026ndash;缺点 双方需要提前拥有密钥 加密分片 对称加密的缺点也明显，密钥长度跟数据长度相等。\n解决的办法是：\n把信息分组，每组对应一段密钥，分别做异或运算就可以得到密文分片，再合并到一起就得到密文（加密的信息）了。\n接收的一方分别做异或运算得到明文分片，在合并到一起就得到原本的信息了。\n加密分片的特点：\n数据按密钥长度分组，不足的填充 可以并行计算各个分组，优化了性能 密文跟明文的序列存在规律对应关系 上面说的就是DES的ECB模式加密\n不过这种简单的分组模式也是很容易发现规律\n一般的改进思路是：信息第一次分组、加密、合并得到了一次密文，然后再进行第二次分组、加密、合并得到二次密文。\n或者第一次分组，一次加密、二次加密、合并。\n非对称加密 请求方请求公钥，接收方发送公钥，请求方加密后发送，接收方用私钥解密\n那密钥这么好，但是有个问题：E（密钥）怎么传输？明文还是密文？\n答案是：明文。\n那密钥是明文的，被Hacker嗅探到了，那上面那些不都白费了。\n所以就有了 非对称加密\n\u0026gt;_\n简单说就是：我先要个保险箱，然后把密钥放进去，关上。这个保险箱只有你开的了，所以被Hacker截获了他也开不了。\n这就是非对称加密。谁都可以跟B拿保险箱，只有B自己才开得了保险箱。\n1 2 3 4 5 打开状态的[保险箱] == 公钥 关闭状态的[保险箱] == 密文 保险箱钥匙 == 私钥 他们的特点就是：\n任何人都可以请求并拿到公钥 用公钥加密明文变成密文 仅能用私钥解开密文得到明文 私钥不能丢失 RSA就是这样一个公钥（保险箱）私钥（钥匙）的算法，具体的数学应用利用了 大质数相乘难以分解，费马小定理 等数学理论，使得它难以破解（思考：所以从质数、小定理这些数学理论入手，是不是有机会破解非对称加密？）。\n非对称加密需要做乘法模除等运算，性能效率比对称加密差很多。\n对称加密需要做异或预算，性能效率比较高。\n那么就综合起来，用非对称加密传输密钥E，然后再用对称加密传输数据。\n认证 找个我们都信得过的组织来保证我们不会被骗走密钥\n接上面的思考，其实不用那么麻烦，硬刚刚不赢，可以曲线救国嘛~~\n\u0026gt;_\n如上，因为Hacker在中间截胡，所以他两边欺骗，然后只是做一个转发的工作。这个过程中，信息就给他看完了，而A、B都以为自己在跟对方通信，其实都被Hacker欺骗了。接下来开始传输数据的时候，Hacker前面拿到了密钥，所以他能解密任何数据，这样就绕过了非对称加密，保险箱不起作用了。\nCA证书 那要怎么保证A请求B的公钥（保险箱）后，对方发过来的公钥（保险箱）就一定是B的呢？\n这里就需要一个彼此信任的组织，给每个人发身份证。就好像我们信任政府发的个人身份证（假设身份证没法伪造），所以我们看到个人身份证的时候就相信这个叫身份证上的名字。\n在加密中，这个政府就是CA，身份证就是CA证书、CA数字签名。\n大家都信任CA，所以检查CA证书后我们就相信B 是 B。\n这个证书里面有两个重要的内容：B的公钥+CA做的数字签名\nCA证书是反过来的，用私钥加密，用公钥解密。\nCA用自己的私钥加密B的信息，A手里都有CA的公钥，在收到信息的时候，用CA的公钥解密，如果能解开，就证明B就是B。\n换句话说，A请求B发保险箱过来，B先把保险箱给CA做个记号（CA认证加密），然后再发给A，A收到后看看记号跟CA约定的一不一样（CA的公钥解不解得开），如果Hacker发一个自己的保险箱，上面是没记号的（或者记号跟约定的不一样），那就说明这个保险箱是假的。\n\u0026gt;_\n以上就是一个简单的过程，Hacker发的假保险箱（公钥）跟CA约定的不一样（CA公钥解不开），A就停止发送密钥，Hacker欺骗失败\n完整性 非对称加密 和 认证 解决了保密性和真实性，但是完整性还没有一个保障。\n如果Hacker等A、B非对称加密传输完密钥之后，在对称加密传输数据这个环节入手，篡改信息怎么办？\n答案是：哈希一下\n单向哈希（Hash）可以把一个输入变成一个定长的输出串，它的特点就是无法从这个输入逆向还原输入内容，并且输入只要有一点改变，哪怕是那么一丢丢，输出串都会完全不同。\n\u0026gt;_\n这里哈希并不是这么简单，只需要知道哈希不可逆，一点点改变都会导致结果完全不同。\n总结 安全可靠的通信：\nB让CA用 # CA私钥 # 签名 [B的公钥]（给B的保险箱做个记号） A请求B给 [B的公钥]（打开的保险箱） B发送签名过的 [[B的公钥]]（带记号的保险箱）给A A用 ## CA的公钥 ## 校验B发来的 [[ B的公钥 ]]（检查记号） 用 [ B的公钥 ] 加密 \u0026ldquo;密钥E\u0026rdquo;（密钥放进保险箱关上门） B用【B的私钥】解密 \u0026ldquo;密钥E\u0026rdquo; A 用 \u0026ldquo;密钥E\u0026rdquo; 加密后传输数据 B 用 \u0026ldquo;密钥E\u0026rdquo; 解密数据 \u0026gt;_\n","permalink":"https://www.boii.xyz/posts/rsa/%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/","summary":"\u003cp\u003e怎么和聊天才能不被人看到信息内容？\u003c/p\u003e","title":"通信中的加密与解密"},{"content":"数学是一种很奇妙的东西\n质数：只能被1和自身整除的数\n互质数：两个数的公约数只有1，这两个为互质数\n欧拉函数：OL(n)=x，x：从0到n的范围内，和n互质的数 的 个数，也就是从0到n的范围内，和n的公约数只有1的数的个数\nRSA加密原理 P：质数1\tQ：质数2\tN：最小公倍数\tOL(N)=X -\u0026gt; X：小于N \u0026amp; 和N互质 的数的个数\nE：公钥\tD：私钥\tM：明文\tC：密文\n找出P、Q\n比如：P = 3\tQ=11\n找公共模数（求最小公倍数）\nN = P * Q = 3 * 11 = 33\tN=33\n欧拉函数\nOL(N) = (P - 1)(Q - 1)\nOL(33) = (3 - 1)(11 - 1) = 20\n计算公钥E\n1 \u0026lt; E \u0026lt; OL(N)\t=\t1 \u0026lt; (1,20) \u0026lt; 20\nE的取值范围{3，5，7，11，13，17，19}\nE必须是整数，E必须和**OL(N)**互质\n假设E=3，3是整数，3和20互质\n计算私钥D\nE * D % OL(N) = 1\t=\t3 * D % 20 = 1，得出D=7\n到这我们就计算出公钥和密钥了，现在我们开始用公钥加密，然后用私钥解密\n加密解密 公钥加密\n比如我们加密数字2：M=2\nC = ME mod N; 即\t密文 = 明文公钥 % 最小公倍数\nC = 23 % 33 = 8\tC = 8\n明文2经过RSA加密后变成密文8\n私钥解密\nM = Cd mod N; 即 明文 = 密文私钥 % 最小公倍数\nM = 87 % 33 = 2\tM = 2\n密文8经过RSA解密后变成明文2\n","permalink":"https://www.boii.xyz/posts/rsa/rsa%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/","summary":"\u003cp\u003e数学是一种很奇妙的东西\u003c/p\u003e","title":"RSA加密原理"},{"content":"","permalink":"https://www.boii.xyz/posts/git/mergerebasecherry-pick/","summary":"","title":""},{"content":"换源 1 sudo pacman-mirrors -i -c China -m rank 或者自动选择\n1 pacman-mirrors -c China 或者自动选择最快的\n1 pacman-mirrors --fasttrack 安装 Yay 1 sudo pacman -Sy yay 安装字体 1 yay -Sy wqy-zenhei wqy-microhei adobe-source-han-sans-otc-fonts tty-font-awesome tty-cascadia-code nerd-fonts-cascadia-code ttf-material-icons 输入法 1 sudo pacman -Sy fcitx5 fcitx5-chinese-addons fcitx5-qt fcitx5-gtk fcitx5 是输入法框架，默认支持英文。 fcitx5-chinese-addons 是中文支持。\n配置环境变量 1 sudo vim ~/.pam_environment 输入：\n1 2 3 4 INPUT_METHOD DEFAULT=fcitx5 GTK_IM_MODULE DEFAULT=fcitx5 QT_IM_MODULE DEFAULT=fcitx5 XMODIFIERS DEFAULT=\\@im=fcitx5 配置自启动 1 sudo cp /usr/share/applications/org.fcitx.Fcitx5.desktop /etc/xdg/autostart/ /usr/share/applications 下可能不是叫 org.fcitx.Fcitx5.desktop，可能是 fcitx5.desktop，自己看下。\n选择 注销重启，在菜单栏右键选择一个 键盘-英语，再选一个 拼音\n设置 翻页 1 2 3 4 5 6 7 8 9 10 sudo vim ~/.config/fcitx5/conf/pinyin.conf # 翻页 [PrevPage] 0=minus 1=comma [NextPage] 0=equal 1=period 主题 1 sudo pacman -S fcitx5-material-color 配置主题\n1 2 3 4 5 6 7 8 9 10 11 # ~/.config/fcitx5/conf/classicui.conf # 垂直候选列表 Vertical Candidate List=False # 按屏幕DPI使用 PerScreenDPI=True # Font (设置成自己喜欢的，前提是安装了字体) Font=\u0026#34;Source Han Sans Medium 13\u0026#34; # 主题 Theme=Material-Color-Blue 字体名字可以到 /usr/share/fontconfig/conf.default/ 下，用 vim 打开查看。fontconfig.match.test.string 里就是正确的名字。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE fontconfig SYSTEM \u0026#34;../fonts.dtd\u0026#34;\u0026gt; \u0026lt;fontconfig\u0026gt; \u0026lt;match target=\u0026#34;scan\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;fullname\u0026#34; compare=\u0026#34;eq\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Source Han Sans Medium\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026#34;weight\u0026#34; mode=\u0026#34;assign\u0026#34;\u0026gt; \u0026lt;const\u0026gt;demibold\u0026lt;/const\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026#34;scan\u0026#34;\u0026gt; \u0026lt;test name=\u0026#34;fullname\u0026#34; compare=\u0026#34;eq\u0026#34;\u0026gt; \u0026lt;string\u0026gt;Source Han Sans K Medium\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; ... GitHub Fcitx5-Material-Color\nAUR WIKI\nNeoVIM 1 yay -Sy nvim 推荐配置：nvimdots\n科学上网 v2raya\n其他软件 flameshot 截图 1 yay -Sy flameshot timeshift 备份回滚 1 yay -Sy timeshift Alacritty TTY工具 1 yay -S alacritty GitHub Alacritty\nConfig: ～/.config/alacritty/\nPolybar 菜单栏 1 yay -Sy polybar WIKI: GitHub polybar\nPicom 半透明效果 1 yay -Sy picom 墙纸 ~/.wallpapers\n1 yay -Sy feh Rofi 快捷启动+切换 1 yay -Sy rofi GitHub Rofi\nRanger 文件浏览器\nfzf 文件搜索\n音频管理\nnmcli 网络管理\nlight 亮度管理\nxrandr 外接显示设备管理\n蓝牙音箱 确保安装了 bluez 等, 特别是 pulseaudio-bluetooth-a2dp-gdm-fix\n1 sudo pacman -S bluez bluez-utils pulseaudio-bluetooth pavucontrol pulseaudio-alsa pulseaudio-bluetooth-a2dp-gdm-fix pulseaudio-bluetooth pulseaudio-bluetooth-a2dp-gdm-fix.sh 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 #!/usr/bin/env bash # https://aur.archlinux.org/packages/pulseaudio-bluetooth-a2dp-gdm-fix sudo groupadd pulse-users sudo chown -R root:pulse-users /usr/bin/pulseaudio sudo usermod -a -G pulse-users $USER sudo chmod 650 /usr/bin/pulseaudio echo \u0026#34;reboot to apply\u0026#34; 启动蓝牙\n1 2 sudo systemctl enable bluetooth sudo systemctl start bluetooth 启动pulseaudio服务\n1 2 pulseaudio -k # 确保没有pulseaudio启动 pulseaudio --start # 启动pulseaudio服务 输入 pavucontrol 控制输出设备\n1 pavucontrol Q\u0026amp;A Q: 安装以后 terminal 中文显示正常，但是其他 GUI 的地方中文不显示 A: 安装 adobe-source-han-sans-otc-fonts 字体\n1 yay -Sy adobe-source-han-sans-otc-fonts Pacman 命令 安装软件 命令 描述 pacman -S 软件名 安装软件。也可以同时安装多个包，只需以空格分隔包名即可。 pacman -S \u0026ndash;needed 软件名1 软件名2 安装软件，但不重新安装已经是最新的软件。 pacman -Sy 软件名 安装软件前，先从远程仓库下载软件包数据库(数据库即所有软件列表)。 pacman -Sv 软件名 在显示一些操作信息后执行安装。 pacman -Sw 软件名 只下载软件包，不安装。 pacman -U 软件名.pkg.tar.gz 安装本地软件包。 pacman -U http://www.example.com/repo/example.pkg.tar.xz 安装一个远程包（不在 pacman 配置的源里面）。 卸载软件 命令 描述 pacman -R 软件名 该命令将只删除包，保留其全部已经安装的依赖关系 pacman -Rv 软件名 删除软件，并显示详细的信息 pacman -Rs 软件名 删除软件，同时删除本机上只有该软件依赖的软件。 pacman -Rsc 软件名 删除软件，并删除所有依赖这个软件的程序，慎用 pacman -Ru 软件名 删除软件,同时删除不再被任何软件所需要的依赖 搜索软件 命令 描述 pacman -Ss 关键字 在仓库中搜索含关键字的软件包（本地已安装的会标记） pacman -Sl 显示软件仓库中所有软件的列表，可以省略，通常这样用:`pacman -Sl pacman -Qs 关键字 搜索已安装的软件包 pacman -Qu 列出所有可升级的软件包 pacman -Qt 列出不被任何软件要求的软件包 参数加q可以简洁方式显示结果，比如pacman -Ssq gcc会比pacman -Ss gcc显示的好看一些。\npacman -Sl | gcc跟pacman -Ssq gcc很接近，但是会少一些和gcc有关但软件名不包含gcc的包。\n查询软件信息\n命令 描述 pacman -Q 软件名 查看软件包是否已安装，已安装则显示软件包名称和版本 pacman -Qi 软件名 查看某个软件包信息，显示较为详细的信息，包括描述、构架、依赖、大小等等 pacman -Ql 软件名 列出软件包内所有文件，包括软件安装的每个文件、文件夹的名称和路径 更新系统 pacman -Sy: 从服务器下载新的软件包数据库（实际上就是下载远程仓库最新软件列表到本地）。 pacman -Su: 升级所有已安装的软件包。 pacman 可以用一个命令就可以升级整个系统。花费的时间取决于系统有多老。这个命令会同步非本地(local)软件仓库并升级系统的软件包：pacman -Syu 软件包组 命令 描述 pacman -Sg 列出软件仓库上所有的软件包组 pacman -Qg 列出本地已经安装的软件包组和子包 pacman -Sg 软件包组 查看某软件包组所包含的所有软件包 pacman -Qg 软件包组 和pacman -Sg 软件包组完全一样 很多人建议通过安装软件组来安装工具链，例如：\npacman -S mingw-w64-x86_64-toolchain pacman -S mingw-w64-i686-toolchain pacman -S mingw-w64-x86_64-qt5 pacman -S base-devel 清理缓存 pacman -Sc：清理未安装的包文件，包文件位于 /var/cache/pacman/pkg/ 目录。 pacman -Scc：清理所有的缓存文件 常用命令 命令 描述 pacman -Syu 升级系统及所有已经安装的软件。 pacman -S 软件名 安装软件。也可以同时安装多个包，只需以空格分隔包名即可。 pacman -Rs 软件名 删除软件，同时删除本机上只有该软件依赖的软件。 pacman -Ru 软件名 删除软件，同时删除不再被任何软件所需要的依赖。 pacman -Ssq 关键字 在仓库中搜索含关键字的软件包，并用简洁方式显示。 pacman -Qs 关键字 搜索已安装的软件包。 pacman -Qi 软件名 查看某个软件包信息，显示软件简介,构架,依赖,大小等详细信息。 pacman -Sg 列出软件仓库上所有的软件包组。 pacman -Sg 软件包组 查看某软件包组所包含的所有软件包。 pacman -Sc 清理未安装的包文件，包文件位于 /var/cache/pacman/pkg/ 目录。 pacman -Scc 清理所有的缓存文件。 ","permalink":"https://www.boii.xyz/posts/manjaro/manjaro/","summary":"换源 1 sudo pacman-mirrors -i -c China -m rank 或者自动选择\n1 pacman-mirrors -c China 或者自动选择最快的\n1 pacman-mirrors --fasttrack 安装 Yay 1 sudo pacman -Sy yay 安装字体 1 yay -Sy wqy-zenhei wqy-microhei adobe-source-han-sans-otc-fonts tty-font-awesome tty-cascadia-code nerd-fonts-cascadia-code ttf-material-icons 输入法 1 sudo pacman -Sy fcitx5 fcitx5-chinese-addons fcitx5-qt fcitx5-gtk fcitx5 是输入法框架，默认支持英文。 fcitx5-chinese-addons 是中文支持。\n配置环境变量 1 sudo vim ~/.pam_environment 输入：\n1 2 3 4 INPUT_METHOD DEFAULT=fcitx5 GTK_IM_MODULE DEFAULT=fcitx5 QT_IM_MODULE DEFAULT=fcitx5 XMODIFIERS DEFAULT=\\@im=fcitx5 配置自启动 1 sudo cp /usr/share/applications/org.","title":""},{"content":"淘汰算法 将计算机简单看作一个 「计算+存储」 的工具，那么 CPU 的主要作用就是 「计算」，硬盘的主要作用就是 「存储」。\n计算需要从硬盘里将数据搬运到 CPU 中，但是硬盘的速度是在太慢，从而有了折中的「内存」。即能存储一定的数据，又比硬盘速度更快些，虽然对于 CPU 而言还是太慢了。\n计算机将部分数据从硬盘搬到内存中，在 CPU 需要时可以快速给到 CPU，从而提高 CPU 使用率。\n但是内存是有限的，她被发明的本意就是为了加快访问。计算机不可能同时将全部的程序都放在内存中，但是我们又需要同时运行许多程序，于是操作系统就站出来负责这些工作。\n一台计算机只有 4G 的内存，但是却可以运行 8G 的程序，其原因是由于程序的局部性原理，我们不需要同时运行 8G 的程序。\n我们可以将程序中目前需要的部分先加载到内存中，随着程序的运行访问到某个子程序不在内存中，这个时候再去硬盘中加载到内存，这称为「内存页面置换」，也就是操作系统的内存管理的内容之一。\n站在操作系统的视角，现在 A 程序运行的时候需要有个子程序 A\u0026rsquo; ，但不在内存中，毫无疑问需要去硬盘中加载。但是加载之前有个问题需要考虑：目前内存是否有足够空间容纳子程序 A\u0026rsquo;？\n如果空间足够，那么加载进来就完事儿，如果不够怎么办？答案就是把一部分数据抱回硬盘，再把需要的子程序 A\u0026rsquo; 抱进来内存中。\n那么，把哪部分数据抱回去？也就是个淘汰谁的问题。于是诞生出许多的淘汰算法。这就是淘汰算法的由来。\n!!! summary 由于资源的稀缺，我们建立一个兼顾速度和容量的中间件——内存。但是内存容量依然有限，而我们又有多程序同时运行的需求，所以操作系统站出来负责内存管理。\n在进行内存管理的时候，需要将旧数据换下去，把新数据换上来，所以有了把谁换下去的问题，于是有了淘汰算法。 解决方案 淘汰算法不仅仅适用于操作系统的内存管理，同样适用其他空间不足时需要替换数据的场景中。\n常见的淘汰算法有：\nOPT (Optimum 最佳淘汰算法) (理想化，未来没准能实现) FIFO (First In First Out 先进先出算法) (绝对公平，但不实用) LRU (Least Recently Used 最近最少使用算法) (容易把热点数据淘汰掉) LFU (Least Frequently Used 最近最不常使用算法) (实现比较复杂) ARC (Adaptive Replacement Cache 自适应缓存替换算法) (结合了 LRU 和 LFU) 首先我们准备一个空队列，然后准备一组编号代表第几号页被访问的顺序：701203042303212\n每当访问一个页面的时候，我们就将其编号入队，通过观察其位置来区别不同算法的差异。\nLRU LRU 不仅记录了编号，还记录了其上次被访问至当前的时长。但是我们可以通过每次访问都将该编号放到队头，这样队尾自然演化成上次访问时间最长的那些。\n7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 备注 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 队头 7 0 1 2 0 3 0 4 2 3 0 3 2 1 7 0 1 2 2 3 0 4 2 2 0 3 3 队尾 前面三列可以看出，队列未满的时候， 7、0、1 依次入队，此时队头至队尾顺序为 107；\n接着 2 入队，这时候 7 是距离入队时间(上次访问时间)最久的，所以被淘汰，于是队列成了 210；\n然后 0 再次入队，因为 0 已经在队列中，所以把 0 调整到队头即可，此时队列成了 021；\n然后 3 入队，此时 1 是距离入队时间最久的，所以被淘汰，于是队列成了 302，后面的情况也是如此。\n这就是朴素的 LRU 算法，之所以实现简单就在于，虽然她带着一个「上次访问时间」的维度，但是这个维度可以通过将编号调整至队头，慢慢的队尾就是最久的一个。\n那么实现起来只需要一个 链队 即可搞定。访问的编号在队中，只需要执行链表结点删除、插入队头两个操作即可；访问的编号不在队中，那么将队尾结点删除，插入队头两个操作即可。由于是链表，所以插入删除的时间复杂度仅为 O(1)。\n但是要插入删除之前得先找到该结点，这样就得去遍历链表，时间复杂度是 O(n)，这个问题也简单，只需要增加一个哈希表，在插入和删除的时候维护这个哈希表即可。\n??? example\n```go package main type Node struct { Pre, Next *Node key int Data any } type LRUCache struct { length int capacity int H map[int]*Node Head *Node Tail *Node } func NewLRU(capacity int) *LRUCache { return \u0026amp;LRUCache{ H: make(map[int]*Node, capacity), capacity: capacity, } } func (l *LRUCache) Get(idx int) *Node { node := l.H[idx] if node == nil { return nil } l.moveToHead(idx) return node } func (l *LRUCache) moveToHead(idx int) { node := l.H[idx] node.Next.Pre = node.Pre node.Pre.Next = node.Next first := l.Head first.Pre = node node.Next = first l.Head = node } func (l *LRUCache) eliminate() { if l.length \u0026lt; l.capacity { return } last := l.Tail if last == nil { return } // 清理map delete(l.H, last.key) // 断链 l.Tail = last.Pre last.Pre.Next = nil last = nil // 长度减1 l.length-- } func (l *LRUCache) Put(idx int, data any) { node := \u0026amp;Node{ key: idx, Data: data, } // 数据存在，就放到队头，不存在，就淘汰一个再放队头 if _, ok := l.H[idx]; ok { l.moveToHead(idx) } // 淘汰数据 l.eliminate() l.put(node) } func (l *LRUCache) put(node *Node) { if l.Head == nil { l.Head = node l.Tail = node l.length++ return } first := l.Head first.Pre = node node.Next = first l.Head = node l.H[node.key] = node l.length++ } ``` 优点 热点数据命中率高。\n缺点\n朴素的 LRU 可能会导致热点数据被淘汰下去。例如，765432176576543243218，除了 1，其他都是反复被访问的页面，然后 1 就一直排在队尾，队列长这样 2345671。\n然后访问了一下 1，变成 1234567，再访问下 8，这时候直接把 7 淘汰掉了，变成 8123456。而我们知道 7 的访问次数是比 1 高的。\n这样就造成 7 这个热点数据被淘汰，而 1 这个冷数据却留下来了。\n还有一种情况就是，当 1234567 的访问次数都很高，也就是他们都是热点数据，这时候 LRU 将失去优点。\nLFU LRU 记录了「上次访问时间」的维度，而 LFU 这是记录了「访问频率」的维度。\n","permalink":"https://www.boii.xyz/posts/note/lru/","summary":"淘汰算法 将计算机简单看作一个 「计算+存储」 的工具，那么 CPU 的主要作用就是 「计算」，硬盘的主要作用就是 「存储」。\n计算需要从硬盘里将数据搬运到 CPU 中，但是硬盘的速度是在太慢，从而有了折中的「内存」。即能存储一定的数据，又比硬盘速度更快些，虽然对于 CPU 而言还是太慢了。\n计算机将部分数据从硬盘搬到内存中，在 CPU 需要时可以快速给到 CPU，从而提高 CPU 使用率。\n但是内存是有限的，她被发明的本意就是为了加快访问。计算机不可能同时将全部的程序都放在内存中，但是我们又需要同时运行许多程序，于是操作系统就站出来负责这些工作。\n一台计算机只有 4G 的内存，但是却可以运行 8G 的程序，其原因是由于程序的局部性原理，我们不需要同时运行 8G 的程序。\n我们可以将程序中目前需要的部分先加载到内存中，随着程序的运行访问到某个子程序不在内存中，这个时候再去硬盘中加载到内存，这称为「内存页面置换」，也就是操作系统的内存管理的内容之一。\n站在操作系统的视角，现在 A 程序运行的时候需要有个子程序 A\u0026rsquo; ，但不在内存中，毫无疑问需要去硬盘中加载。但是加载之前有个问题需要考虑：目前内存是否有足够空间容纳子程序 A\u0026rsquo;？\n如果空间足够，那么加载进来就完事儿，如果不够怎么办？答案就是把一部分数据抱回硬盘，再把需要的子程序 A\u0026rsquo; 抱进来内存中。\n那么，把哪部分数据抱回去？也就是个淘汰谁的问题。于是诞生出许多的淘汰算法。这就是淘汰算法的由来。\n!!! summary 由于资源的稀缺，我们建立一个兼顾速度和容量的中间件——内存。但是内存容量依然有限，而我们又有多程序同时运行的需求，所以操作系统站出来负责内存管理。\n在进行内存管理的时候，需要将旧数据换下去，把新数据换上来，所以有了把谁换下去的问题，于是有了淘汰算法。 解决方案 淘汰算法不仅仅适用于操作系统的内存管理，同样适用其他空间不足时需要替换数据的场景中。\n常见的淘汰算法有：\nOPT (Optimum 最佳淘汰算法) (理想化，未来没准能实现) FIFO (First In First Out 先进先出算法) (绝对公平，但不实用) LRU (Least Recently Used 最近最少使用算法) (容易把热点数据淘汰掉) LFU (Least Frequently Used 最近最不常使用算法) (实现比较复杂) ARC (Adaptive Replacement Cache 自适应缓存替换算法) (结合了 LRU 和 LFU) 首先我们准备一个空队列，然后准备一组编号代表第几号页被访问的顺序：701203042303212","title":""},{"content":" ♂ | 95后 | 菜鸡小学生\n不爱搞事 | 不爱刷圈 | 拒绝IE | 拥抱开源\n喜欢钻研底层技术🔧、记录博客📝、参与翻译🔄，乐于将 Idea 实现出来💡\nTodo Project oneTiny: eFTP 局域网文件服务器 oneDB: 用 Go 实现的 SQLite oneEdit: markdown 编辑器 + 图床管理 + 一键部署托管平台 My Skill Set Github Statistics 喜欢的工作 参与开源 开发基础软件 用技术助力公益 喜欢的书 《Go 语言从入门到上天》 —— Less is more\n《颈椎腰椎康复指南》 —— 别治了，没救的。\n喜欢的影视 《让子弹飞》 —— 姜文\n《3 Idiot》 —— 阿米尔·汗\n喜欢的话 Talk is cheap. Show me the code！ —— 屁话少说，放码过来！\nStandards are paper. I use paper to wipe my butt every day. That how much that paper is worth. —— 标准就是一堆纸。我每天用这堆纸擦屁股。这就是这些纸的价值所在。\nI\u0026rsquo;m allways right. This time I\u0026rsquo;m just even more right than usual. —— 我总是正确的。这次我比平时更正确一些。\nfinally, My name is Linus Torvalds and I am your god. —— 我的名字叫Linus Torvalds，我是你们的上帝。\n联系 i@tcp404.com\n经常不在线，看到就回复哈哈哈哈哈！\n声明 本博客所有内容均为原创，如有雷同，算你抄我。\n","permalink":"https://www.boii.xyz/me/","summary":"♂ | 95后 | 菜鸡小学生\n不爱搞事 | 不爱刷圈 | 拒绝IE | 拥抱开源\n喜欢钻研底层技术🔧、记录博客📝、参与翻译🔄，乐于将 Idea 实现出来💡\nTodo Project oneTiny: eFTP 局域网文件服务器 oneDB: 用 Go 实现的 SQLite oneEdit: markdown 编辑器 + 图床管理 + 一键部署托管平台 My Skill Set Github Statistics 喜欢的工作 参与开源 开发基础软件 用技术助力公益 喜欢的书 《Go 语言从入门到上天》 —— Less is more\n《颈椎腰椎康复指南》 —— 别治了，没救的。\n喜欢的影视 《让子弹飞》 —— 姜文\n《3 Idiot》 —— 阿米尔·汗\n喜欢的话 Talk is cheap. Show me the code！ —— 屁话少说，放码过来！","title":"Me"}]